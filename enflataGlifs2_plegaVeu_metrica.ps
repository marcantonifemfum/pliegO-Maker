%% una evolució per al plegaVeu d'enflataGlifs2.ps
%% marcarem canvis i afegits amb el prefix
%%PV#.# numeracions descrites a feinaFetaPlegaVeuCultura_desembre2021.txt
%%PVcec evitem de pintar res que no sigui el mateix text (o ni això si només mesurem la mètrica)
%%PVmut matem missatges del prompt 
%%PVsense pintar! (no componem re)

%% disseccionem la mecànica de posicionat de glifs dins un path actiu
%% de manera que serveixi per compondre text per segmentació en rectes, arcs i béziers

%% mirem d'implementar un control més ben ponderat del posicionament dels glifs

%%MENÚ: marcarà les variables clau de gestió de l'algorisme

%% línia de comanda perquè no ens giri la pàgina del PDF resultant en funció de l'orientació del text
%% gs -q -dNOSAFER -o out.pdf -sDEVICE=pdfwrite -dAutoRotatePages=/None -c .setpdfwrite -f enflataGlifs2.ps
%% nova crida gs 9.55
%% gs -q -dNOSAFER -o metrica.pdf -sDEVICE=pdfwrite -dAutoRotatePages=/None -f enflataGlifs2_plegaVeu_metrica.ps

%%PV20.1
%%MENÚ: format i nivells de qualitat
<<
  /PageSize [842 595]  %% l'escala de treball ens pot ajudar a guanyar precisió: a més gran format, més precisió
  /HWResolution
  [
%   4000 4000  %% màxim
   72 72  %% mínim
  ]  %% la resolució del dispositiu (de 72 a 4000) també juga amb setflat pel flattenpath de segmentació
>>setpagedevice
% .2  %% màxim
100  %% mínim
 setflat  %% flatness: valors de .2 (qualitat màxima, molts segments) a 100 (qualitat mínima, pocs segments)

%%MENÚ: Text a escriure (compondre)
%(tant de sol als turmells, de mar llisa i daurada)
%(AGNUS DEI MIRABILIS SERRATUM AGNUS DEI MIRABILIS SERRATUM AGNUS DEI MIRABILIS SERRATUM AGNUS DEI MIRABILIS SERRATUM AGNUS DEI MIRABILIS SERRATUM AGNUS DEI MIRABILIS SERRATUM AGNUS DEI MIRABILIS SERRATUM)
%(sí, no, potser, sí, no, potser, sí, no, potser, sí, no, potser, sí, no, potser, sí, no, potser, sí, no, potser, sí, no, potser)
%(WmVlUkTjSiRhQgPfOeNdMcLKaJvIuHtGsFrEqDZpCYoBXnA) %% a la GrissomFour la b peta?
%(Repressió: tres mil tres-cent (3300) represaliats pel cap baix i anem sumant)

%%PV20.1 textos plegaVeu
%% 100 glifs
%(Efectivament, era tot tan bell! semblava que la terra contenta de veure's habitada s'havia deixondit)
(Afer roí que ens pertorba la pensa i ens distreu d'allò assenyat, encara que ens corca molt avall!)
/tae exch def

%%Unicode
%%EP no perdem de vista l'algorisme repicaHTMLentities.ps com a eina lectora de cadenes Unicode
/ctts 1 def  %% octets de treball (byte senzill o doble o més)

%%PV20.1
%%MENÚ: sentit d'escriptura per alfabets diferents al llatí o altres efectes
%% per escriure d'esquerra a dreta: true (occidental)
%% per escriure de dreta a esquerra: false (oriental)
/eAd true def

eAd
{   %% d'esquerra a dreta dels octets dins la cadena de text a escriure
 /iGac 0 def  %% índex inicial pel glif a composar
 %% la divisió fa sentit quan treballem a doble octet o més
 /MAXglif tae length ctts idiv def  %% límit de glifs a compondre
}
{  %% de dreta a esquerra dels octets dins la cadena de text a escriure
 /iGac tae length ctts idiv 1 sub def  %% índex inicial pel glif a composar
 %% la divisió fa sentit quan treballem a doble octet o més
 /MAXglif -1 def  %% límit de glifs a compondre
}ifelse

%%PV20.1
%%MENÚ: tipografia i cos de treball (hi hauria cap relació ideal entre cos i nombre de segments que inclouen un glif?)
%(/Users/femfum/calaixDtipus/Balius/TR00032-2020/Patufet/otf/Patufet-Mono-Mig-Italic.otf)
%(/Users/femfum/calaixDtipus/Balius/TR00032-2020/Patufet/otf/Patufet-Mono-Mig.otf)
%(/Users/femfum/calaixDtipus/PepelPatau/furafont/tipus/Chupada-Bold\ italic.otf)
(/Users/femfum/calaixDtipus/Gentium/GentiumPlus-5.000-developer/GentiumPlus-I.ttf)

24 selectfont

%% mètrica fixa per la Patufet-Mono-Mig-Italic.otf i Patufet-Mono-Mig.otf
%(A) stringwidth (<<<< 1/1000 = 600 )pstack quit

%%Unicode
%% així seria l'array bidimensional d'Encoding basada en Unicode per poder treballar en doble octet
%% caldria classificar-les pel primer octet i que el contingut correspongués al segon, exemple:
%% [
%%  [
%%   #00 segon octet
%%   ...
%%   #ff
%%  ]  %% 00 primer octet
%%  ...
%%  [
%%   #00 segon octet
%%   ...
%%   #ff
%%  ]  %% ff primer octet
%% ]
%% crida de GS al codificat que fem servir
/Encoding systemdict /EncodingDirectory get /WinAnsiEncoding get def
%%EP no perdem de vista l'algorisme repicaHTMLentities.ps com a eina lectora de cadenes Unicode


%%PV20.1
%%MENÚ: traç componedor i sentit (esquerra/dreta o viceversa) de la línia de base
%% el path actiu pot, en la direcció en que el dibuixem, condicionar el sentit del componedor
%% també ens ajuda a construir una componedora universal per tota mena d'alfabets i escriptura creativa

%%Crida al garigot?
false{
%290 100 translate
%% format en funció dels paràmetres ample i alt (sempre enters!) q condicionaran el marc gràfic de l'aleatori de Beziers
842 /amplE exch def
595 /alT exch def
usertime srand  % posem la llavor de l'aleatori

/rc {rand amplE mod rand alT mod} bind def  %% punt aleatori
/mb { rc rc rc curveto } bind def  %%  corba Bezier atzarosa
/bezes
{
 rrand
% newpath
 rc 2 copy moveto rand 10 mod
 {mb} repeat 
 rc rc 6 -2 roll curveto
 closepath cleartomark
} bind def
/B
{
 mark bezes
 % stroke
} bind def
/iRGB 0 def
/repeatB
{
 2
 {
%  gsave
  % és curiós que malgrat aïllem l'estat gràfic, si activem les transparències
  % deixa de funcionar l'efecte de tac sòlid de l'overprint... i no sé q passaria imprimint...
  %[ /ca .5 /CA .5 /BM /Normal /SetTransparency pdfmark
%  [
%   (1 0 0 setcolor)
   %(1 0 1 setcolor)
   %(0 0 1 setcolor)
   %(0 0 0 setcolor)
%  ]
%  iRGB get cvx exec
%  iRGB 0 eq {/iRGB 0 def}{iRGB 1 add /iRGB exch def}ifelse
  B  % la corba aleatòria
%  grestore
 }repeat
} def
repeatB
%%AaG
%%Garigot
%% si volem veure el cursus segmentat per flattenpath...
%%gsave
%%1 0 0 setrgbcolor
%%0 setlinewidth
%%stroke
%%grestore
}if

%%RECTA
%100 200 moveto 700 200 lineto  %% d'esquerra a dreta
%700 200 moveto 100 200 lineto  %% de dreta a esquerra
%% fent 2 rectes hi pot haver 2 comportaments: adaptació progressiva al pendent o adaptació estricte del path
%% l'exemple més evident és quan volem recórrer un quadrat: activant les variables %%!! el recorrem fidelment
%% i si no ho fem, en funció de com s'acosta el glif al canvi de sentit, es compensa amb un pendent al vèrtex següent
%100 200 moveto 350 400 lineto 700 200 lineto

%%MAREJOL
%(marejol.ps) (r) file cvx exec

%%QUADRAT
%% 100 100 moveto 100 400 lineto 400 400 lineto 400 100 lineto closepath  %% amb closepath fa un segment menys al flattenpath
%100 100 moveto 100 400 lineto 400 400 lineto 400 100 lineto 100 100 lineto

%%ARC no podem controlar la direcció doncs sempre pinta en el sentit contrari a les agulles del rellotge
400 300 200 0 270 arc  %% de dreta a esquerra
%% pintem l'arc
%gsave stroke grestore

%%BÉZIER
%100 100 moveto 50 400 600 150 700 500 curveto  %% d'esquerra a dreta
%% aquesta és dibuixada en sentit contrari de l'anterior
%700 500 moveto 600 150 50 400 100 100 curveto  %% de dreta a esquerra

%% l'enflatador de path, fent latent el traçat segmentat
flattenpath

[

 {  %% proc moveto, deixa 2 coordenades x,y a l'stack
  % == == (m)==
 }
 {  %% proc lineto, deixa 2 coordenades x,y a l'stack
  % == == (l)==
 }
 {  %% aquí hem de donar un error (quan pot passar això?)
  ( ...hi ha curveto ...sortim!)pstack quit
 }
 {  %% proc closepath, inicialment sense efectes
 }
 pathforall

]
/apfa exch def

%%PVcec
%%Pintem el path segmentat? (blau)
false{
gsave 0 setlinewidth 0 0 1 setrgbcolor stroke grestore
}if

%%EP! ens cal netejar tant el traçat latent del path com el dels glifs
newpath

apfa length dup /MAXxy exch def 2 idiv
%% dup 12 string cvs (\n)print flush  ( ...nombre de nodes del path: ) print flush print flush
1 sub dup /nS exch def  %% nombre de segments
dup /nSi exch def  %% nombre de segments inicial (a voltes una recta aparentment contínua té diversos trams de planxat)

%%PVmut
true{
12 string cvs (\n)print flush  ( ...nombre de trams planxats: ) print flush print flush (\n\n)print flush
}
{
 pop
}ifelse

%%De què ens hauria de servir mesurar si el tram de segmentació més petit és més gran o no que l'ample del Bbox pel cos triat?
%% per exemple: seria útil per recalcular la línia de base del glif, quan el seu ample inclogui diversos segments

%%PV20.1
%%MENÚ: sentit d'escriptura del componedor per alfabets diferents al llatí o altres efectes
%% true: en el mateix sentit que s'ha dibuixat el path componedor i false en el contrari
%% això fa que es compongui per la línia de base (allà on la situem), sigui per la part interior o exterior del path
/seC true def

%% decidim el sentit de lectura x,y dels segments
seC
{  %% en el mateix sentit que s'ha dibuixat el path componedor
 /iil 0 def  %% índex d'inici de lectura
 /ifl MAXxy 1 sub def  %% índex del final de lectura
 /sentit {add} def  %% endavant
}
{  %% en el sentit contrari que s'ha dibuixat el path componedor
 /iil MAXxy 1 sub def  %% índex d'inici de lectura
 /ifl 0 def  %% índex del final de lectura
 /sentit {neg add} def  %% endarrera
}ifelse


%% l'algorisme enflatador que teniem dins els procs de pathforall de moveto/lineto
%% computem segments i nodes
/segmentsARAglif 0 def  %% hauria de comptar els segments que abracen l'ample de cada glif
/txtEsgotat false def  %% gatell per saber si hem esgotat el text a compondre

%% dins el pathforall apuntaria dins del proc moveto
/XtramEscriu 0 def  %% acumulat x, dins un mateix segment, del cursor que compon els glifs sobre el path
/dS 0 def  %% mida (distància) del segments acumulada

%% x,y del node inicial del segment (aquest només es crida el primer cop)
%% l'hem de pescar o del cap o la cua d'/apfa
seC
{
 /suaraX apfa iil get def
 /suaraY apfa iil 1 sentit get def
}
{
 /suaraY apfa iil get def
 /suaraX apfa iil 1 sentit get def
}ifelse

suaraX suaraY moveto  %% punt d'inici del primer glif

%%Test pel loop de dins el for
/ES 0 def
/NOes 0 def

%%PV2.1.1 acumulat d'amples dels glifs compostos
/TxGlifs 0 def

%% dins el pathforall apunta al proc de lineto
%% sentit de lectura dels segments (sentit d'escriptura en la direcció de com s'han dibuixat)
%% comencem enretirant els dos índex x,y inicials (doncs ja els hem desat a suaraX i suaraY) recorrent tot el segmentat /apfa
iil  %% índex d'inici de lectura
0 2 sentit exch 1 index add exch  %% salt, endavant o endarrera
ifl  %% índex final de lectura
%suaraX suaraY(vvvvv)pstack quit
{  %% for que compon per la línia de base (o cap/peus del FontBBox), indistintament per la part interior o exterior del path

 seC
 {  %% x,y del node final del segment
  apfa exch dup 2 index exch get /araX exch def 1 add get /araY exch def
 }
 {  %% x,y del node final del segment
  apfa exch dup 2 index exch get /araY exch def 1 sub get /araX exch def
 }ifelse

%%PVmut
false{
araX == araY ==  %% x,y del node final del segment
(- - - - - - - - -)==
suaraX == suaraY ==  %% x,y del node d'inici del segment componedor
}if

 %% distància del segment (teorema de Pitàgores)
 araX suaraX sub abs dup mul  %% el quadrat del valor x
 araY suaraY sub abs dup mul  %% el quadrat del valor y
 add sqrt

%%Nou
 dS add  %% hi sumem la distàcia del segment acmulada

 /dS exch def  %% l'arrel quadrada de la suma ens dóna la distància del segment

 segmentsARAglif 1 add /segmentsARAglif exch def

 %% situem l'eix de coordenades en el pla del segment o per pintar el node o per pintar el glif (o totes dues coses)
 gsave

%%Test
%%PVcec
false{
 %% pintem el node de la cua del segment
 gsave
 araX araY 2 copy translate
 suaraY sub exch suaraX sub
 %% filtre per evitar 0 0 atan = indefineresult
 2 copy eq
 {
  dup 0 eq
  {
   pop
  }
  {
   atan
  }ifelse
 }
 {
  atan  %% angle del segment en relació al node anterior
 }ifelse
 rotate  %% pot ser la rotació per pintar la perpendicular del node o la línia de base per pintar el glif
 0 1 0 setrgbcolor 0 setlinewidth
 0 -50 moveto 0 50 lineto stroke  %% amb una perpendicular al segment del flattenpath
 grestore
}if

 %% aquí hauríem d'activar un avaluador que ens digués si el glif que ara toca encara hi cap
 {  %% loop per recórrer el segment, fins que s'esgoti, amb els glifs a compondre

  {  %% el proc componedor per cshow deixa a l'stack el codi i l'ample x,y de composició del glif

%%Sentit d'escriptura per alfabets diferents al llatí o altres efectes
%% ens caldria actuar aquí per alfabets, com el japonès, que componen en vertical)
   pop  %% valor Y per fonts amb composició vertical (en composició horitzontal s'elimina)

%%PV20.1
%%PVmut
false{
dup == (^ pitch)==
}if

%%EP!
%% tenint aquí l'ample del glif, el primer que hauríem d'avaluar és quants trams l'inclouen i si l'actual s'esgota
%dS XtramEscriu add gt(||||)pstack quit
dup /xGlif exch def  %% pesquem l'ample per pintar en vermell la línia de base glif a glif

%%PV20.1.1
xGlif TxGlifs add /TxGlifs exch def

%%Nou
%   dS xGlif lt  %% els segments acumulats NO superen l'ample del glif?
dup XtramEscriu add dS gt  %% el posicionat x del glif, esgota el segment?

   {  %% si l'esgota el segment, pot ser per dues raons:
    %% perquè l'ample de composició del glif abraça 2 o més segments (cal calcular quants segments hi caben en un ample?)
    %% perquè ja no hi han més segments però sí que hi ha més text (cal saber quan de text queda per compondre)
    %% llavors:
    %% ni pintem el glif, ni fem córrer l'index iGac

%%Nou
    /dS 0 def

    pop pop  %% ens carreguem l'ample i codi del glif
%% com que hem de canviar de segment, també el deixem a zero!
    /XtramEscriu 0 def
%    /XtramEscriu XtramEscriu dS sub def  %% però inicialitzem XtramEscriu amb l'ample que sobra

    /cmpnm false def  %% componem? (de moment no actua)

%%Test
%ES 1 add dup == /ES exch def
%/NOes 0 def

%%PV20.1.1 desfem la suma acumulada d'amples de glif
    TxGlifs xGlif sub /TxGlifs exch def

%%NO sempre hauríem de sortir?
%%PVmut
false{
(<<< sortim)==
}if

    exit  %% temporalment tant si hi ha o no més segments, sortim del loop de forma fixa

   }
   {  %% com que no s'esgota, componem el glif i fem córrer l'índex iGac

%%Test
%NOes 1 add dup == /NOes exch def
%%Test pel loop de dins el for
%/ES 0 def

    exch  %% el codi del glif a cercar

%1 string dup 3 -1 roll 0 exch put stringwidth

    Encoding exch get  %% nom del glif a compondre

%%Test
%%PVmut
false{
dup ==  (^ nom del glif) == %% nom del glif que componem
}if

gsave  %% preservem l'estat gràfic del glif que componem
newpath

   suaraX suaraY 2 copy translate
   araY sub exch araX sub atan  %% angle del segment en relació al node anterior

%% cal entendre que fa realment aquesta rotació i les seves possibilitats
   -180 sub  %% en quina direcció de lectura ens convé?
%% pop 0  %% si rotem a zero ens ho escriu en línia recta passant del path establert
   rotate  %% pot ser la rotació per pintar la perpendicular del node o la línia de base per pintar el glif

%%EP!
%% no hi ha diferències entre l'ample de la línia de base que ens dóna cshow o amb la que obtenim amb stringwidth
%%PV20.1
%%PVcec
false{
%%TEST
0 setlinewidth
1 0 0 setrgbcolor
%currentpoint pop xGlif sub 0 lineto stroke  %% pintem la línia de base del glif amb ample corresponent a cadascun
0 0 moveto xGlif 0 lineto stroke  %% pintem la línia de base del glif amb ample corresponent a cadascun
}if

%%PV20.1
%%NouNou
%%Prosa
%6  %% si en passem de cert valor (aprox 60% del cos?) es col·lapsen els glifs?
0  %% desplaçament horitzontal del glif, de manera que suma a la distància X entre glifs (podríem activar aquí el kerning!)
%    XtramEscriu dS sub  %% 0 gt  %% si la distància x és més gran que zero, és que ja ens hem menjat el segment

%%PV20.1
%%MENÚ: línia de base: aquí podem decidir on situem la línia de base del glif en relació al path componedor
    %% part superior del FontBBox (caldria calcular-la)
    0  %% desplaçament vertical Y des de la línia de base natural en punts
    %% part inferior del FontBBox (caldria calcular-la i aplicar-hi el multiplicador de la mètrica 1/1000)
    moveto

%%PVsense pintar!
false{
   glyphshow  %% posicionem el glif
}if

%%Nou
currentpoint  %% el final del glif és el del nou origen del següent


%%NouNou
pop 0  %%  rectifiquem cada vegada la posició Y sobre la línia de base natural (l'X no s'ha de rectificar)


%%PVsense pintar!
pop exch pop 1 index 3  1 roll


transform  % dóna les coordenades del punt x,y (eix normal) en unitats del dispositiu de sortida (device pixels)
grestore
itransform  % dóna les coordenades del punt x,y (eix normal) en punts tipogràfics
%% noves coordenades d'inici (amb l'eix sense rotar)
/suaraY exch def
/suaraX exch def

%%PV20.1
%% ens diu els segments que s'inclouen dins un mateix glif
%%Test
%%PVmut
false{
segmentsARAglif == (^ segments)==
%(passo)==
}if

/segmentsARAglif 0 def

%%PV20.1
%%Sentit d'escriptura per alfabets diferents al llatí o altres efectes
    XtramEscriu add /XtramEscriu exch def  %% x del glif següent

%%Unicode
%%EP no perdem de vista l'algorisme repicaHTMLentities.ps com a eina lectora de cadenes Unicode
    iGac ctts  %% aquí és on podríem treballar amb strings a doble octet o més
%%Sentit d'escriptura per alfabets diferents al llatí o altres efectes
    %% eAd decideix si llegim la cadena de text de dreta a esquerra (sub) o d'esquerra a dreta (add)
    eAd {add}{sub}ifelse

%%TEST
%dup 2 eq{(....)pstack quit}if

    /iGac exch def

    %% exhaurim els glifs?
    %% quan s'esgota el text (el repetim o ens aturem?) i no s'esgoten els segments
    iGac MAXglif eq
    {
%%PVmut
false{
     (\n ...hem esgotat els )print flush MAXglif 12 string cvs print flush ( glifs que tenia el text\n)print flush
     ( ...encara ens queden )print flush nS 12 string cvs print flush ( segments per compondre\n)print flush
%% en el cas de les rectes llargues aquest % no és acurat doncs hauria de computar el % que ha fet del darrer per ser exactes
     ( ...queda per compondre el )print flush nS 100 mul nSi div round cvi 12 string cvs print flush (% del recorregut\n)print flush
}if

     %% si tenim una mitjana de segments/glif hauríem de poder deduir el nombre de caràcters que faltarien per esgotar el text
%%TEST
/txtEsgotat true def
     exit
    }if
    /cmpnm true def  %% componem? (de moment no actua)
   }ifelse

%%TEST
%exit
  }  %% proc componedor de cshow
%%Unicode
%%EP no perdem de vista l'algorisme repicaHTMLentities.ps com a eina lectora de cadenes Unicode
  tae iGac ctts  %% aquí és on podríem treballar amb strings a doble octet o més
  getinterval
  %% aquest operador, per sí sol, no compon ni pinta cap glif, tal com diu el PLRM3:
  %% «cshow does not paint the glyph and does not change the current point, although proc may do so»
  cshow  %% sense necessitat de posicionar-nos, dins el proc, ens dóna el codi i l'ample x,y de composició del glif

 }loop  %% per recórrer el segment, fins que s'esgoti, amb els glifs a compondre

 grestore  %% desactivem la rotació de la línia de base de composició

 %% aquí hauríem de decidir si aturem l'algorisme o tornem a començar el text fins a esgotar els segments
 txtEsgotat
 {  %% si hem esgotat el text sortim del for dels segments
  exit
 }if

%%Nou%%!!
%% activant de nou aquestes variables fa que l'inici dels glifs quadrin amb l'inici dels nodes d'enllaç?
%% un cop hem mesurat la distància del segment ja podem actualitzar x,y node inicial pel següent
%% l'exemple més evident és quan volem recórrer un quadrat: activant aquestes variables el recorrem fidelment
%% i si no ho fem, en funció de com s'acosta el glif al canvi de sentit, es compensa amb un pendent al vèrtex següent
% araX /suaraX exch def
% araY /suaraY exch def

%%PVmut
false{
(...segment...)==
}if

 %% quan s'esgoten els segments i no s'esgota el text?
 nS 1 sub 0 eq
 {

%%PVmut?
true{
  (\n ...hem esgotat els segments i queden encara... ) print flush
  MAXglif iGac sub ctts idiv abs 12 string cvs print flush  %% glifs que encara queden per compondre
  ( ...glifs per compondre\n\n)print flush

%%PVclau resta de text dins l'string /tae que encara queda per compondre
tae iGac MAXglif iGac sub getinterval ==
}if

  exit
 }
 {
  nS 1 sub /nS exch def
 }ifelse

%%TEST
%exit

}for  %% que compon per la línia de base (o cap/peus del FontBBox), indistintament per la part interior o exterior del path

%%PVclau
%%PVmut
true{
dS == (^ /dS longitud de segments planxats)==
TxGlifs == (^ /TxGlif longitud d'amples dels glifs compostos)==
suaraX == suaraY == (^ suaraX | suaraY)==
}if

%apfa araX araY suaraX suaraY
suaraX ==
(b r o s s a)pstack

showpage

