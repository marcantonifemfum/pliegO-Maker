%!
%#  `GNU AGPL FemFum CaLi2CoPi v0.042´ és una llibreria d'anàlisi de PDF per verificar,
%#  modificar i reescriure `Portable Document Format´ per mitjà del llenguatge PostScript.
%#  Per a intèrprets `GNU AGPL Ghostscript´ però també, amb ben pocs retocs, pot córrer
%#  amb l'Adobe Acrobat Distiller (fins hi tot amb MacOSX PSNormalizer Framework/Apple pstopdf).
%# 
%#  `Copyleft 2000-2024 :: l'Ametlla de Merola :: Marc Antoni Malagarriga i Picas´
%#  `<http://www.femfum.com> | <marcantoni@femfum.com>´
%#  `https://github.com/marcantonifemfum/CaLi2CoPi´
%# 
%#  Aquest programa és programari lliure: podeu redistribuir-lo i/o modificar-lo
%#  sota els termes de la Llicència Pública General de GNU publicada per la Free
%#  Software Foundation, ja sigui la versió 3 de la Llicència, o (a la seva elecció)
%#  qualsevol versió posterior.
%# 
%#  Aquest programa es distribueix amb l'esperança que sigui útil, però SENSE CAP GARANTIA;
%#  ni tan sols la garantia implícita MERCANTIL o d'APTITUD PER A UN OBJECTIU PARTICULAR.
%#  Consulteu els detalls de la Llicència Pública General de GNU per a més informació.
%# 
%#  Haurieu de rebre una còpia de la Llicència Pública General de GNU junt amb aquest
%#  programa. En cas contrari, consulteu <http://www.gnu.org/licenses/>
%# 
%# 
%#  `GNU AGPL FemFum CaLi2CoPi v0.042´ is a PDF parser library to preflight,
%#  modify and rewrite the Portable Document Format under PostScript language.
%#  For `GNU AGPL Ghostscript´ interpreter, but also available with minor changes
%#  for Adobe Acrobat Distiller (even for MacOSX PSNormalizer Framework/Apple pstopdf).
%# 
%#  `Copyleft 2000-2024 :: l'Ametlla de Merola :: Marc Antoni Malagarriga i Picas´
%#  `<http://www.femfum.com> | <marcantoni@femfum.com>´
%#  `https://github.com/marcantonifemfum/CaLi2CoPi´
%# 
%#  This program is free software: you can redistribute it and/or modify
%#  it under the terms of the GNU General Public License as published by
%#  the Free Software Foundation, either version 3 of the License, or
%#  (at your option) any later version.
%# 
%#  This program is distributed in the hope that it will be useful,
%#  but WITHOUT ANY WARRANTY; without even the implied warranty of
%#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%#  GNU General Public License for more details.
%# 
%#  You should have received a copy of the GNU General Public License
%#  along with this program.  If not, see <http://www.gnu.org/licenses/>

%% quan treballem amb la interfície web executem el fitxer de capçalera escrit per executal.php
%% i activem la línia de lectura del fitxer, esborrant les dades manuals de capçalera fins la
%% fi de dades de capçalera (opcions de menú) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (capCaLi2CoPi.dat) (r) file cvx exec

%% miralls del codi a:
%% `http://femfumcali2copi.sourceforge.net/ ... /home/persistent/f/fe/femfumcali2copi´
%% `ftp de femfum.com ... /web/bin/DeuNosEnGuard´
%% `http://femfumcali2copi.sourceforge.net/htmlcodifont/CaLi2CoPi_codiPSnetiplanxat.html´
%% repositori github `https://github.com/marcantonifemfum/CaLi2CoPi´

%#% execució amb GS per línia de comandes (la comanda "-c .setpdfwrite" ja no és vàlida a gs 9.54 en endavant)
%# gs -q -dNOSAFER -o re.pdf -sDEVICE=pdfwrite -f FemFum_CaLi2CoPi_042.ps
%# escriu els missatges a un .log de sortida però no al Terminal
%# gs -q -dNOSAFER -sstdout=aviam.log -o re.pdf -sDEVICE=pdfwrite -f FemFum_CaLi2CoPi_042.ps 
%% /home/users/m/ma/marcantoni/userweb/persistent/gs860/bin/gs ... crida al gs de sourceforge

%%UBpliegOMaker
%% etiquetem el nou codi o modificacions de la versió de CaLi2CoPi ajustada al desenvolupament de pliegOMaker

%#%00% Normes d'escriptura a seguir dins el codi per a una gestió de codiPSnetiplanxat_html.ps
%# i fitesigatellsPSnetiplanxat_html.ps i per una bona traducció a Google Translator:
%# 1. Els comentaris normals (gris) han de tenir només 2 o 3 % seguits ... mai 1 de sol % !
%# 2. El millor es que tots els comentaris normals en tinguin 2 %% doncs si acabem la línia amb uns
%# punts suspensius ... la traducció elimina el % inicial (i amb 1 d sol ja no seria un comentari!)
%# 3. Cal separar amb un espai a l'acabar i començar, quan escrivim tres punts suspensius ... 
%# 4. Els comentaris amb interrogració, el signe ? final ha d'anar enganxat a la darrera paraula
%# 5. El contingut d'un comentari que NO volem que es tradueixi, ho posarem entre els caràcters d'accent `grave i acute´
%# obrim no traduïr: ascii 96 = grave = U+0060 (Unicode Basic Latin | CE)
%# tanquem no traduïr: ascii 180 = acute = U+00B4 (Unicode Latin-1 Supplement | CE)
%# aquests dos signes dins el fitxer html desparareixen
%# 6. Els comentaris que són fites (vermell) s'han d'escriure com segueix, quan els iniciem:
%# %#%01% això és una fita on l'identificador numèric 01 va entre %01% i s'inicia amb %#
%# les línies addicionals d'una fita comencen amb: %#  seguit d'un espai en blanc!
%# però si volem forçar una línia en blanc per dalt quan fem un llistat amb la utilitat
%# fitesigatellsPSnetiplanxat_html.ps posem: %#%  seguit d'un espai en blanc i el que vulguem!
%# 7. Els comentaris que són gatells (blau), s'obren i tanquen, i la seva sintaxi és:
%# %:00 això és el gatell 00 que obre
%# %/00 això és el gatell 00 que tanca
%# 8. Pel codi PS (negre) no hi ha cap mena de restricció
%# 9. Errors en aquesta sintaxi poden produir falles d'execució a les dues aplicacions de repicat:
%# fitesigatellsPSnetiplanxat_html.ps i codiPSnetiplanxat_html.ps

%#%%%% OPCIONS DE MENÚ
%#%01% dades de capçalera (opcions de menú)
(%#%01%)==

%#% A array amb el path+nom del PDF a tractar i el path+nom del PDF reescrit (o null) %%%%%%%%%
%# si el segon paràmetre és un null seguirem amb la nomenclatura clàssica segons %#% B

%%Pegues 0
%%Cal veure per que CaLi2CoPi #0 no és capaç de reparar aquest fitxer! Acrobat i Preview si!
%% segurament és degut als dos possibles comportament que hem dissenyat per l'operador stream:
%% si l'entrada Length duu un valor numèric per excés (més enllà d'endstream) el mètode preferent
%% assenyalat amb true, farà petar el fitxer, llavors segurament utilitzant false anirà bé
%%(/enfony/CaLi2CoPi/JBC/errors100910/ComportamentDeTJxGestionarEspaisBlancs.pdf)
%%Dins a Ghostscript podem estalviar-nos totes les definicions d'encoding gràcies al diccionari
%% systemdict /EncodingDirectory get ... on hi trobarem tots els recursos de xifrat que necessitem
%% i per treballar en doble byte a ... systemdict /AdobeGlyphList get
%%Hem reescrit el cuc de femfum amb Unicode (doble byte) per tal que es vegi bé a les
%% darreres versions de l'Acrobat (Producer, Creator i Author)
%% ... a l'inici de l'string hi ha d'anar <feff> per anunciar el doble byte

%%(/Users/femfum/Desktop/analisiEdicionsElaGeminada/EdicionsDeLaElaGeminada_cobertaDefinitiva_calanalitzar.pdf)
%%(/Remsa/xDespresDfestaMajor/multipaginaAmbRotate_Apel.pdf)
%%(/Users/femfum/Desktop/Zitruslab_JordiUbanell/2javascriptsMP3exclusius.pdf)
%%(/Users/femfum/Desktop/Farrerons/out.pdf)
%%(/Remsa/marc/nomesTitular_BaltimoreSun.pdf)
%%(/Users/femfum/Desktop/SarrioDadaVarAAVV/carnet_mestre_1titRetocParents.pdf)
%%(/Users/femfum/Desktop/Polynorma_261011/mantenimEMC_BDC.pdf)

%%(/Users/femfum/Desktop/DIGIPACK/DIGIPACK_noSCnoLi.pdf)
%%(/Users/femfum/Desktop/LLIBRET/BSO_noSCnoLi.pdf)
%%(/Users/femfum/Desktop/LLIBRET/BSO_APSNF_retallat.pdf)
%%(/Users/femfum/Desktop/DIGIPACK/DIGIPACK_sensetracar.pdf)

%%(/Users/femfum/enfony/ghostscript/re2.pdf)
%%(/Users/femfum/enfony/CaLi2CoPi/_038_\~0_doc_1_amBaseURL_pdf_iDeM.pdf)
%%(/Users/femfum/JBC/exempleDcridesPDFsofisticades/faproxy.pdf)
%%(/Users/femfum/JBC/exempleDcridesPDFsofisticades/faproxy.pdf)
%%(/Users/femfum/JBC/ModificarRessaltatPlanols/48077.pdf)
%%(/Users/femfum/JBC/53645_CIDToGIDMap.pdf)
%% Xespinosa/
%(/Users/femfum/enfony/CaLi2CoPi/cara_DEFINITIVA_WinAnsiType1.pdf)

%(/Users/femfum/visuals2014/escales/1_10_graons.pdf)
%(/Users/femfum/elageminada/ATypIBCN/_TheGeminatedEl_presentacio-ATypI-final.pdf)
%(/Users/femfum/Masats/_038_\~0_012MY1A1-tbo-amb-capas_pdf_iDeM_JSvar.pdf)
%(/Users/femfum/OnEtsOncleGuillem/mitjans/diariSegre_pg3_031114.pdf)

%%Fi de Pegues 0


%%Pegues 1
%%Fi de Pegues 1


%%Pegues 2
%%Fi de Pegues 2


%%Pegues 3
%%Fi de Pegues 3


%%Pegues 4
%%Al tornar a salvar amb el Preview, li treu l'ObjectStreamCompression però ho posa dins un Form i
%%CaLi2CoPi NO HI ENTRA i es pensa que no duu text!!!
%% (/enfony/CaLi2CoPi/JBC/HTcreator/PDFdirecteWord/00011_Preview.pdf)
%%(/enfony/CaLi2CoPi/JBC/HTcreator/PDFdirecteWord/00011_API.pdf)
%%(/enfony/CaLi2CoPi/textdinsunformSI.pdf)

%%Hi ha CIDToGIDMap ... i ens cal implementar-ho? ... PLEGUEM!
%%(/enfony/CaLi2CoPi/JBC/errors100910/test\ guions\ word.pdf)

%%Darrers problemes de JBC!
%%Cal afegir a #4 un analitzador a posteriori, aprofitant el del torsimany, però que abans
%% d'unificar línies analitzi si s'han de remuntar paraules que tenen els seus caràcters tractats
%% de forma individual, doncs ara al refinar l'extractor moltes de les referències de JBC que
%% sortien unificades, ara surten a trossos. Una de les problemàtiques que haurem de contemplar,
%% a banda de les associades a l'ample de les lletres, serà la que relaxi la precisió de la posició
%% Y a un sol decimal, doncs hem vist que quan treballa amb dos o tres, pot entendre que hi ha
%% caràcters en línies diferents i només es tracta d'un error de precisió en la composició al segon
%% o tercer decimal (degut a l'eina o a l'operador). Això ens servirà per construir el detector de
%% paràgrafs que necessitem pel torsimany. També caldrà eliminar el detector d'omisió dels
%% caràcters 'N.P.' que ara tenim associat als operadors, per afegir-lo a l'analitzador aquest.
%%(/enfony/CaLi2CoPi/JBC/errors100910/32688_OriginalOmetReferencies_foraInlines.PDF)
%%(/enfony/CaLi2CoPi/JBC/errors100910/32660_OriginalProblematicaGuions_foraInlines.PDF)
%%(/enfony/CaLi2CoPi/JBC/errors100910/31817_OriginalEnganxatNP_foraInlines.PDF)

%%Mishima: retoquem la precisió Y dels operadors de text TJ Tj ' " només al primer decimal
%% (trucant la resta de decimals) per tal de minimitzar un problema detectat amb imprecisions de
%% posicionat a la centéssima de punt, que fan interpretar textos com si estiguessin en línies
%% diferents i en realitat no ho estan. Quan hi ha rotacions de text i segons com es disposen els
%% operadors, amb aquesta mesura no n'hi ha prou per solucionar-ho. Aquest problema també el podrem
%% filtrar més tard amb l'algorisme que munta l'array ClavaLinies?
%%(conflicteTJ.pdf)
%%(tresParaules.pdf)
%%(dosPetitsParagrafs.pdf)

%%Error: /rangecheck in --putinterval--
%%(/Users/femfum/Sites/www.femfum.com/PDF/ElaGeminada/5JPL_PonenciaElaGeminada.pdf)

%% (%#%20bis%)
%%Error: /rangecheck in --cvs--
%%(/Users/femfum/Desktop/eraalescriptori_220810/100822103559.pdf)

%% (%#%20bis%)
%% ... This Page don't have Text
%% (:::JBC:::pagina sense TEXT)
%% /43_____________0 /13
%%Error: /stackunderflow in --dup--
%%(/Users/femfum/Desktop/01_lip.pdf)

%%Extrau ARAMEU als dos!
%%(/Users/femfum/Desktop/orgueporta.pdf)
%%(/Users/femfum/Desktop/orguepositiu.pdf)

%% errors reportats a Kosmopolis...
%%Error: /rangecheck in --putinterval-- Operand stack: TT17
%% (%#%20bis%) Serif ... Font Descriptor Flag 2
%%  >>> PROBABLEMENT hem detectat un xifrat esoteric! <<<
%%(/Users/femfum/Desktop/Kosmopolis/NODACcat_des2006.pdf)

%%EP ... hi ha CIDToGIDMap ... i ens cal implementar-ho? ... PLEGUEM!
%%Podem salpassar aquest error repicant el PDF amb el GS amb compatibilitat 1.5
%%(/Users/femfum/Desktop/Kosmopolis/From_The_Creative_Minds_Book2.pdf)
%%(/Users/femfum/JBC/53645_CIDToGIDMap.pdf)

%% (%#%23%) ( ... peta Tj)
%%Error: /rangecheck in --get-- Operand stack: (The Basics)
%%(/Users/femfum/Desktop/Kosmopolis/direct_action_guide.pdf)
%% fi d'errors que m'han dit a Kosmopolis

%%Peta ...
%% (/Users/femfum/Desktop/Programa-dia-emprenedor-2010-catala2.pdf)
%% (%#%20bis%) ... This Page don't have Text (:::JBC:::pagina sense TEXT)
%% /213____________0 /36 Symbolic ... Font Descriptor Flag 3
%% ... hi ha CIDToGIDMap ... i ens cal implementar-ho? ... PLEGUEM!

%%Aquí el codi 0003303 queda extret amb #4 com a CCC ...
%% (/enfony/CaLi2CoPi/JBC/planolsvaris/29401.PDF)
%% (i xq aquí les 3 primeres etiquetes amb #8 no queden ben posicionades per les x?)

%%Peta x inLine il·legal: Error: /rangecheck in --readline-- 
%%(/enfony/CaLi2CoPi/JBC/planolsvaris/32602.PDF)
%%(/enfony/CaLi2CoPi/JBC/planolsvaris/32600.PDF)
%%(/enfony/CaLi2CoPi/JBC/planolsvaris/32400.PDF)
%%(/enfony/CaLi2CoPi/JBC/planolsvaris/31717.PDF)

%%Aquí hi ha un xifrat esotèric detectat per #4
%% doncs el codi (0009613) no s'extrau correctament (són tot lletres!)
%% (/enfony/CaLi2CoPi/JBC/planolsvaris/tractats/PlanosPDF/32719.PDF)

%%Xifrat esotèric
%% (%#%20bis%) ... This Page don't have Text (:::JBC:::pagina sense TEXT) /773____________0 /143
%% >>> hem detectat un xifrat esoteric SEGUR! <<<
%% Error: /rangecheck in --putinterval--
%% Operand stack: G2   --dict:5/5(L)--   --nostringval--   176   --nostringval--
%%(/Users/femfum/Desktop/polyNorma/Tarifapdfhigh.pdf)

%%Fi de Pegues 4


%%Pegues 5
%%Caldria afegir un seguit de nous valors a escollir a banda de les tres variables que tenim ara:
%% /sDADA /aDADAv /pathDADAv de manera que hauríen d'anar en una array per tal de poder donar
%% cabuda per la cua a nous paràmetres com: afegim alguna de les 14 Core Fonts?, quina (índex)
%% els continguts de text van amb cometes?, quines,
%%EP! ara de forma fixa (per assegurar el WinAnsi) afegim sempre un nou objecte font Helvetica-Bold
%%De forma fixa també posem un substitutiu del cos a .90 en l'ús de Tf per reduïr-lo

%%SARRIO
%%(/Users/femfum/Desktop/SarrioDadaVarAAVV/carnet_mestre_1titRetocParents_Tj_iDeM.pdf)

%%REMSA
%%(/Volumes/TRANSCEND/RemsaMarc/dadaVariable/dadaVariable_iDeM.pdf)

%%Fi de Pegues 5


%%Pegues 6
%%A3copiseny millores a fer al gatell cosidor d'imatges #6

%%Nou planteig d'en Martí Parellada d'unificar totes les imatges en 1 sola capa a sota de tot
%% i donar un efecte 'croma' al blanc per tal que sigui transparent
%% aquesta seria la línia de comanda per rasteritzar de forma bàsica un PDF amb només imatge
%% gs -q -dNOSAFER -o pix.jpg -sDEVICE=jpeg -r300 -dJPEGQ=100  el.pdf
%%(/enfony/CaLi2CoPi/a3copiseny/PaginesTotRoureda_49.pdf)
%%Primer cal solucionar el problema de les imatges que duen traçats de retall al voltant
%(/enfony/CaLi2CoPi/a3copiseny/Prova1\ sense\ treure\ tracats\ de\ retall.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/NouMetodeDcosit/TotRoureda49.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/NouMetodeDcosit/ceipPompeuFabra_percapes_1solJPEGinserit.pdf)
%% només apareix la primera imatge de baix de tot de les dues primeres fotos i la de dalt cap
%%(/enfony/CaLi2CoPi/a3copiseny/Prova1\ treient\ els\ tracats\ de\ retall.pdf)
%% demostra que els retalladors parcials s'haurien de sumar doncs si els treiem a sac es poden
%% produir desastres com el que veiem aquí on almenys dues fotos surten del marge del filet negre!
%%(/enfony/CaLi2CoPi/a3copiseny/Prova2\ sense\ treure\ tracats\ de\ retall.pdf)
%% es repeteix l'efecte de que només surt la primera imatge de la sèrie tallada
%%(/enfony/CaLi2CoPi/a3copiseny/Prova2\ treient\ els\ tracats\ de\ retall.pdf)
%% malgrat sembli que ho fa correctament hem detectat un desplaçament gravíssim de píxels en el
%% cosit de les llesques horirzontals! (mireu el bastonet que duu la nena a la foto de baix)
%% i en canvi la foto de dalt la cus perfectament (l'enllaç al mig del paper ho demostra)

%%Cosia quatre imatges simetriques de 4x4 però hi havia un desfassament de color d'1 píxel
%% FET! ara s'ha solventat i llistarem les dades sensibles treballades que podien influir-hi:
%% capçalera: a %#% C triem 0 
%% la variable de píxels de tolerància /tlrnc era a 5
%% i sobretot la clau en la redefinició d'stream: filtrem l'stream per la clau endstream final
%% o forcem amb el 'false' que ja ve comentat del per què serveix per a 6
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/2x2_simetric.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/2x2_asimetric.pdf)

%% no troba ni les imatges per cosir!
%% hauria de ser capaç de completar els píxels que manquen a banda i banda en cada tros per unir-la
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/ninot_amb8imatgesIrregularsH.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/ninot_amb8imatgesIrregularsH_inLines.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/ninot_amb4imatgesIrregularsVH.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/3imatges3Xdiferents.pdf)

%% només cus dues imatges, una a sobre l'altre, o una al costat de l'altre
%% i els píxels es contaminaven entre imatges segons la configuració de l'operador stream
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/nomesEnCus2AmbContaminacioDverd.pdf)  %% NO contamina si treballem stream correctament
%%  >>>> NO HE TROBAT imatges trencades que es puguin cosir ... pleguem!
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/nomesEnCus2AmbContaminacioDverdNegreAsota.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/unaimatgealcostatdelaltre.pdf)  %% no passa
%% INFLUEIX DE COM ESCRIVIM L'STREAM DE DADES!!! (amb el mètode false va bé!)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/EnCus2VerticalsAmbContaminacioDverd.pdf)  %% passa
%% es contamina la imatge frontisa i la que li segueix i donen per blau!
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/3unasobrelaltra.pdf)  %% per evitar-ho stream a de ser false
%% ENS CAL REVISAR la redefinició d'stream per veure que passa en aquest efecte de contaminació?

%% provoca l'error ... (>>> CaLi2CoPi#6 ... els pixels d'ample de les linies d'imatge que formen el trencaclosques NO s'adiuen ... PLEGUEM!)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/ForcemMidaXidemAmbpixelsDampleDiferents.pdf)

%% provoca l'error ... (>>> CaLi2CoPi#6 ... els pixels d'altura de les imatges que formen aquesta linia NO s'adiuen ... PLEGUEM!)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/ForcemMidaYidemAmbpixelsDaltDiferents.pdf)

%%Hauriem de començar per aqui la nova millora de 6!
%% >>>> NO HE TROBAT imatges trencades que es puguin cosir ... pleguem!
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/unasotalaltredamplesdiferents.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/unasotalaltredamplesdiferents2.pdf)

%%EP! són inLines!!!!
%%EP! no les detecta xq són inLines !!!
%% FALS! >>>> NO HE TROBAT imatges trencades que es puguin cosir ... pleguem!
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/2x2_asimetric_inLines.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/8x8unasobrelaltreInlines.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/1x3_inLines.pdf)

%%Aquí hi han unes imatges trencades molt petites de 2x1 píxels i la cosidora #6 es queda inalbis
%%(/enfony/CaLi2CoPi/JBC/HTcreator/PDFdirecteWord/00011_PDFA.pdf)  %% es queda a (imatge!
%% em comprovat que el posicionat i mida de les imatges no hi té res a veure ...
%%(/enfony/CaLi2CoPi/JBC/HTcreator/PDFdirecteWord/misteri2x1_9_pdf_pla2.pdf)  %% es queda a Parsing...

%%Quan fem #06 es queda in albis a (%#%23%) (<--- imatge!)
%% (/Users/femfum/Desktop/iva2009/_3714ATTR.pdf)

%%No és cert: (%#%26%) MRCT20 This Page don't have Resources
%% cal veure que passa en aquest algorisme ara, doncs no sap localitzar els Resources de pàgina
%%(/enfony/CaLi2CoPi/a3copiseny/beCosits/4pagines_2si2no.pdf)
%% fi d'exemples de millora del gatell cosidor
%%(/Users/femfum/Desktop/A3Copiseny_error/296R009_03_senseSuperC.pdf)
%%Fi de Pegues 6


%%Pegues 7
%%Fi de Pegues 7


%%Pegues 8
%%Aquí el codi 0003303 queda extret amb #4 com a CCC ...
%% (/enfony/CaLi2CoPi/JBC/planolsvaris/29401.PDF)
%% (i xq aquí les 3 primeres etiquetes amb #8 no queden ben posicionades per les x?)

%% aquest és un cas curiós per l'extractor on podem veure la precisió de localització de caràcters
%% al logo del Colifree i el tractament dels signes accentuats amb dos caràcters, i també altres
%% perles de caràcters amb xifrat que caldria aclarir
%%(/Users/femfum/Desktop/eraalescriptori_220810/programa-a4.pdf)
%%Fi de Pegues 8


%%Pegues 9
%%(/Users/femfum/Desktop/TrepitjantPoesia.pdf)
%(/Users/femfum/OnEtsOncleGuillem/parlament/compareixenca/S20C-41410201124012_36_34.pdf)
%%Fi de Pegues 9


%%Pegues 10
%%Amb #10 hi ha un error en la visualització d'Acrobat8 però el Preview l'obre bé
%%(/Users/femfum/Desktop/Colloqui\ WB\ WEB.pdf)

%%L'opció #10 genera un PDF que l'Acrobat es queixa per errors de visualització
%%(/Users/femfum/Desktop/Pantone-FCR-sp2010f.pdf)

%%No separa correctament els elements d'imatge (inLines?)
%%(/enfony/CaLi2CoPi/a3copiseny/proves13i14/Imatges trocejades.pdf)

%%Caldria implementar els objectes cridats com a un Pattern (sense l'operador sh)
%% per tal d'incorporar-los a la capa dels ShadingPatterns
%%(/Users/femfum/Sites/a3copiseny/CaLi2CoPi_13/xA3copiseny/3TecniquesDdegradats.pdf)

%%(/Users/femfum/Desktop/eraalescriptori_250909/barca-athletic.pdf)
%%(/Users/femfum/Desktop/propostaLlotja/PublicacioESDAP_web.pdf)

%(/Users/femfum/Desktop/jakobReloaded/1-128_9788723035769.pdf)
%%(/Users/femfum/Desktop/rectaFinalElaGeminada/comunicatPDF/comunicat-ela-h2.pdf)
%%(/Users/femfum/Downloads/ARA/ara_1290898800.pdf)
%(/Users/femfum/Masats/012MY1A1-tbo-amb-capas.pdf)
%%Fi de Pegues 10


%%Pegues 11
%%Fi de Pegues 11

%%Pegues 12
%% Simsi: projecte de Polynorma
%% x analitzar
%%(/Users/femfum/Desktop/polyNorma/Pag1TarifaNaviDirecte290910.pdf)
%%(/Users/femfum/Desktop/polyNorma/3linies.pdf)
%%(/Users/femfum/Desktop/polyNorma/duespagines.pdf)
%%(/Users/femfum/Desktop/polyNorma/012034056.pdf)

%%Recta final?
%%(/Users/femfum/Desktop/polyNorma/0123456_60123456_6xfer.pdf)  %%
%%(/Users/femfum/Desktop/polyNorma/012345601203456xfer.pdf)  %% B!
%%(/Users/femfum/Desktop/polyNorma/6543211112435xfer.pdf)  %% B!
%%(/Users/femfum/Desktop/polyNorma/112435xfer.pdf)  %% B!
%%(/Users/femfum/Desktop/polyNorma/1paginaCatalegPolynorma_NavisionPDFcreator.pdf)  %% B!
%%(/Users/femfum/Desktop/polyNorma/1234555455xfer.pdf)  %% B!
%%(/Users/femfum/Desktop/polyNorma/00112223333xfer.pdf)  %% B!
%%(/Users/femfum/Desktop/polyNorma/012034056xfer.pdf)  %% B!
%%(/Users/femfum/Desktop/polyNorma/6543210011222000xfer.pdf)  %% B!

%%Cal afinar la recomposició de línies amb el tabulat de l'índex de contingut de pàgina, doncs ara
%% no es respectarà correctament el càlcul de l'amplada de composició al recompondre una línia
%% d'una mateixa jerarquia, en dues o més, cal tenir en compte que això ara no és especialment greu
%% doncs és molt improvable degut a que el localitzador de bookmarks no treballa per paràgrafs si
%% no que treballa per línies isolades (hi hauríem de començar corregint això primer!)
%%Cal esbrinar per que una crida a un tipus de lletra... /Helvetica findfont ...peta a partir de les
%% redefinicions d'encodings a %#%20% ...és hora de treballar amb systemdict /EncodingDirectory get
%%(/Users/femfum/Desktop/polyNorma/faJerarquies.pdf)

%%Error: /typecheck in --cvi--
%%(/Users/femfum/Desktop/Feliz_2011.pdf)
%%Error: /undefined in aTm
%%(/Users/femfum/Desktop/1059458_u.pdf)

%%(/Users/femfum/Desktop/polyNorma/JuguemAmbTextAcrobat_paginaDindex.pdf)

%%(/Users/femfum/Desktop/polyNorma/01344244344_HeusAquiElCaos.pdf)
%%(/Users/femfum/Desktop/polyNorma/0123566664666566_HeusAquiElCaos.pdf)
%%(/Users/femfum/Desktop/polyNorma/0123566665_houston.pdf)

%%(/Users/femfum/Desktop/polyNorma/darrers/pags_TarifasComentariosArbol.pdf)  %% B!

%%Curiosament ara amb el PowerPC del MacBook, just quan repiquem dues vegades, s'ha disparat el
%% temps d'execució i només triga uns 25/30' (abans triplicava aquest temps!)
%%(/Users/femfum/Desktop/polyNorma/darrers/TarifasComentariosArbol.pdf)

%%(/Users/femfum/Desktop/polyNorma/555657TarifasComentariosArbol.pdf)
%%(/Users/femfum/Desktop/polyNorma/1pag_TarifasComentariosArbol.pdf)

%%Ep! si hi ha una pàgina en blanc sense Resources, aturem la feina
%%MRCT20 This Page don't have Resources

%%Hem classificat amb el gatell %%ProblemaD tots els punts de l'algorisme on podem forçar un format
%% de pàgina fictici per tal d'obligar a paginar les noves planes inserides com a índex i estudiar
%% la problemàtica que es produeix, en cas que es generin errors
%%(/Users/femfum/Desktop/polyNorma/1pag_TarifasComentariosArbol.pdf)

%%Error: /undefined in ARAdex
%%(/Users/femfum/Desktop/polyNorma/303132TarifasComentariosArbol.pdf)
%%(\n ... error estructural reinserint l'index ... PLEGUEM!\n\n)
%%(/Users/femfum/Desktop/polyNorma/123TarifasComentariosArbol.pdf)

%%(/Users/femfum/Desktop/polyNorma/01235656356356CreixSenseFi.pdf)  %% B!
%%(/Users/femfum/Desktop/polyNorma/01235656356CreixSensFi.pdf)  %% B!

%%Error: /undefined in araPstream
%%(/Users/femfum/Desktop/polyNorma/properaentrega/Tarifas_10p.pdf)
%%(/Users/femfum/Desktop/polyNorma/properaentrega/Tarifa_PVPs_Marzo_2011_senseOSC.pdf)
%%(/Users/femfum/Desktop/polyNorma/properaentrega/1_10_Tarifa_PVPs_Marzo_2011_senseOSC.pdf)

%% On Ets Oncle Guillem
%%Generant l'Index amb Pagines ...
%% (Kids 0)
%% Error: /undefined in --get--
%% peta si li diem que faci les pàgines d'índex i els Bookmarks NO els genera jeràrquicament bé!
%%(/Users/femfum/Desktop/OnEtsOncleGuillem/re.pdf)
%%No fa el PDF i no dóna cap error!
%%(/Users/femfum/Desktop/OnEtsOncleGuillem/arbreGenealogic.pdf)

%%Hem afegit un filtrat de l'string del text a l'escriure l'índex com a contingut de pàgina
%% doncs s'ha donat el cas d'escriure un parèntesi aïllat dins un titular, vegeu avuipintem
%(/enfony/CaLi2CoPi/polynorma/la21_TarifaPVPsDiciembre2012.pdf)
%%Fi de Pegues 12

%%Pegues 13

%% localització correcte d'inLines
%%(/enfony/CaLi2CoPi/JBC/HTcreator/PDFdirecteWord/misteri2x1_9_pdf_pla2.pdf)
%%(/enfony/CaLi2CoPi/JBC/HTcreator/PDFdirecteWord/00011_PDFA.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/2x2_asimetric_inLines.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/8x8unasobrelaltreInlines.pdf)

%%(/enfony/CaLi2CoPi/a3copiseny/tipusDcosit/inLineiText.pdf)
%% cal forçar l'eliminat de forma explícita els operadors que queden entremig i que estiguin
%% directament relacionats amb els tipus d'objectes que esborrem susceptibles de provocar error
%% com p.e. scn SCN sc SC, pels vectorials i text (caldria veure quins més hem de localitzar)
%%(/enfony/CaLi2CoPi/a3copiseny/Prova1\ sense\ treure\ tracats\ de\ retall.pdf)

%% aquí hi havia un cas excepcional d'un literal que excedeix els 128 caràcters normatius
%% el que ens ha fet modificar els dos algorismes espiadic
%%(/enfony/CaLi2CoPi/a3copiseny/errors13i14/2/7Ciencies36_iMARTI\ 3.pdf)
%%Fi de Pegues 13

%%Pegues 14

%%(/enfony/CaLi2CoPi/a3copiseny/Prova1\ sense\ treure\ tracats\ de\ retall.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/errors13i14/prova.pdf)

%%ATENCIÓ: el nom del pdf a tractar ha de tenir 2 numèrics (llargària indiferent) amb l'estructura:
%% ######_#####_elquesigui.pdf on el segon numèric ha de coincidir amb els numèrics dels noms
%% dels JPEGs a restaurar a cada pàgina ... ######_1.jpg #####_2.jpg #####_3.jpg ... etc
%% el primer numèric és indiferent, doncs és el que posa l'aplicatiu web per distingir-lo
%% tant el pdf original com els JPEGs han d'estar al mateix directori del paràmetre %#% B
%%(/enfony/CaLi2CoPi/1234_08875220043_prova_pdf.pdf)
%%(/enfony/CaLi2CoPi/a3copiseny/errors13i14/4/Setzedefebrer06_pagina26.pdf)
%%Fi de Pegues 14

%%Pegues 15
%%MASATS00
%(/Users/femfum/Masats/entregaFinal/DM0977600E0v2_v2014-4.pdf)  %% capes a 8bits
%(/Users/femfum/Masats/012MY1A1-tbo-amb-capas.pdf)  %% capes en Unicode
%(/Users/femfum/Masats/entregaFinal/DM0977600E0_v2014_llistaIndexDcapes.pdf)  %% capes a 8bits
%(/Users/femfum/enfony/CaLi2CoPi/wwwBugs/dedebo/fets/Mercat_09_pdf.pdf)  %% veiem com s'unifiquen /Contents a 1 sol stream
%(/Users/femfum/Masats/OClayers_capes_lleixes_apel/1lleixa_apel.pdf)  %% provem les redefinicions de BDC EMC
%(/Users/femfum/Masats/DM0977600E0v4_v2014-8.pdf)  %% darrer plànol mestre via Vectorworks
%(/Users/femfum/enfony/CaLi2CoPi/_039_\~0_1lleixa_apel_pdf_iDeM.pdf)  %% test
%(/Users/femfum/Masats/entregaFinal/DM0977600E0v5.pdf)  %% B! x Vectorworks
%(/Users/femfum/Masats/DM0977600E0v6_v2015.pdf)  %% Vectorworks v2015 (duu Object Stream Compression!)
%(/Users/femfum/Masats/DM0977600E0v6_v2015_senseObjectStreamCompression.pdf)  %% Vectorworks v2015 sense ObjectStreamCompression
%(/Users/femfum/Masats/DM0977600E_senseSuperC.pdf)  %% 1 CAPA NO DESAPAREIX! capes a 8bits x Adobe InDesign CS6 (Win) + Adobe PDF Library 10.0.1
%(/Users/femfum/Masats/012MY1A1-tbo-amb-capas.pdf)  %% B! x Vectorworks
%(/Users/femfum/enfony/CaLi2CoPi/_039_\~15_012MY1A1-tbo-amb-capas_pdf_iDeM.pdf)
%(/Users/femfum/Masats/DM0977600E0_v2014.pdf)  %% B! x DraftSight + PDF Export Teigha(r) 3.08.1.48922

%%Test del compressor /Flate en tota mena d'streams
%(/Users/femfum/Masats/OClayers_capes_lleixes_apel/lleixesQdepareixen_LengthDirecte_1solStream.pdf)
%(/Users/femfum/Masats/OClayers_capes_lleixes_apel/lleixesQdepareixen_LengthDirecte_1solStreamDinsArray.pdf)
%(/Users/femfum/Masats/OClayers_capes_lleixes_apel/lleixesQdepareixen_LengthIndirecte_1solStreamDinsArray.pdf)

%%MASATSfebrer0
%% ara posarem el path del pdf a tractar dins una array seguit d'un segon path + el nom del pdf de sortida
%% si el segon paràmetre és un null no farem res i seguirem amb la nomenclatura clàssica segons %#% B
%[
% (/Users/femfum/Masats/contaminatDcolors/DM0977600E0v8_v2015_senseOSC.pdf)
% (/Users/femfum/Masats/contaminatDcolors/apareixVermell.pdf)
%]

%%Incongruències detectades en la generació de PDF del CAD Vectorworks v2014 i anteriors
%% versió a 1.4 quan hauria de ser mínima a 1.5 (les OC no existien abans!) :: ho corregim a la capçalera del fitxer
%% doble marca de cadena unicode <feff> als noms de les capes :: no ho corregim i fa aparèixer un ? al davant del nom
%% doble array a /Order [[ ... ]] al dic /D a /OCProperties :: no ho corregim i ens priva d'esborrar els objectes (no afecta)
%% marcat amb %%MASATS08 ús dels operadors scn i SCN sense haver definit cap ColorSpace a Resources ni haver-lo cridat (cs CS) a Contents :: com que de moment sempre treballa en RGB, ho hem corregit reescrivint al seu lloc rg i RG. A l'esborrar capes, això ens provocava la desaparició de continguts, doncs quan scn o SCN era cridat sense abans haver cridat cap altra color amb rg o RG, perdia el referent!
%% l'anellat gràfic q Q entre elements vectorials (per canvi de color, gruix de línies, etc), és inexistent, la qual cosa afebleix el codi per a possibles manipulacions
%%MASATS09 implementem amb aquest gatell el repicat de Contents comprimits amb Flate

%% peruqè peta a 15?
%%%%%%%% MASATS: llistat de capes del PDF Error: /typecheck in --get-- Operand stack: --nostringval--   --nostringval--   2
%% (/Users/femfum/OnEtsOncleGuillem/20170707_PC_Llei_11_reparacio_juridica_victimes_franquisme.pdf)


%%Fi de Pegues 15


%%Pegues 16
%%MASATStext

[  %% NOU ARRAY de lectura del PDF d'entrada (string índex 0) i escriptura del PDF de sortida (string índex 1)

%%Gatell 0
%%Masats febrer-abril'16
%%ObjectStreams 3.4.6
%%Cal veure la diferència entre (A8 i+): Compress Entire File vs Compress Document Structure
%%Cal veure el suport a les 3.4.7 Cross-Reference Streams vs les clàssiques Cross Reference Tables
%%(ObjectStreamProblem1)
%%Fet! (/Users/femfum/enfony/CaLi2CoPi/ObjectStreamProblem/duuObjectStream_CompressEntireFile_apel.pdf)  %% repara l'original!
%%Fet! (/Users/femfum/enfony/CaLi2CoPi/ObjectStreamProblem/duuObjectStream.pdf)
%%Fet! (/Users/femfum/enfony/CaLi2CoPi/ObjectStreamProblem/aquestPDFduuObjectStreamExtendsLiniaritzat.pdf)  %% duu signatura
%%Fet! (/Users/femfum/Masats/treuificaText/DM0977600E0v9_v2015_original.pdf)  %% duu ObjectStream
%% original de Vectorworks GP28 amb OSC
%%Fet! (/Users/femfum/Masats/treuificaText/errors/GP28originalDM0977600C00v2_v2015.pdf)
%% original de Vectorworks GP09 amb OSC
%%Fet! (/Users/femfum/Masats/treuificaText/errors/GP09originalDM0977600E0v10_v2015.pdf)
%% cercant menes d'ObjectStream
%% aquest sembla un fals OSC
%%Fet! (/Users/femfum/Polynorma/TomDeBeer/20311\ IMPRENTEX.pdf)
%% FWV + ObjectStream (XRefStm + ObjStm)
%%Fet! (/Users/femfum/exposicioRosoCuso1.pdf)
%% FWV + ObjectStream (XRef + ObjStm)
%%Fet! (/Users/femfum/7881_libros_web.pdf)
%% Reader+Acrobat es queixen quan obren un pdf on algun nombre real duu notació exponencial tipus 123.6e10 (p.e. una coordenada)
%% per això hem rebaixat a 10000 el multiplicador del repicat de nombres... 10000 mul truncate 10000 div ...abans era 10000000
%%Fet! (/Users/femfum/23568143904_UBcursusductus.pdf)
%%Fet! AQUEST DOCUMENT DUU SEGURETAT I CAL DETECTAR-LA ABANS DELS Object Streams i Cross-Reference Streams!!!!!!
%% (/Users/femfum/TarrioCarrodeguas_Santiago_B_TD_2012_5de13.pdf)
%%Fet! Error d'estructura: PDF sense Root al trailer!
%(/Users/femfum/Cartell\ Caminada-sopar\ Ref.\ Rasos.pdf)
%%Fet! Resolt un error d'escriptura d'espai de color al fitxer XRay
%(/Users/femfum/Vissir\ \(1\).pdf)
%%Exemple de fitxer amb MRCT16 Cua de PDF amb brossa (%#%09%) on podriem netejar la brossa que dóna Error: /undefined in ÿError
%(/Users/femfum/Polynorma/TomDeBeer/Tarifa\ C3.pdf)

%% Casas Vilardaga
%(/Users/femfum/IsidreCasasTubau/familiaCasasVilardaga9.pdf)

%%Sarrió 28-09-16 28-10-16
%%(/Users/femfum/Downloads/Atrian_Bakers_2016.pdf)

%%ERROR! (%#%13%) Recalculem la clau /Length Error: /rangecheck in --cvs-- Operand stack: --nostringval-- 3533___________0 (\000\000\000\000\000\000\000\000\000\000)
%(/Users/femfum/enfony/CaLi2CoPi/Sarrio/Atrian_Bakers_2016_1solaSoftMask_p8.pdf)

%(/Users/femfum/elageminada/espaifabria.pdf)

%%ERROR 0! (%#%25%) Error: /typecheck in --get-- Operand stack: R23 23_____________0 23_____________0 Type
%(/Users/femfum/calaixDtipus/PepelPatau/furafont/re_error.pdf)

%(/Users/femfum/calaixDtipus/PepelPatau/furafont/re.pdf)
%(/Users/femfum/OnEtsOncleGuillem/20170707_PC_Llei_11_reparacio_juridica_victimes_franquisme.pdf)

 %% Martin Stumpf
 %(/Users/femfum/calaixDtipus/PepelPatau/furafont/SF_cat/FuraFont_v.0.002/exemple_glifBluesNodeSospitosos.pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/FAZ-RMZ-19.10.2017\[1\].pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/_1_ePaper_WELT_DWBE-HP_02.10.2017_Gesamtausgabe_DWBE-HP.pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/Seite_1_Burgdorf__Emmental_2017-10-31.pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/badische_z_itung_fre_demo_30042016_Seite_1.pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/_1_taz_2017_11_01.pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/_Seite_1_Burgdorf__Emmental_2017-10-31.pdf)
 %(/Users/femfum/historiaDlaMevaVida/unaPaginaEnBlanc_laHistoriaDeLaMevaVida_154.pdf)

%%MASATSencvlct
%(/Users/femfum/Masats/projecteSumaCapes/2019/caixeti_pla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1117-C.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1132-C.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1214-C.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1413-C.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1522-C.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1612-C.pdf)

%% test /Resources
%(/Users/femfum/Masats/projecteSumaCapes/2019/encadenats7planols_masats.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FAnPaginesBuides.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/7planols_masats_pla17.pdf)
%% test Bbox
%(/Users/femfum/Masats/projecteSumaCapes/2019/7aplanxar_masats_juguemBbox.pdf)

%% xapes llill
%%(/Users/femfum/CEM/CEM75a/18\ no\ complet/75GLLS/DOSSIER/2019/fa131agulles/xapes/Xapa50mm_ambmarge62mm.pdf)
%(/Users/femfum/CEM/CEM75a/18\ no\ complet/75GLLS/DOSSIER/2019/logoRodoText_llillpdf.pdf)
%(/Users/femfum/CEM/CEM75a/18\ no\ complet/75GLLS/DOSSIER/2019/fa131agulles/xapes/banderins/banderiTipus_180x250_senseText.pdf)

%% peta el repicat de subseccions?
%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/JoAcuso/ZGlhcmkganVkaWNpIGRlbW9jcmFjaWEgbnVtZXJvIDE.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/JuguemAmb_n_i_f_Apel.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/JoAcuso/diari-omnium-judici-a-la-democracia.pdf)

%%BUG surt estranyament sense errors a MRCT20 This Page don't have /Resources /69_____________0 (3) ...DONE (some garbage collected on /tmp will be useful)
%(/Users/femfum/OnEtsOncleGuillem/fosses/MaquisSantMateu/llibreStMateu2019/Llibre_Sant_Mateu_Revisio.pdf)

%%BUG al REPICAT a zero 
%%ATENCIÓ:hi ha un inexplicable desplaçament vertical progressiu (de baix a dalt) de les anotacions envers la casella gràfica
%(/Users/femfum/calaixDtipus/PepelPatau/furafont/FURAFONT_v0001/exemple_Valliciergo_1000x9caselles.pdf)

%% sense subseccions
%(/Users/femfum/nadalaAltimis2018.pdf)
%(/Users/femfum/out.pdf)

%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/MakeAmove/logo_blanc.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/Llibertat_ANC.pdf)
%(/Users/femfum/enfony/CaLi2CoPi/Sarrio/problemaDiBaAjMan/EstructuraEmpresarialDemarcacioBarcelona2017_WEB_A8optim_pla_ResourcePattern_300.pdf)
%(/Users/femfum/enfony/CaLi2CoPi/Sarrio/problemaDiBaAjMan/EstructuraEmpresarialDemarcacioBarcelona2017_WEB_A8optim_pla_.pdf)
%(/Users/femfum/Sarrio_270218/Estructura_Empresarial_Demarcacio_Barcelona_2017_WEB_pla_senseCapes.pdf)
%(/Users/femfum/Sarrio_270218/Estructura_Empresarial_Demarcacio_Barcelona_2017_WEB.pdf)
%(/Users/femfum/Sarrio_270218/Pag7_Estructura_Empresarial_Demarcacio_Barcelona_2017_pla3.pdf)
%(/Users/femfum/enfony/CaLi2CoPi/Sarrio/problemaDiBaAjMan/2016/EstructuraEmpresarialDemarcacioBarcelona2016.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/resultat.pdf)

%(/Users/femfum/PliegOS/codi_pliegOS/resultat_patufet_4up.pdf)

%% sobre lligadures PDF vs lligadures HTML
%(/Users/femfum/elageminada/GVB.pdf)

%%Aplanats
%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/Vic/llasavic.pdf)
%(/Users/femfum/expoPicas/textDefinitiuCortines.pdf)
%(/Users/femfum/expoPicas/credits_lateralDret_pla.pdf)
%(/Users/femfum/CAPporta.pdf)
%(/Users/femfum/elageminada/exemples_TaggedPDF/textflow_pdfua1.pdf)

%%XReferenceXobjects
%(/Users/femfum/JBC/exempleDcridesPDFsofisticades/exemplesDreferenceXObjectsByShradhaBudhiraja/refxob_x5_1pg.pdf)
%(/Users/femfum/JBC/exempleDcridesPDFsofisticades/exemplesDreferenceXObjectsByShradhaBudhiraja/targetX5.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/resultat_2up.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/patufet_avuiFa100anys_19200410-23204.pdf)

%%PliegO'Maker
%(/Users/femfum/PliegOS/codi_pliegOS/PDFscripting/ACJ_pliego_test_1a.pdf)
%(/Users/femfum/extracte_mossegar-la-poma.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/pseudoMalevitx_ambCropBox.pdf)

%%CEM100
%(/Users/femfum/Sites/Sarrio/BUSTIA_700x200_V_4x4.pdf)
%(/Users/femfum/Sites/Sarrio/NObustia_783x200_V_4x4.pdf)
%(/Users/femfum/Sites/Sarrio/prova35x35_filet.pdf)
%(/Users/femfum/CEM/novaSeu/facanaDvidre/entregaSarrio/vidre_0_xaletRasosFlorDeNeu_CutContour.pdf)
%(/Users/femfum/CEM/novaSeu/facanaDvidre/entregaSarrio/vidre_0/xaletDelsRasos_bustia_refugiarbreflordeneu_350x285px_0_CutContour.pdf)
%(/Users/femfum/Sites/Sarrio/JosepClaretGuberna_200x200mm_180x180px_definitiu_.pdf)
%(/Users/femfum/CEM/novaSeu/facanaDvidre/entregaSarrio/vidre_2/Montserrat_vidre2_tros_4_.pdf)
%(/Users/femfum/Sites/Sarrio/columnaMetallica_0_.pdf)
%(/Users/femfum/CEM/novaSeu/facanaDvidre/entregaSarrio/SrClaret/aveureCutContourViaPS.pdf)

%%Nira
%(/Users/femfum/expoNira/merlets/merletBase_mandalaArtDeViure_DWG.pdf)
%(/Users/femfum/expoNira/ulls/ull_vector_x5.pdf)

%%Lletraferits 2023
%(/Users/femfum/fancytooltips.pdf)
%(/Users/femfum/floating_text.pdf)

%(/Users/femfum/ComunitatDpropietarisPonent/plaquesSolarsTecnium/Acord_veins-EraDenComa.pdf)
%(/Users/femfum/OnEtsOncleGuillem/parlament/errorCompareixents/FundacioCiprianoGarcia/compareixenaalparlamentprojectedelleidememriadem/BOPC_538_8.pdf)

%%ARA 22/10/2023 especial Miró-Picasso
%(/Users/femfum/ARA221023_MiroPicasso_file-f44e18f.pdf)
%%ARA 10/12/2023 especial Any Tàpies
%(/Users/femfum/ARAdiumenge101223_AntoniTapies100anys_file-efdad18.pdf)
%(/Users/femfum/ARA_101223_TapiesDiariEspecial_file-47fe52d.pdf)

%(/Users/femfum/JardinsDeLlum2024/8x8_gubia.pdf)
%(/Users/femfum/JardinsDeLlum2024/tallDeGubia_94x14px_100x15cm_tractamentOptimitzat.pdf)
%(/Users/femfum/PliegOS/gigapliegos/re.pdf)

%%IN
%%UBpliegOMaker

%% exemple de PDF signat digitalment
%(/home/femfum/Documents/UB/pressupostUB_10_2024_MarcantoniMalagarrigaPicas_signat.pdf)

%% exemples de PDFs encriptats
%% (/home/femfum/Documents/pliegOMakerUB/encriptatAEIOUSenzill.pdf)
(/home/femfum/Documents/pliegOMakerUB/encriptatAEIOUSenzill_obertura_aeiou.pdf)


%%URLREpublica
%exch  %% path i nom del fitxer carregat al servidor a tractar
%aCaLi2CoPi

%(/Users/femfum/PliegOS/codi_pliegOS/ElBorinot_any1_n1_19231129.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/8CropBox.pdf)
%(/Users/femfum/Sites/REMSA/prntdssr/PDFsAmbCasuistiques/duuSeguretat_1.pdf)
%(/Users/femfum/enfony/CaLi2CoPi/signatReaderXI_039_\~15_DM0977600E0v6_v2015_senseObjectStreamCompression_pdf_eliminaLlesques.pdf)

%%PETEN!
%%ARASOM

%%CAL saber el perquè si %#% C és a 0 (unifiquem streams de Contents) va bé i si fem 1 (deicar-ho intacte) peta?
%(/Users/femfum/PliegOS/codi_pliegOS/PDFscripting/ACJ_pliego_test_1a_pla_aZero.pdf)

%%CAL saber perquè peta tant si %#% C és a 0 o a 1
%% (%#%25%) Error: /undefined in --get--
%(/Users/femfum/PP-Gramatica-dels-noms-propis.pdf)

%(/Users/femfum/Albert-Forns-Chuck-Palahunik-a-Barcelona.pdf)

%(/Users/femfum/extracte_mossegar-la-poma_pla.pdf)

%%Ela geminada
%(/Users/femfum/elageminada/el_riure_definitiu2_edicionsElGeminada.pdf)


%%Altres
%(/Users/femfum/OnEtsOncleGuillem/fosses/obriuTotsElsClots/adhesiuHumanRights/HumanRightsLogo_just.pdf)
%(/Users/femfum/diariARA061022_EugeniaBalcells.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/documental_llill/bolus/BCN_LesCorts/BCNlesCorts_cartell_llum_i_llibertat.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/resultat.pdf)
%(/Users/femfum/calaixDtipus/BunkerType/Brother_HL-L2350DW.pdf)
%(/Users/femfum/calaixDtipus/BunkerType/Malament.pdf)
%(/Users/femfum/enfony/enflataGlifs/out.pdf)
%(/Users/femfum/flck_sense.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/elTempsDeLesArts/dossier_llill_ArtistesDeLaRepublica.pdf)
%(/Users/femfum/elageminada/out.pdf)
%(/Users/femfum/CEM/centenari/pessebres/plantaBibliotecaCasino_zonaExpoPessebres100CEM_3grupsPressebres.pdf)
%(/Users/femfum/represaEnsenyament/AnnexII_trajectoriaProfessional_2005_2021.pdf)

%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/exemplesPDFfoms/DatesExample2_start.pdf)
%(/Users/femfum/Downloads/JavaScriptClock.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/Brunet/quasiapunt/fitxaCimViaPirinenca2022_enBlanc.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/aveuri.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/exemplesPDFfoms/DynamicList_imatgeBotoDesada.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/faFitxesDassaig/re.pdf)
%(/Users/femfum/AC01_fitxaDassaigViaPirinenca.pdf)

%%ERRORS PER RESOLDRE ENCARA

%%Error de visualització si comprimim els streams amb Flate! ...funciona bé si els deixem en obert
%(/Users/femfum/AT\ Calendario\ 2014.pdf)

%%Aquest avís passa de tant en quan un cop hem fet el repicat ...és un error de byteoffset?
%% Cannot extract the embedded font 'LCEFTM+ChronicleDisplay-Black'. Some characters may not display or print correctly.???
%(/Users/femfum/rar_1401573601.pdf)
%% Cannot extract the embedded font 'TWRLXL+ChronicleDisplay-Black'. Some characters may not display or print correctly.
% (/Users/femfum/rar_1402178401.pdf)
%% en comparativa EN AQUESTS NO DÓNA ERROR
%% (/Users/femfum/rar_1441490401.pdf)
%% (/Users/femfum/rar_1442095201.pdf)

%%Gatell 9 (extracció d'imatges)
%(/Users/femfum/laTaulaDelsSavis/persiana2.pdf)

%%Aquí interpreta i repica bé el text

 %(/Users/femfum/Masats/treuificaText/errors/GP28_senseOSCviaA8_DM0977600C00v2_v2015.pdf)  %% sense OSC A8
 %(/Users/femfum/Masats/treuificaText/GP09_DM0977600E0v9manipulat_OSCaplanatXa11.pdf)
 % (/Users/femfum/Masats/treuificaText/errors/GP28.pdf)  %% sense OSC A11
 %(/Users/femfum/Masats/treuificaText/errors/pla_GP28.pdf)
 %(/Users/femfum/Masats/treuificaText/DM0977600E0v9_v2015_senseOSC.pdf)
 %(/Users/femfum/Masats/entregaFinal/DM0977600E0v5.pdf)

 %(/Users/femfum/Masats/DM0977600E0v6_v2015_senseObjectStreamCompression.pdf)
 %(/Users/femfum/Masats/treuificaText/pla_DM0977600E0v9_v2015_brossaTj.pdf)
 %(/Users/femfum/Masats/contaminatDcolors/DM0977600E0v8_v2015_senseOSC.pdf)

 %(/Users/femfum/Masats/treuificaText/pla_coreFontAmbRiscDglifs.pdf)
 %(/Users/femfum/Masats/treuificaText/pla_textos_TJ.pdf)

 %% amb font original (KozGoPr6N-Bold) ben incrustada i amb mètrica particular
 %(/Users/femfum/Masats/treuificaText/pla_KozGoPr6N-Bold.pdf)

%(/Users/femfum/OnEtsOncleGuillem/UB/Malgosa080715.pdf)
%(/Users/femfum/Downloads/diumenge_ARA010215.pdf)

 %(/Users/femfum/enfony/CaLi2CoPi/JuguemAmbTextApel_fontsType3.pdf)
 %(/Users/femfum/Masats/treuificaText/2mots2Rengs.pdf)
 %(/Users/femfum/Masats/treuificaText/2MotsMateixReng_gs_pla.pdf)
 %(/Users/femfum/Masats/treuificaText/2mots1rotat.pdf)
 %(/Users/femfum/Masats/treuificaText/2mots3pagines1enBlanc.pdf)
 %(/Users/femfum/Masats/treuificaText/2mots3pagines1enBlanc1repetit.pdf)
 %(/Users/femfum/Masats/treuificaText/2mots3pagines1enBlanc1repetitMateixaY.pdf)
 %(/Users/femfum/Masats/treuificaText/textMMType1_ambNOMES_Td_senseTm_cm_pla.pdf)

 %(/Users/femfum/TargetesWhatsUp.pdf)  %% aquí hi ha una pseudoCoreFont amb subconjunt de notació 123456+
 %(/Users/femfum/Masats/manual122014_Masats.pdf)
 %(/Users/femfum/CatalegTocats14Definitiu.pdf)
 %(/Users/femfum/ranpoint14032004.pdf)
 %(/Users/femfum/a_MinionMM_correccioOptica_6_72.pdf)

 %(/Users/femfum/Masats/treuificaText/errors/pla_GP28_1LiniaConflictiva.pdf)  %% aïllem el problema

 %(/Users/femfum/Masats/treuificaText/DM0977600E0v9_v2015_original_OSCaplanatXa8.pdf)
 %(/Users/femfum/Masats/treuificaText/pla_DM0977600E0v9_v2015_original_OSCaplanatXa8.pdf)
 %(/Users/femfum/Masats/treuificaText/errors/GP09.pdf)  %% sense OSC A11

 %(/Users/femfum/Masats/treuificaText/pla_especialAmbGlyphshowDuuDifferences.pdf)
 %(/Users/femfum/Masats/treuificaText/textAmbFontDidotIncrustada.pdf)
 %(/Users/femfum/Masats/treuificaText/especialAmbGlyphshowDuuDifferences.pdf)

%%ERRORS PENDENTS:

%%Jordi Servitja 270715
%%Error: 16
%%( ... peta Tm)(698)null(698)null698.839 270.2814.0 0.0 0.0 14.0
%(/Users/femfum/Masats/treuificaText/errors/072015_GP09.pdf)

% (/Users/femfum/Masats/treuificaText/_masega.pdf)
%%Ara extrau bé però desapareixen els continguts al Viewer!
% (/Users/femfum/Masats/entregaFinal/DM0977600E0v2_v2014-4.pdf)
%%Error: /rangecheck in --get-- CAL TRASLLADAR L'ALGORISME FET A Tj CAP A TJ

%%AMB TJ
%% (%#%52bis.6.2%) /1 (BESSONADA #2#) ( ... peta TJ)
% 243 [556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 277 556 556 556 556 556 556 556 556 556 556 556 610 556 556 556 556 556 556 556 556 777 556 556 722 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 556 500 556 556 277 556 556 222 556 556 556 556 556 556 556 556 333 500 277 556 500] 243
% (\000R\000e\000v\000i\000s\000i\000\363\000n\000:) [[(Revisi\363n:) (Ex\340men:) 0 false /fMSTS4 false false]]
% [(\000R\000e\000v\000i\000s\000i\000\363\000n\000:)] -dict-
%%AMB Tj
% (%#%52bis.6.2%) /1 (BESSONADA #2#)
%%Error: /rangecheck in --get--
% Operand stack: --dict:6/6(L)--   (\000R\000e\000v\000i\000s\000i\000\363\000n\000:)   --nostringval--   (\000R\000e\000v\000i\000s\000i\000\363\000n\000:)   243   --nostringval--   243
% (/Users/femfum/Masats/treuificaText/pla_DM0977600E0v2_v2014-4.pdf)

%(/Users/femfum/Masats/DM0977600E0_v2014.pdf)

%%CAL REPASSAR SI ENCARA PETEN:

%% cal comprovar si l'extracció és correcta
%(/Users/femfum/Masats/012MY1A1-tbo-amb-capas.pdf)

%% (%#%27bis%) (F4) ( ... peta Tf)
%%Error: /undefined in --get--
%% Operand stack: --dict:2/2(L)--   C2_0
% (/Users/femfum/Masats/DM0977600E_senseSuperC.pdf)

%% (%#%23%) /1 (F3) (F3) (F3) (F3) (F3) (F3) (F3) (F3) (BESSONADA 3) ( ... peta Tj 0) 30
%% [500 278 500 500 500 500 500 500 500 250 278 611 556 556 778 611 611 500 611 278]
%% 30 (\037...)
% (/Users/femfum/bcn_olesa_monts.pdf)




 %(/Users/femfum/Masats/treuificaText/masega.pdf)
 %(/Users/femfum/Masats/abril2016/aviam.pdf)
 %(/Users/femfum/IsidreCasasTubau/fcv_apel.pdf)

 %%Sarrió 28-09-16 28-10-16
 %(/Users/femfum/enfony/CaLi2CoPi/Sarrio/apel_Atrian_Bakers_2016_1SoftMask_p8.pdf)

 % (/Users/femfum/elageminada/espaifabria_PDFcontext.pdf)
 %(/Users/femfum/calaixDtipus/PepelPatau/furafont/re_pla.pdf)
 %(/Users/femfum/elageminada/operacioLligadura/PDF/AVL_pla.pdf)

 %(/Users/femfum/OnEtsOncleGuillem/20170707_PC_Llei_11_reparacio_juridica_victimes_franquisme_Recomp1stream.pdf)

 %% Martin Stumpf
 %(/Users/femfum/calaixDtipus/PepelPatau/furafont/SF_cat/FuraFont_v.0.002/CaLi2CoPi_exemple_glifBluesNodeSospitosos.pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/FAZ-RMZ-19.10.2017_1.pdf)  %% encriptat
 % els forms aniuats fan impossible l'esborrat correcte de continguts a 15
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/1_1_ePaper_WELT_DWBE-HP_02.10.2017_Gesamtausgabe_DWBE-HP.pdf)
 %% bon exemple de les 5 matèries primeres: XObjects, Form XObjects (sense aniuar!), Paths, Shanding Patterns, Text
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/_Seite_1_Burgdorf__Emmental_2017-10-31.pdf)
 %% 3 matèries primeres
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/_badische_z_itung_fre_demo_30042016_Seite_1.pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/_taz_2017_11_01.pdf)
 %(/Users/femfum/enfony/CaLi2CoPi/MartinStumpf/raster__Seite_1_Burgdorf__Emmental_2017-10-31.pdf)
 %(/Users/femfum/historiaDlaMevaVida/unaPaginaEnBlanc_laHistoriaDeLaMevaVida_154_pla.pdf)

%%MASATSencvlct
%(/Users/femfum/Masats/projecteSumaCapes/2019/caixeti_repla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1117-C_pla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1132-C_pla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1214-C_pla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1413-C_pla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1522-C_pla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FUNA1612-C_pla.pdf)

%% test Resources
%(/Users/femfum/Masats/projecteSumaCapes/2019/encadenats7planols_masats_encavalcat.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/FAnPaginesBuides_pla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/7planols_masats_pla17_encavalcats.pdf)
%% test Bbox
%(/Users/femfum/Masats/projecteSumaCapes/2019/7aplanxar_masats_juguemBbox_.pdf)

%% xapes llill
%% (/Users/femfum/CEM/CEM75a/18\ no\ complet/75GLLS/DOSSIER/2019/fa131agulles/xapes/Xapa50mm_ambmarge62mm_pla.pdf)
%(/Users/femfum/CEM/CEM75a/18\ no\ complet/75GLLS/DOSSIER/2019/logoRodoText_llillpdf_pla.pdf)
%(/Users/femfum/CEM/CEM75a/18\ no\ complet/75GLLS/DOSSIER/2019/fa131agulles/xapes/banderins/banderiTipus_180x250_senseText_pla.pdf)

%% peta el repicat de subseccions?
%% (%#%56%) Error: /rangecheck in --getinterval-- Operand stack:  --nostringval--   --nostringval--   254   36
%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/JoAcuso/ZGlhcmkganVkaWNpIGRlbW9jcmFjaWEgbnVtZXJvIDE_Xpla.pdf)
%(/Users/femfum/Masats/projecteSumaCapes/2019/JuguemAmb_n_i_f_Apel_Xpla.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/JoAcuso/diari-omnium-judici-a-la-democracia_Xpla.pdf)

%%BUG surt estranyament sense errors a MRCT20 This Page don't have /Resources /69_____________0 (3) ...DONE (some garbage collected on /tmp will be useful)
%(/Users/femfum/OnEtsOncleGuillem/fosses/MaquisSantMateu/llibreStMateu2019/Llibre_Sant_Mateu_Revisio_pla.pdf)

%%BUG al REPICAT a zero 
%%ATENCIÓ:hi ha un inexplicable desplaçament vertical progressiu (de baix a dalt) de les anotacions envers la casella gràfica
%(/Users/femfum/calaixDtipus/PepelPatau/furafont/FURAFONT_v0001/exemple_Valliciergo_1000x9caselles_pla.pdf)

%(/Users/femfum/nadalaAltimis2018_pla.pdf)
%(/Users/femfum/out_pla.pdf)

%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/MakeAmove/logo_blanc_pla.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/Llibertat_ANC_pla.pdf)

%(/Users/femfum/enfony/CaLi2CoPi/Sarrio/problemaDiBaAjMan/EstructuraEmpresarialDemarcacioBarcelona2017_WEB_A8optim_pla_ResourcePattern_347.pdf)
%(/Users/femfum/Sarrio_270218/Estructura_Empresarial_Demarcacio_Barcelona_2017_WEB_pla_senseCapes_test.pdf)
%(/Users/femfum/Sarrio_270218/Estructura_Empresarial_Demarcacio_Barcelona_2017_WEB_pla.pdf)
%(/Users/femfum/Sarrio_270218/Pag7_Estructura_Empresarial_Demarcacio_Barcelona_2017_optim.pdf)
 %% /301 (BESSONADA 2) (%#%23bis53%) (%#%25%) (%#%26%) MRCT20 This Page don't have /Resources
%(/Users/femfum/PliegOS/codi_pliegOS/resultat_pla.pdf)

%(/Users/femfum/PliegOS/codi_pliegOS/resultat_patufet_4up_pla.pdf)

%%Aplanats
%%(/Users/femfum/ArtistesDeLaRepublica/espiguesDor/glifalmapa/Vic/llasavic_pla.pdf)
%(/Users/femfum/expoPicas/textDefinitiuCortines_pla.pdf)
%(/Users/femfum/expoPicas/credits_lateralDret_arapla.pdf)
%(/Users/femfum/CAPporta_pla.pdf)
%(/Users/femfum/elageminada/onomasticaLdot_valencia_castella_4_5968779449263456802_pla.pdf)
%(/Users/femfum/elageminada/exemples_TaggedPDF/textflow_pdfua1_pla.pdf)
% (/Users/femfum/laTaulaDelsSavis/persiana2_ltds.pdf)

%%ReferenceXobjects
%(/Users/femfum/JBC/exempleDcridesPDFsofisticades/exemplesDreferenceXObjectsByShradhaBudhiraja/refxob_x5_1pg_pla.pdf)
%(/Users/femfum/JBC/exempleDcridesPDFsofisticades/exemplesDreferenceXObjectsByShradhaBudhiraja/targetX5_pla.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/resultat_2up_pla.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/patufet_avuiFa100anys_19200410-23204_pla.pdf)

%%PliegO'Maker
%(/Users/femfum/PliegOS/codi_pliegOS/PDFscripting/ACJ_pliego_test_1a_pla.pdf)
%(/Users/femfum/extracte_mossegar-la-poma_foraCropBox_pla.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/pseudoMalevitx_ambCropBox_pla.pdf)

%%CEM100
%(/Users/femfum/Sites/Sarrio/BUSTIA_700x200_V_4x4_pla.pdf)
%(/Users/femfum/Sites/Sarrio/NObustia_783x200_V_4x4_pla.pdf)
%(/Users/femfum/Sites/Sarrio/prova35x35_filet_pla.pdf)
%(/Users/femfum/CEM/novaSeu/facanaDvidre/entregaSarrio/vidre_0_xaletRasosFlorDeNeu_CutContour_pla.pdf)
%(/Users/femfum/CEM/novaSeu/facanaDvidre/entregaSarrio/vidre_0/xaletDelsRasos_bustia_refugiarbreflordeneu_350x285px_0_CutContour_pla.pdf)
%(/Users/femfum/Sites/Sarrio/Montserrat_vidre_3_tros_3_CutContour.pdf)
%(/Users/femfum/Sites/Sarrio/JosepClaretGuberna_200x200mm_180x180px_definitiu_CutContour.pdf)
%(/Users/femfum/CEM/novaSeu/facanaDvidre/entregaSarrio/vidre_2/Montserrat_vidre2_tros_4_CutContour.pdf)
%(/Users/femfum/Sites/Sarrio/columnaMetallica_0_CutContour.pdf)
%(/Users/femfum/CEM/novaSeu/facanaDvidre/entregaSarrio/SrClaret/aveureCutContourViaPS_pla.pdf)

%%Nira
%(/Users/femfum/expoNira/merlets/merletBase_mandalaArtDeViure_DWG_pla.pdf)
%(/Users/femfum/expoNira/ulls/ull_vector_x5_pla.pdf)

%%Lletraferits 2023
%(/Users/femfum/fancytooltips_pla.pdf)
%(/Users/femfum/floating_text_pla.pdf)

%(/Users/femfum/ComunitatDpropietarisPonent/plaquesSolarsTecnium/Acord_veins-EraDenComa_pla.pdf)
%(/Users/femfum/OnEtsOncleGuillem/parlament/errorCompareixents/FundacioCiprianoGarcia/compareixenaalparlamentprojectedelleidememriadem/BOPC_538_8_pla.pdf)

%%ARA 22/10/2023 especial Miró-Picasso
%(/Users/femfum/ARA221023_MiroPicasso_file-f44e18f_HansPeter.pdf)
%%ARA 10/12/2023 especial Any Tàpies
%(/Users/femfum/ARAdiumenge101223_AntoniTapies100anys_file-efdad18_pla.pdf)
%(/Users/femfum/ARA_101223_TapiesDiariEspecial_file-47fe52d_pla.pdf)

%(/Users/femfum/JardinsDeLlum2024/8x8_gubia_pla.pdf)
%(/Users/femfum/JardinsDeLlum2024/tallDeGubia_94x14px_100x15cm_tractamentOptimitzat_senseObjStm.pdf)
%(/Users/femfum/PliegOS/gigapliegos/re_pla.pdf)

%%OUT
%%URLREpublica
%%UBpliegOMaker

dup dup length dup /araVa exch def 8 add string dup 3 -1 roll 0 exch putinterval dup araVa (_pla.pdf) putinterval

%(VIIIAMMM) pstack quit
%(/Users/femfum/PliegOS/codi_pliegOS/ElBorinot_any1_n1_19231129_pla.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/8CropBox_pla.pdf)
%(/Users/femfum/Sites/REMSA/prntdssr/PDFsAmbCasuistiques/duuSeguretat_1_pla.pdf)
%(/Users/femfum/enfony/CaLi2CoPi/signatReaderXI_039_\~15_DM0977600E0v6_v2015_senseObjectStreamCompression_pdf_eliminaLlesques_pla.pdf)

%%PETEN!
%%ARASOM
%(/Users/femfum/PliegOS/codi_pliegOS/PDFscripting/ACJ_pliego_test_1a_pla_aZero_pla.pdf)
%(/Users/femfum/PP-Gramatica-dels-noms-propis_pla.pdf)
%(/Users/femfum/Albert-Forns-Chuck-Palahunik-a-Barcelona_pla.pdf)

%(/Users/femfum/extracte_mossegar-la-poma_plaBO.pdf)


%%Ela geminada
%(/Users/femfum/elageminada/el_riure_definitiu2_edicionsElGeminada_pla.pdf)


%%Altres
%(/Users/femfum/OnEtsOncleGuillem/fosses/obriuTotsElsClots/adhesiuHumanRights/HumanRightsLogo_just_pla.pdf)
%(/Users/femfum/diariARA061022_EugeniaBalcells_pla.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/documental_llill/bolus/BCN_LesCorts/BCNlesCorts_cartell_llum_i_llibertat_pla.pdf)
%(/Users/femfum/PliegOS/codi_pliegOS/resultat_pla.pdf)
%(/Users/femfum/calaixDtipus/BunkerType/Brother_HL-L2350DW_pla.pdf)
%(/Users/femfum/calaixDtipus/BunkerType/Malament_pla.pdf)
%(/Users/femfum/enfony/enflataGlifs/out_pla.pdf)
%(/Users/femfum/flck_sense_pla.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/elTempsDeLesArts/dossier_llill_ArtistesDeLaRepublica_pla.pdf)
%(/Users/femfum/elageminada/out_pla.pdf)
%(/Users/femfum/CEM/centenari/pessebres/plantaBibliotecaCasino_zonaExpoPessebres100CEM_3grupsPressebres_pla.pdf)

%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/exemplesPDFfoms/DynamicList_imatgeBotoDesada_pla.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/exemplesPDFfoms/JavaScriptClock_pla.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/Brunet/quasiapunt/fitxaCimViaPirinenca2022_enBlanc_pla.pdf)
%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/aveuri_pla.pdf)
%%(/Users/femfum/ArtistesDeLaRepublica/Pirineus/serpentEnorme/fitxesCIM/faFitxesDassaig/re_pla.pdf)
%(/Users/femfum/AC01_fitxaDassaigViaPirinenca_pla.pdf)

]
%%Fi de Pegues 16

%#% B path + tram del nom del nou PDF reescrit i tractat segons l'opció escollida %%%%%%%%%%%%%

%%% en cas del projecte JBC es la DLL qui controla el nom i el path del fitxer de sortida
%%(C:/MaRCanToni/FemFum/taller_d'applets/CaLi2CoPi/0test036_JBC.pdf)

%% Win
%%(C:/MaRCanToni/FemFum/taller_d'applets/CaLi2CoPi/0test036)
%%(C:/MaRCanToni/FemFum/taller_d'applets/aramateix/DiBa/Institutd'Edicions/Coromines/REFET.PDF)
%%(C:/MaRCanToni/FemFum/taller_d'applets/aramateix/WebProof/CALi2COPi/0test034)

%%% GS MacOSX/Unix/Linux %%%
%%(/enfony/CaLi2CoPi/_CREUS_test036_)

(/Users/femfum/enfony/CaLi2CoPi/_042_)
%(/Users/femfum/Sarrio_270218/_041_)

%%SARRIO
%%(/Users/xavier/dadavariable/nou_)

%%% adreça pseudoUnix a Distiller!
%%(Macintosh_HD:Users:femfum:Desktop:0test034)



%#% C marques de tall i reescriptura idem %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%# Si a %#% G triem 0 o 15, llegirem aquest dígit per decidir si unifiquem els
%# <Stream Contents> o els deixem intactes en cas que estiguin trencats (variable xQuinaArea)
%# 0= Unifiquem els <Stream Contents>  1= Ho deixem intacte
%# Si a %#% G triem 2, llegirem aquest dígit per triar l'àrea on posarem les
%# Creus de Tall, si no, el valor d'aquest apartat és indiferent (variable xQuinaArea)
%# 0= MediaBox  1= CropBox  2= TrimBox
%# Si a %#% G triem 6, llegirem aquest dígit per saber si de la interfície d'a3copiseny ens ve
%# el pocessat d'un sol fitxer =0  o el processat d'un directori sencer =1 (ho necessita el .log)

0



%#% D extrau o reinsereix imatges JPEG %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%# path del directori on hi hagin les imatges a exportar (~9) o a reinserir (~7)

%%(/Users/femfum/Desktop/Alquimia2012/)
%(/Users/femfum/OnEtsOncleGuillem/parlament/compareixença/)
(/Users/femfum/ArtistesDeLaRepublica/documental_llill/bolus/BCN_LesCorts/)


%#% E anàlisi textual i etiqueta text %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%# Llargàries mínima (NO pot ser mai zero!) i màxima dels mots sospitosos a ser analitzats
1  %% llargaria mínima del mot sospitós (mai pot ser zero o més petit!)
256  %% llargaria màxima del mot sospitós (per JBC ara és 11 doncs contemplem el cas de N.P.)

%#% path i nom del fitxer dels rengs de text fruit de l'anàlisi de sortida (es llegeix o s'escriu) 
%%(C:/MaRCanToni/FemFum/taller_d'applets/CaLi2CoPi/rengsDtext.txt)
(/Users/femfum/enfony/CaLi2CoPi/rengsDtext.txt)

%#% posem les etiquetes transparents en una lleixa NO imprimible? true:SI false:NO
true

%#% missatge tipus Tooltip, Sticky Note o Post-It per als fitxers no localitzats a la base de dades
(File not found in our database)

%#% #11 torsimany: preparem el fitxer TXT de l'anàlisi de sortida pels traductors en línia?
%% (motors de Google, Apertium, etc) true:SI false:NO, aquest gatell és imprescindible que estigui
%% a true quan fem treballar CaLi2CoPi com a eina de traducció amb la combinatòria dels gatells
%% #04 i #08 ...i quan no és així cal que estigui obligatòriament a false
false


%#% F dada variable %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% cal polir els operadors clau (BDC EMC Tj) del segon diccionari de repicat de Contents
%%Caldrà implementar quan toqui la resta d'operadors de text: ' " TJ
%% cal explorar l'encoding de caràcters de la tipografia que conté la dada variable (04) per tal
%% de repicar l'array DADAmestre amb el xifrat adaptat
%% cal polir el lector de CSV doncs si ara no hi ha un ; (punt i coma) al final de línia, doncs
%% la darrerera dada no es llegeix!

%# De com preparar la plantilla del PDF per la dada variable:
%# Cal generar el PDF amb les tipografies incrustades i amb el 100% del joc de caràcters
%# Cal marcar el text per ordre que haurà de ser tractat com a dada variable fent, amb dos mètodes possibles (#a, #b i comú # sense lletra):
%# 0. Obrir el fitxer PDF amb un AcrobatPro que ha de servir de plantilla de la dada variable.
%# 0a. Desplegar el menú View>Navigation Tabs>Content.
%# 1a. Desplegar per l'arbre de pestanyes d'aquest menú flotant, fins arribar a localitzar el text que ens interessa marcar com a dada variable. Si la unitat de text que hem de marcar és més petita que la que ens mostra aquest arbre de continguts, no podrem marcar el text per aquest mètode #a i hauremn de seguir per les instruccions #b.
%# 2a. Cliquem sobre el text que actua com a una unitat de dada variable prement el botó de la dreta del ratolí o CTRL+clic per escollir 'Create Artifact'.
%# 3a. Podem acceptar, prement 'OK', el que surti per defecte en aquest menú.
%# 4a. Tornem a clicar sobre el mateix text i premem novament el botó de la dreta del ratolí o CTRL+clic per escollir 'Properties' i anem a la solapa 'Content'.
%# 5a. Omplim el camp 'Container Tag' amb un nom personalitzat, on el text no ha de tenir espais en blanc, ni caràcters fora de l'ascii, podent jugar amb majúscules i minúscules. Aquest etiquetarà l'element de dada variable dins l'array /aDADAv (patró de les claus per cada línia de dada variable llegida).
%# 6a. Premem el tabulador per assegurar la dada i sortim amb 'close' o matant la finestra.
%# 7a. Pôdem estar segurs que ho hem fet bé si el nostre nom personalitzat apareix entre < ... > dins el desplegable.
%# 1b. Tanquem el menú flotant del 'Content' i escollim l'eina 'TouchUp Text Tool'.
%# 2b. Seleccionar el text que actua com a una unitat de dada variable.
%# 3b. Prémer el botó de la dreta del ratolí o CTRL+clic per escollir 'Create Artifact'.
%# 4b. Podem acceptar, prement 'OK', el que surti per defecte en aquest menú.
%# 5b. Tornem a seleccionar el mateix text i premem novament el botó de la dreta del ratolí o CTRL+clic per escollir 'Properties' i anem a la solapa 'Content'.
%# 6b. Omplim el camp 'Container Tag' amb un nom personalitzat, on el text no ha de tenir espais en blanc, ni caràcters fora de l'ascii, podent jugar amb majúscules i minúscules. Aquest etiquetarà l'element de dada variable dins l'array /aDADAv (patró de les claus per cada línia de dada variable llegida).
%# 7b. Premem el tabulador per assegurar la dada i sortim amb 'close' o matant la finestra.
%# 1. Un cop etiquetats tots els textos, podem desar el PDF millor fent un 'Save As'.

%# Consideracions:
%# 1. ara no distingim tipus de dades variables (numèrics, text, lògics, dates, etc)
%# 2. donem per fet que el fitxer TXT duu només dades útils com a text entre dobles cometes " ... " si no fos així hauríem de posar el caràcter anellador com un paràmetre més de capçalera
%# 3. també a %#%42bis3% podríem personalitzar la dada única per reescriure el nom del PDF però ara hi ha un simple numerador (NMrDR) per simplificar aquest tema
%# 4. el TXT de dada variable si acaba amb linies en blanc generarà fitxers idem al darrer registre
%# 5?. donem per fet que el xifrat de la tipografia que conté la dada variable és WinAnsi?doncs fins que no ho analitzem inicialment ho haurem de comprovar manualment
%# 6?. donem per fet que el joc de caràcters de la tipografia de conté la dada variable és complet doncs fins que no ho analitzem inicialment ho haurem de comprovar manualment
%# 7. sempre ens quedarà el recurs d'utilitzar una de les 14 core fonts (a implementar més endavant) per treballar amb més portabilitat (i evitar xifrats esotèrics o jocs restringits), o també tindriem la possibilitat d'incrustar en aquest procés una font lliure.

%# path del fitxer de lectura de dada variable
%%(/enfony/CaLi2CoPi/Sarrio/Eurofer4definitiu.txt)

%%SARRIO
%%(/Users/femfum/Desktop/SarrioDadaVarAAVV/aaaviam5.txt)

%%REMSA
(/Volumes/TRANSCEND/RemsaMarc/dadaVariable/exempleCSV.txt)


%# array pel patró dels noms clau per cada línia (registre) de dada variable llegida
%% l'ordre ha de correspondre a la successió de dades del fitxer TXT (csv)
%%[null /nom1 /cognom1 null /dni1]
%%[
%% null  %% numèric
%% %% aquests 3 camps idèntics es controlen amb l'excepció<1>
%% /NOM  %% 2n cognom del titular
%% /NOM  %% 1er cognom
%% /NOM  %% nom
%% null  %% numèric del nombre de beneficiaris
%% /BENE1  %% 1er beneficiari
%% /PARENTIU1
%% /BENE2  %% 2n beneficiari
%% /PARENTIU2
%% /BENE3  %% 3er beneficiari
%% /PARENTIU3
%% /BENE4  %% 4t beneficiari
%% /PARENTIU4
%% /BENE5  %% 5è beneficiari
%% /PARENTIU5
%%]  %% AAVV Passeig i Rodalies

%%REMSA
[/NOM /numDsoci]


%# string amb el caràcter separador dels camps de dades a les línies de dada variable
(;)


%#% Fbis generació de l'arbre jeràrquic i numeració de pàgines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Simsi:
%# array dels nivells jeràrquics de l'índex
[
 [  %% 0 màxim nivell
  %% si ve de disseny
%%  [/MetaMedium-Caps 23.94]
  %% si ve de l'índex generat per Navision
  [/Arial-BoldMT 20]
  [/Helvetica-Bold 20]  %% via PDFCreator

  [/FarreronsSerifLight 18]  %% OnEtsOncleGuillem
  [/Courier 18]
 ]
 [  %% 1
  [/ArialMT 19]
  [/Helvetica 19]  %% via PDFCreator

  [/FarreronsSerifLight 18.1]  %% OnEtsOncleGuillem
  [/Courier 18.1]
 ]
 [  %% 2
  [/ArialMT 16]
  [/Helvetica 16]  %% via PDFCreator

  [/FarreronsSerifLight 18.2]  %% OnEtsOncleGuillem
  [/Courier 18.2]
 ]
 [  %% 3
  [/ArialMT 12]
  [/Helvetica 12]  %% via PDFCreator
 ]
 [  %% 4
  [/Arial-ItalicMT 12]
  [/Helvetica-Oblique 12]  %% via PDFCreator
 ]
 [  %% 5
  [/Arial-BoldItalicMT 10]
  [/Helvetica-BoldOblique 10]  %% via PDFCreator
 ]
 [  %% 6
  [/Arial-ItalicMT 8]
  [/Helvetica-Oblique 8]
 ]
]
%% /Nji exch def  %% captura provisional de l'array dels nivells jeràrquics de l'índex

%% polyFEM
%%false{
[
 %# generem l'índex amb bookmarks?
 true

 %# generem l'índex amb pàgines?
 false

 %# numerem les pàgines?
 %% quan el numerador trova una pàgina completament en blanc, la compta però no la numera
 false  %% si o no?
 false  %% a sota centrat (true) o a sota a la dreta (false)?

 %# fins a quina jerarquia despleguem la visibilitat inicial dels bookmarks?
 0  %% zero és la primera jerarquia possible a partir de la qual encongim l'arbre
]
%%}if

%#% Fbis2 eliminem continguts de pàgina segons fem #13 o #14 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% quins continguts de pàgina eliminem?
%% pel gatell 13
%%[  %% [1] només eliminem el Text per rasteritzar la resta conjuntament
%% %% 0 estrat d'imatges [XObjects]
%% false  %% /MRCT_llXObject  %% nom a l'stream de dades i a l'array Properties
%% %% 1 estrat de farcells grafics [Form XObjects]
%% false  %% /MRCT_llFXObject
%% %% 2 estrat d'imatges farcides [inLines]
%% false  %% /MRCT_llinLine
%% %% 3 estrat de grafics vectorials [Paths]
%% false  %% /MRCT_llPath
%% %% 4 estrat d'esfumats dinamics [Shading Patterns] (deixarem els Tiling Patterns per + endavant)
%% false  %% /MRCT_llShading
%% %% 5 estrat de text [Text]
%% true  %% /MRCT_llText
%%]
%% [2] només deixem els XObjects + inLines per rasteritzar-los
%% [false true false true true true]
%%MASATS05
[true true true true true true]
%[true]

%% pel gatell 14
%%[true true true true true false]  %% l'invers de [1] ho elimina tot menys el Text
%[true false true false false false]  %% l'invers de [2] només elimina XObjects i inLines

%#% Fbis3 paràmetres de comportament del gatell #14 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[
 true  %% el blanc pur (255) de la imatge JPEG serà transparent? (clau /Mask per l'efecte cromakey)
 true  %% la imatge anirà a sota de tots els altres objectes gràfics? (si no, reaprofita la posició de la primera imatge que troba)
]

%%MASATS07
%#% Fbis4 array de capes que volem eliminar segons les dades que es llisten a %#% G 15
[
% [69 /73_____________0 /MC69 (?CAIXETI ANGLES)]
% [0 /4______________0 /MC0 (?CAIXETI)]
% [7 /428____________0 null (referencies)]

% [0 /29_____________0 /R29 (-248.0 > OtherBlue)]
% [12 /30_____________0 /R30 (-248.0 > OtherBlue)]

%[0 /201____________0 /MRCT_llXObject (imatges [XObjects])]
%[1 /203____________0 /MRCT_llFXObject (farcells gr\340fics [Form XObjects])]
%[2 /205____________0 /MRCT_llPath (gr\340fics vectorials [Paths])]
%[3 /207____________0 /MRCT_llShading (esfumats din\340mics [Shading Patterns])]
%[4 /209____________0 /MRCT_llText (text [Text])]

 %% a _1_taz_2017_11_01.pdf no podem esborrar les capes perquè son totes dins un Form?
 %[0 /118____________0 /MRCT_llXObject (imatges [XObjects])]
 %[1 /120____________0 /MRCT_llFXObject (farcells gr\340fics [Form XObjects])]
 %[2 /122____________0 /MRCT_llPath (gr\340fics vectorials [Paths])]
 %[3 /124____________0 /MRCT_llText (text [Text])]

 %% a _Seite_1_Handelsblatt_2017-11-01.pdf només funciona aïllant el Text
 %[0 /2058___________0 /MRCT_llXObject (imatges [XObjects])]
 %[1 /2060___________0 /MRCT_llPath (gr\340fics vectorials [Paths])]
 %[2 /2062___________0 /MRCT_llShading (esfumats din\340mics [Shading Patterns])]
 %[3 /2064___________0 /MRCT_llText (text [Text])]

]

%%MASATSfebrer1
[
 true  %% eliminem totes les Additional Actions /AA de /Page
 false  %% blindem les capes amb una instrucció genèrica de negre RGB pels perfilats i els omplenats
]

%%MASATS09
%%Ens convé una array per a desenvolupadors?: tots els streams a disc? 1 sol stream de Contents? retorn de carro? etc
%# gatell per les dades del(s) stream(s) de /Contents: comprimim a Flate (true) o sense comprimir per fer-les visibles (false)
false

%%MASATStext
%#% Fbis5 cerca i substitució de text, dins unes condicions concretes:
[

false{
%% pla_GP28_1LiniaConflictiva.pdf
 [  %% per cada mot o frase seguida a substituir dins una mateixa línia de text
  (Quotation:)  %% caldrà fer un algorisme per trencar les paraules (i haurem de saber si són a yRENGS), doncs és la primera la que condiciona la posició de la resta
  (Target:)  %% si és buit, s'elimina òbviament l'anterior
  0 %% gatell de justificat 0 = caixa esquerra 1 = caixa dreta 2 = centrat, des de l'orígen de (elMOTaTROBAR)
 ]
 [
  (Quit)
  (AV)
  2
 ]
 [  %% per (/Users/femfum/Masats/treuificaText/pla_KozGoPr6N-Bold.pdf)
  %% amb font original (KozGoPr6N-Bold) ben incrustada i amb mètrica particular
  (Revisión:)
%  (VIDRE)
  (Exàmen:)
%  (VERID)
  2
 ]
}if


false{
%% 2motsMateixReng2.pdf
 [  %% per cada mot o frase seguida a substituir dins una mateixa línia de text
  (ela)  %% caldrà fer un algorisme per trencar les paraules (i haurem de saber si són a yRENGS), doncs és la primera la que condiciona la posició de la resta
  (miola)  %% si és buit, s'elimina òbviament l'anterior
  1  %% gatell de justificat 0 = caixa esquerra 1 = caixa dreta 2 = centrat, des de l'orígen de (elMOTaTROBAR)
 ]
 [
  (Ui)
  (Ai)
  0
 ]
 [
  (Lla)
  (allà)
  0
 ]
}if

false{
 [  %% per cada mot o frase seguida a substituir dins una mateixa línia de text
  (Ref)  %% caldrà fer un algorisme per trencar les paraules (i haurem de saber si són a yRENGS), doncs és la primera la que condiciona la posició de la resta
  (Referencia)  %% si és buit, s'elimina òbviament l'anterior
  2  %% gatell de justificat 0 = caixa esquerra 1 = caixa dreta 2 = centrat, des de l'orígen de (elMOTaTROBAR)
 ]
 [
  (ema)
  (EMA)
  0
 ]
}if

false{
%% DM0977600E0v9_v2015_original_OSCaplanatXa8.pdf
 [
  (T1)
  (TE un)
  0
 ]
 [
  (T2)
  (TE dos)
  0
 ]
 [
  (T3)
  (TE tres)
  0
 ]
}if

%% qualque
false{
[
 (Picapoll-Macabeu)
 (Xarel·lo)
 0
]
}if

%% pla_coreFontAmbRiscDglifs.pdf
false{
[
 (OF1)
 (oefa1)
 0
]
[
 (D1)
 (de1)
 0
]
}if

%% pla_textos_TJ.pdf
false{
[
 (POLVO)
 (pols)
 0
]
[
 (PINTURA)
 (pintura)
 0
]
}if

false{
%% pla_KozGoPr6N-Bold.pdf
[
 (VIDRE)
 (VERRE)
 2
]
[
 (BRUTA)
 (ex)
 0
]
}if

false{
%%Malgosa
%%NO troba re!
[
 (.CAT)
 (gat)
 0
]
}if

[
 (T1)
 (TE UN)
 0
]

%% JuguemAmbTextApel_fontsType3.pdf
false{
[
 (ab)
 (AB)
 0
]
}if

%% MMType1
false{
[
 (a)
 (A)
 0
]
}if

%% TargetesWhatsUp.pdf
false{
[
 (president)  %% sense el punt l'ignora i NO AVISA QUE ÉS UN FRAGMENT!
 (pecident)
 0
]
[
 (Prologue)  %% sense el punt NO AVISA QUE ÉS UN FRAGMENT!
 (epilogue)
 0
]
}if

%% GP09_DM0977600E0v9manipulat_OSCaplanatXa11.pdf
false{
 [
  (PHOTOCELL)
  (així com cell)
  0
 ]
}if

]


%#% G triem Que Li Fem Fer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%# què li fem fer ?
%#  0 :: XRay+ reescriptura idem del PDF però amb un seguit de canvis interns (fet!)
%#  1 :: XRay+ separació de tintes amb tants PDF com tintes hi hagi (només per a PDF d'1 sola pàgina) (fet!)
%#  2 :: XRay+ marques de tall automàtiques fent créixer el format de pàgina (MediaBox) si cal (fet!)
%#  3 :: XRay+ corrector tipogràfic de la Ela Geminada (per fer)
%#  4 :: XRay+ anàlisi textual amb generació de rengsDtext.TXT per #08 sense fer el repicat a PDF (fet!)
%#  5 :: XRay+ dada variable (fet!) 
%#  6 :: XRay+ cosit d'imatges trencades que s'hagin localitzat (fet! però queden coses per polir encara)
%#  7 :: XRay+ reinsereix imatges JPEG segons l'ordre com s'hagin exportat amb Acrobat o amb l'opcio #9 (fet! però queden coses per polir encara)
%#  8 :: XRay+ etiqueta text afegint vincles i marques transparents segons les dades de #4 (JBC) 
%#  9 :: XRay+ extrau imatges JPEG segons convencions (escales de gris + RGB, no ICC, no Indexat) a JPEG ... NO FA el repicat a PDF ... (fet! pero cal polir coses encara)
%# 10 :: XRay+ preflight amb capes (verificador per al Col·legi de Disseny Gràfic: capes x material digital per anar + enllà d'XRay (ho estem fent)
%# 11 :: XRay+ traducció (ho estem fent) ...en realitat és una determinada combinació de 4+8
%# 12 :: XRay+ generació d'arbre jeràrquic d'índex amb bookmarks i pàgines (Polynorma)
%# 13 :: XRay+ elimina tots els continguts de pàgina que no siguin imatge (inLine i XObjects), segons una array (aEliminar) de materials digitals, idèntica a la del gatell 10, regenerant un nou PDF amb només imatges
%# 14 :: XRay+ activa una array de materials digitals inversa a la del gatell 13 (aEliminar), de forma que només elimina les imatges (inLine i XObjects), per tal d'inserir-hi una (1) sola imatge XObject (referenciada pel núm. de pàgina) de les que tingui disponibles en un directori d'importació
%# 15 :: XRay+ elimina lleixes (layers) amb els seus continguts dins l'estructura OC corresponent + Additional Actions /AA de /Page (MASATS)
%# 16 :: XRay+ cerca i substitució de text dins unes condicions concretes (MASATS)
%# 17 :: XRay+ %%MASATSencvlct encavalca tots els continguts de pàgina del document, per ordre, damunt la primera de totes 
%# 18 :: Hackovid | pliegO'Maker fa un procés parcial de l'XRay, just per capturar el MediaBox/CropBox de les pàgines i surt

0



%#% H path + inici del nom del fitxer TXT informatiu XRay %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Win
%%(C:/MaRCanToni/FemFum/taller_d'applets/CaLi2CoPi/XRay_036_)
%%(C:/MaRCanToni/FemFum/taller_d'applets/aramateix/WebProof/CALi2COPi/XRay_034_)
%%(C:/Documents and Settings/L'amo/Escritorio/+PDFs/Logs/)

%%UBpliegOS
%%URLREpublica de moment amb un path indirecte
(Hpdf/XRay_042_)


%%% GS MacOSX/Unix/Linux %%%
%(/Users/femfum/enfony/CaLi2CoPi/XRay_042_)
%(/Users/femfum/Sarrio_270218/XRay_041_)
%%SARRIO
%%(/Users/xavier/dadavariable/XRay_037_)

%% adreça pseudoUnix a Distiller!
%% (Macintosh_HD:Users:femfum:Desktop:XRay_034_)



%%#% Ep! deixem activada la generació d'XRay de forma fixa
%%# (E) I %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%# generem el fitxer XRay d'info TXT ?
%%# 0= NO  1= SI

%% 1



%#% J path de treball dels fitxers temporals %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%# si treballem amb el gatell 12, aquest path no pot dur cap mena de caràcter fora de l'ascii
%%# universal ni cap espai en blanc (el path és utilitzat com un literal per a un diccionari)

%% Win
%%(C:/MaRCanToni/FemFum/taller_d'applets/CaLi2CoPi/tmp/)
%%(C:/MaRCanToni/FemFum/taller_d'applets/aramateix/DiBa/Institutd'Edicions/Coromines/tmp/)
%%(C:/MaRCanToni/FemFum/taller_d'applets/aramateix/WebProof/CALi2COPi/tmp/)

%%UBpliegOS
%%URLREpublica de moment amb un path indirecte
(tmp/)


%%% GS MacOSX/Unix/Linux %%%
%(/Users/femfum/enfony/CaLi2CoPi/tmp/)
%(/Users/femfum/Sarrio_270218/tmp/)

%%SARRIO
%%(/Users/xavier/dadavariable/tmp/)

%%% adreça pseudoUnix a Distiller!
%%(Macintosh_HD:Users:femfum:Desktop:tmp:)



%%% eliminat 26.03.09
%%% K %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% path + fitxer amb el valor de validació de l'Applet

%% Win
%%(C:/MaRCanToni/FemFum/LlumiColor/_Atles_/aTLeSBeta/clau.key)

%%% GS MacOSX %%%
%%(/Users/femfum/Desktop/clau.key)
%%% adreça pseudoUnix a Distiller!
%%(Macintosh_HD:Users:femfum:Desktop:clau.key)



%%% eliminat 26.03.09
%%% L %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% valor de validació de l'Applet

%%(AFC0A6256022//MARC-5GU08U9FMO/Administrador)

%#% fi de dades de capçalera (opcions de menú) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%testVM
%%(VM inici ) == vmstatus == == ==

%#%02% paquet de missatges BaBeL
(%#%02%)==
%# estratègia per concentrar tots els missatges impresos i escrits indexats en una array
%# indexant també en una array superior els diversos idiomes
%# activem l'idioma desitjat amb un simple índex

/bAbElArrAy
[
 /cAtAlA	% index 0
 /EnglIsh	% index 1
%% /EspAnOl	% index 2
%% /frAncAIs	% index 3
%% /dEUtch	% index 4
] def

/cAtAlA
[
 %% 0
 (\n\nMRCT0 l'Applet No Parla Aquest Idioma\n\n)

 %% 1
 (\n\nCaLi2CoPi treballa amb el gatell ... )

 %% 2
 (\n\nDesfem el Fast Web View\n)

 %% 3
 (\n\nMRCT1 CaLi2CoPi Nomes Treballa amb Adobe Acrobat Distiller 5 o +\n\n)

 %%4
 (\n\nMBaBel 8 getRCT2 Error de Sintaxi al Path del PDF a tractar\n\n)

 %% 5
 (\nFWV amb ByteOffset erroni a /L\n)

 %% 6
 (Ventant ... )

 %% 7
 (\nEsborrem els Fitxers Temporals\n\n)

 %% 8
 (\n\n\nMRCT3 Estructura de Fitxer No Suportada per CaLi2CoPi\n ... objecte malmes ... )

 %% 9
 (\nFWV amb ByteOffset erroni a /H\n)

 %% 10
 (\n\nVersio de PDF ... )

 %% 11
 (\n\nMRCT4 Aquest PDF es Encriptat\n\n)

 %% 12
 (\n\nNombre d'Objectes Interns ... )

 %% 13
 (\n\nMRCT5 Teniu un Error a la capçalera de dades de CaLi2CoPi\n\n)

 %% 14
 (\nReconstruim el nou PDF\n)

 %% 15
 (\n\n)

 %% 16
 (\n\nMRCT6 Aquest PDF duu Signatura Digital\n\n)

 %% 17
 (\n\nMRCT7 Aquest PDF duu la compressio 1.5 Object Stream\n ...descapdellant Object Streams i Cross-Reference Streams...\n\n)

 %% 18
 (\n\nMRCT8 Error d'estructura: PDF sense l'arrel /Pages\n\n)

 %% 19
 (\nEliminant objectes duplicats\n)

 %% 20
 (\n\nMRCT9 Aquest PDF ha estat desencriptat per un Crack\n)

 %% 21
 (\n\nMRCT10 Error a la Clau Digital\n\n)

 %% 22
 (\n\nMRCT19 Aquesta plana no duu /Contents\n\n)

 %% 23
 (\nReinterpretant els /Contents de nou\n)

 %% 24
 (\nMRCT11 Interpret PS Desconegut: fes servir AGPL Ghostscript o Adobe Acrobat Distiller\n\n)

 %% 25
 (\n\nMRCT12 CaLi2CoPi Nomes Treballa amb AGPL Ghostscript 8 o +\n\n)

 %% 26
 (\n\nMRCT13 Cap del PDF erroni\n\n)
 
 %% 27
 (\n\nMRCT14 Cap del PDF amb brossa\n\n)
 
 %% 28
 (\n\nMRCT15 Cua de PDF erronia\n\n)

 %% 29
 (\n\nMRCT16 Cua de PDF amb brossa\n\n)

 %% 30
 (\nEscrivim el fitxer XRay\n)
 
 %% 31
 (\nMRCT17 Errors a XRay )
 
 %% 32
 (\n\nMRCT18 Stream sense l'entrada /Length\n\n)
 
 %% 33
 (\n\nMRCT20 Aquesta pagina no duu /Resources\n\n)
 
 %% 34
 (\nFem la Separacio de Tintes de les imatges\n)

 %% 35
 (\n\nMRCT21 Aquesta imatge XObject duu l'stream buit\n\n)
 
 %% 36
 (\nFem la Separacio de Tintes dels Pattern&Shading\n)
 
 %% 37
 (\nReconstruim un PDF per cada Tinta\n)
 
 %% 38
 (\n\nMRCT22 Aquest document te mes d'una (1) pagina ...)
 
 %% 39
 (\n\nMRCT23 Aquest objecte duu una clau /Length erronia i no suportada ...\n\n)

 %% 40
 (\nRecalculem la clau /Length\n)
 
 %% 41
 (\n\nMRCT24 ERROR inLine: hem exhaurit la capacitat permesa per una inLine i ens hem menjat les dades sens trobar el final correcte!!!\n\n)

 %% 42
 (\n\nMRCT25 ERROR inLine: ens hem menjat les dades sens trobar el final correcte!!!\n\n)

 %% 43
 (\n\n ... Aquesta pagina no duu text\n\n)
 
 %% 44
 (\n >>>> Type 0 amb CMap NO suportat o Encoding inexistent <<<< \n\n\n)

 %% 45
 (\n\n >>>> NO HE TROBAT imatges trencades que es puguin cosir ... pleguem!\n\n\n)

 %% 46
 (\n\n ... sense Form XObjects\n)

 %% 47
 (\n\n >>>> el nom del PDF no es normatiu per restaurar les imatges ... pleguem!\n\n\n)

 %% 48
 (\n\n >>>> NO hem trobat cap JPEG per restaurar ... pleguem!\n\n\n)

 %% 49
 (\n\n >>>> els índex de les capes han de ser numerics enters ... pleguem!\n\n\n)

 %% 50
 (\n\n ...FET \(certa morralla al /tmp pot ser de profit\)\n\n)

 %% 51
 (\nReescrivim... )

 %% 52
 (\n ...eliminem la capa d'index... )

 %% 53
 ( ...anomenada... )

 %% 54
 (\n <<<< fi del llistat de capes\n)

 %% 55
 (\n\n >>>> active PDF layers\n\n)

 %% 56
 (\n >>> aquest PDF no te capes!\n\n)

 %% 57
 (>>>> aquesta capa NO existeix... )

 %% 58
 ( <<<< aquest index/nom correspon a una capa inexistent i fora de rang al document\n)

 %% 59
 ( <<<< aquest index/nom correspon a una capa inexistent al document\n)

 %% 60
 (\n >>>> aquest index/nom correspon a una capa inexistent al document ... )

 %% 61
 (\n >>>> no hi han índex/noms assignats per eliminar o no es corresponen a capes en actiu)

 %% 62
 (\n >>>> reescriurem el fitxer PDF sense canvis!\n)

 %% 63
 ( >>>> aquesta capa tenia errades\n)

 %% 64
 ( >>>> aquesta capa tenia comportaments desconeguts\n)

 %% 65
 ( >>>> aquesta capa era buida de continguts\n)

 %% 66
 (\n\n >>>> l'ample del MediaBox supera la tolerancia permesa ...pleguem!\n\n\n)

 %% 67
 (\n\n >>>> l'alt del MediaBox supera la tolerancia permesa ...pleguem!\n\n\n)

 %% 68
 (\n\n >>>> l'ample del CropBox supera la tolerancia permesa ...pleguem!\n\n\n)

 %% 69
 (\n\n >>>> l'alt del CropBox supera la tolerancia permesa ...pleguem!\n\n\n)

 %% 70
 (\n\n ...els formats de pagina i retalladors s'adiuen\n\n)

 %% 71
 ( ...pleguem!\n\n\n)
] def

/EnglIsh
[
 %% 0
 (\n\nMRCT0 The Applet doesn't Support this Language\n\n)

 %% 1
 (\n\nCaLi2CoPi PS Applet is Working with the switch ... )

 %% 2
 (\n\nRemoving the Fast Web View\n)

 %% 3
 (\n\nMRCT1 CaLi2CoPi Only Works with Adobe Acrobat Distiller 5 or +\n\n)

 %%4
 (\n\nMRCT2 Input PDF Path Syntax Error\n\n)

 %% 5
 (\nFWV with ByteOffset Error in /L\n)

 %% 6
 (Processing ... )

 %% 7
 (\nRemoving Temporal Files\n\n)

 %% 8
 (\n\n\nMRCT3 File Structure Not Supported by CaLi2CoPi PS Applet\n ... wrong object ... )

 %% 9
 (\nFWV with ByteOffset Error in /H\n)

 %% 10
 (\n\nPDF Version ... )

 %% 11
 (\n\nMRCT4 This PDF is Encrypted\n\n)

 %% 12
 (\n\nNumber of Internal Objects ... )

 %% 13
 (\n\nMRCT5 Syntax Error in the CaLi2CoPi Header\n\n)

 %% 14
 (\nRebuilding the PDF output\n)

 %% 15
 (\n\n)

 %% 16
 (\n\nMRCT6 This PDF Have Digital Signatures\n\n)

 %% 17
 (\n\nMRCT7 This PDF Have 1.5 Object Stream Compression\n ...unpacking Object Streams & Cross-Reference Streams...\n\n)

 %% 18
 (\n\nMRCT8 Structural Error: the PDF /Pages Root is Missing\n\n)

 %% 19
 (\nRemoving Duplicate Objects\n)

 %% 20
 (\n\nMRCT9 This PDF are a Hacking product\n)

 %% 21
 (\n\nMRCT10 Digital Key Error\n\n)

 %% 22
 (\n\nMRCT19 This Page don't have /Contents\n\n)

 %% 23
 (\nParsing the /Contents again\n)

 %% 24
 (\nMRCT11 Unknown PS Interpreter: try AGPL Ghostscript or Adobe Acrobat Distiller\n\n)

 %% 25
 (\n\nMRCT12 CaLi2CoPi Only Works with AGPL Ghostscript 8 or +\n\n)

 %% 26
 (\n\nMRCT13 Damaged PDF Header\n\n)
 
 %% 27
 (\n\nMRCT14 Dirty PDF Header\n\n)
 
 %% 28
 (\n\nMRCT15 Damaged PDF Footer\n\n)

 %% 29
 (\n\nMRCT16 Dirty PDF Footer\n\n)

 %% 30
 (\nWriting the XRay file\n)
 
 %% 31
 (\nMRCT17 XRay ERRORS )
 
 %% 32
 (\n\nMRCT18 /Length is Missing in Data Stream\n\n)
 
 %% 33
 (\n\nMRCT20 This Page don't have /Resources\n\n)
 
 %% 34
 (\nSplitting image Tints\n)

 %% 35
 (\n\nMRCT21 This image XObject don't have stream data\n\n)
 
 %% 36
 (\nSplitting Pattern&Shading Tints\n)
 
 %% 37
 (\nRebuilding a PDF for each Tint\n)
 
 %% 38
 (\n\nMRCT22 This document have more than 1 page ...)
 
 %% 39
 (\n\nMRCT23 Object with wrong&unsupported /Length stream keyword ...\n\n)

 %% 40
 (\nRearranging stream object with wrong /Length\n)
 
 %% 41
 (\n\nMRCT24 inLine ERROR: inLine capacity overflowed and haven't found the correct EOF!!!\n\n)

 %% 42
 (\n\nMRCT25 inLine ERROR: end of data and cannot find the correct EOF!!!\n\n)

 %% 43
 (\n\n ... This Page don't have Text\n\n)
 
 %% 44
 (\n >>>> Type 0 with unsupported CMap or missing Encoding <<<< \n\n\n)

 %% 45
 (\n\n >>>> CAN'T find broken images for binding ... Bye!\n\n\n)

 %% 46
 (\n\n ... without Form XObjects\n)

 %% 47
 (\n\n >>>> this PDF filename don't match our convention to recover images ... Bye!\n\n\n)

 %% 48
 (\n\n >>>> there is NO JPEG to recover ... Bye!\n\n\n)

 %% 49
 (\n\n >>>> the layer index assignment must be integer ... Bye!\n\n\n)

 %% 50
 (\n\n ...DONE \(some garbage collected on /tmp will be useful\)\n\n)

 %% 51
 (\nRewriting... )

 %% 52
 (\n ...deleting index layer... )

 %% 53
 ( ...named... )

 %% 54
 (\n <<<< end of layers list\n)

 %% 55
 (\n\n >>>> active PDF layers\n\n)

 %% 56
 (\n >>>> PDF without layers!\n\n)

 %% 57
 (>>>> this layer don't exists... )

 %% 58
 ( <<<< this index/name points to a document missing layer and out of range\n)

 %% 59
 ( <<<< this index/name points to a document missing layer\n)

 %% 60
 (\n >>>> this índex/name points to a document missing layer... )

 %% 61
 (\n >>>> there is no index/names into active data array or don't match any active layer to erase)

 %% 62
 (\n >>>> we will rewrite the PDF file without changes!\n)

 %% 63
 ( >>>> this layer has bugs\n)

 %% 64
 ( >>>> layer with unknow behaviors\n)

 %% 65
 ( >>>> layer with empty contents\n)

 %% 66
 (\n\n >>>> the width MediaBox threshold overflows their limits ...Bye!\n\n\n)

 %% 67
 (\n\n >>>> the height MediaBox threshold overflows their limits ...Bye!\n\n\n)

 %% 68
 (\n\n >>>> the width CropBox threshold overflows their limits ...Bye!\n\n\n)

 %% 69
 (\n\n >>>> the height CropBox threshold overflows their limits ...Bye!\n\n\n)

 %% 70
 (\n\n ...the all Media and Crop boxes are matching\n\n)

 %% 71
 ( ...Bye!\n\n\n)
] def

/lleNguatge 0 def  %% idioma a escollir (0 Catala . 1 Angles/DLL ... )

{bAbElArrAy lleNguatge get} stopped
{cAtAlA 0 get print flush EnglIsh 0 get print flush quit}if  %% activem directament l'error d'idioma

cvx exec

/BaBeL exch def  %% redefinim l'array de l'idioma actiu
%%% fi de paquet babel

%#%03% captura de dades de capçalera
(%#%03%)==
{  %% stopped 
 %% eliminat 26.03.09
 %% L valor de validacio de l'Applet
 %% /GENclau exch def
 %% K path+fitxer amb el valor de validacio de l'Applet
 %% /pathGENclau exch def 
 
 %% J path de treball dels fitxers temporals
 /tEmp exch def
 %% I %% /FemXRay exch def  % deixem x defecte fixada la generacio d'XRay
 %% H path + inici del nom del fitxer TXT informatiu XRay
 /FitxerXRay exch def
 %% G triem Que Li Fem Fer
 /QueLiFemFer exch def

%%Hackovid
%% gatells pel pliegO'Maker
QueLiFemFer 18 eq {/plgmkr true def /QueLiFemFer 0 def }{/plgmkr false def }ifelse

 %% D extrau o reinsereix imatges JPEG
 QueLiFemFer 7 eq
 {  %:07 REINSEREIX IMATGES JPEG
  pop pop pop pop pop pop pop pop pop pop pop pop pop pop pop pop pop  %% ens carreguem les dades de E, F, Fbis, Fbis2, Fbis3, Fbis4 i Fbis5
  /imatgesXreinserir exch def  %% D extrau o reinsereix imatges JPEG
  /xQuinaArea exch def  %% C marques de tall i reescriptura idem
  %% agafem el valor que hi hagi xq no petin els comparatius i/o si reincrustem els Contents trencats en 1 sol objecte
 }  %/07 REINSEREIX IMATGES JPEG
 {  %%  C marques de tall i reescriptura idem
  QueLiFemFer 2 eq
  {  %:02 MARQUES DE TALL
   pop pop pop pop pop pop pop pop pop pop pop pop pop pop pop pop pop  %% ens carreguem les dades de E, F, Fbis, Fbis2, Fbis3, Fbis4 i Fbis5
   /imatgesXreinserir exch def  %% D extrau o reinsereix imatges JPEG
   /xQuinaArea exch def  %% C marques de tall i reescriptura idem
   /llUm 50 def  %% determina el marge que guanyarem x banda (total X = llUm x 2  total Y = llUm x 2)
   /torsimany false def  %%NOU xq si no fa petar l'opció 2!
/SIcreus false def  %% si el cerquem més avall podem descomentar aquest gatell a 3 llocs per tal NO pinti les creus de tall
  }  %/02 MARQUES DE TALL
  {
   QueLiFemFer 3 eq  %% tret que fem el corrector tipografic
   QueLiFemFer 4 eq  %% tret que fem l'eina d'anàlisi textual per #8 (JBC) 
   QueLiFemFer 5 eq  %% tret que fem la dada variable
   QueLiFemFer 8 eq  %% tret que afegim vincles i marques transparents segons les dades de #4 (JBC) 
   QueLiFemFer 12 eq  %% tret que fem l'arbre jeràrquic
   QueLiFemFer 16 eq  %% tret que fem cerca i substitució de text (MASATS)
   or or or or or
   {  %:03 CORRECTOR TIPOGRÀFIC
      %:04 ANÀLISI TEXTUAL
      %:05 dada variable
      %:08 ETIQUETA TEXT
      %:12 arbre jeràrquic
      %:16 cerca i substitució de text

    /FICAiTREU exch def  %#% Fbis5 cerca i substitució de text (MASATS)
    pop pop pop pop pop  %% eliminem les dades d'Fbis2, Fbis3 i d'Fbis4
%% provisionalment carreguem els diccionaris xifrats a WinAnsi aquí?
dup 1 get
{
 [
  /Helvetica findfont
  dup length dict begin
  {
   1 index /FID ne
   {def}{pop pop}ifelse
  }forall
  /Encoding systemdict /EncodingDirectory get /WinAnsiEncoding get def
  currentdict end
  /Helvetica_WA exch definefont pop
  /Helvetica_WA findfont

  /Helvetica-Oblique findfont
  dup length dict begin
  {
   1 index /FID ne
   {def}{pop pop}ifelse
  }forall
  /Encoding systemdict /EncodingDirectory get /WinAnsiEncoding get def
  currentdict end
  /Helvetica-Oblique_WA exch definefont pop
  /Helvetica-Oblique_WA findfont

  /Helvetica-Bold findfont
  dup length dict begin
  {
   1 index /FID ne
   {def}{pop pop}ifelse
  }forall
  /Encoding systemdict /EncodingDirectory get /WinAnsiEncoding get def
  currentdict end
  /Helvetica-Bold_WA exch definefont pop
  /Helvetica-Bold_WA findfont
 ] /hemfetfindfont exch def
}if 

    %% Fbis arbre jeràrquic
    /polyFEM exch def  %% array de comportaments per l'arbre jeràrquic i numerador de pàgines
    /Nji exch def  %% array dels nivells jeràrquics de l'índex

    %% F dada variable
    /sDADA exch def  %% string amb el caràcter separador dels registres a les línies de dada variable
    /aDADAv exch def  %% array pel patró dels noms clau per cada línia de dada variable llegida
    /pathDADAv exch def  %% path del fitxer de lectura de dada variable

    %% E anàlisi textual i etiqueta text
    /torsimany exch def  %% preparem el fitxer TXT de l'anàlisi de sortida pels traductors en línia (Google, Apertium)?
    /noTrobat exch def  %% missatge per (botó cec) al fitxer no trobat a la base de dades
    /lleixaNOi exch def  %% posem les etiquetes transparents en una lleixa NO imprimible?
    /rengsDtext exch def  %% path i nom del fitxer dels rengs de text fruit de l'analisi de sortida
    torsimany  %% treballem pel traductor?
    {
     pop pop  %% eliminem les dades de capçalera
     %% posem els valors útils per extraure tot el text sense restriccions
     256/maxMot exch def  %% llargaria maxima del mot sospitos
     1/minMot exch def  %% llargaria minima del mot sospitos
    }
    {
     /maxMot exch def  %% llargaria maxima del mot sospitos
     /minMot exch def  %% llargaria minima del mot sospitos
    }ifelse
    /imatgesXreinserir exch def  %% D extrau o reinsereix imatges JPEG
    /xQuinaArea exch def  %% C marques de tall i reescriptura idem
    %% agafem el valor que hi hagi xq no petin els comparatius i/o si reincrustem els Contents trencats en 1 sol objecte
    %% KTCS  valors x corrector tipografic o merging?
    /araE false def  %% valor x defecte de la generacio d'etiquetes
    /QueTa () def  %% valor x defecte de la cadena on muntarem el nom de l'etiqueta x generar la fusio
%%    (buffer.txt) dup length faPathA add string dup
%%    /pAthA exch def 0 tEmp putinterval
%%    pAthA exch faPathA exch putinterval
%%    pAthA /_auToRS exch def  % adre?a del fitxer .TXT que fa de buffer d'extraccio d'anuncis
%%    _auToRS (w) file /auToRS exch def  % fem el fitxer buffer.TXT que fa de buffer d'extraccio d'anuncis
   }  %/16 cerca i substitució de text
      %/12 arbre jeràrquic
      %/08 ETIQUETA TEXT
      %/05 dada variable
      %/04 ANÀLISI TEXTUAL
      %/03 CORRECTOR TIPOGRÀFIC
   {
    pop  %#% eliminem Fbis5
    /Aflate exch def  %#% Fbis4 comprimim a Flate? o deixem sense comprimir? (codi de contingut de pàgina visible)
    /AAiRGB exch def  %#% Fbis4 eliminem /AA de Page? blindem les layers amb RGB a negre? (MASATS)
    /LleixesAeliminar <<>> def  %#% Fbis4 diccionari de noms interns de lleixes que hem d'eliminar, pel gatell #15 (MASATS)
    dup
    {  %% forall x farcir el diccionari amb els noms interns que hem d'eliminar, pel gatell #15 (MASATS)
     LleixesAeliminar exch 2 get dup null eq
     {
      pop pop
     }
     {
      null put
     }ifelse
    }forall
    mark exch
    {
     0 get
    }forall
    ] /iOCkill exch def  %#% Fbis4 array d'índex de lleixes que hem d'eliminar, pel gatell #15 (MASATS)
    /manies14 exch def  %#% Fbis3 paràmetres de comportament del gatell #14
    /aEliminar exch def  %% Fbis2 array amb els continguts de pàgina que ens cal eliminar
    pop pop  %% ens carreguem les dades d'Fbis
    pop pop pop
    /torsimany exch def  %% el necessitem a (%#%53bis%) 
    pop pop pop pop pop  %% ens carreguem les dades que no utilitzarem
    /imatgesXreinserir exch def  %% D extrau o reinsereix imatges JPEG
    /xQuinaArea exch def  %% C marques de tall i reescriptura idem
    %% agafem el valor que hi hagi xq no petin els comparatius i/o si reincrustem els Contents trencats en 1 sol objecte
   }ifelse
  }ifelse
 }ifelse
 %% B %% path + inici del nom del nou PDF reescrit i tractat segons l'opció escollida
 /aFeGeiX exch def
 %% A %% path i nom del PDF a tractar 

%%MASATSfebrer0
 dup 1 get /bateiG exch def  %% null o path+nom del pdf a repicar
 0 get %% agafem el path+nom del pdf a tractar
 dup bateiG eq{stop}if  %% estaríem intentant reescriure el fitxer de sortida amb el mateix nom que el d'entrada!
 bateiG null ne{bateiG length 0 eq{stop}if}if  %% estaríem intentant reescriure el fitxer de sortida en una string buida

 /fApplet exch def

 [
  {  %% 00 XRay + reescriptura idem
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~0_) putinterval
   /aFeGeiX exch def
  }
  {  %% 01 XRay + separació de tintes
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~1_) putinterval
   /aFeGeiX exch def
  }
  {  %% 02 XRay + creus de tall
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~2_) putinterval
   /aFeGeiX exch def
  }
  {  %% 03 XRay + corrector tipogràfic
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~3_) putinterval
   /aFeGeiX exch def
  }
  {  %% 04 XRay + anàlisi textual
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~4_) putinterval
   /aFeGeiX exch def
  }
  {  %% 05 XRay + dada variable
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~5_) putinterval
   /aFeGeiX exch def
  }
  {  %% 06 XRay + cosit d'imatges
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~6_) putinterval
   /aFeGeiX exch def
  }
  {  %% 07 XRay + reinsereix imatges JPEG
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~7_) putinterval
   /aFeGeiX exch def
  }
  {  %% 08 XRay + etiqueta text segons l'anàlisi 04
   %% en cas del projecte JBC és la DLL qui controla el nom i el path del fitxer de sortida
   %%aFeGeiX dup length dup /iNSeRT exch def 3 add string
   %%dup 3 -1 roll 0 exch putinterval dup iNSeRT (~8_) putinterval
   %% /aFeGeiX exch def
  }
  {  %% 09 XRay + extrau imatges a JPEG
   %% (segons convencions d'A3copiseny)
   aFeGeiX dup length dup /iNSeRT exch def 3 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~9_) putinterval
   /aFeGeiX exch def
  }
  {  %% 10 Preflight amb capes
   aFeGeiX dup length dup /iNSeRT exch def 4 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~10_) putinterval
   /aFeGeiX exch def
  }
  {}  %% 11 Torsimany 4+8
  {  %% 12 arbre jeràrquic
   aFeGeiX dup length dup /iNSeRT exch def 4 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~12_) putinterval
   /aFeGeiX exch def
  }
  {  %% 13 eliminem continguts de pàgina
   aFeGeiX dup length dup /iNSeRT exch def 4 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~13_) putinterval
   /aFeGeiX exch def
  }
  {  %% 14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
   aFeGeiX dup length dup /iNSeRT exch def 4 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~14_) putinterval
   /aFeGeiX exch def
  }
  {  %% 15 XRay + eliminem continguts de lleixes segons els index triats (MASATS)
   aFeGeiX dup length dup /iNSeRT exch def 4 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~15_) putinterval
   /aFeGeiX exch def
  }
  {  %% 16 XRay + cerca i substitució de text en unes condicions concretes (MASATS)
   aFeGeiX dup length dup /iNSeRT exch def 4 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~16_) putinterval
   /aFeGeiX exch def
  }
  {  %% 17 XRay + %%MASATSencvlct encavalca tots els continguts de pàgina del document, per ordre, damunt la primera de totes 
   aFeGeiX dup length dup /iNSeRT exch def 4 add string
   dup 3 -1 roll 0 exch putinterval dup iNSeRT (~17_) putinterval
   /aFeGeiX exch def
  }
 ]
 QueLiFemFer get cvx exec
 
 %% deixem fixa la generació d'XRay
 %%[
 %% {false /BoolXRay exch def}
 %% {true /BoolXRay exch def}
 %%]
 %%FemXRay get cvx exec
} stopped
{
 BaBeL 13 get print flush stop
%%UBpliegOMaker
} if

%% inici del missatge d'execució de l'Applet
BaBeL 1 get print flush
QueLiFemFer 2 string cvs print flush
BaBeL 15 get print flush

%#%04% Detecta intèrprets Distiller i Ghostscript (o desconeguts) i n'avalua la versió
(%#%04%)==
/Ghost false def  %% flag x detectar Ghostscript (true) o Distiller (false)
/soRTim false def  %% flag de sortida per errors
%% /vldrs true def  % podem treballar amb transparencies?

systemdict /product known
{  %% és Ghostscript?
 systemdict /product get (Ghostscript) search
 {  %% si, és GS
  pop pop pop
  %% és una versió prou estable?
  systemdict /revision get cvi 800 ge
  {  %% es 8.54 o + x treballar amb transparències?
   /Ghost true def
  }
  {
   %% és 8.54 o + per treballar amb transparències?
   %%(\n\n ginyB42 necessita Ghostscript 8.54 o + per treballar amb transparencies \n ... el dial del llindar quedara perfilat ... ) print flush
   %% /vldrs false def
   BaBeL 25 get dup print flush /soRTim true def
  }ifelse
 }
 {  %% no és pas GS
  systemdict /product get (Distiller) search
  {  %% si, és Distiller
   pop pop pop
   /currentdistillerparams where
   {  %% és Distiller
    pop currentdistillerparams /CoreDistVersion get 5000 lt  % és 5.0 o + ?
    {
     %% avalua si és 6000 (6.0) o superior x poder activar les transparències
     %%(\n\n ginyB42 necessita Distiller 6.0 o + per treballar amb transparencies \n ... el dial del llindar quedara perfilat ... ) print flush
     %% /vldrs false def
     BaBeL 3 get dup print flush /soRTim true def
    }if
   }
   {  %% seria estrany que no tingués currentdistillerparams ...
    %% intèrpret desconegut
    BaBeL 24 get dup print flush /soRTim true def
   } ifelse
  }
  {  %% és una altra cosa (p.e. Apple pstopdf) ...
   systemdict /product get (\n\n) print flush print flush
   ( ... interpret NO implementat per aquest programari <<<\n ... PLEGUEM!\n\n) print flush /soRTim true def
  }ifelse
 }ifelse
}
{
 BaBeL 24 get dup print flush /soRTim true def
}ifelse
soRTim {stop}if  %% és millor treballar amb stop que amb quit? (amb quit Ghostscript desapareix i amb stop els stacks es veuen)

%%% UTILITAT PER COMPROVAR EL S.O.
%%mark  % tanca de recollida d'escombraries

%% comprova si es Mac o Win/Linux/Unix

%% /MoW 0 def
%% comprova si trova fitxers o directoris amb l'identificador del Mac
%%(:*) {MoW 1 add /MoW exch def} 100 string filenameforall
%% MoW 0 eq

%#%05% estratègia més efectiva per saber el separador que utilitza l'intèrpret
%# per tal de definir tots els fitxers temporals de treball que necessitem
%# i d'alguna manera saber en quin OS treballem: (:) Mac clàssic o (/) Win/Linux/Unix
%# per tal de generar tots els path de treball temporal a disc
(%#%05%)==
currentsystemparams /GenericResourcePathSep get
(/) eq
{
 tEmp length /faPath exch def
 /bUsca (/) def		%% utilitzat a l'Applet per extraure el nom del fitxer

 (*) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /TotEmp exch def  %% utilitzat a l'Applet per esborrar tots els fitxers

 (??????????_?????) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /EtEmp exch def  %%(./tmp/??????????_?????) % utilitzat a l'Applet per esborrar tots els fitxers de 16 caràcters

 (*.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /EtEmp2 exch def  %%(./tmp/*.obj) % utilitzat a l'Applet per llegir i esborrar tots els trossos de PDF

 (*.nou) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /EtEmp3 exch def  %% utilitzat a l'Applet per esborrar tots els nous streams a disc

 tEmp length /faPathA exch def
 (afegeix.obj) dup length faPathA add string dup
 /pAthA exch def 0 tEmp putinterval
 pAthA exch faPathA exch putinterval
 pAthA /repiCa exch def  %% utilitzat per l'Applet per afegir els Contents originals en un sol stream

 (Sfncns.obj) dup length faPathA add string dup
 /pAthA exch def 0 tEmp putinterval
 pAthA exch faPathA exch putinterval
 pAthA /funKy exch def  %% utilitzat per l'Applet per desar els streams de les funcions decodificades

 (1__________.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /NOMfitx exch def  %%(./tmp/1__________.obj) % utilitzat a l'Applet per desar tots els trossos de PDF abans de ser tractat

 (Sxref______.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /SUBxref exch def  %%(./tmp/Sxref______.obj) % utilitzat a l'Applet per desar les subseccions de l'xref

 (Txref______.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /TOTxref exch def  %%(./tmp/Txref______.obj) % utilitzat a l'Applet per desar tota l'xref

 (contentsdenou.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet exch def  %% utilitzat per l'Applet per reescriure els Contents unificats per mitjà les seves redefinicions

 (contentsdenou2.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet2 exch def  %% utilitzat per l'Applet per aplicar el tractament dels Contents unificats per mitjà les seves redefinicions

 (contentsdenou3.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet3 exch def  %% utilitzat per l'Applet per aplicar el tractament dels streams dels Patterns&Shadings per mitjà les seves redefinicions

 (contentsdenou4.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet4 exch def  %% utilitzat per l'Applet per aplicar el tractament dels streams dels Patterns&Shadings per mitjà les seves redefinicions

 (contentsdenou5.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet5 exch def  %% utilitzat per l'Applet per aplicar el tractament dels streams dels Form XObject per mitjà les seves redefinicions

 (brossa.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /BRoSSa exch def  %% utilitzat per l'Applet per llençar informació

 (brossa2.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /BRoSSa2 exch def  %% utilitzat per l'Applet per llençar informació

 (1__________.nou) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /nousStreams exch def  %% utilitzat per l'Applet per desar els nous streams redefinits al disc

 (1__________.cob) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /nousCoOb exch def  %% utilitzat per l'Applet per desar els nous composite objects (dics+arrays) repicats al disc
}  %% Win/Linux/Unix
{  %% Mac clàssic
 tEmp length /faPath exch def
 /bUsca (:) def		%% utilitzat a l'Applet per extraure el nom del fitxer

 (*) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /TotEmp exch def  %% utilitzat a l'Applet per esborrar tots els fitxers

 (??????????_?????) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /EtEmp exch def  %%(./tmp/??????????_?????) % utilitzat a l'Applet per esborrar tots els fitxers de 16 caràcters

 (*.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /EtEmp2 exch def  %%(./tmp/*.obj) % utilitzat a l'Applet per llegir i esborrar tots els trossos de PDF

 (*.nou) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /EtEmp3 exch def  %% utilitzat a l'Applet per esborrar tots els nous streams a disc

 tEmp length /faPathA exch def
 (afegeix.obj) dup length faPathA add string dup
 /pAthA exch def 0 tEmp putinterval
 pAthA exch faPathA exch putinterval
 pAthA /repiCa exch def  %% utilitzat per l'Applet per afegir els Contents originals en un sol stream

 (Sfncns.obj) dup length faPathA add string dup
 /pAthA exch def 0 tEmp putinterval
 pAthA exch faPathA exch putinterval
 pAthA /funKy exch def  %% utilitzat per l'Applet per desar els streams de les funcions decodificades

 (1__________.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /NOMfitx exch def  %%(./tmp/1__________.obj) % utilitzat a l'Applet per desar tots els trossos de PDF abans de ser tractat

 (Sxref______.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /SUBxref exch def  %%(./tmp/Sxref______.obj) % utilitzat a l'Applet per desar les subseccions de l'xref

 (Txref______.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /TOTxref exch def  %%(./tmp/Txref______.obj) % utilitzat a l'Applet per desar tota l'xref

 (contentsdenou.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet exch def  %% utilitzat per l'Applet per reescriure els Contents unificats per mitjà les seves redefinicions

 (contentsdenou2.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet2 exch def  %% utilitzat per l'Applet per aplicar el tractament dels Contents unificats per mitjà les seves redefinicions

 (contentsdenou3.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet3 exch def  %% utilitzat per l'Applet per aplicar el tractament dels streams dels Patterns&Shadings per mitjà les seves redefinicions

 (contentsdenou4.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet4 exch def  %% utilitzat per l'Applet per aplicar el tractament dels streams dels Patterns&Shadings per mitjà les seves redefinicions

 (contentsdenou5.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /l'objectenet5 exch def  %% utilitzat per l'Applet per aplicar el tractament dels streams dels Form XObject per mitjà les seves redefinicions

 (brossa.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /BRoSSa exch def  %% utilitzat per l'Applet per llençar informaciò

 (brossa2.obj) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /BRoSSa2 exch def  %% utilitzat per l'Applet per llençar informació

 (1__________.nou) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /nousStreams exch def  %% utilitzat per l'Applet per desar els nous streams redefinits al disc

 (1__________.cob) dup length faPath add string dup /pAthXiU exch def
 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
 pAthXiU /nousCoOb exch def  %% utilitzat per l'Applet per desar els nous composite objects (dics+arrays) repicats al disc
}ifelse  %% sintaxi segons S.O.

%% podriem passar amb una sola llista de path !!!!!

%%cleartomark  % recull les possibles escombraries (p.e. a Mac OS)
%%% fi d'OS

%#%06% %%%DLL%%% Atenció: això no li agrada a la DLL i al comprimir-lo (Flate) cal treure-ho!!!
(%#%06%)==
%% ara esborrem tots dels fitxers del tmp al principi (i si no podem deixem un missatge)
BaBeL 7 get print flush
TotEmp {
        {deletefile} stopped
        {
         (\n) print flush print flush ( <<< NO he pogut esborrar el Temporal !!\n) print flush
        }if
       } 256 string filenameforall
%%%DLL%%%

%% eliminat 26.03.09
%%07%% VALIDACIO DE LA CLAU DIGITAL IDENTIFICATIVA
%%(%07%)==
%%save
%% clau digital generada pel nou sistema GenClau
%% GENclau
%%{pathGENclau (r) file 256 string readstring pop}stopped
%%{ BaBeL 21 get print flush quit } if
%%eq not  % es igual ?
%%{
%% BaBeL 21 get print flush quit
%%}if
%%restore
%%% FI DE CLAU DIGITAL IDENTIFICATIVA

%#%08% aquí llistem x la pantalla el nom del PDF que explorem ...
(%#%08%)==
BaBeL 6 get print flush
fApplet dup
{
 bUsca search
 {pop pop}{exit}ifelse
}loop dup /nomFITX exch def print flush(\n\n)print flush
%% comprovem que existeixi ...
status
{
 pop pop /bytFITX exch def pop
}  %% bytes totals del fitxer pel trillador ...
{
 BaBeL 4 get print flush stop
%%UBpliegOMaker
}ifelse

%#%09% aquí posem un detector de si compleix la convenció dels 1024 del cap i la cua
%# i un detector de brossa del PDF (si la trobem, de moment descartem aquests fitxers i deixem x més endavant la creació d'un netejador)
(%#%09%)==
%% comprovem si duu el cap normatiu, dins dels marges 1024
fApplet (r) file 0 (%PDF-) /SubFileDecode filter 1025 string readstring pop
dup length 0 eq  %% i si duu brossa
{
 pop
 /byteCapNet 0 def  %% offset a partir del qual el PDF es net
}
{
 dup length 1025 eq
 {
  BaBeL 26 get print flush pop stop %%quit
%%UBpliegOMaker
 }
 {
  dup (%!PS-Adobe-) search
  {
   dup /elCAP exch def length /byteCapNet exch def  %% offset a partir del qual el PDF es net
   (\n\n >>>> cap de PDF amb convencio %!PS-Adobe\n\n) print flush
   pop pop pop
  }
  {
   dup /elCAP exch def length /byteCapNet exch def  %% offset a partir del qual el PDF es net
  }ifelse
 }ifelse
}ifelse
byteCapNet 0 eq
{
 fApplet (r) file 10 string readline pop (%PDF-) anchorsearch
 pop pop /vPDF exch def  %% desem la versio del cap de PDF
 %% mes endavant comprovarem que no dugui l'entrada Version dins el Catalog
}
{
 {elCAP cvx exec} stopped
 {  %% sortim si duu caracters que donen error a l'interpret ...
  BaBeL 27 get print flush stop %quit
%%UBpliegOMaker
 } if  %% la donem x bona si es formada per caracters inofensius x l'interpret (CRs, espais, nulls, etc)
}ifelse

%% comprovem si la cua es normativa
fApplet (r) file dup bytFITX 1024 sub dup  % calculem on s'escau el byte dels darrers 1024 del fitxer
0 lt
{  %% ens assegurem que els PDF no sigui + petit que 1024
 pop /darrers1024 0 def /CUAfa bytFITX def
}
{
 /darrers1024 exch def /CUAfa 1024 def
}ifelse

darrers1024 setfileposition  %% ens posicionem als darrers 1024

%% escorcollem recursivament fins el darrer %%EOF (si hi es)

1024 string readstring pop

{
 (%%EOF) search
 {pop pop}{exit}ifelse
}loop /laCUA exch def

laCUA length CUAfa eq
{  %% si es idem es que no ha trobat %%EOF dins els darrers 1024 bytes del fitxer
 BaBeL 28 get print flush stop %quit
%%UBpliegOMaker
}
{  %%EOF existeix
 {  %% executem la cadena que hi ha despres del darrer %%EOF x saber-ne la validesa
  laCUA cvx exec
 } stopped
 {  %% ens aturem si es formada per caracters que donen error a l'interpret
  BaBeL 29 get print flush stop %quit
%%UBpliegOMaker
 } if  %% la donem x bona si es formada per caracters inofensius x l'interpret (CRs, espais, nulls, etc)
}ifelse

%% fi del detector de brossa i convencio 1024 del cap i cua

%#%10% trillador de PDF per superar la limitació 65535 famosa
%# de passada podem saber d'antuvi de quants objectes disposa
(%#%10%)==

%% trencapdf.ps

%% cal veure si aquesta quantitat cal variar-la en funcio del nombre d'objectes
%% del fitxer o les caracteristiques del l'interpret PS/maquina que utilitzem
%% amb aquest parametre s'hi pot jugar x ventar tots els objectes al disc (sempre que matem la funcio d'esborrar fitxers del final)
/tiBadesFINS 500 def  % comptador de com agruparem els fitxers al trillar-los

%% Us del filtre SubFileDecode com a trencador de fitxers PDF a traves d'una cadena
%% de text, podent agrupar cada n vegades que ha estat trobada, en fitxers numerats
%% tambe serveix per fer el recompte d'objectes existents
save
fApplet /nOm exch def  %% cadena amb el nom del fitxer a llegir

/FINS (endobj) def  %% cadena per on trencarem el fitxer
FINS length /salta'tFINS exch def

/tiBades 0 def  %% comptador de vegades que em trobat FINS
/numFITX 1 def  %% digit sequencial pel nom del fitxer

nOm (r) file  %% arxiu a llegir
/LLEgIR exch def

%%
NOMfitx
(w) file  %% arxiu final amb el resultat de la recerca
/ESCRiURE exch def
%%

NOMfitx length 15 sub /posNum exch def  %% posicio d'inici fixa del numerador d'objectes

/engrapa 65535 def  %% buffer de lectura (65535 es el maxim)
/posFITX 0 def  %% valor inicial del comptador de la posicio en bytes del fitxer de lectura

{  %% inici del loop 1
 LLEgIR  %% fitxer a llegir
 dup posFITX setfileposition  %% posiciona en el lloc correcte l'inici de la recerca
 0 FINS  %% s'aturara quan trobi la cadena
 /SubFileDecode filter  %% dona un fitxer de lectura on s'inicia la recerca de la cadena final FINS
 { %% inici del loop comptador de les dades llegides
  dup engrapa string readstring
  not
  {
   dup ESCRiURE exch writestring  %% escrivim la cadena al fitxer d'escriptura
   length posFITX add /posFITX exch def pop exit
  } if
  dup ESCRiURE exch writestring  %% escrivim la cadena al fitxer d'escriptura
  length posFITX add /posFITX exch def
 } loop  %% final del loop comptador

 posFITX salta'tFINS add /posFITX exch def  %% comptador de posicions del fitxer de lectura
 LLEgIR posFITX setfileposition  %% ens posicionem en el punt on hem d'iniciar la recerca de la cadena final FINS
 tiBades 1 add /tiBades exch def
 posFITX bytFITX ge {exit} if  %% si la posicio del fitxer es igual a a la seva capacitat total (o limit de bytes establerts) es que som al final de la seva lectura i per tant sortim del programa
 ESCRiURE dup FINS writestring 13 write  %% hi afegim la cadena final que busquem
 tiBades tiBadesFINS eq
 {
  %% inicialitzador dels noms i fitxers sequencials
  ESCRiURE closefile
  /tiBades 0 def  %% comptador de vegades que em trobat FINS
  numFITX 1 add /numFITX exch def
  NOMfitx
  posNum  %% EP!
  numFITX 10 string cvs putinterval
  NOMfitx
  (w) file  %% arxiu final amb el resultat de la recerca
  /ESCRiURE exch def
  %%
 } if
} loop  %% final del loop 1

%% missatge per pantalla (Distiller)
%%(\n Hem Trencat el PDF en ... ) print flush numFITX 10 string cvs print flush
%%( ... Fitxers .obj \n\n) print flush

%% posem per la DLL dins XRay el nombre d'objectes ?
%%(\n\n Aquest PDF te ... ) print flush
BaBeL 12 get print flush
numFITX 1 sub tiBadesFINS mul tiBades add
1 sub  %% hem detectat que sempre en marcava 1 de mes!
dup globaldict /objPDF 3 -1 roll put  %% desem a Globaldict el nombre d'objectes x poder-lo incrustar + avall al dic PeDeEfa d'XRay
10 string cvs print flush (\n)print flush
%%( ... objectes) print flush
restore
%% fi de trencapdf.ps (trillador)

%%%CALi2COPi%%%
%% aqui teniem definit el fitxer on reconstruir el PDF
%%%CALi2COPi%%%

%#%11% Nou algorisme que reescriu un diccionari, basat en espiadic_fura2.ps
%# per tal de no tenir problemes amb els diccionaris recursius (per més que n'hi hagin!)
(%#%11%)==
%% cal estudiar bé si posem EOL en certs punts d'aquest ventador

/espiadic_fura2
{
 /AraVento_D exch def
 /iDic 0 def  %% índex de diccionaris a incrustar a l'array
 /NohAdic true def  %% és imprescindible que comenci amb true ?

 %% AraVento i AraBorro són variables que s'aniran alternant el diccionari intern d'esborrat
 %% de les dades a mida que es vagin ventant
 AraVento_D 10 dict copy /AraBorro_D exch def

 %% la idea és fer una array dels diccionaris que anem ventant (còpies no vinculades)
 %% l'array anirà creixent a mida que anem entrant a diccionaris més interns
 %% i d'aquestos anirem eliminant els parells ventats a mida que els anem ventant
 %% fent-ne l'actualització/eliminació de l'array quan convingui

 /Adic 1 array def  %% paquet amb els diccionaris que anem ventant

 {  %% loop 1
  {  %% loop 2
   AraVento_D
   {  %% forall
    dup type /dicttype eq  %% hem d'escriure el diccionari a mida que l'anem trobant
    {
     exch dup AraBorro_D exch undef  %% dono de baixa el parell
     %% escrivim la clau
     127 string cvs  %% converteix a cadena el nom Clau amb el màxim permés per a un literal al PDF 1.3
     %% posem el caràcter / per la clau literal
     dup length 1 add string dup 0 (/) putinterval dup 3 -1 roll 1 exch putinterval
     Objected'Ara exch writestring
     %% Objected'Ara ( ) writestring
     Objected'Ara ( <<) writestring  %% escrivim l'inici del diccionari
     iDic 1 add /iDic exch def  %% comptador d'índex pel proper diccionari
     %% ampliem l'array de diccionari a 1 més i reincrustem l'anterior
     Adic length 1 add array dup Adic 0 exch putinterval /Adic exch def
     Adic exch iDic exch put  %% incrustem el diccionari que ventem a la darrera posició
     Adic iDic 1 sub AraBorro_D put  %% incrustem el diccionari còpia purgat a la posició anterior
     /NohAdic false def
     Adic iDic get /AraVento_D exch def
     AraVento_D 10 dict copy /AraBorro_D exch def exit
    }
    {
     exch dup AraBorro_D exch undef  %% dono de baixa el parell
     %% escrivim la clau
     127 string cvs  %% converteix a cadena el nom Clau amb el màxim permés per a un literal al PDF 1.3
     %% posem el caràcter / per la clau literal
     dup length 1 add string dup 0 (/) putinterval dup 3 -1 roll 1 exch putinterval
     Objected'Ara exch writestring
     Objected'Ara ( ) writestring
     %% escrivim el valor esbrinant de quina mena
     dup type /integertype eq 
     {
      256 string cvs
     }
     {
      dup type /booleantype eq 
      {
       6 string cvs
      }
      {
       dup type /realtype eq
       {
        10000 mul truncate 10000 div
        256 string cvs
       }
       {
        dup type /stringtype eq
        {
         %% 65535 string cvs  % es redundant?
         %% salvaparent2.ps
         %% de com reescriure una string x solucionar el problema de no deixar-nos
         %% el backslash \ i els parentesi () sense el \ que els marca com a caràcters
         %% adaptat de l'algorisme NRMLTZDR2.ps del cercador de pal·líndroms TURURUT2
         /fora
         [  %% paquet de caràcters a cercar
          (\134)  %% \
          (\050)  %% (
          (\051)  %% )
         ] def
         /FAfora 3 def  %% pestell de sortida del loop
         /foraX
         [  %% paquet de substitució de caràcter
          (\\\\)
          (\\\()
          (\\\))
         ] def
         /ifora 0 def  %% índex de fora
         %% aquí la cadena a reescriure correctament
         %% (el primer \\\)el segon\\\( el tercer \)\(el quart i el cinquè\(\))
         mark exch
         {  %% loop general
          {  %% loop cerca/subs de caràcters
           fora ifora get search
           {
            exch pop
            dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
            dup 3 -1 roll 0 exch putinterval
           }
           {
            exit
           }ifelse
           exch
          } loop
          %% aquest loop capgira tots els elements trobats a l'stack mentre n'hi hagi més d'un
          counttomark 1 gt
          {
           counttomark /atura't exch def
           /ici 2 def
           {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
           {  %% loop empalmador de les cadenes trobades en 1 sola
            dup length dup 3 index length add string dup 4 -1 roll
            0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
            counttomark 1 eq {exit} if
           } loop
          } if
          ifora 1 add /ifora exch def
          FAfora ifora eq {exit}if
         } loop
         exch pop  %% ens carreguem mark
         %% fi de salvaparent2.ps
         %% posem els caràcters ( ... ) com a cadena
         dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
         dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
        }
        {
         dup type /nametype eq
         {
          %% hem localitzat noms que excepcionalment NO compleixen la convenció dels 128 de màxim!
          %% exemple ... 7Ciencies36_iMARTI 3.pdf d'A3copiseny
          256 string cvs  %% per això hi posem 256!
          dup length 16 eq
          {
           dup 10 get 95 eq  %% ens assegurem que el caràcter central sigui un _
           {  %% reconstruïm les tres dades originals de referència indirecta d'objecte (# # R)
            (_) search pop exch pop exch
            {
             (_) search {pop pop}{(R) exit}ifelse
            } loop
            3 -1 roll Objected'Ara exch writestring Objected'Ara ( ) writestring exch
            Objected'Ara exch writestring Objected'Ara ( ) writestring  %% deixem la (R) per cua de l'algorisme
           }
           {  %% posem el caràcter / per la clau literal
            dup length 1 add string dup 0 (/) putinterval dup 3 -1 roll 1 exch putinterval
           }ifelse
          }
          {  %% posem el caràcter / per la clau literal
           dup length 1 add string dup 0 (/) putinterval dup 3 -1 roll 1 exch putinterval
          }ifelse
         }  %% tots aquest tipus els posa el seu valor en una cadena de text i després en un paquet
         {
          dup type /arraytype eq
          {  %% aquí cridem l'espiapaq_fura3 i deixem una string buida per que no peti
           /salva'l save def espiapaq_fura3 salva'l restore ()
          }
          {
           dup type /nulltype eq
           {
            pop (null)
           }
           {  %% la resta de tipus que quedin es posa en una cadena de text el nom del tipus
            type 256 string cvs
           } ifelse
          } ifelse  %% del arraytype
         } ifelse  %% de nametype
        } ifelse  %% del stringtype
       } ifelse  %% del realtype
      } ifelse  %% del booleantype
     } ifelse  %% del integertype
     Objected'Ara exch writestring
     Objected'Ara  %% dup
     ( ) writestring  %% flushfile
     %% fi d'escriptura del valor i esbrinat de la mena
    }ifelse
   } forall
   NohAdic {exit}if  %% sortim si al diccionari més allunyat ja no en niua cap més
   /NohAdic true def  %% cada vegada que acabem de ventar un diccionari ...
  } loop  %% 2
  Adic length 0 eq {exit} if  %% filtre per l'array de diccionaris buida
  Adic iDic AraBorro_D put  %% incrustem el diccionari acabat de ventar i purgat a la darrera posició
  %% eliminem enrera els diccionaris buits i reconstruim Adic a la mida justa per continuar el ventat
  %% només sortirem quan Adic estigui a 0
  {  %% loop
   Adic iDic get length 0 eq  %% quan trobem un diccionari que no és a 0 sortim del purgat d'Adic
   {
    Adic length 1 sub Adic exch 0 exch getinterval /Adic exch def
    Adic length 0 eq {exit} if
    %% aquí la cua del diccionari
    Objected'Ara  %%d up
    (>> ) writestring  %% flushfile  % escrivim la cua del diccionari
   }
   {
    exit
   } ifelse
   iDic 1 sub /iDic exch def
  } loop
  Adic length 0 eq {exit} if  %% pleguem ?
  Adic iDic get /AraVento_D exch def  %% agafem el darrer diccionari no zero per continuar el ventat
  AraVento_D 10 dict copy /AraBorro_D exch def  %% en fem la còpia pel purgat
 } loop  %% 1
} bind def
%% fi de l'algorisme que reescriu un diccionari espiadic_fura2

%#%12% Nou algorisme que reescriu una array, basat en epfadict.ps
%# igual que espiapaq_fura2 pot fer tota mena d'arrays recursius (per més que n'hi hagin!)
(%#%12%)==
%% però ara gestiona molt millor la VM i les arrays gegants

/espiapaq_fura3
{
 %% fem el diccionari on definirem els objectype, així evitem treballar amb els if recursius
 <<
   %% és un paquet ...
   /arraytype
   {
    %% exch dup AraBorro exch undef  % dóno de baixa l'element
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  %% índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo %% null
      mark put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    Objected'Ara ([) writestring  %% escrivim l'inici del paquet
    iPaq 1 add /iPaq exch def  %% comptador d'índex pel proper paquet
    %% ampliem l'array de paquets a 1 més i reincrustem l'anterior
    Apaq length 1 add array dup Apaq 0 exch putinterval /Apaq exch def
    Apaq exch iPaq exch put  %% incrustem el paquet que ventem a la darrera posició
    %% purguem els nulls d'AraBorro que hi hagin
    /iKill 0 def  %% l'índex a matar
    {  %% loop
     /iAo 0 def  %% índex general del paquet original
     /iAr 0 def  %% índex general del paquet a repicar
     AraBorro_A
     iKill get %% null
     mark eq
     {
      AraBorro_A dup length 1 sub array
      /laNova exch def  %% el paquet repicat sempre tindrà n-1 elements
      {  %% forall
       iAo iKill eq
       {
        pop
        iAr 1 sub /iAr exch def
       }  %% si és l'element que hem de matar, doncs el matem
       {
        laNova exch iAr exch put
       } ifelse  %% la resta els repiquem a laNova
       iAo 1 add /iAo exch def
       iAr 1 add /iAr exch def
      } forall
      laNova /AraBorro_A exch def
      iKill 1 sub /iKill exch def  %% comptador per saber l'índex a matar
     } if
     iKill 1 add /iKill exch def  %% comptador per saber l'índex a matar
     AraBorro_A length /maxLoop exch def  %% quan sortim
     iKill maxLoop ge {exit} if
    } loop
    %% fi del purgat de nulls
    Apaq iPaq 1 sub AraBorro_A put  %% incrustem el paquet còpia purgat a la posició anterior
    /NohApaq false def
    Apaq iPaq get /AraVento_A exch def
    AraVento_A dup length array copy /AraBorro_A exch def exit
   }
   %% és un enter ...
   /integertype 
   {
    %% fix per a tots els objectes
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  %% índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo  %% null
      mark put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    %% fix per a tots els objectes
    256 string cvs
   }
   %% és un booleà ...
   /booleantype
   {
    %% fix per a tots els objectes
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  %% índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo  %% null
      mark put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    %% fix per a tots els objectes
    6 string cvs
   }
   %% és un real ...
   /realtype
   {
    %% fix per a tots els objectes
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  %% índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo  %% null
      mark put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    %% fix per a tots els objectes
    10000 mul truncate 10000 div
    256 string cvs
   }
   %% és una cadena ...
   /stringtype
   {
    %% fix per a tots els objectes
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  % índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo  %% null
      mark put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    %%% fix per a tots els objectes
    %%% salvaparent2.ps
    %%% de com reescriure una string per solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caràcters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de pal·líndroms TURURUT2
    /fora
    [  %% paquet de caràcters a cercar
     (\134)  %% \
     (\050)  %% (
     (\051)  %% )
    ] def
    /FAfora 3 def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitució de caràcter
     (\\\\)
     (\\\()
     (\\\))
    ] def
    /ifora 0 def  %% índex de fora
    %% aquí la cadena a reescriure correctament
    %% (el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caràcters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% aquest loop capgira tots els elements trobats a l'stack mentre n'hi hagi més d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% fi de salvaparent2.ps
    %% posem els caràcters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
   }
   %% és un literal ...
   /nametype
   {
    %% fix per a tots els objectes
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  %% índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo  %% null
      mark put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    %% fix per a tots els objectes
    %% hem localitzat noms que excepcionalment NO compleixen la convenció dels 128 de màxim!
    %% exemple ... 7Ciencies36_iMARTI 3.pdf d'A3copiseny
    256 string cvs
    dup length 16 eq
    {
     dup 10 get 95 eq  %% ens assegurem que el caràcter central sigui un _
     {  %% reconstruïm les tres dades originals de referència indirecte d'objecte (# # R)
      (_) search pop exch pop exch
      {
       (_) search {pop pop}{(R) exit}ifelse
      } loop
      3 -1 roll Objected'Ara exch writestring Objected'Ara ( ) writestring exch
      Objected'Ara exch writestring Objected'Ara ( ) writestring   %% deixem la (R) per cua de l'algorisme
     }
     {  %% posem el caràcter / per la clau literal
      dup length 1 add string dup 0 (/) putinterval dup 3 -1 roll 1 exch putinterval
     }ifelse
    }
    {  %% posem el caràcter / per la clau literal
     dup length 1 add string dup 0 (/) putinterval dup 3 -1 roll 1 exch putinterval
    }ifelse
   }  %% tots aquest tipus els posa el seu valor en una cadena de text i després en un paquet
   %% és un diccionari ...
   /dicttype
   {  %% aquí cridem l'espiadic_fura2 i deixem una string buida per que no peti
    %% fix per a tots els objectes
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  %% índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo  %% null
      mark
      put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    %% fix per a tots els objectes
    Objected'Ara (<<) writestring
    /salva'l save def espiadic_fura2 salva'l restore ()
    Objected'Ara (>>) writestring
    %% el diccionari que quedaria a l'stack seria el presumible culpable
    %% del null de més que sempre sortia a la cua del l'array
    %% però realment ara integrat a Rustec ... hi queda?
    %% deixem aquest codi com a test temporal per comprovar-ho
    %% count 1 ne {exch dup type /dicttype eq {pop ( ... Hi ha el Dic dels Nulls!!)==}{exch}ifelse}if
    %% si veiem que amb molts tests no hi surt l'eliminarem ...
   }
   %% és un null ...
   /nulltype
   {
    %% fix per a tots els objectes
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  %% índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo  %% null
      mark put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    %% fix per a tots els objectes
    pop (null)
   }
   %% és una mark ...
   /marktype
   {
    %% fix per a tots els objectes
    %% donem de baixa un element cada vegada (cal saber el seu índex) marcant-lo amb un null
    /iAo 0 def  %% índex general del paquet original
    AraBorro_A
    {  %% forall
     iAo iKill eq
     {
      AraBorro_A iAo  %% null
      mark put
      pop
     }  %% si és l'element que hem de matar, doncs el matem
     {
      pop
     } ifelse
     iAo 1 add /iAo exch def
    } forall
    %% fix per a tots els objectes
    pop (mark)
   }
 >>
 /furaP exch def
 /AraVento_A exch def  %% pesquem el paquet
 Objected'Ara ([) writestring  %% escrivim l'inici del paquet
 /iPaq 0 def  %% índex de paquets a incrustar a l'array Apaq
 /NohApaq true def  %% és imprescindible que comenci amb true ?
 %% la idea és fer una array dels paquets que anem ventant (còpies no vinculades)
 %% l'array anirà creixent a mida que anem entrant a paquets més interns
 %% i d'aquestos anirem eliminant els elements ventats a mida que els anem ventant
 %% fent-ne l'actualització/eliminació del array quan convingui
 /Apaq 1 array def  %% paquet amb els arrays que anem ventant
 %% deixem el paquet a trams a l'stack
 %% aquest algorisme extrau trams d'un paquet en funció de la variable rAng
 %% sempre que rAng sigui més petit que maxA, si no extrau tota l'array de forma intacte
 /rAng 13 def  %% mida del tram a extraure, ÉS LA MILLOR QUE HEM TROBAT PER UNA ARRAY AL MÀXIM!!
 /iRay 0 def  %% índex dinàmic d'inici d'extracció del tram
 mark  %% pel counttomark!
 AraVento_A  %% paquet a tractar
 dup length /maxA exch def  %% mida del paquet
 maxA rAng lt  %% la capacitat del paquet és més petita que el tram a extraure?
 {
  iRay maxA getinterval  %% extraiem el paquet de forma intacte
 }
 {
  {
   dup iRay rAng getinterval exch  %% extraiem el paquet
   iRay rAng add /iRay exch def  %% actualitzem l'índex dinàmic d'inici d'extracció del tram
   %% si queda per extraure una quantitat menor que rAng, l'agafem com a darrer valor
   maxA iRay sub rAng lt {maxA iRay sub /rAng exch def}if
   maxA iRay le {pop exit}if  %% si la capacitat del paquet és més petita o igual que l'índex dinàmic, sortim
  } loop
 } ifelse
 %% fi de deixar el paquet a trams a l'stack
 %% aquest loop capgira tots els elements trobats a l'stack
 counttomark dup 1 gt
 {  %% capgirem sempre que hi hagi més d'un paquet
  /atura't exch def
  /ici 2 def
  {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
  %% per carregar-nos la mark
  atura't 1 add -1 roll pop
 }
 {
  pop exch pop /atura't 1 def
 } ifelse
 %%
 %% ara ho farem amb un repeat en comptes d'un loop!
 atura't
 { %% repeat 0 de llegir l'array per trams
  /AraVento_A exch def
  %% AraVento i AraBorro són variables que s'aniran alternant el paquet intern d'esborrat
  %% de les dades a mida que es vagin ventant
  AraVento_A dup length
  dup 0 eq
  {
   pop pop
   %% 1 array
   0 array  %% quan és una simple array buida no hi podem posar un null doncs p.e. al PDF 21KX75.pdf (d'Esko!) es dóna la curiositat que al diccionari 28 0 obj (una mena de Shading Pattern crec) l'entrada /Bounds ha d'estar buida [] i si duia [null] no donava error pero l'Acrobat no visualitzava res!
  }
  {
   array copy
  } ifelse %% filtre per arrays buides
  /AraBorro_A exch def
  save /salva'm exch def
  {  %% loop 1
   {  %% loop 2
    /iKill 0 def  %% inicialitzem l'índex a matar
    AraVento_A
    {  %% forall
     %% aquí interroguem l'objecte i tibem el seu type de la definició del diccionari furaP
     dup type furaP exch get exec
     Objected'Ara exch writestring
     Objected'Ara  %% dup
     ( ) writestring  %% flushfile
     %% fi d'escriptura del valor i esbrinat de la mena
     iKill 1 add /iKill exch def  %% comptador per saber l'índex a matar
    } forall
    NohApaq {exit}if  %% sortim si a l'array més allunyat ja no en niua cap més
    /NohApaq true def  %% cada vegada que acabem de ventar un array ...
   } loop  %% 2
   %% purguem els nulls d'AraBorro que hi hagin
   /iKill 0 def  %% l'índex a matar
   {  %% loop
    /iAo 0 def  %% índex general del paquet original
    /iAr 0 def  %% índex general del paquet a repicar
    AraBorro_A
    %% filtre per arrays buides
    %% sense aquest filtre el cas de l'objecte 9 0 del fitxer H200205081001000JAI.pdf
    %% dóna un error típic d'array buida ...
    %% [ Error: rangecheck; OffendingCommand: get ] %% Stack: 0 []
    dup length 0 eq {pop Apaq length 0 eq {1 array /Apaq exch def}if exit} if
    iKill get  %% null
    mark eq
    {
     AraBorro_A dup length 1 sub array
     /laNova exch def  %% el paquet repicat sempre tindrà n-1 elements
     {  %% forall
      iAo iKill eq
      {
       pop
       iAr 1 sub /iAr exch def
      }  %% si és l'element que hem de matar, doncs el matem
      {
       laNova exch iAr exch put
      } ifelse  %% la resta els repiquem a laNova
      iAo 1 add /iAo exch def
      iAr 1 add /iAr exch def
     } forall
     laNova /AraBorro_A exch def
     iKill 1 sub /iKill exch def  %% comptador per saber l'índex a matar
    } if
    iKill 1 add /iKill exch def  %% comptador per saber l'índex a matar
    AraBorro_A length /maxLoop exch def  %% quan sortim
    iKill maxLoop ge {exit} if
   } loop
   %% fi del purgat de nulls
   Apaq iPaq AraBorro_A put  %% incrustem el paquet acabat de ventar i purgat a la darrera posició
   %% eliminem enrera els paquets buits i reconstruïm Apaq a la mida justa per continuar el ventat
   %% només sortirem quan Apaq estigui a 0
   {  %% loop
    Apaq iPaq get length 0 eq  %% quan trobem una array que no és a 0 sortim del purgat d'Apaq
    {
     Apaq length 1 sub Apaq exch 0 exch getinterval /Apaq exch def
     Apaq length 0 eq {exit} if
     %% aquí la cua del paquet
     Objected'Ara  %% dup
     (]) writestring  %% flushfile  % escrivim la cua del paquet
    }
    {
     exit
    } ifelse
    iPaq 1 sub /iPaq exch def
   } loop
   Apaq length 0 eq {exit} if  %% pleguem ?
   Apaq iPaq get /AraVento_A exch def  %% agafem el darrer array no zero per continuar el ventat
   AraVento_A dup length array copy /AraBorro_A exch def  %% en fem la còpia pel purgat
  } loop  %% 1
  salva'm restore
  %% counttomark 0 eq {pop exit}if  % sortim quan ja no hi hagi cap paquet a l'stack
  %% dup type /arraytype ne {exit}if
 } repeat  %% ARA NO loop  % 0 NOOOOOUUUUUU
 Objected'Ara  %%dup dup
 (]\012) writestring  %%EOL writestring flushfile  % escrivim el final del paquet
} bind def
%% fi de l'algorisme que reescriu un paquet espiapaq_fura3

%% nous afegits per gestionar millor les xref
%% filtrats diversos bugs de versions anteriors
%#%13% aquí comença el nucli original de comdimoni
(%#%13%)==
%%killMetadata+InfoVell+ObjectesLength
%% ressucitem aquest dic x matar l'objecte real dic+stream de la Metadata i objectes amb el valor Length dels streams
/OdeBaixa 2 dict def

%% Aquesta utilitat activa com a "Clau" (literal) totes les referencies
%% d'objectes d'un PDF (directes -obj- i indirectes -R-), i com a "Valor"
%% el diccionari original del PDF, afegint-hi a tots aquells que porten
%% "streams" de dades el parell: /XiU (path + nom del fitxer amb les dades)
%% Just abans haurem escrit al disc les dades de l'stream en un fitxer
%% amb el nom de la "Clau" (literal). 03.12.99

%% 03.01.04 cal veure com guanyem molt de temps aplicant els parells save/restore
%% (garbage collection) en totes les redefinicions on sigui significatiu

false {  %% desacivem l'implementacio
%% important implementacio per guanyar eficiencia
%% Aquest algorisme redefineix l'operador de tancament de diccionaris per controlar el nombre d'objectes indirectes
%% ... 1 0 R ... definits d'una vegada dins un diccionari, doncs si en supera un determinat nombre,
%% Gostscript i Distiller peten en la repeticio d'n cops de l'algorisme R d'encadenat a string i despres a literal,
%% llavors els empaquetem per manats per estalviar memoria a l'interpret i els desem en un altre diccionari extern
%% deixant com a testimoni la cadena (HeM FeT @ MaNaTS) al seu lloc original
%% Dins un aplicatiu real (com CaLi2CoPi) cal preservar la definicio original de l'operador de tancament de diccionaris dins un altre variable per
%% restaurar-la despres del que en hem proposat.

%% inicialitzem ...
/aGrupem 3 def  %% nombre maxim de parells clau/valor que agruparem
/maNat aGrupem 2 mul 1 add def  %% per a us del roll
/manatsExterns 4 dict def  %% diccionari on desarem els manats externs (se suposa que la capacitat es indiferent)
/femManats false def  %% gatell x activar o no el darrer operador de tancament del diccionari
/quantsManats 0 def  %% comptador de manats fets
/tesTimoni true def  %% gatell x saber si hem de crear el testimoni al diccionari original

%% redefinim l'operador de tancament de dicionaris per tal d'agrupar els elements en manats i ser + eficients en la gestio de la memoria de l'interpret
(>>) cvn
{
 femManats
 {
  counttomark 2 idiv
  dup 0 eq
  {  %% som al darrer manat buit xq es exacte ...
   pop  %% ens carreguem el zero sobrer
   /femManats false def
   pop  %% ens carreguem la mark del diccionari que estaria buit
   quantsManats 1 add array astore  %% empaquetem la clau/valors fets a manats
   /quantsManats 0 def  %% inicialitzem el comptador de manats fets
   count
   {  %% loop per assegurar-nos que nomes copiem la clau de l'objecte que treballem ara (el literal que te la mark oberta + a prop de la base de l'stack)
    dup index type /marktype eq
    {
     index  %% copiem la clau de l'objecte que estem interpretant
     exit  %% i sortim
    }
    {
     1 sub
    }ifelse
   }loop
   dup manatsExterns exch known  %% aquest objecte ja te + manats desats?
   {  %% llavors fem creixer l'array, el farcim i el desem a manatsExterns
    dup manatsExterns exch get /aFicar exch def exch /aVeure exch def aFicar dup length 1 add dup 1 sub
    /Dmes exch def array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put dup length array copy
    manatsExterns 3 1 roll put
   }
   {  %% el posem dins una array i el desem a manatsExterns
    exch manatsExterns 3 1 roll 1 array astore put
   }ifelse
   /tesTimoni true def  %% cal tornar a crear el testimoni
  }
  {
   aGrupem lt
   {  %% si som al darrer manat ...
    /femManats false def
    >>  %% endrecem el darrer diccionari
    /tesTimoni true def  %% cal tornar a crear el testimoni
    quantsManats 2 add array astore  %% empaquetem la clau/valors fets a manats
    /quantsManats 0 def  %% inicialitzem el comptador de manats fets
    count
    {  %% loop per assegurar-nos que nomes copiem la clau de l'objecte que treballem ara (el literal que te la mark oberta + a prop de la base de l'stack)
     dup index type /marktype eq
     {
      index  %% copiem la clau de l'objecte que estem interpretant
      exit  %% i sortim
     }
     {
      1 sub
     }ifelse
    }loop
    dup manatsExterns exch known  %% aquest objecte ja te + manats desats?
    {  %% llavors fem creixer l'array, el farcim i el desem a manatsExterns
     dup manatsExterns exch get /aFicar exch def exch /aVeure exch def aFicar dup length 1 add dup 1 sub
     /Dmes exch def array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put dup length array copy
     manatsExterns 3 1 roll put
    }
    {  %% el posem dins una array i el desem a manatsExterns
     exch manatsExterns 3 1 roll 1 array astore put
    }ifelse
   }if
  }ifelse
 }
 {  %% no fem manats
  >>
  /tesTimoni true def  %% cal tornar a crear el testimoni
  /femManats false def  %% gatell x activar o no el darrer operador de tancament del diccionari
  /quantsManats 0 def  %% comptador de manats fets
 }ifelse
} bind def
%%% fi d'implementacio
}if  %% la desactivem?


%%{  % inici de l'stopped

%% redefinicio d' obj i R
%% aqui la descripcio dels bugs esmenats de les versions 1 2 i 3
%% cal incrustar els numerics de /obj i /R en una string fixa de 16 (10+1+5)  (________________) per no generar noms amb espais
%% cal incrustar els numerics de /trailer en una string fixa de 10 (nomes el num del primer objecte)
/obj
{
%%flush  % ¿? neteja?
%% /sAlvAm save def
 %%{  %% stopped optatiu
 %%% ES MOLT IMPORTANT EL FET D'INCRUSTAR ELS GUIONS AMB NullEncode
 %%% PER TAL DE REGENERAR L'STRING CADA VEGADA (composite object!!)
 %%16 string dup /NullEncode filter dup (________________) writestring flushfile  % incrustem 16 guions baixos
 %% i no podem simplificar-ho amb un ...
 (________________) dup length string copy
 /Nom exch def  %% cadena on muntarem la referencia de l'objecte
 exch
%%dup ==  % :-z aqui podem llistar el primer num de l'objecte
 10 string cvs  %% encadenem la primera xifra
 Nom exch 0 exch putinterval  %% l'incrustem a l'inici de Nom
 %%% estrategia per desar els objectes que excepcionalment no tenen un GN=zero
 dup 0 eq
 {  %% objecte amb GN=0
  pop Nom
  15 (0) putinterval  %% incrustem la segona xifra a Nom
 }
 {  %% objecte amb GN<>0
  5 string cvs
  dup Nom  %% encadenem la segona xifra
  exch  %% posem la cadena farcidora a sota
  dup length 16 exch sub  %% en deduim l'index de posicio
  exch putinterval  %% incrustem la segona xifra a Nom
  Nom (_) search pop exch pop exch pop  %% ens preparem per desar els valors a noZero
  exch noZero 3 1 roll put
 }ifelse
 Nom cvn  %% NO convertim la cadena a literal ?
 dup  %% i la deixem a l'stack
 %%test
 %%dup ==
 /xIu exch def  %% guardem el literal
 %%} stopped {(\n\n   ERROR d'estructura a ... obj\n   l'objecte ... ) print Nom print (\n\n) print flush quit} if  % stopped optatiu
} bind def

/R
{
 %%{  %% stopped optatiu
 %% necessitavem treballar com un fitxer per profilaxi?
 %%16 string dup /NullEncode filter dup (________________) writestring closefile  % incrustem 16 guions baixos

%% 16 string /ENCIAi exch def ENCIAi /NullEncode filter /fENCIAi exch def
%% exch 10 string cvs  % encadenem la primera xifra
%% dup length /Gbaixos exch def
%% fENCIAi exch writestring
%% 5 string cvs  % encadenem la segona xifra
%% dup length Gbaixos add 16 exch sub /Gbaixos exch def
%% Gbaixos{fENCIAi (_) writestring}repeat
%% fENCIAi exch writestring fENCIAi closefile
%% ENCIAi cvlit dup type  pstack quit

 %% i no podem simplificar-ho amb un ...
 (_______________0) dup length string copy
 /nOm exch def  %% cadena on muntarem la referencia de l'objecte
 exch 10 string cvs  %% encadenem la primera xifra
 nOm exch 0 exch putinterval  %% l'incrustem a l'inici de Nom
 dup 0 eq
 {
  pop
 }
 {
  5 string cvs  %% encadenem la segona xifra
  nOm exch  %% posem la cadena farcidora a sota
  dup length 16 exch sub  %% en deduim l'index de posicio
  exch putinterval  %% incrustem la segona xifra a Nom
 }ifelse
 nOm cvn  %% NO convertim la cadena a literal? i la deixem a l'stack com a valor d'string (tambe es bo com a clau de diccionari!) x alleugerir l'execucio (hem vist q amb diccionaris amb + de 15mil entrades petava amb un limitcheck)
 %%currentfile flushfile  % neteja? %flush %currentfile closefile  % ¿? neteja?
 %%} stopped {(\n\n   ERROR d'estructura a ... R\n   l'objecte ... ) print Nom print (\n\n) print flush quit} if  % stopped optatiu

 %%% comptador i filtre per fer manats segons aGrupem, doncs combina amb la redefinicio de l'operador de tancament de diccionaris 
 %%counttomark 2 idiv aGrupem eq
 %%{
 %% >>
 %% % aqui es on copiem la clau del diccionari i la cadena de testimoni que diu que ha estat fet a manats ...
 %% % ... tret q ja l'haguem copiat
 %% tesTimoni
 %% {
 %%  1 index 3 1 roll (HeM FeT @ MaNaTS) 3 1 roll  % creem el testimoni
 %%  /tesTimoni false def  % no hem de tornar a crear el testimoni
 %% }if
 %% mark
 %% /femManats true def
 %% quantsManats 1 add /quantsManats exch def
 %%}if

} bind def

%%% test
/endstream
{}bind def
%%% redefinim endstream buit

%% redefinicio d'stream
%% ha de tenir connexio amb el detector de SO
%% p.e. directori TMP existent en tots els Distillers
/pAth tEmp def  % on copiarem els fitxers amb dades "stream"
pAth length /faPath exch def
/stream
{
 %%{  %% stopped optatiu
 %% posem un detector de l'entrada /Length i en el cas que sigui mes petita de 65000
 %% no escriurem l'stream al disc i ho farem en una cadena, d'aquesta manera guanyarem
 %% velocitat (a l'exemple 1366objectes.pdf es 4 vegades+rapid) en fitxers molt grans
 dup /Length known
 {
  dup /Length get dup /fadellarg exch def
  %% si es un obj indirecte, l'eliminem i reescrivim l'entrada Length
  type /nametype eq
  {  %% es un literal (ref. ind. de Length)
   %% llavors posem la ref. ind. de l'objecte (fadellarg) al dic OdeBaixa x eliminar + tard ...
   OdeBaixa fadellarg null put
   %% ... i escrivim a pinyo fix l'stream a disc
   xIu 16 string cvs dup length faPath add string dup /pAthXiU exch def 0 pAth putinterval
   pAthXiU exch faPath exch putinterval  % incrustem el nom del fitxer (xIu) al path
   0  %% valor inicial per calcular el Length exacte
   save  %% imprescindible per la higiene dels fitxers?
   pAthXiU (w) file /scriu exch def  %% fem el fitxer d'escriptura
   currentfile << /EODCount 0 /EODString (endstream) >> /SubFileDecode filter
   {  %% loop
    dup 65535 string readstring
    {
     scriu exch dup length 6 -1 roll add 5 1 roll writestring
    }
    {
     scriu exch dup length
     dup 2 le
     {  %% si l'stream te entre zero i 2 caracters, en descartem l'esquilat
      pop
     }
     {
      dup /faDcadena exch def 6 -1 roll add 5 1 roll
      %% avaluem la cua de les dades x saber si hi ha un 13+10 o un 10
      %% ... o potser un 13
      dup faDcadena 2 sub 2 getinterval dup 1 get 10 eq
      {  %% amb alguna mena de retorn abans d' endstream
       0 get 13 eq
       {  %% amb retorn dur 13+10 abans d' endstream
        %% aqui polim el Length i la darrera cadena a escriure
        5 -1 roll 2 sub 5 1 roll
        0 faDcadena 2 sub getinterval
        %%(amb retorn dur 13+10 abans d' endstream) pstack quit
       }
       {  %% amb line feed 10 abans d' endstream
        %% aqui polim el Length i la darrera cadena a escriure
        5 -1 roll 1 sub 5 1 roll
        0 faDcadena 1 sub getinterval
        %%(amb line feed 10 abans d' endstream) pstack quit
       }ifelse
      }                                                                                                       
      {  %% o amb 13 o sense cap mena de retorn abans d' endstream
       1 get 13 eq
       {
        %% aqui polim el Length i la darrera cadena a escriure
        5 -1 roll 1 sub 5 1 roll
        0 faDcadena 1 sub getinterval
        %%(amb retorn dur 13 abans d' endstream) pstack quit
       }
       {  %% no cal que polim res
        %%(sense cap mena de retorn abans d' endstream) pstack quit
       }ifelse
      }ifelse
     }ifelse
     writestring closefile scriu closefile
     exit
    } ifelse
   } loop  %% escrivim totes les dades d'stream al fitxer (xIu)
   restore  %% imprescindible per la higiene dels fitxers?
   true  %% deixa un true com a detector d'streams a disc per a endobj
   exch
   %% aqui no hi ha avaluador del Length xq no anem a l'objecte indirecte a buscar-lo, doncs l'eliminem directament i el reincrustem un cop calculat al dic
   2 index /Length 3 -1 roll  % repiquem el Length exacte que tenim sumat a l'stack
   put
  }
  {  %% es un enter directe ...
%%   true  % gatell per aplicar una o altra metode de lectura dels streams de dades
%% hauríem de poder implementar un mètode per poder reinterpretar l'stream en cas d'error
   false  %% amb aquesta opció evitem l'efecte de contaminació d'imatges a l'opció 6 de la cosidora
   {  %% METODE PREFERENT: filtrem l'stream pel nombre d'octets declarats a la clau /Length
    fadellarg 65000 le  %% hem obtat per abaixar 535 bytes el maxim doncs hem detectat fitxers
    %% (com Presentaci_n10_pdf.pdf) que duen un error que feia petar l'algorsime a 65535
    %% aqui posant un false i eliminant la linia de dalt, podriem obligar a escriure tots els streams a disc
    %% false
    {  %% NO escrivim a disc: capturem l'stream en una cadena per desar-la directament al diccionari
%%(:-b)pstack quit
     0  %% valor inicial per calcular el Length exacte
%% currentfile << /EODCount 0 /EODString (endstream) >> /SubFileDecode filter
     currentfile << /EODCount fadellarg /EODString () >> /SubFileDecode filter
%%{  % loop
     dup 65535 string readstring
     {  %% aqui donarem un error fatal, doncs a part que el Length segur estara malament
       %%supera el 65535 i descartem repara-lo de forma simple
      (\n\n ... Length incorrecte i excessiu ... ara NO el repararem ... SORTIM!\n\n)
      BaBeL 39 get print flush pstack clear stop  %%quit
%%UBpliegOMaker
     }
     {
      dup length 4 -1 roll add 3 1 roll   %% aqui la activar els sumadors del Length
      /pAthXiU exch def  %% la cadena amb l'stream i Length teoricament exactes
      closefile  %% tanquem el currentfile ara, doncs ja esta esgotat
      %% el tornem a obrir per filtrar possibles errors del Length fins a endstream
      currentfile << /EODCount 0 /EODString (endstream) >> /SubFileDecode filter
      %% aquest valor de cua seria la maxima tolerancia en cas d'error del Length
      dup 65535 string readstring
      {  %% aqui donarem un error fatal, doncs a part que el Length segur estara malament
       %%supera el 65535 i descartem repara-lo de forma simple
       (\n\n ... Length incorrecte i excessiu ... ara NO el repararem ... SORTIM!\n\n)
       BaBeL 39 get print flush pstack clear stop  %%quit
%%UBpliegOMaker
      }
      {
       dup length
       dup 2 le
       {  %% si l'stream te entre zero i 2 caracters, en descartem l'esquilat
%% pero ens cal assegurar que es tracta de caracters d'EOL valids
        pop
       }
       {
%%% ARA ENS CAL BASTIR UN PDF DE TEST AMB LENGTHS INCORRECTES I AVALUAR LA POSSIBILITAT
%%% DE FER MARXA ENRERE AMB EL METODE DE LECTURA, DE fORMA Q PRIMER APLICARIEM EL METODE
%%% DEL Length I SI FALLES APLICARIEM EL DE endstream
%% ens cal avaluar si ens hem passat (+ enlla d'endstream) o ens hem quedat curts (abans d'endstream)
(:-x)pstack quit
        pop dup length 6 sub 5 getinterval (:-X)pstack quit
        dup 5 -1 roll add 4 1 roll
        %% avaluem la cua de les dades x saber si hi ha un 13+10 o un 10
        %% ... o potser un 13
        exch dup 3 -1 roll
        2 sub 2 getinterval dup 1 get 10 eq
        {  %% amb alguna mena de retorn abans d' endstream
         0 get 13 eq
         {  %% amb retorn dur 13+10 abans d' endstream
          %% aqui polim el Length i la darrera cadena a escriure
          3 -1 roll 2 sub dup 4 1 roll
          0 exch getinterval
          %%(amb retorn dur 13+10 abans d' endstream) pstack quit
         }
         {  %% amb line feed 10 abans d' endstream
          %% aqui polim el Length i la darrera cadena a escriure
          3 -1 roll 1 sub dup 4 1 roll
          0 exch getinterval
          %%(amb line feed 10 abans d' endstream) pstack quit
         }ifelse
        }
        {  %% o amb 13 o sense cap mena de retorn abans d' endstream
         1 get 13 eq
         {
          %% aqui polim el Length i la darrera cadena a escriure
          3 -1 roll 1 sub dup 4 1 roll
          0 exch getinterval
          %%(amb retorn dur 13 abans d' endstream) pstack quit
         }
         {  %% no cal que polim res
          %%(sense cap mena de retorn abans d' endstream) pstack quit
         }ifelse
        }ifelse
       }ifelse
       %%avaluem si la cua es un EOL o no
       <<
         (\012) null  %% salt de linia (LF)
         (\015) null  %% retorn de carro (CR)
         (\015\012) null  %% retorn de carro (CR) + salt de linia (LF)
       >>
       1 index known
       {
        pop closefile  %% ens carreguem la cadena i tanquem el currentfile
       }
       {
        % reincrustem la cua que ens ha quedat a la cadena?
        dup length
        (:-F)pstack quit
       }ifelse
      }ifelse  %% tolerancia d'error del lenght
%%       exit
     } ifelse
%%} loop  % escrivim totes les dades d'stream en una cadena i informem si el Length es incorrecte
     dup fadellarg eq
     {  %% te el Length correcte
      pop
     }
     {  %% cal ajustar el Length
      BaBeL 40 get print flush
      1 index exch /Length exch put
     }ifelse
     false  %% deixa un false com a detector d'streams a string per a endobj
    }
    {  %% SI q escrivim a disc
     %% test: treballem fent cas del Length fadellarg
     xIu 16 string cvs dup length faPath add string dup /pAthXiU exch def 0 pAth putinterval
     pAthXiU exch faPath exch putinterval  % incrustem el nom del fitxer (xIu) al path
     0  %% valor inicial per calcular el Length exacte
     save  %% impresindible per la higiene dels fitxers
     pAthXiU (w) file /scriu exch def  %% fem el fitxer d'escriptura
     currentfile << /EODCount fadellarg /EODString () >> /SubFileDecode filter
     {  %% loop
      dup 65535 string readstring
      {
       scriu exch dup length 6 -1 roll add 5 1 roll writestring
      }
      {
       scriu exch dup length 6 -1 roll add 5 1 roll writestring
       closefile  %% tanquem el primer currentfile doncs ja esta esgotat
       %% el tornem a obrir per filtrar possibles errors del Length fins a endstream
       currentfile << /EODCount 0 /EODString (endstream) >> /SubFileDecode filter
       %% aquest valor de cua seria la maxima tolerancia en cas d'error del Length
       65535 string readstring
       %% avaluem la cua de dades fins a endstream
       {  %% aqui donarem un error fatal, doncs a part que el Length segur estara malament
          %% supera el 65535 i no ens deixa repara-lo de forma simple dins una cadena
        (\n\n ... Length incorrecte i excessiu ... ara NO el podem reparar ... SORTIM!\n\n)
        BaBeL 39 get print flush pstack clear stop  %%quit
%%UBpliegOMaker
       }
       {
        scriu exch dup length
        dup 2 le
        {  %% si l'stream te entre zero i 2 caracters, en descartem l'esquilat
         pop
        }
        {
         dup /faDcadena exch def
         5 -1 roll add 4 1 roll
         %% avaluem la cua de les dades x saber si hi ha un 13+10 o un 10
         %% ... o potser un 13
         dup faDcadena 2 sub 2 getinterval
         dup 1 get 10 eq
         {  %% amb alguna mena de retorn abans d' endstream
          0 get 13 eq
          {  %% amb retorn dur 13+10 abans d' endstream
           %% aqui polim el Length i la darrera cadena a escriure
           4 -1 roll 2 sub 4 1 roll
           0 faDcadena 2 sub getinterval
           %%(amb retorn dur 13+10 abans d' endstream) pstack quit
          }
          {  %% amb line feed 10 abans d' endstream
           %% aqui polim el Length i la darrera cadena a escriure
           4 -1 roll 1 sub 4 1 roll
           0 faDcadena 1 sub getinterval
           %%(amb line feed 10 abans d' endstream) pstack quit
          }ifelse
         }
         {  %% o amb 13 o sense cap mena de retorn abans d' endstream
          1 get 13 eq
          {
           %% aqui polim el Length i la darrera cadena a escriure
           4 -1 roll 1 sub 4 1 roll
           0 faDcadena 1 sub getinterval
           %%(amb retorn dur 13 abans d' endstream) pstack quit
          }
          {  %% no cal que polim res
           %%(sense cap mena de retorn abans d' endstream) pstack quit
          }ifelse
         }ifelse
        }ifelse
        %% si aquesta cua no fos zero, donariem el Length com a erroni?
        writestring  %% escrivim la cua de dades q ens ha quedat
        scriu closefile
        exit
       }ifelse
      }ifelse
     } loop  %% escrivim totes les dades d'stream al fitxer (xIu)
     restore  %% impresindible per la higiene dels fitxers
     dup fadellarg eq
     {  %% te el Length correcte
      pop
     }
     {  %% cal ajustar el Length
      BaBeL 40 get print flush
      1 index exch /Length exch put
     }ifelse
     true  %% deixa un true com a detector d'streams a disc per a endobj
    }ifelse  %% escrivim a disc o no
   }
   {  %% filtrem l'stream per la clau endstream final
%%    fadellarg 65000 le  %% hem obtat per abaixar 535 bytes el maxim doncs hem detectat fitxers (com Presentaci_n10_pdf.pdf) que duen un error que feia petar l'algorsime a 65535
    %% aqui posant un false i eliminant la linia de dalt, podriem obligar a escriure tots els streams a disc
    false
    {  %% capturem l'stream en una cadena per desar-la directament al diccionari
     0  %% valor inicial per calcular el Length exacte
     currentfile << /EODCount 0 /EODString (endstream) >> /SubFileDecode filter
     {  %% loop
      dup 65535 string readstring
      {  %% aqui donarem un error fatal, doncs a part que el Length segur estara malament, supera el 65535 i no ens deixa repara-lo de forma simple dins una cadena
       %%(\n\n ... Length incorrecte i excessiu ... ara NO el podem reparar ... SORTIM!\n\n)
       BaBeL 39 get print flush pstack clear stop  %%quit
%%UBpliegOMaker
      }
      {
       dup length
       dup 2 le
       {  %% si l'stream te entre zero i 2 caracters, en descartem l'esquilat
        pop
       }
       {
        dup 5 -1 roll add 4 1 roll
        %% avaluem la cua de les dades x saber si hi ha un 13+10 o un 10
        %% ... o potser un 13
        exch dup 3 -1 roll
        2 sub 2 getinterval dup 1 get 10 eq
        {  %% amb alguna mena de retorn abans d' endstream
         0 get 13 eq
         {  %% amb retorn dur 13+10 abans d' endstream
          %% aqui polim el Length i la darrera cadena a escriure
          3 -1 roll 2 sub dup 4 1 roll
          0 exch getinterval
          %%(amb retorn dur 13+10 abans d' endstream) pstack quit
         }
         {  %% amb line feed 10 abans d' endstream
          %% aqui polim el Length i la darrera cadena a escriure
          3 -1 roll 1 sub dup 4 1 roll
          0 exch getinterval
          %%(amb line feed 10 abans d' endstream) pstack quit
         }ifelse
        }
        {  %% o amb 13 o sense cap mena de retorn abans d' endstream
         1 get 13 eq
         {
          %% aqui polim el Length i la darrera cadena a escriure
          3 -1 roll 1 sub dup 4 1 roll
          0 exch getinterval
          %%(amb retorn dur 13 abans d' endstream) pstack quit
         }
         {  %% no cal que polim res
          %%(sense cap mena de retorn abans d' endstream) pstack quit
         }ifelse
        }ifelse
       }ifelse
       /pAthXiU exch def  %% la cadena amb l'stream i Length exactes
       closefile
       exit
      } ifelse
     } loop  %% escrivim totes les dades d'stream en una cadena i informem si el Length es incorrecte
     dup fadellarg eq
     {  %% te el Length correcte
      pop
     }
     {  %% cal ajustar el Length
      BaBeL 40 get print flush
      1 index exch /Length exch put
     }ifelse
     false  %% deixa un false com a detector d'streams a string per a endobj
    }
    {  %% escrivim l'stream a disc
     xIu 16 string cvs dup length faPath add string dup /pAthXiU exch def 0 pAth putinterval
     pAthXiU exch faPath exch putinterval  %% incrustem el nom del fitxer (xIu) al path
     0  %% valor inicial per calcular el Length exacte
     save  %% impresindible per la higiene dels fitxers
     pAthXiU (w) file /scriu exch def  %% fem el fitxer d'escriptura
     currentfile << /EODCount 0 /EODString (endstream) >> /SubFileDecode filter
     {  %% loop
      dup 65535 string readstring
      {
       scriu exch dup length 6 -1 roll add 5 1 roll writestring
      }
      {
       scriu exch dup length
       dup 2 le
       {  %% si l'stream te entre zero i 2 caracters, en descartem l'esquilat
        pop
       }
       {
        dup /faDcadena exch def
        6 -1 roll add 5 1 roll
        %% avaluem la cua de les dades x saber si hi ha un 13+10 o un 10
        %% ... o potser un 13
        dup faDcadena 2 sub 2 getinterval
        dup 1 get 10 eq
        {  %% amb alguna mena de retorn abans d' endstream
         0 get 13 eq
         {  %% amb retorn dur 13+10 abans d' endstream
          %% aqui polim el Length i la darrera cadena a escriure
          5 -1 roll 2 sub 5 1 roll
          0 faDcadena 2 sub getinterval
          %%(amb retorn dur 13+10 abans d' endstream) pstack quit
         }
         {  %% amb line feed 10 abans d' endstream
          %% aqui polim el Length i la darrera cadena a escriure
          5 -1 roll 1 sub 5 1 roll
          0 faDcadena 1 sub getinterval
          %%(amb line feed 10 abans d' endstream) pstack quit
         }ifelse
        }
        {  %% o amb 13 o sense cap mena de retorn abans d' endstream
         1 get 13 eq
         {
          %% aqui polim el Length i la darrera cadena a escriure
          5 -1 roll 1 sub 5 1 roll
          0 faDcadena 1 sub getinterval
          %%(amb retorn dur 13 abans d' endstream) pstack quit
         }
         {  %% no cal que polim res
          %%(sense cap mena de retorn abans d' endstream) pstack quit
         }ifelse
        }ifelse
       }ifelse
       writestring closefile
       scriu closefile
       exit
      } ifelse
     } loop  %% escrivim totes les dades d'stream al fitxer (xIu)
     restore  %% impresindible per la higiene dels fitxers
     dup fadellarg eq
     {  %% te el Length correcte
      pop
     }
     {  %% cal ajustar el Length
      BaBeL 40 get print flush
      1 index exch /Length exch put
     }ifelse
     true  %% deixa un true com a detector d'streams a disc per a endobj
    }ifelse
   }ifelse
  } ifelse  %% es un literal (ref ind de Length) o un enter directe?
 }
 {
  %%(\n\n >>>> FORMAT ERRONI * Stream sense l'entrada /Length \n\n) print flush
  BaBeL 32 get print flush
  %% informem dels fitxers del tmp
  BaBeL 50 get print flush
  stop  %%quit
%%UBpliegOMaker
 }ifelse
 %%} stopped {(\n\n   >>> ERROR d'estructura a ... stream\n   >>> l'objecte ... ) print Nom print (\n\n) print flush quit} if  % stopped optatiu
}bind def

%% redefinicio d' n
/n
{
 %%{  %% stopped optatiu
 %% convertiem en array cada linia de referencia creuada
 %% /n 3 array astore
 %% exch dup type /integertype eq
 %% {
 %%  array 3 -1 roll 10 string cvs cvn /nomS exch def nomS exch def /iAO 0 def
 %%  nomS cvx exec iAO 3 -1 roll put XREFdict nomS nomS cvx exec put
 %%  iAO 1 add /iAO exch def
 %%  nomS  % deixem el literal a recollir per trailer i donar-lo de baixa mes endavant
 %% }
 %% {
 %%  exch
 %%  XREFdict nomS get dup 3 -1 roll iAO exch put
 %%  XREFdict exch nomS exch put
 %%  iAO 1 add /iAO exch def
 %% }ifelse
 %%% NOVA definicio
 pop pop  %% eliminem els dos digits de l'stack per evitar un possible vessament (500 max)
 %%} stopped {(\n\n   >>> ERROR d'estructura a ... n\n\n) print flush quit} if  % stopped optatiu
} bind def

%% redefinicio d' f
/f
{
 %%{  %% stopped optatiu
 %% /f 3 array astore
 %% exch dup type
 %% /integertype eq
 %% {
 %%  array 3 -1 roll 10 string cvs cvn /nomS exch def nomS exch def /iAO 0 def
 %%  nomS cvx exec iAO 3 -1 roll put XREFdict nomS nomS cvx exec put
 %%  iAO 1 add /iAO exch def
 %%  nomS  % deixem el literal a recollir per trailer i donar-lo de baixa mes endavant
 %% }
 %% {
 %%  exch
 %%  XREFdict nomS get dup 3 -1 roll iAO exch put
 %%  XREFdict exch nomS exch put
 %%  iAO 1 add /iAO exch def
 %% }ifelse
 %%EP% segurament aquest loop de donar de baixa no serveix per a res ... ¿?
 %%% NOVA definicio
 %%R
 %% /iDimoni 0 def
 %%{  % loop de descarrega de possibles objectes donats de baixa pero encara existents
 %% iDimoni 4 string cvs cvn
 %% dup userdict exch known {userdict exch get exch undef exit}{pop pop}ifelse
 %% iDimoni 1 add /iDimoni exch def
 %%} loop  % de descarrega
 pop pop  %% eliminem els dos digits de l'stack per evitar un possible vessament (500 max)
 %%} stopped {(\n\n   >>> ERROR d'estructura a ... f\n\n) print flush quit} if  % stopped optatiu
} bind def

%% redefinicio de trailer
/trailer
{
 %%{  %% stopped optatiu
 %% li donem ara una funcio de recollida de definicions de subseccio que hem de donar de baixa al final de l'execucio de COMdimoni
 %%counttomark array astore exch pop
 %%% NOVA definicio
 cleartomark
 %%} stopped {(\n\n   >>> ERROR d'estructura a ... trailer\n\n) print flush quit} if  % stopped optatiu
} bind def

%% redefinicio d' endobj
%% cal posar un detector de si ha de definir directament el diccionari o abans ha d'incrustar
%% el path del fitxer en una nova entrada (/XIU ?)
/endobj
{
 {  %% stopped preventiu x casos erronis on endobj es repeteix + d'1 cop
  dup type /booleantype eq
  {  %% segons sigui true o false desem ...
   {  %% la cadena amb el path de l'stream a disc dins una array
    dup /XIU pAthXiU 1 array astore put
   }
   {  %% directament la cadena amb les dades del stream
    dup /XIU pAthXiU put
   }ifelse
  } if
  def  %% definim el contingut de l'objecte amb el literal generat per obj
  %%% test x saber quans objectes estem definint al dict comdimoni5
  %%currentdict length ==
  } stopped  %%{(\n\n   >>> ERROR d'estructura a ... endobj\n   >>> l'objecte ... ) print Nom print (\n\n) print flush quit} if  
  {
   (\n\n ... localitzat 'endobj' fora de lloc o sobrer ... \n) print flush  %% avisem que hi ha 'endobj' fora de lloc o sobrers
  }if               
 %%sAlvAm restore
} bind def

%% redefinicio d' startxref
/startxref
{
 %%{  %% stopped optatiu
 %% convertim a string el byte offset que segueix a startxref
 currentfile 128 string readline pop
 %% ep! posem un filtre per evitar possibles espais en blanc o altres caràcters fantasmes al davant
 %% o al final ! (al fitxer 57-A914.pdf d'en Jakob ens pasava això i també al xorrez.pdf)
 cvx exec 32 string cvs
 %% aquí hi ha un altre mètode possiblement +acurat però +lent per filtrar caràcters fantasmes
 %%{
 %% dup length 1 sub /Subur exch def
 %% dup Subur get 32 le  % evitarem tots els caràcters fantasmes com el tab o altres
 %% {0 Subur getinterval}{exit}ifelse
 %%} loop
 cvn  %% convertim a literal el byte offset que segueix a startxref
 %% ObjectStreamProblem
 %% si és un PDF 1.5 o+ amb la compressió Object Streams + Cross-Rererefence Streams activada la
 %% taula l'xref desapareix i l'entrada trailer també i per tant startxref només té a l'stack
 %% el byte offset del nou objecte (/Type /XRef) especial que conté l'xref comprimida, però ara
 %% com que CaLi2CoPi no treballa amb byte offsets haurem de cercar l'objecte per l'entrada única
 %% /Type /XRef
 count 1 eq
 {  %% si té Object Streams incrustem un diccionari buit pel trailer amb la clau del byte offset per
    %% tal de reconstruir el dic trailer convencional des del Cross-Reference Stream més endavant
  tauXref exch <<>> put
 }
 {
  tauXref 3 1 roll exch put  %% incrustem el dic trailer a tauXref amb clau única del byte offset
 } ifelse
 %%} stopped {(\n\n   >>> ERROR d'estructura a ... startxref\n\n) print flush quit} if  % stopped optatiu
} bind def

%% redefinicio d' xref
/xref
{
 %%{  %% stopped optatiu
 %%mark /XREFdict 10 dict def
 %%% NOVA definicio
 mark
 %%} stopped {(\n\n   >>> ERROR d'estructura a ... xref\n\n) print flush quit} if  % stopped optatiu
} bind def  %% marca l'inici de la referencia creuada + diccionari amb els index dels objectes i la linia de byte offsets

%%currentdict {pop ==} forall quit
%% /COMdimoni 10 dict def  % guardarem totes les entrades en aquest diccionari
%% sembla que amb 2000 de capacitat inicial funciona be
%% doncs si no en posavem (<<>>) petava l'aplicacio en alguns PDF complexes
%% COMdimoni begin
%% /tauXref 10 dict def  % creem el diccionari on desarem totes les xref ordenades pel nom del seu byte offset

%%2000000 setvmthreshold
%%currentfile 80 string .peekstring (!) pstack quit
%% execucio de COMdimoni5
%% desfent, desintegrant, ventant, analitzant ...
%%{  % de l'stopped
%% NOU!
%%testVM
-1 vmreclaim  %% superimportant!!!!!!
%%testVM
%%(VM just abans d'executar el PDF i despres de vmreclaim >>>) == vmstatus == == ==
%% fApplet
%% x l'index de noms de COMdimoni
/iDimoni 0 def
%%% NOU! aquestes noves definicions que s'utilitzen a les crides obj les haurem de donar de baixa?
5 dict /noZero exch def  %% diccionari per desar els objectes que excepcionalment no tenen un GN=zero
%%{  % stopped x controlar errors estructurals
 EtEmp2
 {
  dup /QuinTrosPeta exch def  %% desem el nom del tros .obj x si peta
  iDimoni 4 string cvs cvn dup
  10 dict def  %% guardarem totes les entrades en aquest diccionari
  %% sembla que amb 10 de capacitat inicial funciona be
  %% doncs si no en posavem (<<>>) petava l'aplicacio en alguns PDF complexes
  cvx exec begin
  /tauXref 10 dict def  %% creem el diccionari on desarem totes les xref ordenades pel nom del seu byte offset
  (r) file cvx exec
  %% desem els literals de subseccio per donar-los de baixa mes endavant
  count array astore /SubSec exch def
  end
  iDimoni 1 add /iDimoni exch def
 } 256 string filenameforall
%%} stopped

%%(!!!!!!!!!)pstack quit
false

{  %% si hi ha error estructural el cacem aqui ...
 clear
 BaBeL 8 get print flush
 Nom print flush  %% donem el num d'objecte que provoca l'error estructural
 BaBeL 15 get print flush
 %% aqui repiquem a un fitxer els valors que ens interessen de l'error
 $error  %% esborrem les entrades d control d'errors q ara no ens interessa escriure
 dup /dstack undef
 dup /estack undef
 dup /ostack undef
 dup /recordstacks undef
 dup /globalmode undef
 dup /SubstituteFont undef
 dup /.nosetlocal undef
 dup /errorinfo undef
 dup /newerror undef
 dup /.inerror undef
 dup /binary undef
 aFeGeiX dup length dup /iNSeRT exch def nomFITX length add string
 dup 3 -1 roll 0 exch putinterval dup iNSeRT nomFITX putinterval
 dup length dup /iNSeRT exch def 7 add string
 dup 3 -1 roll 0 exch putinterval dup iNSeRT (_ERROR_) putinterval
 dup length dup /iNSeRT exch def 16 add string
 dup 3 -1 roll 0 exch putinterval dup iNSeRT Nom putinterval
 dup length dup /iNSeRT exch def 4 add string
 dup 3 -1 roll 0 exch putinterval dup iNSeRT (.txt) putinterval
 (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
 /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
 QuinTrosPeta ==  %% tros de PDF que peta
 quit  %% aqui no hi pot anar stop, doncs el GS es queda encantat
} if
%%testVM
%%(VM un cop interpretat el PDF >>>) == vmstatus == == ==

%% control de temps
%%usertime Td'ara sub == (hem executat el PDF\n) print flush

%% control de temps
%%usertime /Td'ara exch def

%% descarreguem les definicions no utils al diccionari COMdimoni
%% COMdimoni
%% x l'index de noms de COMdimoni
iDimoni /MaxDimoni exch def  %% sortirem del loop

/iDimoni 0 def
{  %% loop de descarrega de definicions pels dic creats
 currentdict iDimoni 4 string cvs cvn get dup /TrosDic exch def
 
 dup /faDcadena undef
 
 dup /xIu undef
 dup /Nom undef
 dup /nOm undef
 dup /noM undef
 dup /scriu undef
 dup /pAthXiU undef

 dup /nomS undef  %% noves entrades de COMdimoni5 a donar de baixa
 dup /fadellarg undef
 dup /SLngth undef
 dup /iAO undef
 %%% NOU! desactivat
 %%dup /XREFdict undef
 dup /iDimoni undef
 dup /SubSec get
 {  %% forall
  dup type /arraytype eq
  {
   {
    dup TrosDic exch
    known {TrosDic exch undef}{pop}ifelse
   } forall
  }
  {
   pop
  }ifelse
 } forall  %% donem de baixa les definicions de subseccio
 %%dup
 /SubSec undef
 %% /Subur undef  % nou pel filtre dels possibles espais en blanc a la cua de l'startxref
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% de descarrega

iDimoni /MaxDimoni exch def  %% recalculem x sortir del loop

%%% fi d'execucio de comdimoni5

%%% capturem en una altra variable el dic tauXref doncs el donarem de baixa mes
%%% endavant i tambe per saber quants objectes hem de escriure a l'xref
%%% del nou fitxer, i crear un nou diccionari OdeBaixa amb els objectes de baixa (f)
%% COMdimoni
1 dict /TAUxREF exch def  %% la creem buida per desar-hi amb un copy totes les xrefs que hi hagin en els diferents objectes trencats

/iDimoni 0 def
{  %% loop de descàrrega de definicions pels dic creats
 currentdict iDimoni 4 string cvs cvn get
 dup /tauXref known
 {
  /tauXref get dup length
  dict copy TAUxREF copy /TAUxREF exch def  %% afegim a l'existent
 }
 {
  pop
 }ifelse
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% de descàrrega
%%% aviam com es un Font File i si val la pena llegir-lo ...
%%currentdict /0 get /24_____________0 get /XIU get
%%0 () /SubFileDecode filter
%%  <<
%%    /Filter /FlateDecode
%%  >> /ReusableStreamDecode filter
%%65535 string readstring pop (/enfony/CaLi2CoPi/aviamToUnicode.txt) (w) file dup
%%3 -1 roll writestring closefile (:-x)pstack quit

%#%14% anàlisi per validar el PDF
(%#%14%)==
%# primer, mirem si el PDF és encriptat

%% /iDimoni 0 def
%%{  % loop de decarrega de definicions pels dic creats
%% currentdict iDimoni 4 string cvs cvn get

TAUxREF
{  %% forall
 exch pop  %%dup type /dicttype eq
 %% {
 %%  dup /TRaiLeR known
 %%  {
 %%   /TRaiLeR get
 dup /Encrypt known
 {
  /Encrypt get type /nulltype eq
  {  %% te brossa d'encriptats (possiblement l'han passat x un crack)
   {
    BaBeL 20 get print flush
    %% esborrat dels fitxers del tmp
    BaBeL 50 get print flush
%%URLREpublica
%%UBpliegOMaker
    %stop  %%quit
    CRACK ENCRIPTAT  %% de moment abortem l'execucio a sac per tal s'activi el prompt de la interficie web d'errors
   }stopped {stop}if
  }
  {  %% se suposa que els objectes que pengen son vius i x tant l'encriptat es real
   {
    BaBeL 11 get print flush
    %% esborrat dels fitxers del tmp
    BaBeL 50 get print flush
%%URLREpublica
%%UBpliegOMaker
    %  stop
    ENCRIPTAT  %% de moment abortem l'execucio a sac per tal s'activi el prompt de la interficie web d'errors
   }stopped {stop}if

  }ifelse
 }
 {
  pop
 }ifelse
 %%  }{pop} ifelse
 %% }{pop}ifelse
}forall

%% iDimoni 1 add /iDimoni exch def
%% iDimoni MaxDimoni eq {exit} if
%%} loop  % de descarrega

%%% NOU! desactivem
%% valors inicials del ViaMorta
%% /QuiEsAra 0 def

%# segon, ara NO tenim en compte la versió de PDF i mirem sempre si pot tenir la
%# supercompressió d'ObjectStreams activada, doncs la funció d'optimitzar de l'A6
%# permet tenir pdf antics amb la 'compress document structure' posada
%# llavors també hi ha PDF liniaritzats que també la duen (vegeu PDFReference16.pdf)
%# i petaven degut a que la supercompressió no es comprobava abans
%%vPDF  % la versio de PDF
%%cvr 1.3 ge
%%{

%%NO cal doncs tenim TAUxREF /CrossRefStrm <<>> def  %% diccionari per anar-hi afegint tots els objectes /XRef
/Prev+Nou 0 def  %% desarem el núm. d'objecte més nou
/ObjectStrm <<>> def  %% diccionari per anar-hi afegint tots els objectes /ObjStm
%%COMdimoni
/iDimoni 0 def
/OBJstreams false def  %% flag x detectar si ho es
{  %% loop de decàrrega de definicions pels dic creats
 currentdict iDimoni 4 string cvs cvn get
 {  %% forall
  dup type /dicttype eq
  {  %% de moment aturem l'applet si ho es
   dup /Type known
   {  %% ObjectStreamProblem
    dup /Type get dup /ObjStm eq
    {
     pop
%     %% fem una detecció preventiva de la clau Extends x analitzar-ne possibles efectes
%     dup /Extends known
%     {  %% ara no diem re
%      %% (\n\n >>> Aquest diccionari Object Stream duu Extends ...cal estar al cas!\n)
%      %% print flush %quit
%     }if
     ObjectStrm 3 1 roll put  %% hi desem el parell número d'objecte i diccionari del ObjStm
     /OBJstreams true def  %% activem el flag
    }
    {
     %% fem també la cerca exhaustiva a la Cross-Reference Stream amb /Type /XRef
     /XRef eq
     {
      %% si el pdf fos encriptat i amb OBJstreams, al pentinat fet a (%#%14%) no ho hauríem detectat
      dup /Encrypt known
      {  %% se suposa que els objectes que pengen son vius i x tant l'encriptat es real
       BaBeL 11 get print flush
       %% esborrat dels fitxers del tmp
       BaBeL 50 get print flush
       stop  %%quit
      }if
      %% donarem de baixa aquests objectes
      OdeBaixa 3 -1 roll
      dup /araPrev exch def  %% desem el núm. d'objecte
      null put
      %% i només ens mirarem les dades del que dugui /Prev
      dup /Prev known
      {  %% no és el diccionari de la XRef més nova?
       %% ...tret que dugui /Root i el núm d'objecte sigui més actualitzat que el darrer /Prev
       dup /Root known
       {
        araPrev 16 string cvs (_) search pop cvi dup Prev+Nou gt
        {  %% SI que és el diccionari de la XRef més nova (passem de mirar el gen num)
         /Prev+Nou exch def
         pop pop
         TAUxREF exch /99999999 exch put
         /xref+nova 99999999 def
        }
        {  %% segur que no és el diccionari de la XRef més nova
         pop pop pop
        }ifelse
       }
       {  %% segur que no és el diccionari de la XRef més nova
        pop
       }ifelse
      }
      {  %% és el diccionari de la XRef més nova i el desem dins un byte offset teòric per tal sigui segur el darrer
       %% hem de tenir garanties que hi dugui /Root
       dup /Root known
       {
        TAUxREF exch /99999999 exch put
        /xref+nova 99999999 def
       }
       {  %% segur que no és el diccionari de la XRef més nova
        pop
       }ifelse
      }ifelse
     }
     {
      pop pop
     }ifelse
    }ifelse
   }
   {
    pop pop
   }ifelse
  }
  {
   pop pop
  }ifelse
 } forall
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
}loop  %% de descàrrega

%% ObjectStreamProblem
OBJstreams
{
%% descapdellant Object Streams i Cross-Reference Streams
 BaBel 17 get print flush
 /arrel+nova -1 def  %% valor per diagnosticar objectes /Root
 /info+nova -1 def  %% valor per diagnosticar objectes /Info
 /id+nova -1 def  %% valor per diagnosticar objectes /ID
}if

%% {
%%  BaBeL 10 get print flush vPDF print flush (\n) print flush
%% }ifelse
%%}
%%{
%% BaBeL 10 get print flush vPDF print flush (\n) print flush
%%}ifelse

%# tercer, detectem si el PDF està liniaritzat (Fast Web View ~ ús del byte offset )
%% COMdimoni
/LNRZD false def  %% flag unic x detectar si ho es
/iDimoni 0 def
{  %% loop de decarrega de definicions pels dic creats
 currentdict iDimoni 4 string cvs cvn get dup /TrosDic exch def
 /LNRZD_ false def  %% flag x detectar si ho es i l'objecte que te /H esta en el tros que processem
 {  %% forall
  dup type /dicttype eq
  {
   /Linearized known
   {
    /LNRZD true def
    /LNRZD_ true def
    /quinObj exch def
   }
   {
    pop
   }ifelse
  }
  {
   pop pop
  }ifelse
 } forall
 LNRZD_
 {  %% desliniaritzem si ho esta ...
  BaBeL 2 get print flush
  %% posem a la llista de baixa, l'objecte diccionari amb les dades de la liniaritzacio
  %%OdeBaixa quinObj (objecte de baixa) put
  %% capturem els offsets del paquet d'H (hints)
  TrosDic quinObj get dup
  /L get /Loctets exch def  %% bytes exactes del tot fitxer PDF
  /H get dup length 2 eq
  {0 get 1 array astore}{dup 0 get exch 2 get 2 array astore}ifelse
  /elsHints exch def
  %%% NOU! donem de baixa directament l'objecte del diccionari
  TrosDic quinObj undef
 }if
 %%% voleu dir que no podriem sortir del loop un cop ja em trobat l'objecte i el Hints?
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% de descarrega

%% flag x detectar si hi ha brossa de liniaritzacio (fitxers que no estan liniaritzats pero que tenen restes d'objectes que hi estan relacionats)
/Lbrossa true def

%%% aquest algorisme busca el num. d'objecte mes gran de totes les xref
%%% per tal de que podem començar a donar nums als objectes de nova creacio

%%% NOU! ara no caldra cercar quin es el num d'objecte mes gran (ja el deduirem si de cas al reescriure el PDF)
%%% doncs ja no treballem per paquets

%% TAUxREF

%% /8408200 get /TRaiLeR get {== ==} forall quit

%%{ % forall
%% exch pop
%% { % forall
%%  dup type /arraytype eq
%%  {
%%   exch 10 string cvs cvi

%%% algorisme viaMorta
%%% per fer-nos una llista d'objectes donats de baixa al dic OdeBaixa
%%% per tal de no reescriure'n cap en cas que (tot hi amb f) encara existeixi
%% /ndo exch def

%%    {
%%% treu per la pantalleta l'xref
%% dup ==
%%     dup 2 get /f eq
%%     {
%%      1 get ndo exch
%%      pop 0  % substituim el proper gen num de l'objecte de baixa pel zero, doncs segurament sera el gen num original que tenia
%%      R OdeBaixa exch (objecte de baixa) put
%%     }
%%     {

%% si esta liniaritzat mirem si es correcte (bytFITX=Loctets) donc podria NO tenir els Hints Streams que completen la liniaritzacio
LNRZD
{
 bytFITX Loctets eq  %% els octets reals del fitxer coincideixen amb l'entrada /L ?
 {  %% si coincideixen podem donar tranquilament de baixa els objectes corresponents als byte offsets dels Hints
  elsHints dup length 1 eq {0 get 1 array astore}{dup 0 get exch 1 get 2 array astore}ifelse
  {  %%forall
   fApplet (r) file dup 3 -1 roll setfileposition 1024 string readline pop (obj)
   search
   {
    cvx exec R  %% convertim a literal
    /BOhint exch def pop pop
    /Lbrossa false def  %% assegurem que estigui Liniaritzat de veritat
    /iDimoni 0 def
    {  %% loop per donar de baixa els objectes corresponents al byte offset dels Hints
     currentdict iDimoni 4 string cvs cvn get
     dup BOhint known {BOhint undef exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop
   }
   {  %% error de ByteOffset a /H
    pop
    %% cal emetre un MRCT ?
    BaBeL 9 get print flush
    /Lbrossa false def  %% aquest flag permet salpassar errors derivats d'aquest ByteOffset fora de la norma
   }ifelse
  }forall
 }
 {  %% error de ByteOffset a /L
  %% cal emetre un MRCT ?
  BaBeL 5 get print flush
  /Lbrossa false def  %% aquest flag permet salpassar errors derivats d'aquest ByteOffset fora de la norma
 }ifelse
} if

%% TAUxREF {exch pop {== ==} forall} forall 
%% Lbrossa == quit

%%{pop}ifelse
%%     }ifelse
%%     ndo 1 add /ndo exch def 
%%    }forall
%%% fi d'algorisme viaMorta

%%   ndo QuiEsAra gt  % el num d'objecte mes gran de la seccio de l'xref es mes gran ?
%%   {
%%    ndo 1 sub /QuiEsAra exch def
%%   } if
%%  }{pop pop}ifelse
%% }forall
%%} forall
%%% fi de QuiEsAra

%% QuiEsAra pstack quit
%% QuiEsAra 1 add /QuiEsAra exch def
%% OdeBaixa {== ==} forall quit

%% si LNRZD es a true i te errors de ByteOffset posem /LNRZD a false
LNRZD
{
 Lbrossa {/LNRZD false def}if
} if

%# quart, analitzem a fons la versió comparant el valor del cap del PDF
%# amb una possible entrada /Version al /Root de l'xref + nova
%% pesquem el trailer de la darrera xref (la mes nova)
%% tret de si esta liniaritzat que sera la primera de totes (amb valor xref+nova=0)
0 /xref+nova exch def  %% valor inicial de l'xref mes nova

LNRZD not  %% no ho executem si esta liniaritzat (sempre agafara la xref+nova=0)
{
 TAUxREF
 {  %% l'xref mes nova sera la que tingui el literal mes gran numericament
  exch dup 64 string cvs cvi dup xref+nova gt
  {/xref+nova exch def pop pop}{pop pop pop}ifelse
 }forall
} if

%# cinquè, desfem l'ObjectStreamProblem (Cross-Reference Stream + Object Streams)
OBJstreams
{  %% si té Object Streams reconstruïm el dic trailer convencional des Cross-Reference Stream
 [  %% mark per l'array ordenada per byte offsets de diccionaris trailer 
  [  %% mark per l'array ordenada de byte offsets
   TAUxREF {pop 32 string cvs cvx exec}forall
   %% endreça una seqüència numèrica existent a l'stack de menys a més (operador ge) o de més a menys (operador le)
   %% a comptar des de la base de l'stack
   {  %% loop mentre estiguin desordenats
    counttomark 1 sub /iCul exch def
    %% escombrat d'ordenació
    iCul
    {  %% repeat
     iCul index /araCul exch def
     iCul 1 sub index araCul ge  %% ordre d'endreça
     {
      iCul 1 sub /iCul exch def
     }
     {
      iCul -1 roll
      iCul 1 add 1 roll
     }ifelse
    }repeat
    %% mirem si estan per ordre de menys a més (ge)
    %% o de més a menys (le), començant pel cul de l'stack
    /Ordenats true def
    counttomark 1 sub /iCul exch def
    iCul
    {  %% repeat
     iCul index /araCul exch def
     iCul 1 sub index araCul ge  %% ordre d'endreça
     {
      iCul 1 sub /iCul exch def
     }
     {
      /Ordenats false def
      exit
     }ifelse
    }repeat
    Ordenats{exit}if
   }loop
  ]  %% tanquem l'array ordenada de menys a més byte offset

  dup /AOB exch def  %% array ordenada de byte offset

  %% hi posem els diccionaris ordenats pel seu byte offset
  {
   32 string cvs TAUxREF exch get
  }forall
 ]  %% tanquem l'array ordenada de diccionaris trailer

 /hihaXRefStm false def  %% control d'excepció... hybrid-reference file's trailer dictionary

 %% ens cal generar una nova TAUxREF amb només una entrada que tingui com a clau la xref+nova
 %% i com a valor un diccionari amb l'entrada /Root amb arrel+nova
 %% /Info en cas que hi sigui, amb info+nova i /ID en cas que hi sigui, amb id+nova
 dup /AODxB exch def  %% array ordenada de diccionaris per byte offset
 length 1 sub 0 exch 1 exch  %% dades del for per poder tenir controlada la clau /AOB
 {  %% for per l'array ordenada de diccionaris trailer
  dup /iAOB exch def AODxB exch get
  dup /Root known
  {  %% ens quedarem amb l'arrel més nova
   AOB iAOB get /xref+nova exch def
   dup /Root get
   %% filtrem que no hi hagi +d'1 /Root i donem de baixa les més velles
   dup arrel+nova eq
   {
    pop
   }
   {  %% si és diferent, la desada anteriorement serà donada de baixa
    OdeBaixa arrel+nova null put  %% i desem la seva ref ind per donar-lo de baixa
    /arrel+nova exch def  %% desem el literal del Catalog + nou
   }ifelse

%%Aquí hi pot anar el control d'excepció /XRefStm hybrid-reference file's trailer dictionary
%%O fer cas al byte offset teòric de l'xref més nova que ens dirà, en cas d'estar liniaritzat, si cal anar al /99999999
dup /XRefStm known
{
 /hihaXRefStm true def
}if

   dup /Info known
   {
    dup /Info get
    dup info+nova eq
    {
     pop
    }
    {  %% si és diferent, la desada anteriorement serà donada de baixa
     OdeBaixa info+nova null put  %% i desem la seva ref ind per donar-lo de baixa
     /info+nova exch def  %% desem el literal del diccionari /Info més nou
    }ifelse
   }if
   dup /ID known
   {
    /ID get
    dup id+nova eq
    {
     pop
    }
    {  %% si és diferent, la desada anteriorement serà donada de baixa
     OdeBaixa id+nova null put  %% i desem la seva ref ind per donar-lo de baixa
     /id+nova exch def  %% desem l'array /ID més nou
    }ifelse
   }
   {
    pop
   }ifelse
  }
  {  %% si no hi ha /Root no fa falta mirar res més
   pop
  }ifelse
 }for

 %% refem el diccionari trailer amb només les entrades imprescindibles dins una nova TAUxREF
 /TAUxREF
 <<
   xref+nova 10 string cvs cvn  %% possiblement si aquest valor val zero ens serviria també per saber si está liniaritzat
   <<
     arrel+nova -1 eq
     {
      (\n\nError d'estructura: PDF sense Root al trailer!\n\n) print flush stop
     }
     {
      /Root arrel+nova
     }ifelse
     info+nova -1 ne  %% només si hi ha /Info
     {
      /Info info+nova
     }if
     id+nova -1 ne  %% només si hi ha /ID
     {
      /ID id+nova
     }if
   >>
 >> def

 ObjectStrm
 {  %% forall per a cada objecte ObjStm...
  dup /N get /eNa exch def  %% capturem el nombre d'objectes que duu l'ObjStm
  dup /Filter known  %% es comprimit ?
  {
   dup /Filter get /elFiltre exch def /fesFiltre true def /XIU get /objectesAdesxifrar exch def
  }
  {
   /fesFiltre false def /XIU get /objectesAdesxifrar exch def
  }ifelse
  OdeBaixa exch null put  %% donarem de baixa l'objecte ObjStm
  mark  %% topall per desxifrar l'ObjStm
  %% desxifrem
  objectesAdesxifrar
  %% comprovem si l'stream es un path dins una array o una string de dades directe
  dup type /arraytype eq
  {
   %CMapToUnicodeXIU
   0 get (r) file  %% convertim a fitxer des del path sense decodificar
  }
  {  %% convertim a fitxer la cadena sense decodificar
   0 () /SubFileDecode filter
  } ifelse
  <<
    fesFiltre {/Filter elFiltre}if
  >>
  /ReusableStreamDecode filter
  cvx exec  %% els elements desxifrats són a l'stack

  %% aquest loop capgira tots els elements trobats a l'stack mentre n'hi hagi més d'un fins la mark
  counttomark 1 gt
  {
   counttomark /atura't exch def
   /ici 2 def
   {  %% loop
    ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if
   }loop
  }if
  %% afegirem els objectes desenganxats de l'ObjStm cap al dic del darrer tros de PDF
  MaxDimoni 1 sub 4 string cvs userdict exch get /darrerDic exch def
  %% per a cada objecte descrit a l'stack...
  /ARAeNa eNa def
  eNa
  {
   %% farcim el núm. d'objecte dins el literal que serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
   /QuiEsAra exch def
   %% tots els objectes comprimits en un ObjStm tenen obligatòriament gen.num. zero
   (_______________0) dup length string copy  %% profilaxi!
   dup 0 QuiEsAra 10 string cvs putinterval cvn
   exch pop  %% en carreguem el byte offset
   ARAeNa 2 mul -1 roll  %% fem pujar el dic que toca davant del literal del núm. d'objecte
   darrerDic 3 1 roll put  %% desem al diccionari d'objectes
   ARAeNa 1 sub /ARAeNa exch def
  }repeat
  pop  %% ens carreguem la mark
 }forall
}
{  %% NO té ObjStm
 TAUxREF xref+nova 10 string cvs cvn get  %% el dic del trailer + nou
%%{== ==}forall(***********)== quit
 /Root get /arrel+nova exch def  %% n'extraiem el literal del Catalog + nou
}ifelse

%# sisè, cal consultar si és signat un cop treta la compressió d'Object Streams
/iDimoni 0 def
{  %% loop de decarrega de definicions pels dic creats
 currentdict iDimoni 4 string cvs cvn get
 /SIGdig false def  %% flag x detectar si ho es
 {  %% forall
  dup type /dicttype eq
  {  %% de moment aturem l'applet si ho es
   dup /Type known
   {
    /Type get /Sig eq {/SIGdig true def pop}{pop}ifelse
   }
   {
    pop pop
   }ifelse
  }
  {
   pop pop
  }ifelse
 } forall
 SIGdig
 {
  {
   BaBeL 16 get print flush
   %% informem dels fitxers del tmp
   BaBeL 50 get print flush
%%URLREpublica
%%UBpliegOMaker
   %stop  %%quit
   SIGNAT  %% de moment abortem l'execucio a sac per tal s'activi el prompt de la interficie web d'errors
  }stopped {stop}if
 }if
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% de descarrega


/iDimoni 0 def
{  %% loop de cerca entre els dics trencats
 currentdict iDimoni 4 string cvs cvn get
 dup arrel+nova known
 {
  %% al dic del Catalog + nou verifiquem si duu una entrada /Version
  arrel+nova get

  %# setè, detectem l'entrada /Perm que ens indica que l'accés a certs permisos del document és restringit (p.e. omplir camps)
  dup /Perms known
  {
   {
    BaBeL 16 get print flush
    %% informem dels fitxers del tmp
    BaBeL 50 get print flush
%%URLREpublica
%%UBpliegOMaker
    %stop  %%quit
    SIGNAT  %% de moment abortem l'execucio a sac per tal s'activi el prompt de la interficie web d'errors
   }stopped {stop}if
  }if

  %% posem l'interrogador d'execucions dels gatells de CaLi2CoPi
  dup /PieceInfo known  %% ja existeix aquest diccionari?
  {
   dup /PieceInfo get
   %% tret que sigui una referència indirecta
   dup type /nametype eq
   {
    /laBranca exch def
    %% pesquem la branca ...
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup laBranca known {laBranca get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% d'interrogacio dels dicts de COMdimoni
   }if
   dup /MRCT_CaLi2CoPi known
   {  %% ja l'hem tractat amb CaLi2CoPi
    /MRCT_CaLi2CoPi get /Private get  %% paquet d'execucions i gatells
    {
     QueLiFemFer eq
     {
      [  %% paquet de comportaments si es donen coincidències
       %% això ens portarà a poder posar un filtre al principi per avaluar si ens interessa
       %% continuar executant determinats PDF que ja s'han tractat amb CaLi2CoPi i/o s'hi s'han
       %% d'activar determinats protocols de neteja d'informació (eliminat de capes, continguts
       %% de pàgina entre BDC EMC, anotacions, bookmarks, etc)
       null  %% 0
       null  %% 1
       null  %% 2
       null  %% 3
       null  %% 4
       null  %% 5
       null  %% 6
       null  %% 7
       {
        (\n\n >>>> no podem tractar dues vegades un PDF amb el gatell 8 de CaLi2CoPi <<<<\n\n\n) print flush stop
       }  %% 8
       null  %% 9
       null  %% 10
       null  %% 11
       {
        (\n\n >>>> no podem tractar dues vegades un PDF amb el gatell 12 de CaLi2CoPi <<<<\n\n\n) print flush stop
       }  %% 12
       null  %% 13
       null  %% 14
       null  %% 15
       null  %% 16
       null  %% 17
      ]
      QueLiFemFer get cvx exec
      exit  %% sortim del forall
     }if
    }forall  %% el gatell actual coincideix amb alguna de les execucions anteriors?
   }
   {  %% si no existeix MRCT_CaLi2CoPi es que no s'ha executat mai una versió recent de CaLi2CoPi (.037 03.2010)
    pop
   }ifelse
  }if  %% si no existeix PieceInfo es que no s'ha executat mai una versió recent de CaLi2CoPi (.037 03.2010)

  %%killMetadata+InfoVell+ObjectesLength% ens carreguem l'objecte Metadata a sac (l'XML)
  dup /Metadata known
  {
   dup /Metadata get
   OdeBaixa exch /Metadata put  %% posem el literal de la ref ind de l'objecte al diccionari de matar objectes
   dup /Metadata undef  %% ... i matem l'entrada al Catalog
  }if
  %%% fi
  dup /Version known
  {
   /Version get 5 string cvs cvr dup vPDF cvr gt
   {  %% sempre que sigui mes nova que la del cap, l'actualitzarem
    5 string cvs /vPDF exch def
   }
   {
    pop
   }ifelse
  }
  {
   pop
  }ifelse
  exit
 }
 {
  pop
 }ifelse
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% de cerca

%%% vuitè, treiem x la pantalleta la versio del PDF
BaBeL 10 get print flush vPDF print flush (\n) print flush

%%killMetadata+InfoVell+ObjectesLength

%#%14bis% esborrem de COMdimoni l'objecte Metadata a donar de baixa +InfoVell (en cas que sigui una ref ind) i els objectes que duen el valor Length dels streams
(%#%14bis%)==
/iDimoni 0 def
{  %% loop de descarrega de definicions pels dic creats
 OdeBaixa
 {
  pop
  currentdict iDimoni 4 string cvs cvn get
  exch undef
 } forall
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% de descarrega

%% control de temps
%%usertime Td'ara sub == (gestio d'objectes i baixes\n) print flush

%% control de temps
%%usertime /Td'ara exch def

%#%15% definim una variable pel final de línia EOL, així podrem variar-la quan interessi
(%#%15%)==
[
 (\012)		%% 0 salt de linia (LF) 10 decimal
 (\015)		%% 1 retorn de carro (CR) 13 decimal
 (\015\012)	%% 2 retorn de carro (CR) + salt de linia (LF)
] 2 get /EOL exch def  %% aquest EOL ha de ser obligatori amb 2 caracters? (creiem que no)

%#%16% loop recursiu entre diccionaris x eliminar duplicats d'objectes
(%#%16%)==
BaBeL 19 get print flush
/iDimoni 0 def
{  %% loop on mirem de forma ascendent, objecte x objecte, els diccionaris trencats del PDF
 currentdict iDimoni 4 string cvs cvn get
 {  %% forall x tots els objectes del dic actual
  iDimoni 1 add /iDimoni2 exch def  %% per observar els dics de sobre
  iDimoni2 1 add MaxDimoni gt {pop pop exit} if  %% pleguem si hem superat MaxDimoni
  pop /obBesso exch def  %% nom de l'objecte x cercar-ne el seu besso
  {
   currentdict iDimoni2 4 string cvs cvn get
   %% si el trobem mes amunt, eliminem l'objecte besso al dic mes antic
   obBesso known
   {
    currentdict iDimoni 4 string cvs cvn get obBesso undef exit
   }
   {
    iDimoni2 1 add /iDimoni2 exch def
   }ifelse
   iDimoni2 MaxDimoni eq {exit} if
  } loop
 } forall
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% x eliminar objectes duplicats

%% /Salva'm save def  %% anellat important x poder eliminar els fitxers al final

%#%17% generem el diccionari XRay per tal de desar les dades d'anàlisi del PDF
%# tant per l'escriptura del TXT com per consultes a fer en determinats moments
%# modificarem progressivament aquests continguts xq quedin endreçats a cada pàgina
(%#%17%)==
/XRay
<<
  /PeDeEfa
  <<
    /V vPDF  %% versio de PDF
    /O globaldict /objPDF get  %% pesquem el nombre intern d'objectes
    /Errades
    <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors
    >>  %% diccionari on descriurem els errors i els objectes que els produeixen
%%    /EP
%%    <<  % si el diccionari es buit voldra dir que no hi hauran hagut WARNINGS
%%    >>  % diccionari on descriurem els WARNINGS i els objectes que els produeixen (ara nomes fet servir x errors d'arees)
  >>
  /Lleixes
  <<  %% si el dic es buit es que no n'hi ha
    /nomIE << >>  %% diccionari amb els parells /NumObj [NomIntern NomExtern FetaServir? PrintState iOCGs [ordinal de pàgina] ]
    /Unicode false  %% les cadenes de text son en unicode?
    /NoHeEscrit
    <<  %% si el diccionari es buit voldra dir que no hi hauran hagut incidencies en l'escriptura
    >>  %% diccionari on escriurem els noms dels caracters (com a clau) que no hem pogut escriure i com a valor hi haura un diccionari que contindra una entrada pel seu codi (1/2 bytes) i a quina taula ha fallat (PDF o Win)
    /Errades
    <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors
    >>  %% diccionari on descriurem els errors i els objectes que els produeixen /NumObj (text de l'error)
    /Desconegudes
    <<  %% diccionari on primer desarem el nom intern de les layers utilitzades a l'stream dels Contents i despres mentre comprovem si estan definides a nomIE les anirem donant de baixa ...
    >>  %% de forma que si el dic no queda buit voldra dir que hi ha Layers desconegudes no definides
    /Buides
    << >>  %% diccionari on desarem els noms de les Lleixes absolutament buides i que llistarem com a WARNING:EmptyLayer
  >>
  /Separacions
  <<  %% si el dic es buit es que no n'hi ha
      %% hi desarem directament els noms en parells extern/intern
  >>
  /EstatsGrafics
  <<  %% si el dic es buit es que no n'hi ha
    /Desconeguts
    <<  %% diccionari on primer desarem el nom dels estats grafics utilitzats a l'stream dels Contents i despres a partir del ExtGState dic de Resources anirem donant de baixa els que hi coincideixin ...
    >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Estats Grafics desconeguts no definits a Resources
    /Utilitzats << >>
    /NoUtilitzats << >>
    /Errades
    <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors
    >>  %% diccionari on descriurem els errors i els objectes que els produeixen
  >>
  /EspaisDeColor
  <<  %% si el dic es buit es que no n'hi ha
    /Desconeguts
    <<  %% diccionari on primer desarem el nom dels espais de color utilitzats a l'stream dels Contents i despres a partir del ColorSpace dic de Resources anirem donant de baixa els que hi coincideixin ...
    >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Estats Grafics desconeguts no definits a Resources
    /Utilitzats << >>
    /NoUtilitzats << >>
    /Errades
    <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als espais de color (tant el directe com l'alternatiu)
    >>  %% diccionari on descriurem els errors amb el nom dels espais de color que els produeixen ... /NomInternEspaiColor (text de l'error)
    /TintesiValors
    <<  %% diccionari on descriurem tots els noms diferents de les tintes (colors) que intervenen i els seus valors perceptuals (valors 0/1)
    >>  %% aquesta informacio sera la guia (resultara clau) per fer la Separacio de colors (tintes)
    /Removed << >>  %% diccionari on escriurem les Tintes CMYK que donarem de baixa a TintesiValors segons el criteri de comportament de les separacions provinents de /All
  >>
  /ObjectesX
  <<  %% cal que hi fiquem els contiguts per defecte ara?
  /1  %% iniciem la politica de dades endreçades plana a plana
  <<
    %% deixem de forma fixa el diccionari trEncAclOsqUEs d'analisi de les imatges segmentades
    /trEncAclOsqUEs <<>>
    /Desconeguts
    <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
    >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
    /Utilitzats << >>
    /NoUtilitzats << >>
    /Errades
    <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
    >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
  >>
  >>
  /Patterns&Shadings
  <<  %% de moment farem servir la mateixa estrategia que els XObjects
      %% si el dic es buit es que no n'hi ha
    /Desconeguts
    <<  %% diccionari on primer desarem el nom dels Patterns utilitzats a l'stream dels Contents i despres a partir del ... anirem donant de baixa els que hi coincideixin ...
    >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Patterns desconeguts no definits a ...
    /Utilitzats << >>
    /NoUtilitzats << >>
    /Errades
    <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Patterns
    >>  %% diccionari on descriurem els errors amb el nom dels Patterns que els produeixen ...
  >>
>> def
%% fi del diccionari XRay

%#%18% capturem ara el /Root + nou
(%#%18%)==
0 /xref+nova exch def  %% valor inicial de l'xref mes nova
LNRZD not  %% no ho executem si esta liniaritzat (sempre agafara la xref+nova=0)
OBJstreams %% no ho executem si NO duu ObjectStreams
%% {hihaXRefStm}if  %% l'excepció dels ObjectStreams amb XRefStm pot influir? hybrid-reference file's trailer dictionary
or  %% només s'executa si NO està liniaritzat o duu ObjectStreams o ambdues coses
{
 TAUxREF
 {  %% l'xref mes nova sera la que tingui el literal mes gran numericament
  exch dup 10 string cvs cvi dup xref+nova gt
  {/xref+nova exch def pop pop}{pop pop pop}ifelse
 }forall
} if
TAUxREF xref+nova 10 string cvs cvn get

%% ara de moment nomes modificarem el dic Info si existeix (si no existeix el crearem + avall)
dup /Info known
{
 dup /Info get  %% se suposa es una referencia indirecte?
 dup type /nametype eq
 {  %% si
  /aCercar exch def
  %% pesquem el dic Info ...
  /iDimoni 0 def
  {  %% loop d'interrogacio dels dicts de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   dup aCercar known
   {
    aCercar get dup /elDicInfo exch def

    %% control temporal i exclusiu de JBC per evitar execucions amb versions molt anteriors
%%    QueLiFemFer 8 eq
%%    {
%%     dup /Producer get (CaLi2CoPi) search
%% (:-+)pstack quit
%%      (\n\n >>>> no podem tractar dues vegades un PDF amb el gatell 8 de CaLi2CoPi <<<<\n\n\n)
%%    }if

    %%dup
    /Producer
    %% (GNU AGPL FemFum CaLi2CoPi ¸.·´¯`·.¸.·´¨«~)  %% WinAnsi no es veu bé als nous Viewers
    %% en Unicode per tal que funcioni bé amb tots els sistemes
    <feff0047004e00550020004100470050004c002000460065006d00460075006d002000430061004c006900320043006f00500069002000b8002e00b700b400af006000b7002e00b8002e00b700b400a800ab007e>
    put
    %% /Subject (Tint Separation) put
    exit
   }
   {
    pop
   }ifelse 
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% d'interrogacio dels dicts de COMdimoni  
 }
 {  %% encara que seria molt estrany que fos un dic directe ...
  dup /elDicInfo exch def
  %%dup
  /Producer  %% (GNU AGPL FemFum CaLi2CoPi ¸.·´¯`·.¸.·´¨«~)  %% WinAnsi no es veu bé als nous Viewers
  %% en Unicode per tal que funcioni bé amb tots els sistemes
  <feff0047004e00550020004100470050004c002000460065006d00460075006d002000430061004c006900320043006f00500069002000b8002e00b700b400af006000b7002e00b8002e00b700b400a800ab007e>
  put
  %% /Subject (Tint Separation) put
 } ifelse
}
{
 /elDicInfo null def  %% si no existeix hi posem un null x si volem crear-lo al loop de separacions del final
}ifelse
%% fi de modificacio del DocInfo

%% de l'xref mes nova pesquem Root
/Root get
/CtLg exch def  %% el Root + nou
null /l'arrel exch def  %% valor inicial per detectar casos en que no hi hagi /Pages

%% pesquem l'arrel /Pages del document
/iDimoni 0 def
{  %% loop d'interrogacio dels dicts de COMdimoni
 currentdict iDimoni 4 string cvs cvn get
 dup CtLg known {CtLg get /Pages get /l'arrel exch def exit}{pop}ifelse
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% d'interrogacio dels dicts de COMdimoni

%% no hem trobat l'arrel /Pages !
l'arrel null eq
{
 BaBeL 18 get print flush
 %% informem dels fitxers del tmp
 BaBeL 50 get print flush
 clear stop  %%quit
%%UBpliegOMaker
}if

%#%19% desem l'arbre de pàgines del document dins el diccionari quinaPlana
%# escrivim l'arbre de pàgines de forma ordenada per la seva numeració
(%#%19%)==

%% d'on ve tota aquesta merda !!!!!!!!
%%clear

/elPagesNOESFA <<>> dup l'arrel null put def  %% hi desarem totes les ref ind (hi posarem un valor null) dels objectes /Pages
/quinaPlana <<>> def  %% diccionari on guardarem Num. Pagina / Clau de Pagina
/cntpa 0 def  %% valor inicial del compta pagines

%% pesquem el dict arrel de /Pages
/iDimoni 0 def
{  %% loop d'interrogacio dels dicts de COMdimoni
 currentdict iDimoni 4 string cvs cvn get
 %% el diccionari de l'objecte /Pages arrel
 dup l'arrel known {l'arrel get exit}{pop}ifelse
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% d'interrogacio dels dicts de COMdimoni

/Kids get  %% l'array de fills obligatoria
dup type /nametype eq
{
 /laBranca exch def
 %% pesquem la branca ...
 /iDimoni 0 def
 {  %% loop d'interrogacio dels dicts de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  %% el diccionari de l'objecte
  dup laBranca known {laBranca get exit}{pop}ifelse
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq {exit} if
 }loop  %% d'interrogacio dels dicts de COMdimoni
}if
aload pop
%% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
count dup 1 eq
{
 pop
}  %% tret de que nomes n'hi hagi 1
{
 /atura't exch def /ici 2 def
 {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
} ifelse

{  %% loop d'espia_PagesTree_2.ps
 count 0 eq {exit} if
 {  %% loop
  count 0 ne
  {
   dup type /marktype eq {pop}{exit} ifelse
  }
  {
   exit
  }ifelse
 } loop  %% elimina les marques d'inici d'array
 count 0 eq {exit} if
 %%dup COMdimoni exch get  % el diccionari de l'objecte
 dup /laBranca exch def
 %% pesquem la branca ...
 /iDimoni 0 def
 {  %% loop d'interrogacio dels dicts de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  %% el diccionari de l'objecte
  dup laBranca known {laBranca get exit}{pop}ifelse 
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq {exit} if
 } loop  %% d'interrogacio dels dicts de COMdimoni
 %% (:::) pstack quit  % aqui cal servir el loop de dics de COMdimoni amb una variable
 dup
 dup /Type known
 {  %% nou per controlar pagines (/Pages) que no porten la clau /Type (no Linearized)
  /Type get dup /Pages eq
 }
 {
  dup /Kids known {true}{false}ifelse
 } ifelse  %% nou per controlar pagines (/Pages) que no porten la clau /Type (en fitxers no optimitzats)
 {  %% ifelse
  elPagesNOESFA laBranca null put  %% hi desem la ref ind del objecte /Pages
  %% son Pages
  pop exch pop
  /Kids get
  mark exch aload pop
  %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
  counttomark dup 1 eq
  {
   pop
  }  %% tret de que nomes n'hi hagi 1
  {
   /atura't exch def /ici 2 def
   {
    ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if
   } loop
  } ifelse
  {  %% loop #
   count 0 eq {exit} if
   {  %% loop
    count 0 ne
    {
     dup type /marktype eq {pop}{exit} ifelse
    }
    {
     exit
    }ifelse
   } loop  %% elimina les marques d'inici d'array
   count 0 eq {exit} if
   %%dup COMdimoni exch get
   dup /laBranca exch def
   %% pesquem la branca ...
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup laBranca known {laBranca get exit}{pop}ifelse 
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
   dup
   dup /Type known
   {  %% nou per controlar pagines (/Pages) que no porten la clau /Type (no Linearized)
    /Type get dup
    /Pages eq
   }
   {
    dup /Kids known {true}{false}ifelse
   } ifelse  %% nou per controlar pagines (/Pages) que no porten la clau /Type (en fitxers no optimitzats)
   {  %% son Pages
    pop exch pop
    /Kids get  %% posem l'array a l'stack per la seguent volta de loop
    mark exch aload pop
    %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
    counttomark dup 1 eq
    {
     pop
    }  %% tret de que nomes n'hi hagi 1
    {
     /atura't exch def /ici 2 def
     {
      ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if
     } loop
    } ifelse
   }
   { %% son Pagines
    pop pop  %% ens carreguem el diccionari de la pagina
    cntpa 1 add /cntpa exch def  %% cntpa 5 string cvs show
    quinaPlana exch cntpa 5 string cvs cvn exch put  %% afegim el parell Num. Pagina / Clau de Pagina
    count 0 eq {exit} if
    {  %% loop
     count 0 ne
     {
      dup type /marktype eq {pop}{exit} ifelse
     }
     {
      exit
     }ifelse
    } loop  %% elimina les marques d'inici d'array
    exit
   } ifelse
   count 0 eq {exit} if
   {  %% loop
    count 0 ne
    {
     dup type /marktype eq {pop}{exit} ifelse
    }
    {
     exit
    }ifelse
   } loop  %% elimina les marques d'inici d'array
  } loop  %% fi de loop #
  count 0 eq {exit} if
  {  %% loop
   count 0 ne
   {
    dup type /marktype eq {pop}{exit} ifelse
   }
   {
    exit
   }ifelse
  } loop  %% elimina les marques d'inici d'array
 }
 {  %% son Pagines
  pop pop  %% ens carreguem el diccionari de la pagina
  cntpa 1 add /cntpa exch def  %%cntpa 5 string cvs show
  quinaPlana exch cntpa 5 string cvs cvn exch put  %% afegim el parell Num. Pagina / Clau de Pagina
  count 0 eq {exit} if
  {  %% loop
   count 0 ne
   {
    dup type /marktype eq {pop}{exit} ifelse
   }
   {
    exit
   }ifelse
  } loop  %% elimina les marques d'inici d'array
 } ifelse
 count 0 eq {exit} if
 {  %% loop
  count 0 ne
  {
   dup type /marktype eq {pop}{exit} ifelse
  }
  {
   exit
  }ifelse
 }loop  %% elimina les marques d'inici d'array acomulades
}loop  %% fi d'espia_PagesTree_2.ps

quinaPlana length /maxPlana exch def  %% nombre de pagines del document o darrer numero de plana

QueLiFemFer 14 eq  %:014 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
{
 %% cerquem al PDF d'entrada el tram numèric únic provinent de la variable d'interfície $ETSunic
 %% per tal de construir l'array de fitxers restauraJPEGs
 nomFITX (_) search  %% hem de cercar el segon tram despres del primer underscore
 pop pop pop (_) search  %% per extraure el segon numeric que duu el valor únic idèntic al JPEG
 {
  /ETSunic exch def  %% aquest numèric ens identificarà tots els JPEGs a restaurar
  pop pop
  ETSunic
  {  %% però és realment un numèric?
   dup 48 ge exch 57 le and not
   {  %% el nom no és normatiu per poder continuar cercant els JPEGs
    == BaBeL 47 get print flush stop
   }if
  }forall

  %% ara cerquem tots els fitxers al mateix directori del PDF resultant amb l'escarràs ETSunic*.jpg
  aFeGeiX  %% desempalleguem el nom del fitxer del path d'aterratge del PDF resultant
  {
   bUsca search
   {pop pop}{exit}ifelse
  }loop
  aFeGeiX length exch length sub aFeGeiX exch 0 exch getinterval dup length dup dup /vaETS exch def
  ETSunic length add /vaESC exch def ETSunic length add 5 add string dup 3 -1 roll 0 exch
  putinterval dup vaETS ETSunic putinterval dup vaESC (*.jpg) putinterval

%%  ETSunic search pop dup length dup /vaETS exch def 2 index length dup vaETS add
%%  /vaESC exch def add 5 add string dup 3 -1 roll 0 exch putinterval dup 3 -1 roll vaETS exch
%%  putinterval dup vaESC (*.jpg) putinterval  %% aquí tenim muntada la cadena de cerca
%%  exch pop  %% sobrer de la cerca

  maxPlana array /restauraJPEGs exch def  %% magatzem de JPEGs a restaurar indexats per pàgina
  /hihaJPEG 0 def  %% gatell per assegurar-nos que hem trobat almenys 1 fitxer

  {  %% proc del filenameforall
   hihaJPEG 1 add /hihaJPEG exch def  %% comptador de fitxers trobats
   dup
   %% desempalleguem el nom del fitxer del path
   {
    bUsca search
    {pop pop}{exit}ifelse
   }loop
   (_) search pop pop pop (.jpg) search pop exch pop exch pop  %% cerquem l'índex ...
   cvx exec 1 sub exch restauraJPEGs 3 1 roll
   dup length string copy  %% ho necessitem per profilaxi
   put  %% ... on desar el path del JPEG a restauraJPEGs
  }
  1024 string filenameforall
  hihaJPEG 0 eq
  {  %% si no hem trobat res, pleguem
   BaBeL 48 get print flush stop
  }
  {  %% listem quants JPEGs hem localitzat
   (\n ... localitzats ... ) print flush hihaJPEG 5 string cvs print flush
   ( ... JPEGs per restaurar a la capa d'imatge d'aquest PDF\n) print flush
  }ifelse
 }
 {  %% el nom no és normatiu per poder continuar cercant els JPEGs
  == BaBeL 47 get print flush stop 
 }ifelse
 %% clonem amb profilaxi per poder crear els nous objectes XObject
 restauraJPEGs dup length array copy /JPEGsXObject exch def
}if  %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13

QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
{
 %% excedim el nombre de pagines permes (ara 1) per la separacio de colors ?
 maxPlana 1 gt
 {
%#%19bis0% detector de si hi ha més d'1 pàgina per la separació de colors
(%#%19bis0%)==
  XRay /PeDeEfa get /Errades get /Pages ( Exceed the maximum allowed) put
  BaBeL 38 get print flush
  (\n\n) print flush stop  %%quit
%%UBpliegOMaker
 } if
}if  %/01 SEPARACIÓ DE TINTES

%%%CALi2COPi%%% fi de desat de l'arbre de pagines dins quinaPlana

%%% a3copiseny ... DESACTIVEM XRAY
%%false {

%%19bis1% escrivim la primera part d'XRay                 
BaBeL 30 get print flush
(%#%19bis1%)==
FitxerXRay
%% haurem de treure aquesta linia quan el 6Q ens deixi el dir de la DLL pelat (amb el / final) sense Info
%%dup length 4 sub 0 exch getinterval
%% l'XRay ara sempre el farem de tot el PDF
dup length dup /iNSeRT exch def
nomFITX dup length string copy
%% filtrem possibles caracter indesitjables per _ (95)
/dena exch def  %% cadena a filtrar
/idena 0 def  %% index de caracters
/Mai  %% (*? .:,;/\\) eren els q filtravem abans
( .,;:?*#!§$%&/\(\){}<>=`´|\\'") def  %% els caracters indesitjables (els fem quadrar amb filtrat d'executal.php)
dena
{  %% forall
 /SiMai false def
 /A_ exch def Mai
 {  %% forall
  A_ eq {/SiMai true def exit}if
 }forall
 SiMai {dena idena 95 put}if
 idena 1 add /idena exch def
}forall
dena
length add dup /iNSeRT2 exch def 9 add
string dup 3 -1 roll 0 exch putinterval
dup iNSeRT dena putinterval
dup iNSeRT2 (_XRay.txt) putinterval
/FitxerXRay exch def
FitxerXRay (w) file dup /wFitxerXRay exch def
(Preview:) writestring
[
 {  %% 0 (repica el fitxer de forma 'intacte')
  wFitxerXRay (Identity\015\012) writestring
 }
 {  %% 1 (separacio de colors --projecte WebProof--)
  wFitxerXRay (Tint Separations\015\012) writestring
 }
 {  %% 2 (posa creus de tall)
  wFitxerXRay (Registration Marks\015\012) writestring
 }
 {  %% 3 (corrector tipografic de la Ela Geminada)
  wFitxerXRay (Ghyph Correction\015\012) writestring
 }
 {  %% 4 (dada variable)
  wFitxerXRay (Merging\015\012) writestring
 }
 {  %% 5 (desfa o suma pagines)
  wFitxerXRay (Attach or Detach Pages\015\012) writestring
 }
 {  %% 6 (relliga imatges --projecte A3copiseny--)
  wFitxerXRay (Stich Images\015\012) writestring
 }
 {  %% 7 (farceix imatges previament exportades --projecte A3copiseny--)
  wFitxerXRay (Embeds Exported Images\015\012) writestring
 }
 {  %% 8 (etiqueta text)
  wFitxerXRay (tagging text\015\012) writestring
 }
 {  %% 9 (exportador d'imatges segons convencio d'A3copiseny)
  wFitxerXRay (export JPEG images\015\012) writestring
 }
 {  %% 10 (verificador de PDF)
  wFitxerXRay (PDF preflight\015\012) writestring
 }
 {
 }  %% 11 (torsimany)
 {  %% 12 (arbre jeràrquic --projecte Polynorma--)
  wFitxerXRay (bookmarks tree\015\012) writestring
 }
 {  %% 13 (eliminem continguts de pàgina)
  wFitxerXRay (cleaning page contents\015\012) writestring
 }
 {  %% 14 (restaura les capes d'imatge rasteritzades per CaLi2CoPi 13)
  wFitxerXRay (restoring layers with CaLi2CoPi 13 raster images\015\012) writestring
 }
 {  %% 15 elimina lleixes --continguts i arbre-- pel seu índex intern, projecte MASATS
  wFitxerXRay (erase layers --contents and tree-- via internal index\015\012) writestring
 }
 {  %% 16 cerca i substitució de text en unes condicons concretes, projecte MASATS
  wFitxerXRay (search and replace text on particular context\015\012) writestring
 }
 {  %% 17 %%MASATSencvlct encavalca tots els continguts de pàgina del document, per ordre, damunt la primera de totes 
  wFitxerXRay (overlaps the whole Page Contents, sequentially, over the first one\015\012) writestring
 }
] QueLiFemFer get cvx exec  %% opcio del menu de capçalera
wFitxerXRay dup (PDF:name:) writestring nomFITX writestring
wFitxerXRay dup (\015\012PDF:version:) writestring vPDF writestring
wFitxerXRay dup (\015\012PDF:pages:) writestring maxPlana 7 string cvs writestring

%%Hackovid
/iPmaker 0 def  %% índex per l'array de pàgines
/aPmaker 0 array def  %% array amb els MediaBox o CropBox de cadascuna de les pàgines

%% aqui escriurem tots els Bbox definits
/araPlana 1 def  %% valor inicial del ventador de pagines
{  %% loop explorador d'arees pagina a pagina
 quinaPlana araPlana 12 string cvs
 dup XRay /PeDeEfa get exch 5 dict put  %% incrustem un dict descriptiu x pagina (ara nomes hi posarem les 5 possibles arees)
 get /actGina exch def  %% extraiem la ref ind de la primera pagina
 /iDimoni 0 def
 {  %% loop d'interrogacio dels dicts de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  %% el diccionari de l'objecte
  dup actGina known {actGina get exit}{pop}ifelse 
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq {exit} if
 } loop  %% d'interrogacio dels dicts de COMdimoni
 %% del dic de la plana interroguem totes les possibles arees Bbox que hi poden haver
 dup

%%REpublica esborrem a sac tots els CropBox
dup /CropBox undef

 /sOrtim false def
 /hihaParent false def
 {  %% loop que va pujant mentre hi hagi Parent i no hi hagi MediaBox (fins l'arrel /Pages)
  /MediaBox known
  {
   dup /MediaBox get
   %% Ampliem el MediaBox de llUm punts x banda (30 punts x la meitat de les creus), total llUmx2 punts d'X i llUmx2 punts d'Y
   QueLiFemFer 2 eq  %:02 MARQUES DE TALL
   {  %% modifiquem tambe a l'XRay
    %#%19bis2% definim un format de pàgina per defecte (ara A4 vertical)
    (%#%19bis2%)==
    /paginaXdefecte [0 0 595 842] def
    %#%19bis3% reescrivim les dades de les àrees de treball a l'XRay
    (%#%19bis3%) ==
    [  %% executem un procediment o altre en funcio de l'area de creus de tall triada
     {  %% xMediaBox
      aload pop  %% desempaquetem
      dup llUm add /Ytrim exch def exch dup llUm add /Xtrim exch def exch  %% desem els valors Xur i Yur del TrimBox
      llUm 2 mul add exch llUm 2 mul add exch
      3 index /trimX exch llUm add def 2 index /trimY exch llUm add def  %% desem els valors del Xll i Yll TrimBox
      4 array astore  %% empaquetem
      count 1 sub index 1 index
      /MediaBox exch put  %% deixem a l'stack una copia del MediaBox i desem assegurant-nos que copiem el dic que hi ha a la base de l'stack (doncs segur q es el /Page)
      %% generem el TrimBox per visualitzar millor la feina
      count 1 sub index  %% ens assegurem que copiem el dic que hi ha a la base de l'stack (doncs segur q es el /Page)
      /TrimBox [trimX trimY Xtrim Ytrim] put  %% el desem a /Page

      dup /AMedia exch def  %% en desem una copia
      XRay /PeDeEfa get araPlana 12 string cvs get dup /MediaBox AMedia put  %% desem al dic numerat de la pagina
      /TrimBox [trimX trimY Xtrim Ytrim] put  %% el desem al dic numerat de la pagina
     }
     {  %% xCropBox
      %% aqui nomes ens cal endrecar el MediaBox al dic numnerat de la pagina a PeDeEfa de l'XRay, ja farem la resta quan interroguem si hi ha CropBox
      dup /AMedia exch def  %% en desem una copia
      XRay /PeDeEfa get araPlana 12 string cvs get /MediaBox AMedia put  %% desem al dic numerat de la pagina
     }
     {  %% xTrimBox
      %% aqui nomes ens cal endrecar el MediaBox al dic numnerat de la pagina a PeDeEfa de l'XRay, ja farem la resta quan interroguem si hi ha CropBox
      dup /AMedia exch def  %% en desem una copia
      XRay /PeDeEfa get araPlana 12 string cvs get /MediaBox AMedia put  %% desem al dic numerat de la pagina
     }
    ]
    xQuinaArea get cvx exec
   }if  %/02 MARQUES DE TALL
   %% aqui cal endrecar el MediaBox al dic numerat de la pagina a PeDeEfa de l'XRay xq no falli la comprovacio a la seccio seguent
   dup /AMedia exch def  %% en desem una copia
   XRay /PeDeEfa get araPlana 12 string cvs get /MediaBox AMedia put  %% desem al dic numerat de la pagina
   QueLiFemFer 2 eq xQuinaArea 1 eq xQuinaArea 2 eq or and  %% hem de fer creus pel Crop o el Trim per no escriure ara la dada del MediaBox a fitxer XRay
   {
    pop  %% ens carreguem l'array del MediaBox
   }
   {
    wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:MediaBox:) writestring
    %% escriu la part sencera mes el punt mes la part decimal (fins al quart) manualment
    {  %% forall
     10000 mul cvi 20 string cvs dup
     length 4 sub dup 0 le
     {
      pop (000000) /EmesD exch def
      EmesD /NullEncode filter /XiFRa exch def
      XiFRa (0.) writestring XiFRa exch writestring
      XiFRa closefile
     }
     {
      /pD exch def dup 0 pD getinterval
      dup length 3 -1 roll pD 4 getinterval dup length 3 -1 roll add 1 add string
      /EmesD exch def EmesD /NullEncode filter /XiFRa exch def
      exch XiFRa exch writestring XiFRa 46 write XiFRa exch writestring
      XiFRa closefile
     }ifelse
     EmesD wFitxerXRay exch writestring wFitxerXRay 32 write
    } forall
   }ifelse
   /sOrtim true def
  }
  {  %% si no hi es vol dir que l'hereta del Parent (doncs es obligatori)
   dup /Parent known
   {
    hihaParent
    {
     /Parent get
    }
    {
     dup /Parent get
    }ifelse
    /actParent exch def  %% extraiem la ref ind de la primera pagina
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup actParent known {actParent get exit}{pop}ifelse 
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
    %% el dic de la branca de pagines d'on penja
    dup
    /hihaParent true def
   }
   {  %% haura esgotat tots els Parents sense trobar MediaBox
    %% malgrat sigui un error greu no el fem petar? (doncs l'Acrobat l'admet si hi han altres arees)
    XRay /PeDeEfa get /Errades get /MissingMediaBoxPage: araPlana 12 string cvs put
    /sOrtim true def
   }ifelse
  }ifelse
  sOrtim
  {
   hihaParent {pop}if  %% si hem tibat de Parent hi haura un dic d'entremig sobrer
   exit
  }if
 } loop  %% recursiu per trobar el MediaBox fins l'arrel /Pages si cal

 dup
 /sOrtim false def
 /hihaParent false def
 {  %% loop que va pujant mentre hi hagi Parent i no hi hagi CropBox (fins l'arrel /Pages)
  /CropBox known
  {
   dup /CropBox get dup /ACrop exch def  %% en desem una copia
   %% avaluem si CropBox es dins els marges minim i maxims de MediaBox i si no, fem un WARNING i l'adaptem
   /femWARNING false def
   XRay /PeDeEfa get araPlana 12 string cvs get /MediaBox known  %% hi ha MediaBox?
   {
    QueLiFemFer 2 eq  %:02 MARQUES DE TALL
    {
     [  %% executem un procediment o altre en funcio de l'area de creus de tall triada
      {  %% xMediaBox
       pop AMedia dup dup /ACrop exch def  %% igualem el CropBox al MediaBox
       count 1 sub index  %% ens assegurem que copiem el dic que hi ha a la base de l'stack (doncs segur q es el /Page)
       exch /CropBox exch put  %% i redesem a l'objecte /Page
      }
      {  %% xCropBox
       %% si posem les creus pel CropBox regenerem el MediaBox als marges necessaris de les creus
       aload pop  %% desempaquetem
       dup llUm add /Ytrim exch def exch dup llUm add /Xtrim exch def exch  %% desem els valors Xur i Yur del TrimBox
       llUm 2 mul add exch llUm 2 mul add exch
       3 index /trimX exch llUm add def 2 index /trimY exch llUm add def  %% desem els valors del Xll i Yll TrimBox
       4 array astore  %% empaquetem
       count 1 sub index 1 index
       /MediaBox exch put  %% deixem a l'stack una copia del MediaBox i desem assegurant-nos que copiem el dic que hi ha a la base de l'stack (doncs segur q es el /Page)
       %% generem el TrimBox per visualitzar millor la feina
       count 1 sub index  %% ens assegurem que copiem el dic que hi ha a la base de l'stack (doncs segur q es el /Page)
       dup /TrimBox [trimX trimY Xtrim Ytrim] put  %% el desem a /Page
       /CropBox undef  %% ens assegurem d'esborrar el CropBox a /Page
       dup /AMedia exch def  %% en desem una copia
       XRay /PeDeEfa get araPlana 12 string cvs get dup dup /MediaBox AMedia put  %% desem al dic numerat de la pagina
       /TrimBox [trimX trimY Xtrim Ytrim] put  %% el desem al dic numerat de la pagina
       /CropBox undef  %% ens assegurem d'esborrar el CropBox al dic numerat d'XRay
      }
      {  %% xTrimBox
      }
     ]
     xQuinaArea get cvx exec
    }if  %/02 MARQUES DE TALL
    ACrop 0 get AMedia 0 get lt {ACrop 4 array copy dup AMedia 0 get 0 exch put /ACrop exch def /femWARNING true def}if  %% si te la Xll + petita la igualem a la del MediaBox
    ACrop 1 get AMedia 1 get lt {ACrop 4 array copy dup AMedia 1 get 1 exch put /ACrop exch def /femWARNING true def}if  %% si te la Yll + petita la igualem a la del MediaBox
    ACrop 2 get AMedia 2 get gt {ACrop 4 array copy dup AMedia 2 get 2 exch put /ACrop exch def /femWARNING true def}if  %% si te la Xur + gran la igualem a la del MediaBox
    ACrop 3 get AMedia 3 get gt {ACrop 4 array copy dup AMedia 3 get 3 exch put /ACrop exch def /femWARNING true def}if  %% si te la Yur + gran la igualem a la del MediaBox
    femWARNING
    {
     %% escrivim el WARNING
     wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:WARNING:CropBox overflows MediaBox!) writestring
    }if
   }
   {  %% NO hi ha MediaBox!
    %% fem el mateix que Acrobat: li donem el valor del CropBox tenint en compte que caldra filtra-lo tambe xq es normalitzi (si cal) ...
    ACrop
    %% Ampliem el MediaBox+CropBox de llUm punts x banda (20 de marge + 30 x la meitat de les creus), total llUmx2 punts d'X i llUmx2 punts d'Y
    QueLiFemFer 2 eq  %:02 MARQUES DE TALL
    {
     [  %% executem un procediment o altre en funcio de l'area de creus de tall triada
      {  %% xMediaBox
       aload pop  %% desempaquetem
       dup llUm add /Ytrim exch def exch dup llUm add /Xtrim exch def exch  %% desem els valors maxims originals+llUm x generar el TrimBox
       llUm 2 mul add exch llUm 2 mul add exch
       4 array astore  %% empaquetem i deixem a l'stack
       exch pop dup  %% eliminem l'array original sense modificar xq quedi reflectit el canvi a l'XRay
       /trasllX llUm def /trasllY llUm def  %% valors del trasllat de l'eix de coordenades per resituar el contingut de pagina
       %% generem el TrimBox per visualitzar millor la feina
       count 1 sub index  %% ens assegurem que copiem el dic que hi ha a la base de la pila (doncs segur q es el /Page)
       /TrimBox [trasllX trasllY Xtrim Ytrim] put  %% el desem a /Page
      }
      {  %% xCropBox
       %% si posem les creus pel CropBox regenerem el MediaBox als marges necessaris de les creus
       aload pop  %% desempaquetem
       dup llUm add /Ytrim exch def exch dup llUm add /Xtrim exch def exch  %% desem els valors Xur i Yur del TrimBox
       llUm 2 mul add exch llUm 2 mul add exch
       3 index /trimX exch llUm add def 2 index /trimY exch llUm add def  %% desem els valors del Xll i Yll TrimBox
       4 array astore  %% empaquetem
       count 1 sub index 1 index
       /MediaBox exch put  %% deixem a la pila una copia del MediaBox i desem assegurant-nos que copiem el dic que hi ha a la base de la pila (doncs segur q es el /Page)
       %% generem el TrimBox per visualitzar millor la feina
       count 1 sub index  %% ens assegurem que copiem el dic que hi ha a la base de la pila (doncs segur q es el /Page)
       dup /TrimBox [trimX trimY Xtrim Ytrim] put  %% el desem a /Page
       /CropBox undef  %% ens assegurem d'esborrar el CropBox a /Page
       dup /AMedia exch def  %% en desem una copia
       XRay /PeDeEfa get araPlana 12 string cvs get dup dup /MediaBox AMedia put  %% desem al dic numerat de la pagina
       /TrimBox [trimX trimY Xtrim Ytrim] put  %% el desem al dic numerat de la pagina
       /CropBox undef  %% ens assegurem d'esborrar el CropBox al dic numerat d'XRay
      }
      {  %% xTrimBox
      }
     ]
     xQuinaArea get cvx exec
    }if  %/02 MARQUES DE TALL
    QueLiFemFer 2 eq xQuinaArea 1 eq xQuinaArea 2 eq or and  %% hem de fer creus pel Crop o el Trim per no repicar de nou el Media, Crop i Trim
    {
     pop
    }
    {
     {dup 0 lt{pop 0}if}forall  %% ... si hi ha cap valor menor de zero, el deixem a zero ...
     %% ... llavors restant Xur-Xll i Yur-Yll, en quedaran els valors absoluts que seran els nous Xur i Yur ...
     3 -1 roll sub abs dup 0 eq {pop 3}if  %% ... tret que siguin zero, on llavors hi deixariem el valor minim admes de format de pagina de PDF (3x3 pt)
     exch 3 -1 roll sub abs dup 0 eq {pop 3}if exch
     0 3 1 roll 0 4 1 roll 4 array astore  %% ... doncs Xll i Yll quedaran a zero, i ho empaquetem
     /ACrop exch def  %% desem l'array normalitzada
     XRay /PeDeEfa get araPlana 12 string cvs get dup dup /CropBox ACrop put  %% desem al dic numerat de la pagina el CropBox normalitzat
     /MediaBox ACrop put  %% desem al dic numerat de la pagina el nou MediaBox
     /TrimBox [trasllX trasllY Xtrim Ytrim] put  %% desem al dic numerat de la pagina el nou TrimBox
     %% escrivim el WARNING
     wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:WARNING:MediaBox is now created by CropBox!) writestring
     /femWARNING true def
    }ifelse
   }ifelse
   QueLiFemFer 2 eq xQuinaArea 1 eq and  %% els dos han de ser vertaders per que no desem les dades del CropBox a l'XRay, pero si repiquem les del MediaBox
   {
    wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:MediaBox:) writestring
   }
   {  %% els dos han de ser vertaders per que no desem les dades del MediaBox a l'XRay
    QueLiFemFer 2 eq xQuinaArea 2 eq and not
    {
     XRay /PeDeEfa get araPlana 12 string cvs get /CropBox ACrop put  %% desem al dic numerat de la pagina
     wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:CropBox:) writestring
    }if
   }ifelse
   QueLiFemFer 2 eq xQuinaArea 2 eq and  %% els dos han de ser vertaders per que no escriure les dades del Media o CropBox a l'XRay
   {
    pop  %% ens carreguem l'array del CropBox
   }
   {
    %% escriu la part sencera mes el punt mes la part decimal (fins al quart) manualment
    {  %% forall
     10000 mul cvi 20 string cvs dup
     length 4 sub dup 0 le
     {
      pop (000000) /EmesD exch def
      EmesD /NullEncode filter /XiFRa exch def
      XiFRa (0.) writestring XiFRa exch writestring
      XiFRa closefile
     }
     {
      /pD exch def dup 0 pD getinterval
      dup length 3 -1 roll pD 4 getinterval dup length 3 -1 roll add 1 add string
      /EmesD exch def EmesD /NullEncode filter /XiFRa exch def
      exch XiFRa exch writestring XiFRa 46 write XiFRa exch writestring
      XiFRa closefile
     }ifelse
     EmesD wFitxerXRay exch writestring wFitxerXRay 32 write
    } forall
   }ifelse
   QueLiFemFer 2 eq  %:02 MARQUES DE TALL
   {  %% modifiquem MediaBox/CropBox si cal ...
    [  %% executem un procediment o altre en funcio de l'area de creus de tall triada
     {  %% xMediaBox
      femWARNING  %% modifiquem MediaBox/CropBox?
      {
       XRay /PeDeEfa get araPlana 12 string cvs get
       {  %% repiquem a sac desant a l'objecte /Page els valors de MediaBox i CropBox
        2 index 3 1 roll put
       }forall
      }if
     }
     {  %% xCropBox               
     }
     {  %% xTrimBox
     }
    ]
    xQuinaArea get cvx exec
   }if  %/02 MARQUES DE TALL
   /sOrtim true def
  }
  {  %% si no hi es vol dir que el podria heretar del Parent
   dup /Parent known
   {
    hihaParent
    {
     /Parent get
    }
    {
     dup /Parent get
    }ifelse
    /actParent exch def  %% extraiem la ref ind de la primera pagina
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup actParent known {actParent get exit}{pop}ifelse 
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
    %% el dic de la branca de pagines d'on penja
    dup
    /hihaParent true def
   }
   {  %% haura esgotat tots els Parents sense trobar CropBox
    /sOrtim true def
    QueLiFemFer 2 eq xQuinaArea 1 eq and  %% els dos han de ser vertaders per que si no hi ha CropBox pleguem i no fem res ...
    {
     %% fitxer TXT de control del resultat pel web+PHP
     (mancabox.txt)  %% si HI HA aquest arxiu donarem un error de manca d'area sol·licitada a CaLi2CoPi
     dup length faPath add string dup /pAthXiU exch def
     0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
     pAthXiU (w) file dup 32 write closefile
     (\n\nMRCT26 MANCA CropBox: i no hi puc posar les Creus de Tall ... pleguem!\n\n) print flush stop  %%quit
    }if
   }ifelse
  }ifelse
  sOrtim
  {
   hihaParent {pop}if  %% si hem tibat de Parent hi haura un dic d'entremig sobrer
   exit
  }if
 } loop  %% recursiu per trobar el CropBox fins l'arrel /Pages si cal

%%Hackovid
 %% ens cal desar preferentment el CropBox doncs, en cas de ser-hi, és qui visualment mana
 XRay /PeDeEfa get araPlana 12 string cvs get dup /CropBox known  %% hi ha CropBox?
 {
  /CropBox get
  %% desem el CropBox a l'array ordenat de pàgines /aPmaker
  aPmaker dup length 1 add array dup 3 -1 roll 0 exch putinterval dup /aPmaker exch def
  exch iPmaker exch put
 }
 {
  /MediaBox get
  %% desem el MediaBox a l'array ordenat de pàgines /aPmaker
  aPmaker dup length 1 add array dup 3 -1 roll 0 exch putinterval dup /aPmaker exch def
  exch iPmaker exch put
 }ifelse 

 %% la resta d'arees no son heretables i per tant han d'anar directes a l'objecte Page
 dup /TrimBox known
 {
  dup /TrimBox get dup /ATrim exch def  %% en desem una copia
  %% avaluem si TrimBox es dins els marges minim i maxims de CropBox i si no, fem un WARNING i l'adaptem
  /femWARNING false def
  XRay /PeDeEfa get araPlana 12 string cvs get /MediaBox known  %% hi ha MediaBox?
  {
   XRay /PeDeEfa get araPlana 12 string cvs get dup /CropBox known  %% hi ha CropBox?
   {
    pop
   }
   {  %% si no hi ha CropBox li donem el valor provisional de la variable de MediaBox
    /MediaBox get /ACrop exch def
   }ifelse
   QueLiFemFer 2 eq  %:02 MARQUES DE TALL
   {  %% de moment no fem res ...
    [
     {}  %% xMediaBox
     {}  %% xCropBox
     {  %% xTrimBox
      %% si posem les creus pel CropBox regenerem el MediaBox als marges necessaris de les creus
      aload pop  %% desempaquetem
      dup llUm add /Ytrim exch def exch dup llUm add /Xtrim exch def exch  %% desem els valors Xur i Yur del TrimBox
      llUm 2 mul add exch llUm 2 mul add exch
      3 index /trimX exch llUm add def 2 index /trimY exch llUm add def  %% desem els valors del Xll i Yll TrimBox
      4 array astore  %% empaquetem
      count 1 sub index 1 index
      /MediaBox exch put  %% deixem a la pila una copia del MediaBox i desem assegurant-nos que copiem el dic que hi ha a la base de la pila (doncs segur q es el /Page)
      %% generem el TrimBox per visualitzar millor la feina
      count 1 sub index  %% ens assegurem que copiem el dic que hi ha a la base de la pila (doncs segur q es el /Page)
      dup /TrimBox [trimX trimY Xtrim Ytrim] put  %% el desem a /Page
      /CropBox undef  %% ens assegurem d'esborrar el CropBox a /Page
      dup /AMedia exch def  %% en desem una copia
      XRay /PeDeEfa get araPlana 12 string cvs get dup dup /MediaBox AMedia put  %% desem al dic numerat de la pagina
      /TrimBox [trimX trimY Xtrim Ytrim] put  %% el desem al dic numerat de la pagina
      /CropBox undef  %% ens assegurem d'esborrar el CropBox al dic numerat d'XRay
      wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:MediaBox:) writestring
      %% escriu la part sencera mes el punt mes la part decimal (fins al quart) manualment
      AMedia  %% paquet del MediaBox
      {  %% forall
       10000 mul cvi 20 string cvs dup
       length 4 sub dup 0 le
       {
        pop (000000) /EmesD exch def
        EmesD /NullEncode filter /XiFRa exch def
        XiFRa (0.) writestring XiFRa exch writestring
        XiFRa closefile
       }
       {
        /pD exch def dup 0 pD getinterval
        dup length 3 -1 roll pD 4 getinterval dup length 3 -1 roll add 1 add string
        /EmesD exch def EmesD /NullEncode filter /XiFRa exch def
        exch XiFRa exch writestring XiFRa 46 write XiFRa exch writestring
        XiFRa closefile
       }ifelse
       EmesD wFitxerXRay exch writestring wFitxerXRay 32 write
      } forall
     }
    ]
    xQuinaArea get cvx exec
   }if  %/02 MARQUES DE TALL
   ATrim 0 get ACrop 0 get lt {ATrim 4 array copy dup ACrop 0 get 0 exch put /ATrim exch def /femWARNING true def}if  %% si te la Xll + petita la igualem a la del CropBox
   ATrim 1 get ACrop 1 get lt {ATrim 4 array copy dup ACrop 1 get 1 exch put /ATrim exch def /femWARNING true def}if  %% si te la Yll + petita la igualem a la del CropBox
   ATrim 2 get ACrop 2 get gt {ATrim 4 array copy dup ACrop 2 get 2 exch put /ATrim exch def /femWARNING true def}if  %% si te la Xur + gran la igualem a la del CropBox
   ATrim 3 get ACrop 3 get gt {ATrim 4 array copy dup ACrop 3 get 3 exch put /ATrim exch def /femWARNING true def}if  %% si te la Yur + gran la igualem a la del CropBox
   femWARNING
   {
    %% escrivim el WARNING
    wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:WARNING:TrimBox overflows CropBox!) writestring
   }if
  }
  {  %% NO hi ha MediaBox!
   QueLiFemFer 2 eq  %:02 MARQUES DE TALL
   {
    [  %% executem un procediment o altre en funcio de l'area de creus de tall triada
     {  %% xMediaBox
      %% amb l'opcio 2, ho fem diferent que l'Acrobat: ara al MediaBox li donem el valor del TrimBox (Acrobat hi posaria el format d pagina x defecte) ...
      %% normalitzem ...
      {dup 0 lt{pop 0}if}forall  %% ... si hi ha cap valor menor de zero, el deixem a zero ...
      %% ... llavors restant Xur-Xll i Yur-Yll, en quedaran els valors absoluts que seran els nous Xur i Yur ...
      3 -1 roll sub abs dup 0 eq {pop 3}if  %% ... tret que siguin zero, on llavors hi deixariem el valor minim admes de format de pagina de PDF (3x3 pt)
      exch 3 -1 roll sub abs dup 0 eq {pop 3}if exch
      0 3 1 roll 0 4 1 roll %% ... doncs Xll i Yll quedaran a zero
      %% Ampliem el MediaBox+TrimBox de llUm punts x banda (20 de marge + 30 x la meitat de les creus), total llUmx2 punts d'X i llUmx2 punts d'Y
      3 -1 roll sub llUm 2 mul add /YMedia exch def exch sub llUm 2 mul add /XMedia exch def  %% desem els valors Xur Yur del MediaBox que regenerem
      YMedia llUm sub /Ytrim exch def XMedia llUm sub /Xtrim exch def  %% desem els valors Xur Yur del nou TrimBox
      /trasllX llUm def /trasllY llUm def  %% valors del trasllat de l'eix de coordenades per resituar el contingut de pagina i per Xll i Yll del nou TrimBox
      %% generem el nou TrimBox per visualitzar millor la feina
      count 1 sub index  %% ens assegurem que copiem el dic que hi ha a la base de la pila (doncs segur q es el /Page)
      /TrimBox [trasllX trasllY Xtrim Ytrim] put  %% el desem a /Page
      [trasllX trasllY Xtrim Ytrim] dup /ATrim exch def  %% desem l'array normalitzada
      XRay /PeDeEfa get araPlana 12 string cvs get dup/MediaBox [0 0 XMedia YMedia] put  %% desem al dic numerat de la pagina el nou MediaBox
      /TrimBox ATrim put  %% desem al dic numerat de la pagina el nou TrimBox
      %% escrivim el WARNING
      wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:WARNING:MediaBox is now created by Old TrimBox \(only with CaLi2CoPi option 2\)!) writestring
      /femWARNING true def
     }
     {  %% xCropBox               
     }
     {  %% xTrimBox
      %% si no hi ha MediaBox pleguem de la feina donant un missatge ...
      %% fitxer TXT de control del resultat pel web+PHP
      (mancabox.txt)  %% si HI HA aquest arxiu donarem un error de manca d'area sol·licitada a CaLi2CoPi
      dup length faPath add string dup /pAthXiU exch def
      0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
      pAthXiU (w) file dup 32 write closefile
      (\n\nMRCT26 MANCA MediaBox: i no posarem les Creus de Tall ... pleguem!\n\n) print flush stop %%quit
     }
    ]
    xQuinaArea get cvx exec
   }if  %/02 MARQUES DE TALL
  }ifelse
  wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:TrimBox:) writestring
  %% escriu la part sencera mes el punt mes la part decimal (fins al quart) manualment
  {  %% forall
   10000 mul cvi 20 string cvs dup
   length 4 sub dup 0 le
   {
    pop (000000) /EmesD exch def
    EmesD /NullEncode filter /XiFRa exch def
    XiFRa (0.) writestring XiFRa exch writestring
    XiFRa closefile
   }
   {
    /pD exch def dup 0 pD getinterval
    dup length 3 -1 roll pD 4 getinterval dup length 3 -1 roll add 1 add string
    /EmesD exch def EmesD /NullEncode filter /XiFRa exch def
    exch XiFRa exch writestring XiFRa 46 write XiFRa exch writestring
    XiFRa closefile
   }ifelse
   EmesD wFitxerXRay exch writestring wFitxerXRay 32 write
  } forall
  QueLiFemFer 2 eq  %:02 MARQUES DE TALL
  {  %% de moment no fem res ...
  }  %/02 MARQUES DE TALL
  {
   XRay /PeDeEfa get araPlana 12 string cvs get /TrimBox ATrim put  %% ens assegurem de desar al dic numerat de la pagina
  }ifelse
 }
 {
  QueLiFemFer 2 eq xQuinaArea 2 eq and  %% els dos han de ser vertaders per que si no hi ha TrimBox pleguem i no fem res ...
  {
   %% fitxer TXT de control del resultat pel web+PHP
   (mancabox.txt)  %% si HI HA aquest arxiu donarem un error de manca d'area sol·licitada a CaLi2CoPi
   dup length faPath add string dup /pAthXiU exch def
   0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
   pAthXiU (w) file dup 32 write closefile
   (\n\nMRCT26 MANCA TrimBox: i no hi puc posar les Creus de Tall ... pleguem!\n\n) print flush stop %%quit
  }if
 }ifelse
 dup /BleedBox known
 {
  dup /BleedBox get
  QueLiFemFer 2 eq  %:02 MARQUES DE TALL
  {  %% tant si la pagina creix o s'arronsa, ajustem el BleedBox sumant sempre llUm als 4 valors dels seus arrays
   {llUm add}forall
   4 array astore
   dup 2 index exch /BleedBox exch put
  }if  %/02 MARQUES DE TALL
  dup /ABleed exch def  %% en desem una copia
  wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:BleedBox:) writestring
  %% escriu la part sencera mes el punt mes la part decimal (fins al quart) manualment
  {  %% forall
   10000 mul cvi 20 string cvs dup
   length 4 sub dup 0 le
   {
    pop (000000) /EmesD exch def
    EmesD /NullEncode filter /XiFRa exch def
    XiFRa (0.) writestring XiFRa exch writestring
    XiFRa closefile
   }
   {
    /pD exch def dup 0 pD getinterval
    dup length 3 -1 roll pD 4 getinterval dup length 3 -1 roll add 1 add string
    /EmesD exch def EmesD /NullEncode filter /XiFRa exch def
    exch XiFRa exch writestring XiFRa 46 write XiFRa exch writestring
    XiFRa closefile
   }ifelse
   EmesD wFitxerXRay exch writestring wFitxerXRay 32 write
  } forall
 }if
 dup /ArtBox known
 {
  dup /ArtBox get
  QueLiFemFer 2 eq  %:02 MARQUES DE TALL
  {  %% tant si la pagina creix o s'arronsa, ajustem l'ArtBox sumant sempre llUm als 4 valors dels seus arrays
   {llUm add}forall
   4 array astore
   dup 2 index exch /ArtBox exch put
  }if  %/02 MARQUES DE TALL
  dup /AArt exch def  %% en desem una copia
  wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:ArtBox:) writestring
  %% escriu la part sencera mes el punt mes la part decimal (fins al quart) manualment
  {  %% forall
   10000 mul cvi 20 string cvs dup
   length 4 sub dup 0 le
   {
    pop (000000) /EmesD exch def
    EmesD /NullEncode filter /XiFRa exch def
    XiFRa (0.) writestring XiFRa exch writestring
    XiFRa closefile
   }
   {
    /pD exch def dup 0 pD getinterval
    dup length 3 -1 roll pD 4 getinterval dup length 3 -1 roll add 1 add string
    /EmesD exch def EmesD /NullEncode filter /XiFRa exch def
    exch XiFRa exch writestring XiFRa 46 write XiFRa exch writestring
    XiFRa closefile
   }ifelse
   EmesD wFitxerXRay exch writestring wFitxerXRay 32 write
  } forall
 }if
 %% malgrat haver explorat totes les arees, si no hi ha ni Media, ni Crop, ni Trim ...
 XRay /PeDeEfa get araPlana 12 string cvs get length 0 eq
 {  %% generem un MediaBox amb la paginaXdefecte
  %% Ampliem el MediaBox de la paginaXdefecte de 50 punts x banda (20 de marge + 30 x la meitat de les creus), total 100x100 punts
  QueLiFemFer 2 eq  %:02 MARQUES DE TALL
  {
   paginaXdefecte {llUm add}forall 4 array astore /ATrim exch def
   paginaXdefecte aload pop llUm 2 mul add exch llUm 2 mul add exch 4 array astore /AMedia exch def
  }if  %/02 MARQUES DE TALL
  XRay /PeDeEfa get araPlana 12 string cvs get dup /MediaBox AMedia put /TrimBox ATrim put  %% desem al dic numerat de la pagina
  %% escrivim el WARNING
  wFitxerXRay dup dup (\015\012PDF:page) writestring araPlana 12 string cvs writestring (:WARNING:MediaBox is now created by page default!) writestring
  dup /MediaBox AMedia put  %% restablim el MediaBox a l'objecte /Page
  /TrimBox ATrim put  %% restablim el TrimBox a l'objecte /Page
 }
 {
  pop
 }ifelse
 araPlana 1 add dup maxPlana gt {pop exit}{/araPlana exch def}ifelse

%%Hackovid
iPmaker 1 add /iPmaker exch def

} loop  %% fi del loop explorador d'arees pagina a pagina

%%Hackovid
%% capturaríem la variable d'entorn amb la id úncia del pdf provinent de $PDFunic
%% i si no hi fos?
%% aquí cal activar el filtre del nou gatell pel Hackovid
plgmkr
{
 %% ens cal escriure al directori addon_pdf/ l'array dins un .dat únic
 (aPmaker.dat) (w) file /FaPmaker exch def
 FaPmaker ([) writestring
 aPmaker
 {
  FaPmaker ([) writestring
  {
   128 string cvs FaPmaker exch writestring
   FaPmaker ( ) writestring
  }forall
  FaPmaker (]) writestring
 }forall
 FaPmaker dup (]) writestring closefile
% quit  %% stop? sortim de CaLi2CoPi!
%% (aPmaker.dat) (r) file cvx exec dup length (Hackovid) pstack quit
}if


%%% a3copiseny ... DESACTIVEM XRAY
%%}if

QueLiFemFer 7 eq  %:07 REINSEREIX IMATGES JPEG
{
 %#%19bis4% mirem si hi ha jpegs al directori d'exportació, els validem i n'emmagatzemem els path i les dades que necessitem
 %# cadascun dins un paquet docJpeg on desem pàgina a pàgina en arrays d'imatges, on l'índex ens descriu l'ordre d'exportació
 (%#%19bis4%)==
 XRay /PeDeEfa get  %% el desem en aquest dic per que aixi el podrem actualitzar sense problemes dins l'execucio dels Contents
 /imatgesXordre
 [  %% si volem permetre q es puguin reinserir nomes determinades imatges exportades ...
  null  %% index 0, sempre sera null x tal que quadri el num de plana amb l'index
  maxPlana {null}repeat  %% ... necessitem generar aquest array amb el nombre de nulls exacte q determini el nombre de pagines del document
 ] put  %% en aquest paquet hi haura una array per cada plana amb els noms de les imatges ordenats tal com venen dins l'stream de Contents
 /docJpeg
 [  %% si volem permetre q es puguin reinserir nomes determinades imatges exportades ...
  null  %% index 0, sempre sera null x tal que quadri el num de plana amb l'index
  maxPlana {null}repeat  %% ... necessitem generar aquest array amb el nombre de nulls exacte q determini el nombre de pagines del document
 ] def  %% en aquest paquet hi haura una array per cada plana que tingui imatges exportades i si no hi haura un null
 imatgesXreinserir dup dup length 1 sub get 47 eq  %% duu la barra al final?
 {  %% hi afegim l'asterisc
  dup length dup 1 add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll (*) putinterval
 }
 {  %% hi afegim la barra i l'asterisc
  dup length dup 2 add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll (/*) putinterval
 }ifelse
 dup /niuJpeg exch def  %% desem el path generic
 /niuBuit true def  %% gatell x saber si el directori existeix o es buit
 {  %% filelor explorem tot el directori on hi ha d'haver els jpegs a refarcir
  %% metode per esbrinar el num de pagina i el num d'imatge: for endarrera i search endavant
  null /tercer_ exch def  %% gatell x saber si hem localitzat el tercer _
  0 /i95 exch def  %% comptador de guions baixos
  dup length /faS exch def dup /potserJpeg exch def
  faS 1 sub -1 0
  {  %% for enrera fins el tercer _ (95) per esbrinar-ne el seu index
   2 copy get 95 eq
   {
    i95 1 add /i95 exch def
   }if
   i95 3 eq {/tercer_ exch def exit}{pop}ifelse %% index on hem de parar el for
  }for
  tercer_ null eq

  {  %% no s'adiu al format de nom d'imatge exportat per Acrobat
   == ( <<< NO s'adiu al format de nom d'imatge exportat per Acrobat!) ==
   %% /niuBuit true def  % gatell x saber si el directori existeix o es buit
  }
  {
   /niuBuit false def  %% gatell x saber si el directori existeix o es buit
   %% i llavors llegir la cadena extreta cap endavant amb search ...
   tercer_ 1 add faS tercer_ sub 1 sub getinterval
   %% Pesquem El Num De Pagina On Reincrustar Les imatges
   (_) search pop /PENDPORLi exch def pop
   %% Pesquem El Sequencial De La imatge
   (_) search pop pop pop
   (.) search
   {
    /PESDLi exch def pop pop
    {  %% stopped on ens assegurem que el num de pagina i el num d'imatge siguin numerics (hi ha fatals coincidencies!)
     mark
     PENDPORLi cvx exec PESDLi cvx exec add
    }stopped
    {
     cleartomark
     potserJpeg == ( <<< NO s'adiu al format de nom d'imatge exportat per Acrobat!) ==
    }
    {
     /elJPEGteproblemes false def  %% gatell x filtrar JPEG que no s'adiuen
     %% analitzem el jpeg per extreure'n les dades necessaries
     potserJpeg
     %%% lector de jpeg
     {  %%d'stopped
      %% captura de dades del JPEG i comprovacio de si existeix ...
      dup status
      {
       pop pop
       %% el fitxer fa ...
       /FiFtxr exch def pop
       dup /elD'ara exch def  %% path+Nom del fitxer que processem
       (r) file /tesela exch def  %% fitxer de lectura
       %% mirem el cap i els peus (marcadors d'inici i final) del fitxer aviam si son normatius ...
       tesela FiFtxr 2 sub setfileposition
       tesela 2 string readstring pop <FFD9> eq
       {
        %%(PEUS OK) ==
        tesela dup 0 setfileposition
        2 string readstring pop <FFD8> eq
        {
         %%(CAP OK) ==
         /SoRTiM false def  %% pestell de sortida
         %% explorem el fitxer per localitzar els marcadors significatius que duen les dades d'imatge (qualsevol d'ells es valid)
         {  %% loop
          tesela 2 string readstring  %% llegim el segment
          {
           /SeGMeNT exch def
           0 1 6
           {  %% for
            [<FFC0> <FFC1> <FFC2> <FFC3> <FFC5> <FFC6> <FFC7>]  %% marcadors significatius
            exch get SeGMeNT eq
            {
             %%(JA EL TINC !!!) ==
             tesela 10 string readstring pop
             %% captura del valor de files (y)
             dup dup 3 get 256 mul exch 4 get add (\n >>>> Files (Y) ... ) print flush dup ==
             /_B exch def  %% (Y) FILES D'IMATGE
             %% captura del valor de columnes (x)
             dup dup 5 get 256 mul exch 6 get add ( >>>> Columnes (X) ... ) print flush dup ==
             /_A exch def  %% (X) COLUMNES D'IMATGE
             %% captura dels components de color (1, 3 o 4 canals)
             dup dup 7 get ( >>>> Components de Color ... ) print flush dup ==
             /CNL exch def
             %% bits per component de color (o per pixel)
             dup dup 2 get ( >>>> Bits x Comp ... ) print flush dup == elD'ara print flush (\n) print flush
             /bXp exch def
             /SoRTiM true def
            }if
           } for
           SoRTiM not
           {
            tesela 2 string readstring
            {  %% llegim la llargada del segment per saltar al seguent ...
             dup 0 get 256 mul exch 1 get add
             2 sub string tesela exch readstring {pop}{pop tesela closefile exit}ifelse
            }
            {
             pop tesela closefile exit
            }ifelse
           }if
          }
          {
           pop tesela closefile exit
          }ifelse
          SoRTiM {tesela closefile exit} if
         } loop
         SoRTiM not
	 {
	  (\n\n <<<< NO podem llegir correctament les dades d'aquest JPEG\n\n) print flush
	  /elJPEGteproblemes true def  %% n'hi ha
	 } if
         %% construim la imatge
         {  %% stopped
          [  %% fem petar l'algorisme si l'espai de color no es de 3 canals (RGB)
           (zero)  %%0
           %% 1 canal (ploma, escala de grisos)
           (zero)  %%{/DCD [0 1] def /SCE {/DeviceGray setcolorspace} def}
           (zero)  %%0
           %% 3 canals (RGB)
           {/DCD [0 1 0 1 0 1] def /SCE {/DeviceRGB setcolorspace} def}
           %% 4 canals (CMYK)
           (zero)  %%{/DCD [1 0 1 0 1 0 1 0] def /SCE {/DeviceCMYK setcolorspace} def}
          ]
          CNL get exec
         } stopped
         {  %% canals incorrectes
          (\n\n <<<< Canals Incorrectes ... \n\n) print flush
	  /elJPEGteproblemes true def  %% n'hi ha
         }if
         %% escala  1 = 100% = 72 dpi
         1 /Scl exch def 
         [ _A Scl mul _B Scl mul ] /frmtPGN exch def
         {  %% stopped
          <</PageSize frmtPGN>> setpagedevice
          SCE  %% cridem l'espai de color
          gsave
          0 0 translate
          _A Scl mul _B Scl mul scale
          <<
            /ImageType 1
            /Width _A
            /Height _B
            /BitsPerComponent bXp
            /Decode DCD
            /ImageMatrix [_A 0 0 _B neg 0 _B]
            /DataSource elD'ara (r) file <</ColorTransform 1>> /DCTDecode filter
          >> image grestore
         } stopped
         {
          %%elD'ara print flush ( JPEG incompatible amb el filtre DCTDecode de PostScript ... \n\n) print flush
	  /elJPEGteproblemes true def  %% n'hi ha
         }
         {
          showpage
         } ifelse
        }
        {
         %%(CAP KAPPUT)==
	 /elJPEGteproblemes true def  %% n'hi ha
        }ifelse
       }
       {  %% desactivem x TEST
        %%(PEUS KAPPUT)==
	/elJPEGteproblemes true def  %% n'hi ha
       }ifelse
      }
      {
       %%(NO HI ES ...) == tesela closefile quit
       /elJPEGteproblemes true def  %% n'hi ha
      }ifelse
     }stopped 
     {
      %%clear ( ... PETADA !!\n\n) print flush
      /elJPEGteproblemes true def  %% n'hi ha
     }if
     %%% fi del lector de jpeg
     elJPEGteproblemes
     {  %% algun dels gatells clau peta
      cleartomark
      (\n\n)print flush potserJpeg print flush (\n <<< JPEG erroni o malmes ...\n ... CaLi2CoPi no continuara fins que no el torneu a desar correctament!\n\n)print flush stop  %%quit
     }
     {  %% tot correcte
      cleartomark
      %% aqui hem d'ampliar l'array del document pel num de pagina q toqui (si es q no existeix)
      %% farem coincidir el num de pagina i el num d'imatge amb l'index
      %% llavors el length sempre ha de ser PENDPORLi + 1
      PENDPORLi cvx exec 1 add docJpeg length gt  %% amb el length sabem si el num d pagina existeix o no
      {  %% no existeix el num de pagina i per aixo hem d'ampliar l'array del document fins on demani
       PENDPORLi cvx exec 1 add docJpeg length sub docJpeg length add array dup docJpeg 0 exch putinterval /docJpeg exch def
       docJpeg PENDPORLi cvx exec PESDLi cvx exec 1 add array dup PESDLi cvx exec
       <<
         /Width _A
         /Height _B
	 /xiu potserJpeg dup length string copy  %% per profilaxi
       >> put  %% afegim el dic de la imatge al seu lloc de l'array de pagina
       put  %% i ara la nova array de pagina al paquet general del document
%%docJpeg (+++++1+++++)pstack quit
      }
      {  %% podria existir o no
       docJpeg PENDPORLi cvx exec get null eq
       {  %% no existeix l'array de pagina
        docJpeg PENDPORLi cvx exec PESDLi cvx exec 1 add array dup PESDLi cvx exec
        <<
	  /Width _A
          /Height _B
          /xiu potserJpeg dup length string copy  %% per profilaxi
	>> put  %% afegim el dic de la imatge al seu lloc de l'array de pagina
        put  %% i ara la nova array de pagina al paquet general del document
%%docJpeg(+++++2+++++)pstack quit
       }
       {  %% ja existeix l'array de pagina ...
        %% llavors capturem el paquet de pagina ...
	docJpeg PENDPORLi cvx exec get
	%% ... i posem el dic de la imatge al seu lloc
	dup length PESDLi cvx exec 1 add exch gt
	{  %% hem d'ampliar el paquet de pagina
         PESDLi cvx exec 1 add 1 index length sub 1 index length add array dup 3 -1 roll 0 exch putinterval
	}if
	dup PESDLi cvx exec
	<<
	  /Width _A
          /Height _B
          /xiu potserJpeg dup length string copy  %% per profilaxi
	>> put  %% afegim el dic de la imatge al seu lloc de l'array de pagina
	docJpeg exch PENDPORLi cvx exec exch put  %% i ara l'array de pagina reformada al paquet general del document
%%docJpeg(+++++3+++++)pstack quit
       }ifelse
      }ifelse
     }ifelse
    }ifelse
   }
   {
    pop
    potserJpeg == ( <<< NO s'adiu al format de nom d'imatge exportat per Acrobat!) ==
   }ifelse
  }ifelse
 }256 string filenameforall
 niuBuit
 {
  (\n) print flush niuJpeg print flush
  ( <<< directori BUIT o INEXISTENT ... PLEGUEM!\n\n)print flush stop
 }if
}if  %/07 REINSEREIX IMATGES JPEG

QueLiFemFer 9 eq  %:09 EXTRAU IMATGES JPEG
{
 %#%19bis5% preparem XRay per acollir l'exportació d'imatges
 (%#%19bis5%)==
 XRay /PeDeEfa get  %% el desem en aquest dic per que aixi el podrem actualitzar sense problemes dins l'execucio dels Contents
 /imatgesXordre
 [  %% si volem permetre q es puguin reinserir nomes determinades imatges exportades ...
  null  %% index 0, sempre sera null x tal que quadri el num de plana amb l'index
  maxPlana {null}repeat  %% ... necessitem generar aquest array amb el nombre de nulls exacte q determini el nombre de pagines del document
 ] put  %% en aquest paquet hi haura una array per cada plana amb els noms de les imatges ordenats tal com venen dins l'stream de Contents
}if  %/09 EXTRAU IMATGES JPEG

%#%20% definim el fitxer on reescriurem els Contents x 1er cop
(%#%20%)==
l'objectenet (w) file  %% repicats a traves de les redefinicions d'OpContents_QueLiFemFer#
/sEdAs exch def

%%% definim xifrats (encoding) diversos a utilitzar
QueLiFemFer 16 eq
{  %:16 cerca i substitució de text
 %% taula d'equivalències de tipografies amb risc (Standard 14 Fonts) cap a tipografies forasteres
 <<
   %% la família estàndard Courier i la seva clònica
   (Courier) /fMSTS0
   (Courier-Oblique) /fMSTS1
   (Courier-Bold) /fMSTS2
   (Courier-BoldOblique) /fMSTS3
   (CourierNewPSMT) /fMSTS0
   (CourierNewPS-ItalicMT) /fMSTS1
   (CourierNewPS-BoldMT) /fMSTS2
   (CourierNewPS-BoldItalicMT) /fMSTS3
   %% la família estàndard Helvètica i les seves clòniques
   (Helvetica) /fMSTS4
   (Helvetica-Oblique) /fMSTS5
   (Helvetica-Oblique,Oblique) /fMSTS5
   (Helvetica-Bold) /fMSTS6
   (Helvetica-Bold,Bold) /fMSTS6
   (Helvetica-BoldOblique) /fMSTS7
   (Helvetica-BoldOblique,BoldOblique) /fMSTS7
   (ArialMT) /fMSTS4
   (Arial) /fMSTS4
   (Arial-ItalicMT) /fMSTS5
   (Arial,Italic) /fMSTS5
   (Arial-ItalicMT,Italic) /fMSTS5
   (Arial-BoldMT) /fMSTS6
   (Arial,Bold) /fMSTS6
   (Arial-BoldMT,Bold) /fMSTS6
   (Arial-BoldItalicMT) /fMSTS7
   (Arial,BoldItalic) /fMSTS7
   (Arial-BoldItalicMT,BoldItalic) /fMSTS7
   %% la família estàndard Times i la seva clònica
   (Times-Roman) /fMSTS8
   (Times-Italic) /fMSTS9
   (Times-Bold) /fMSTS10
   (Times-BoldItalic) /fMSTS11
   (TimesNewRomanPSMT) /fMSTS8
   (TimesNewRomanPS-ItalicMT) /fMSTS9
   (TimesNewRomanPS-BoldMT) /fMSTS10
   (TimesNewRomanPS-BoldItalicMT) /fMSTS11
   %% poc provable que la fem servir per aquesta feina
   (Symbol) /fMSTS12
   %% encara menys provable que la fem servir per aquesta feina
   (ZapfDingbats) /fMSTS13
 >>
 /RISCaFORASTERES exch def
}  %/16 cerca i substitució de text
{
 /StandardEncoding ISOLatin1Encoding
 %% StandardEncoding  % no ens cal marejar la perdiu?
 256 array copy def
}ifelse

/WinAnsiEncoding  %% encoding d'escriptura de l'XRay i afegits als noms de fitxers
[/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quotesingle /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one /two /three /four /five /six /seven /eight /nine /colon /semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright /asciitilde /bullet /Euro /bullet /quotesinglbase /florin /quotedblbase /ellipsis /dagger /daggerdbl /circumflex /perthousand /Scaron /guilsinglleft /OE /bullet /Zcaron /bullet /bullet /quoteleft /quoteright /quotedblleft /quotedblright /bullet /endash /emdash /tilde /trademark /scaron /guilsinglright /oe /bullet /zcaron /Ydieresis /space /exclamdown /cent /sterling /currency /yen /brokenbar /section /dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron /degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla /Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis /eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis]
def
/WinAnsiEncoding2Bytes  %% hem convertit la taula WinAnsiEncoding a 2ByteHexa/NomDelCaracter (veure UnicodeadobeglyphlistXwinAnsi.ps)
<<(0020) /space (0021) /exclam (0022) /quotedbl (0023) /numbersign (0024) /dollar (0025) /percent (0026) /ampersand (0027) /quotesingle (0028) /parenleft (0029) /parenright (002a) /asterisk (002b) /plus (002c) /comma (2212) /hyphen (002e) /period (002f) /slash (0030) /zero (0031) /one (0032) /two (0033) /three (0034) /four (0035) /five (0036) /six (0037) /seven (0038) /eight (0039) /nine (003a) /colon (003b) /semicolon (003c) /less (003d) /equal (003e) /greater (003f) /question (0040) /at (0041) /A (0042) /B (0043) /C (0044) /D (0045) /E (0046) /F (0047) /G (0048) /H (0049) /I (004a) /J (004b) /K (004c) /L (004d) /M (004e) /N (004f) /O (0050) /P (0051) /Q (0052) /R (0053) /S (0054) /T (0055) /U (0056) /V (0057) /W (0058) /X (0059) /Y (005a) /Z (005b) /bracketleft (005c) /backslash (005d) /bracketright (005e) /asciicircum (005f) /underscore (0060) /grave (0061) /a (0062) /b (0063) /c (0064) /d (0065) /e (0066) /f (0067) /g (0068) /h (0069) /i (006a) /j (006b) /k (006c) /l (006d) /m (006e) /n (006f) /o (0070) /p (0071) /q (0072) /r (0073) /s (0074) /t (0075) /u (0076) /v (0077) /w (0078) /x (0079) /y (007a) /z (007b) /braceleft (007c) /bar (007d) /braceright (007e) /asciitilde (2022) /bullet (20ac) /Euro (2022) /bullet (201a) /quotesinglbase (0192) /florin (201e) /quotedblbase (2026) /ellipsis (2020) /dagger (2021) /daggerdbl (02c6) /circumflex (2030) /perthousand (0160) /Scaron (2039) /guilsinglleft (0152) /OE (2022) /bullet (017d) /Zcaron (2022) /bullet (2022) /bullet (2018) /quoteleft (2019) /quoteright (201c) /quotedblleft (201d) /quotedblright (2022) /bullet (2013) /endash (2014) /emdash (2122) /trademark (0161) /scaron (203a) /guilsinglright (0153) /oe (2022) /bullet (017e) /zcaron (0178) /Ydieresis (0020) /space (00a1) /exclamdown (00a2) /cent (00a3) /sterling (00a4) /currency (00a5) /yen (00a6) /brokenbar (00a7) /section (00a8) /dieresis (00a9) /copyright (00aa) /ordfeminine (00ab) /guillemotleft (00ac) /logicalnot (002d) /hyphen (00ae) /registered (00af) /macron (00b0) /degree (00b1) /plusminus (00b2) /twosuperior (00b3) /threesuperior (00b4) /acute (00b5) /mu (00b6) /paragraph (00b8) /cedilla (00b9) /onesuperior (00ba) /ordmasculine (00bb) /guillemotright (00bc) /onequarter (00bd) /onehalf (00be) /threequarters (00bf) /questiondown (00c0) /Agrave (00c1) /Aacute (00c2) /Acircumflex (00c3) /Atilde (00c4) /Adieresis (00c5) /Aring (00c6) /AE (00c7) /Ccedilla (00c8) /Egrave (00c9) /Eacute (00ca) /Ecircumflex (00cb) /Edieresis (00cc) /Igrave (00cd) /Iacute (00ce) /Icircumflex (00cf) /Idieresis (00d0) /Eth (00d1) /Ntilde (00d2) /Ograve (00d3) /Oacute (00d4) /Ocircumflex (00d5) /Otilde (00d6) /Odieresis (00d7) /multiply (00d8) /Oslash (00d9) /Ugrave (00da) /Uacute (00db) /Ucircumflex (00dc) /Udieresis (00dd) /Yacute (00de) /Thorn (00df) /germandbls (00e0) /agrave (00e1) /aacute (00e2) /acircumflex (00e3) /atilde (00e4) /adieresis (00e5) /aring (00e6) /ae (00e7) /ccedilla (00e8) /egrave (00e9) /eacute (00ea) /ecircumflex (00eb) /edieresis (00ec) /igrave (00ed) /iacute (00ee) /icircumflex (00ef) /idieresis (00f0) /eth (00f1) /ntilde (00f2) /ograve (00f3) /oacute (00f4) /ocircumflex (00f5) /otilde (00f6) /odieresis (00f7) /divide (00f8) /oslash (00f9) /ugrave (00fa) /uacute (00fb) /ucircumflex (00fc) /udieresis (00fd) /yacute (00fe) /thorn (00ff) /ydieresis>>
def
/WinAnsiEncoding2Identity-H
%% aquest xifrat (q no s'ha d'on ha sortit) es incorrecte
%%[/.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quotesingle /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one /two /three /four /five /six /seven /eight /nine /colon /semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright /asciitilde /bullet /Euro /bullet /quotesinglbase /florin /quotedblbase /ellipsis /dagger /daggerdbl /circumflex /perthousand /Scaron /guilsinglleft /OE /bullet /Zcaron /bullet /bullet /quoteleft /quoteright /quotedblleft /quotedblright /bullet /endash /emdash /trademark /scaron /guilsinglright /oe /bullet /zcaron /Ydieresis /space /exclamdown /cent /sterling /currency /yen /brokenbar /section /dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron /degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters  /questiondown /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla /Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis /eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis]
%% aquest altre xifrat l'hem deduit amb ... l'algorisme empaquetemIdentity_H.ps
%% llegint directament i dexifrant el recurs CMap Identity-H
[/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quotesingle /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one /two /three /four /five /six /seven /eight /nine /colon /semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright /asciitilde /bullet /Euro /bullet /quotesinglbase /florin /quotedblbase /ellipsis /dagger /daggerdbl /circumflex /perthousand /Scaron /guilsinglleft /OE /bullet /Zcaron /bullet /bullet /quoteleft /quoteright /quotedblleft /quotedblright /bullet /endash /emdash /tilde /trademark /scaron /guilsinglright /oe /bullet /zcaron /Ydieresis /space /exclamdown /cent /sterling /currency /yen /brokenbar /section /dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron /degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla /Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis /eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis]
def
/PDFDocEncoding  %% encoding de lectura de les cadenes de text (de fet tots els strings no streams de PDF) pero ara l'utilitzem pel Nom de les Layers
[/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /breve /caron /circumflex /dotaccent /hungarumlaut /ogonek /ring /tilde /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quotesingle /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one /two /three /four /five /six /seven /eight /nine /colon /semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright /asciitilde /.notdef /bullet /dagger /daggerdbl /ellipsis /emdash /endash /florin /fraction /guilsinglleft /guilsinglright /minus /perthousand /quotedblbase /quotedblleft /quotedblright /quoteleft /quoteright /quotesinglbase /trademark /fi /fl /Lslash /OE /Scaron /Ydieresis /Zcaron /dotlessi /lslash /oe /scaron /zcaron /.notdef /Euro /exclamdown /cent /sterling /currency /yen /brokenbar /section /dieresis /copyright /ordfeminine /guillemotleft /logicalnot /.notdef /registered /macron /degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla /Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis /eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis]
def
%% els PDF Predefined Font Encodings hi son tots?
/MacRomanEncoding
[/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quotesingle /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one /two /three /four /five /six /seven /eight /nine /colon /semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute /Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis /atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis /iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve /ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex /udieresis /dagger /degree /cent /sterling /section /bullet /paragraph /germandbls /registered /copyright /trademark /acute /dieresis /.notdef /AE /Oslash /.notdef /plusminus /.notdef /.notdef /yen /mu /.notdef /.notdef /.notdef /.notdef /.notdef /ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown /exclamdown /logicalnot /.notdef /florin /.notdef /.notdef /guillemotleft /guillemotright /ellipsis /space /Agrave /Atilde /Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright /quoteleft /quoteright /divide /.notdef /ydieresis /Ydieresis /fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl /periodcentered /quotesinglbase /quotedblbase /perthousand /Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute /Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve /Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron /breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron]
def
/MacExpertEncoding
[/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /space /exclamsmall /Hungarumlautsmall /centoldstyle /dollaroldstyle /dollarsuperior /ampersandsmall /Acutesmall /parenleftsuperior /parenrightsuperior /twodotenleader /onedotenleader /comma /hyphen /period /fraction /zerooldstyle /oneoldstyle /twooldstyle /threeoldstyle /fouroldstyle /fiveoldstyle /sixoldstyle /sevenoldstyle /eightoldstyle /nineoldstyle /colon /semicolon /.notdef /threequartersemdash /.notdef /questionsmall /.notdef /.notdef /.notdef /.notdef /Ethsmall /.notdef /.notdef /onequarter /onehalf /threequarters /oneeighth /threeeighths /fiveeighths /seveneighths /onethird /twothirds /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /ff /fi /fl /ffi /ffl /parenleftinferior /.notdef /parenrightinferior /Circumflexsmall /hypheninferior /Gravesmall /Asmall /Bsmall /Csmall /Dsmall /Esmall /Fsmall /Gsmall /Hsmall /Ismall /Jsmall /Ksmall /Lsmall /Msmall /Nsmall /Osmall /Psmall /Qsmall /Rsmall /Ssmall /Tsmall /Usmall /Vsmall /Wsmall /Xsmall /Ysmall /Zsmall /colonmonetary /onefitted /rupiah /Tildesmall /.notdef /.notdef /asuperior /centsuperior /.notdef /.notdef /.notdef /.notdef /Aacutesmall /Agravesmall /Acircumflexsmall /Adieresissmall /Atildesmall /Aringsmall /Ccedillasmall /Eacutesmall /Egravesmall /Ecircumflexsmall /Edieresissmall /Iacutesmall /Igravesmall /Icircumflexsmall /Idieresissmall /Ntildesmall /Oacutesmall /Ogravesmall /Ocircumflexsmall /Odieresissmall /Otildesmall /Uacutesmall /Ugravesmall /Ucircumflexsmall /Udieresissmall /.notdef /eightsuperior /fourinferior /threeinferior /sixinferior /eightinferior /seveninferior /Scaronsmall /.notdef /centinferior /twoinferior /.notdef /Dieresissmall /.notdef /Caronsmall /osuperior /fiveinferior /.notdef /commainferior /periodinferior /Yacutesmall /.notdef /dollarinferior /.notdef /.notdef /Thornsmall /.notdef /nineinferior /zeroinferior /Zcaronsmall /AEsmall /Oslashsmall /questiondownsmall /oneinferior /Lslashsmall /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /Cedillasmall /.notdef /.notdef /.notdef /.notdef /.notdef /OEsmall /figuredash /hyphensuperior /.notdef /.notdef /.notdef /.notdef /exclamdownsmall /.notdef /Ydieresissmall /.notdef /onesuperior /twosuperior /threesuperior /foursuperior /fivesuperior /sixsuperior /sevensuperior /ninesuperior /zerosuperior /.notdef /esuperior /rsuperior /tsuperior /.notdef /.notdef /isuperior /ssuperior /dsuperior /.notdef /.notdef /.notdef /.notdef /.notdef /lsuperior /Ogoneksmall /Brevesmall /Macronsmall /bsuperior /nsuperior /msuperior /commasuperior /periodsuperior /Dotaccentsmall /Ringsmall /.notdef /.notdef /.notdef /.notdef]
def
/GIDEncoding
[ /.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one /two /three /four /five /six /seven /eight /nine /colon /semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore /quoteleft /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright /asciitilde /exclamdown /cent /sterling /fraction /yen /florin /section /currency /quotesingle /quotedblleft /guillemotleft /guilsinglleft /guilsinglright /fi /fl /endash /dagger /daggerdbl /periodcentered /paragraph /bullet /quotesinglbase /quotedblbase /quotedblright /guillemotright /ellipsis /perthousand /questiondown /grave /acute /circumflex /tilde /macron /breve /dotaccent /dieresis /ring /cedilla /hungarumlaut /ogonek /caron /emdash /AE /ordfeminine /Lslash /Oslash /OE /ordmasculine /ae /dotlessi /lslash /oslash /oe /germandbls /onesuperior /logicalnot /mu /trademark /Eth /onehalf /plusminus /Thorn /onequarter /divide /brokenbar /degree /thorn /threequarters /twosuperior /registered /minus /eth /multiply /threesuperior /copyright /Aacute /Acircumflex /Adieresis /Agrave /Aring /Atilde /Ccedilla /Eacute /Ecircumflex /Edieresis /Egrave /Iacute /Icircumflex /Idieresis /Igrave /Ntilde /Oacute /Ocircumflex /Odieresis /Ograve /Otilde /Scaron /Uacute /Ucircumflex /Udieresis /Ugrave /Yacute /Ydieresis /Zcaron /aacute /acircumflex /adieresis /agrave /aring /atilde /ccedilla /eacute /ecircumflex /edieresis /egrave /iacute /icircumflex /idieresis /igrave /ntilde /oacute /ocircumflex /odieresis /ograve /otilde /scaron /uacute /ucircumflex /udieresis /ugrave /yacute /ydieresis /zcaron /exclamsmall /Hungarumlautsmall /dollaroldstyle /dollarsuperior /ampersandsmall /Acutesmall /parenleftsuperior /parenrightsuperior /twodotenleader /onedotenleader /zerooldstyle /oneoldstyle /twooldstyle /threeoldstyle /fouroldstyle /fiveoldstyle /sixoldstyle /sevenoldstyle /eightoldstyle /nineoldstyle /commasuperior /threequartersemdash /periodsuperior /questionsmall /asuperior /bsuperior /centsuperior /dsuperior /esuperior /isuperior /lsuperior /msuperior /nsuperior /osuperior /rsuperior /ssuperior /tsuperior /ff /ffi /ffl /parenleftinferior /parenrightinferior /Circumflexsmall /hyphensuperior /Gravesmall /Asmall /Bsmall /Csmall /Dsmall /Esmall /Fsmall /Gsmall /Hsmall /Ismall /Jsmall /Ksmall /Lsmall /Msmall /Nsmall /Osmall /Psmall /Qsmall /Rsmall /Ssmall /Tsmall /Usmall /Vsmall /Wsmall /Xsmall /Ysmall /Zsmall /colonmonetary /onefitted /rupiah /Tildesmall /exclamdownsmall /centoldstyle /Lslashsmall /Scaronsmall /Zcaronsmall /Dieresissmall /Brevesmall /Caronsmall /Dotaccentsmall /Macronsmall /figuredash /hypheninferior /Ogoneksmall /Ringsmall /Cedillasmall /questiondownsmall /oneeighth /threeeighths /fiveeighths /seveneighths /onethird /twothirds /zerosuperior /foursuperior /fivesuperior /sixsuperior /sevensuperior /eightsuperior /ninesuperior /zeroinferior /oneinferior /twoinferior /threeinferior /fourinferior /fiveinferior /sixinferior /seveninferior /eightinferior /nineinferior /centinferior /dollarinferior /periodinferior /commainferior /Agravesmall /Aacutesmall /Acircumflexsmall /Atildesmall /Adieresissmall /Aringsmall /AEsmall /Ccedillasmall /Egravesmall /Eacutesmall /Ecircumflexsmall /Edieresissmall /Igravesmall /Iacutesmall /Icircumflexsmall /Idieresissmall /Ethsmall /Ntildesmall /Ogravesmall /Oacutesmall /Ocircumflexsmall /Otildesmall /Odieresissmall /OEsmall /Oslashsmall /Ugravesmall /Uacutesmall /Ucircumflexsmall /Udieresissmall /Yacutesmall /Thornsmall /Ydieresissmall /001.000 /001.001 /001.002 /001.003 /Black /Bold /Book /Light /Medium /Regular /Roman /Semibold ]
def
%% encoding de tipus privat que es pot personalitzar segons necessitats
%% el vam canviar a WinAnsi per contemplar el cas del fitxer d'AD 02001004.pdf
/SMBLCEncoding
[ /.notdef /.notdef /.notdef  /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one /two /three /four /five /six /seven /eight /nine /colon /semicolon /less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore /quoteleft /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright /asciitilde /exclamdown /cent /sterling /fraction /yen /florin /section /currency /quotesingle /quotedblleft /guillemotleft /guilsinglleft /guilsinglright /fi /fl /endash /dagger /daggerdbl /periodcentered /paragraph /bullet /quotesinglbase /quotedblbase /quotedblright /guillemotright /ellipsis /perthousand /questiondown /grave /acute /circumflex /tilde /macron /breve /dotaccent /dieresis /ring /cedilla /hungarumlaut /ogonek /caron /emdash /AE /ordfeminine /Lslash /Oslash /OE /ordmasculine /ae /dotlessi /lslash /oslash /oe /germandbls /onesuperior /logicalnot /mu /trademark /Eth /onehalf /plusminus /Thorn /onequarter /divide /brokenbar /degree /thorn /threequarters /twosuperior /registered /minus /eth /multiply /threesuperior /copyright /Aacute /Acircumflex /Adieresis /Agrave /Aring /Atilde /Ccedilla /Eacute /Ecircumflex /Edieresis /Egrave /Iacute /Icircumflex /Idieresis /Igrave /Ntilde /Oacute /Ocircumflex /Odieresis /Ograve /Otilde /Scaron /Uacute /Ucircumflex /Udieresis /Ugrave /Yacute /Ydieresis /Zcaron /aacute /acircumflex /adieresis /agrave /aring /atilde /ccedilla /eacute /ecircumflex /edieresis /egrave /iacute /icircumflex /idieresis /igrave /ntilde /oacute /ocircumflex /odieresis /ograve /otilde /scaron /uacute /ucircumflex /udieresis /ugrave /yacute /ydieresis /zcaron /exclamsmall /Hungarumlautsmall /dollaroldstyle /dollarsuperior /ampersandsmall /Acutesmall /parenleftsuperior /parenrightsuperior /twodotenleader /onedotenleader /zerooldstyle /oneoldstyle /twooldstyle /threeoldstyle /fouroldstyle /fiveoldstyle /sixoldstyle /sevenoldstyle /eightoldstyle /nineoldstyle /commasuperior /threequartersemdash /periodsuperior /questionsmall /asuperior /bsuperior /centsuperior /dsuperior /esuperior /isuperior /lsuperior /msuperior /nsuperior /osuperior /rsuperior /ssuperior /tsuperior /ff /ffi /ffl /parenleftinferior /parenrightinferior /Circumflexsmall /hyphensuperior /Gravesmall /Asmall /Bsmall /Csmall /Dsmall /Esmall /Fsmall /Gsmall /Hsmall /Ismall /Jsmall /Ksmall /Lsmall /Msmall /Nsmall /Osmall /Psmall /Qsmall /Rsmall /Ssmall /Tsmall /Usmall /Vsmall /Wsmall /Xsmall /Ysmall /Zsmall /colonmonetary /onefitted /rupiah /Tildesmall /exclamdownsmall /centoldstyle /Lslashsmall /Scaronsmall /Zcaronsmall /Dieresissmall /Brevesmall /Caronsmall /Dotaccentsmall /Macronsmall /figuredash /hypheninferior /Ogoneksmall /Ringsmall /Cedillasmall /questiondownsmall /oneeighth /threeeighths /fiveeighths /seveneighths /onethird /twothirds /zerosuperior /foursuperior /fivesuperior /sixsuperior /sevensuperior /eightsuperior /ninesuperior /zeroinferior /oneinferior /twoinferior /threeinferior /fourinferior /fiveinferior /sixinferior /seveninferior /eightinferior /nineinferior /centinferior /dollarinferior /periodinferior /commainferior /Agravesmall /Aacutesmall /Acircumflexsmall /Atildesmall /Adieresissmall /Aringsmall /AEsmall /Ccedillasmall /Egravesmall /Eacutesmall /Ecircumflexsmall /Edieresissmall /Igravesmall /Iacutesmall /Icircumflexsmall /Idieresissmall /Ethsmall /Ntildesmall /Ogravesmall /Oacutesmall /Ocircumflexsmall /Otildesmall /Odieresissmall /OEsmall /Oslashsmall /Ugravesmall /Uacutesmall /Ucircumflexsmall /Udieresissmall /Yacutesmall /Thornsmall /Ydieresissmall /001.000 /001.001 /001.002 /001.003 /Black /Bold /Book /Light /Medium /Regular /Roman /Semibold ]
def
%% EP! mancaria definir un encoding per la ZapfDingbats ??
%% EP! si fes falta hi ha el dic /NomsAdobeGlyphList a ... FF_Coromines_ieDiBa_008.ps
%% amb l'Adobe Glyph List sencera (nom literal/string unicode)
%% i tambe dins el GS podem cridar-la amb ... systemdict /AdobeGlyphList get (nom literal/integer unicode)
%% test x fi
%%systemdict /AdobeGlyphList get
%% /fi get rengsDtext (w) file dup 3 -1 roll write closefile quit
%% /PDFDocEncoding2Bytes  % hem convertit la taula PDFDocEncoding a 2ByteHexa/NomDelCaracter
%%<<
%%(0000) /.notdef (0001) /.notdef (0002) /.notdef (0003) /.notdef (0004) /.notdef (0005) /.notdef (0006) /.notdef (0007) /.notdef (0008) /.notdef (0009) /.notdef (000a) /.notdef (000b) /.notdef (000c) /.notdef (000d) /.notdef (000e) /.notdef (000f) /.notdef (0010) /.notdef (0011) /.notdef (0012) /.notdef (0013) /.notdef (0014) /.notdef (0015) /.notdef (0016) /.notdef (0017) /.notdef (0018) /breve (0019) /caron (001a) /circumflex (001b) /dotaccent (001c) /hungarumlaut (001d) /ogonek (001e) /ring (001f) /tilde (0020) /space (0021) /exclam (0022) /quotedbl (0023) /numbersign (0024) /dollar (0025) /percent (0026) /ampersand (0027) /quoteright (0028) /parenleft (0029) /parenright (002a) /asterisk (002b) /plus (002c) /comma (002d) /minus (002e) /period (002f) /slash (0030) /zero (0031) /one (0032) /two (0033) /three (0034) /four (0035) /five (0036) /six (0037) /seven (0038) /eight (0039) /nine (003a) /colon (003b) /semicolon (003c) /less (003d) /equal (003e) /greater (003f) /question (0040) /at (0041) /A (0042) /B (0043) /C (0044) /D (0045) /E (0046) /F (0047) /G (0048) /H (0049) /I (004a) /J (004b) /K (004c) /L (004d) /M (004e) /N (004f) /O (0050) /P (0051) /Q (0052) /R (0053) /S (0054) /T (0055) /U (0056) /V (0057) /W (0058) /X (0059) /Y (005a) /Z (005b) /bracketleft (005c) /backslash (005d) /bracketright (005e) /asciicircum (005f) /underscore (0060) /quoteleft (0061) /a (0062) /b (0063) /c (0064) /d (0065) /e (0066) /f (0067) /g (0068) /h (0069) /i (006a) /j (006b) /k (006c) /l (006d) /m (006e) /n (006f) /o (0070) /p (0071) /q (0072) /r (0073) /s (0074) /t (0075) /u (0076) /v (0077) /w (0078) /x (0079) /y (007a) /z (007b) /braceleft (007c) /bar (007d) /braceright (007e) /asciitilde (007f) /.notdef (0080) /bullet (0081) /dagger (0082) /daggerdbl (0083) /ellipsis (0084) /emdash (0085) /endash (0086) /florin (0087) /fraction (0088) /guilsinglleft (0089) /guilsinglright (008a) /minus (008b) /perthousand (008c) /quotedblbase (008d) /quotedblleft (008e) /quotedblright (008f) /quoteleft (0090) /quoteright (0091) /quotesinglbase (0092) /trademark (0093) /fi (0094) /fl (0095) /Lslash (0096) /OE (0097) /Scaron (0098) /Ydieresis (0099) /Zcaron (009a) /dotlessi (009b) /lslash (009c) /oe (009d) /scaron (009e) /zcaron (009f) /.notdef (00a0) /Euro (00a1) /exclamdown (00a2) /cent (00a3) /sterling (00a4) /currency (00a5) /yen (00a6) /brokenbar (00a7) /section (00a8) /dieresis (00a9) /copyright (00aa) /ordfeminine (00ab) /guillemotleft (00ac) /logicalnot (00ad) /.notdef (00ae) /registered (00af) /macron (00b0) /degree (00b1) /plusminus (00b2) /twosuperior (00b3) /threesuperior (00b4) /acute (00b5) /mu (00b6) /paragraph (00b7) /periodcentered (00b8) /cedilla (00b9) /onesuperior (00ba) /ordmasculine (00bb) /guillemotright (00bc) /onequarter (00bd) /onehalf (00be) /threequarters (00bf) /questiondown (00c0) /Agrave (00c1) /Aacute (00c2) /Acircumflex (00c3) /Atilde (00c4) /Adieresis (00c5) /Aring (00c6) /AE (00c7) /Ccedilla (00c8) /Egrave (00c9) /Eacute (00ca) /Ecircumflex (00cb) /Edieresis (00cc) /Igrave (00cd) /Iacute (00ce) /Icircumflex (00cf) /Idieresis (00d0) /Eth (00d1) /Ntilde (00d2) /Ograve (00d3) /Oacute (00d4) /Ocircumflex (00d5) /Otilde (00d6) /Odieresis (00d7) /multiply (00d8) /Oslash (00d9) /Ugrave (00da) /Uacute (00db) /Ucircumflex (00dc) /Udieresis (00dd) /Yacute (00de) /Thorn (00df) /germandbls (00e0) /agrave (00e1) /aacute (00e2) /acircumflex (00e3) /atilde (00e4) /adieresis (00e5) /aring (00e6) /ae (00e7) /ccedilla (00e8) /egrave (00e9) /eacute (00ea) /ecircumflex (00eb) /edieresis (00ec) /igrave (00ed) /iacute (00ee) /icircumflex (00ef) /idieresis (00f0) /eth (00f1) /ntilde (00f2) /ograve (00f3) /oacute (00f4) /ocircumflex (00f5) /otilde (00f6) /odieresis (00f7) /divide (00f8) /oslash (00f9) /ugrave (00fa) /uacute (00fb) /ucircumflex (00fc) /udieresis (00fd) /yacute (00fe) /thorn (00ff) /ydieresis 
%%>> def

QueLiFemFer 3 eq  %:03 CORRECTOR TIPOGRÀFIC
QueLiFemFer 4 eq  %:04 ANÀLISI TEXTUAL
QueLiFemFer 5 eq  %:05 dada variable
QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
QueLiFemFer 12 eq  %:12 arbre jeràrquic
QueLiFemFer 16 eq  %:16 cerca i substitució de text
or or or or or
{
 %#%20bis% mòdul d'anàlisi i extracció de text
 (%#%20bis%)==
 
 %%% CAL VEURE COM ADAPTEM AIXO PEL PROJECTE DE JBC
 %%% diccionari de substitucio sofisticada de caracters en cas de no existir
 %%% encara queden entrar alguns caracters de WinAnsi que no existeixen
 %%% queden per entrar tots els de la font ZapfDingbats que puguin tenir equivalencies
 %%% queden per entrar alguns de la font Symbol que puguin tenir equivalencies
 /SOFIglyphs
 <<
   /dotaccent (--)
   /quotedblbase (,,)
   /quotesinglbase (,)
   /quotedblleft (")
   /quotedblright (")
   /quoteleft (')
   /quoteright (')
   /emdash (--)
   /endash (-)
   /minus (-)  %% afegit x JBC
   /copyright (\(c\))
   /registered (\(r\))
   /ffl (ffl)
   /ffi (ffi)
   /ff (ff)
   /fi (fi)
   /fl (fl)
   /guillemotleft (<<)
   /guillemotright (>>)
   /bullet ( )
   /periodcentered (.)
   /oe (oe)
   /OE (OE)
   /AE (AE)
   /ae (ae)
   /NUL ( )  %% cal esbrinar perque s'activa aquest caracter al PDF casiàjust..pdf i l'utilitza per espai en blanc
   /breve (-)
   /circumflex (')
   /tilde (-)
   /Euro.037 (EUR)
   /Euro (EUR)
 >> def

 %%% repicat d'alguns caracters per la seva compatibilitat/llegibilitat d'ascii pur
 %%% s'ha de fer al Mac encoding tambe pero ara de moment nomes ho fem per Win (tema AD)

 /Win2AsciiPur
 {	   %% com que aquest nom de caracter sera desconegut ...
  dup 132 /_SOFIglyphs put  %% desviem a SOFIglyphs /quotedblbase
  dup 147 /_SOFIglyphs put  %% desviem a SOFIglyphs /quotedblleft
  dup 148 /_SOFIglyphs put  %% desviem a SOFIglyphs /quotedblright
  dup 145 /_SOFIglyphs put  %% desviem a SOFIglyphs /quoteleft
  dup 146 /_SOFIglyphs put  %% desviem a SOFIglyphs /quoteright
  dup 130 /_SOFIglyphs put  %% desviem a SOFIglyphs /quotesinglbase
  dup 151 /_SOFIglyphs put  %% desviem a SOFIglyphs /emdash
  dup 150 /_SOFIglyphs put  %% desviem a SOFIglyphs /endash
  dup 169 /_SOFIglyphs put  %% desviem a SOFIglyphs /copyright
  dup 174 /_SOFIglyphs put  %% desviem a SOFIglyphs /registered
  dup 171 /_SOFIglyphs put  %% desviem a SOFIglyphs /guillemotleft
  dup 187 /_SOFIglyphs put  %% desviem a SOFIglyphs /guillemotright
  dup 127 /space put  %% (/bullet) en blanc
  dup 128 /space put  %% (/bullet) en blanc
  dup 129 /space put  %% (/bullet) en blanc
  dup 141 /space put  %% (/bullet) en blanc
  dup 142 /space put  %% (/bullet) en blanc
  dup 143 /space put  %% (/bullet) en blanc
  dup 144 /space put  %% (/bullet) en blanc
  dup 149 /_SOFIglyphs put  %% desviem a SOFIglyphs /bullet
  dup 157 /space put  %% (/bullet) en blanc
  dup 158 /space put  %% (/bullet) en blanc
  dup 183 /_SOFIglyphs put  %% desviem a SOFIglyphs /periodcentered
  dup 156 /_SOFIglyphs put  %% desviem a SOFIglyphs /oe
  dup 140 /_SOFIglyphs put  %% desviem a SOFIglyphs /OE
  dup 198 /_SOFIglyphs put  %% desviem a SOFIglyphs /AE
  dup 230 /_SOFIglyphs put  %% desviem a SOFIglyphs /ae
  dup 136 /_SOFIglyphs put  %% desviem a SOFIglyphs /circumflex
  dup 152 /_SOFIglyphs put  %% desviem a SOFIglyphs /tilde
 } bind def

 userdict /WinAnsiEncoding get 256 array copy  %% posem l'encoding del SO a la pila (mes endavant hi haura d'anar una funcio que posi automaticament l'encoding del SO (Win Mac o Unix)
 %%% executem la funcio per activar el diccionari de substitucio sofisticada
 Win2AsciiPur /traductorEncoding exch def
 %%% fi CAL VEURE COM ADAPTEM AIXO PEL PROJECTE DE JBC

 %% KTCS diccionari detector de linies (rengs)
 <<
   /iniciXreng 0  %% posicio X d'inici del reng
   /iniciYreng 0  %% posicio Y d'inici del reng
   /finalXreng 0  %% posicio X final del reng
   /finalYreng 0  %% posicio Y final del reng
   /Ulinia []  %% paquet on desarem totes les cadenes (o arrays?) de text que detectem pertanyin a una mateixa linia
   /Linies []  %% paquet on desarem (els index quadraran amb capLpeus) totes les linies detectades (dins una array cadascuna)
   /capLpeus []  %% paquet on desarem (els index quadraran amb Linies) totes les 4 coordenades (dins una array de 4 posicions) dels inici i final de cada linia
   /Areng true  %% gatell per saber si encara estem dins el mateix reng (caldra?)
   /Cinyell 0  %% maxim valor detectat (dins una mateixa linia) d'ample de caracter (de l'inici d'un caracter a l'inici del proper) amb tots els seus espaiats addicionals!
   /MesEnlla 0  %% maxima posicio X admesa pel proper caracter (llavors trencarem la linia i caldra utilitzar el flag)
   /Ylinia 0  %% valor actual de la posicio Y de la linia
 >> /ReNG exch def

 %% x JBC
 %% aquí desarem, pàgina a pàgina, les posicions Y de tots els rengs de text diferents (clau),
 %% on el seu valor serà una array amb cinc elements:
 %% 0: el primer, una array que contindrà una array per a cada caràcter amb les posicions:
 %% índex 0: coordenada X d'inici del caràcter (mesurada en horitzontal)
 %% índex 1: coordenada X de final del caràcter: el seu Width sumat (mesurada en horitzontal)
 %% índex 2: coordenada real X d'inici del caràcter (punt de línia de base corregit a l'eix no rotat)
 %% índex 3: coordenada real Y d'inici del caràcter (punt de línia de base corregit a l'eix no rotat)
 %% índex 4: coordenada real X de final del caràcter (punt de línia de base corregit a l'eix no rotat)
 %% índex 5: coordenada real Y de final del caràcter (punt de línia de base corregit a l'eix no rotat)
 %% ... si hi ha una separació (espai o no) en comptes d'array contindrà un null
 %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
 %% correctament on, si hi hagués una separació (espai o no), contindria un null
 %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
 %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
 %% 4: el cinquè, ens indica si la línia és rotada (null=NO angle=SI)
 
 << >> /yRENGS exch def

 %% detector d'amplada fixa (Fixed Width o Fixed Pitch)
 /mqndscrr false def

 %% Font Descriptor Flags (seccio 5.7.1 de la PDF Reference 1.7)
 /FlagsFontDescriptor
 [  %% posicio del bit (aixo no es un index!)
  {(FixedPitch ... Font Descriptor Flag 1\n) print flush /mqndscrr true def}	 %% 1
 %% {(\n\nMRCTstatus 101\n) print flush}
  {(Serif ... Font Descriptor Flag 2\n) print flush}  %% 2
 %% {(\n\nMRCTstatus 102\n) print flush}
  {(Symbolic ... Font Descriptor Flag 3\n) print flush /SMBLC true def}  %% 3
 %% {(\n\nMRCTstatus 103\n) print flush}
  {(Script ... Font Descriptor Flag 4\n) print flush}  %% 4
 %% {(\n\nMRCTstatus 104\n) print flush}
  {(Reserved ... Font Descriptor Flag 5\n) print flush}  %% 5
 %% {(\n\nMRCTstatus 105\n) print flush}
  {(Nonsymbolic ... Font Descriptor Flag 6\n) print flush /SMBLC false def}  %% 6
 %% {(\n\nMRCTstatus 106\n) print flush}
  {(Italic ... Font Descriptor Flag 7\n) print flush}  %% 7
 %% {(\n\nMRCTstatus 107\n) print flush}
  {(Reserved ... Font Descriptor Flag 8\n) print flush}  %% 8
 %% {(\n\nMRCTstatus 108\n) print flush}
  {(Reserved ... Font Descriptor Flag 9\n) print flush}  %% 9
 %% {(\n\nMRCTstatus 109\n) print flush}
  {(Reserved ... Font Descriptor Flag 10\n) print flush}  %% 10
 %% {(\n\nMRCTstatus 110\n) print flush}
  {(Reserved ... Font Descriptor Flag 11\n) print flush}  %% 11
 %% {(\n\nMRCTstatus 111\n) print flush}
  {(Reserved ... Font Descriptor Flag 12\n) print flush}  %% 12
 %% {(\n\nMRCTstatus 112\n) print flush}
  {(Reserved ... Font Descriptor Flag 13\n) print flush}  %% 13
 %% {(\n\nMRCTstatus 113\n) print flush}
  {(Reserved ... Font Descriptor Flag 14\n) print flush}  %% 14
 %% {(\n\nMRCTstatus 114\n) print flush}
  {(Reserved ... Font Descriptor Flag 15\n) print flush}  %% 15
 %% {(\n\nMRCTstatus 115\n) print flush}
  {(Reserved ... Font Descriptor Flag 16\n) print flush}  %% 16
 %% {(\n\nMRCTstatus 116\n) print flush}
  {(AllCap ... Font Descriptor Flag 17\n) print flush}  %% 17
 %% {(\n\nMRCTstatus 117\n) print flush}
  {(SmallCap ... Font Descriptor Flag 18\n) print flush}  %% 18
 %% {(\n\nMRCTstatus 118\n) print flush}
  {(ForceBold ... Font Descriptor Flag 19\n) print flush}  %% 19
 %% {(\n\nMRCTstatus 119\n) print flush}
  {(Reserved ... Font Descriptor Flag 20\n) print flush}  %% 20
 %% {(\n\nMRCTstatus 120\n) print flush}
  {(Reserved ... Font Descriptor Flag 21\n) print flush}  %% 21
 %% {(\n\nMRCTstatus 121\n) print flush}
  {(Reserved ... Font Descriptor Flag 22\n) print flush}  %% 22
 %% {(\n\nMRCTstatus 122\n) print flush}
  {(Reserved ... Font Descriptor Flag 23\n) print flush}  %% 23
 %% {(\n\nMRCTstatus 123\n) print flush}
  {(Reserved ... Font Descriptor Flag 24\n) print flush}  %% 24
 %% {(\n\nMRCTstatus 124\n) print flush}
  {(Reserved ... Font Descriptor Flag 25\n) print flush}  %% 25
 %% {(\n\nMRCTstatus 125\n) print flush}
  {(Reserved ... Font Descriptor Flag 26\n) print flush}  %% 26
 %% {(\n\nMRCTstatus 126\n) print flush}
  {(Reserved ... Font Descriptor Flag 27\n) print flush}  %% 27
 %% {(\n\nMRCTstatus 127\n) print flush}
  {(Reserved ... Font Descriptor Flag 28\n) print flush}  %% 28
 %% {(\n\nMRCTstatus 128\n) print flush}
  {(Reserved ... Font Descriptor Flag 29\n) print flush}  %% 29
 %% {(\n\nMRCTstatus 129\n) print flush}
  {(Reserved ... Font Descriptor Flag 30\n) print flush}  %% 30
 %% {(\n\nMRCTstatus 130\n) print flush}
  {(Reserved ... Font Descriptor Flag 31\n) print flush}  %% 31
 %% {(\n\nMRCTstatus 131\n) print flush}
  {(Reserved ... Font Descriptor Flag 32\n) print flush}  %% 32
 %% {(\n\nMRCTstatus 132\n) print flush}
 ] def


 %% KTCS
 %% passem el paquet WinAnsi a un dic (d_WAE) per fer + rapida la cerca del codi de l'etiqueta de fusio a escriure
 /d_WAE 2 dict def
 %% aqui hi havia /WinAnsiEncoding definit (ara es definit a %20%)
 WinAnsiEncoding
 0 1 255 {dup 2 index exch get exch d_WAE 3 1 roll put}for
 pop
 %% KTCS
 %% aqui definim els diccionaris de la metrica de les 14 Core PDF fonts
 /14PDFcoreFonts 14 dict def
 14PDFcoreFonts begin
 /Symbol
 <<
   /space 250
   /exclam 333
   /universal 713
   /numbersign 500
   /existential 549
   /percent 833
   /ampersand 778
   /suchthat 439
   /parenleft 333
   /parenright 333
   /asteriskmath 500
   /plus 549
   /comma 250
   /minus 549
   /period 250
   /slash 278
   /zero 500
   /one 500
   /two 500
   /three 500
   /four 500
   /five 500
   /six 500
   /seven 500
   /eight 500
   /nine 500
   /colon 278
   /semicolon 278
   /less 549
   /equal 549
   /greater 549
   /question 444
   /congruent 549
   /Alpha 722
   /Beta 667
   /Chi 722
   /Delta 612
   /Epsilon 611
   /Phi 763
   /Gamma 603
   /Eta 722
   /Iota 333
   /theta1 631
   /Kappa 722
   /Lambda 686
   /Mu 889
   /Nu 722
   /Omicron 722
   /Pi 768
   /Theta 741
   /Rho 556
   /Sigma 592
   /Tau 611
   /Upsilon 690
   /sigma1 439
   /Omega 768
   /Xi 645
   /Psi 795
   /Zeta 611
   /bracketleft 333
   /therefore 863
   /bracketright 333
   /perpendicular 658
   /underscore 500
   /radicalex 500
   /alpha 631
   /beta 549
   /chi 549
   /delta 494
   /epsilon 439
   /phi 521
   /gamma 411
   /eta 603
   /iota 329
   /phi1 603
   /kappa 549
   /lambda 549
   /mu 576
   /nu 521
   /omicron 549
   /pi 549
   /theta 521
   /rho 549
   /sigma 603
   /tau 439
   /upsilon 576
   /omega1 713
   /omega 686
   /xi 493
   /psi 686
   /zeta 494
   /braceleft 480
   /bar 200
   /braceright 480
   /similar 549
   /Euro 750
   /Upsilon1 620
   /minute 247
   /lessequal 549
   /fraction 167
   /infinity 713
   /florin 500
   /club 753
   /diamond 753
   /heart 753
   /spade 753
   /arrowboth 1042
   /arrowleft 987
   /arrowup 603
   /arrowright 987
   /arrowdown 603
   /degree 400
   /plusminus 549
   /second 411
   /greaterequal 549
   /multiply 549
   /proportional 713
   /partialdiff 494
   /bullet 460
   /divide 549
   /notequal 549
   /equivalence 549
   /approxequal 549
   /ellipsis 1000
   /arrowvertex 603
   /arrowhorizex 1000
   /carriagereturn 658
   /aleph 823
   /Ifraktur 686
   /Rfraktur 795
   /weierstrass 987
   /circlemultiply 768
   /circleplus 768
   /emptyset 823
   /intersection 768
   /union 768
   /propersuperset 713
   /reflexsuperset 713
   /notsubset 713
   /propersubset 713
   /reflexsubset 713
   /element 713
   /notelement 713
   /angle 768
   /gradient 713
   /registerserif 790
   /copyrightserif 790
   /trademarkserif 890
   /product 823
   /radical 549
   /dotmath 250
   /logicalnot 713
   /logicaland 603
   /logicalor 603
   /arrowdblboth 1042
   /arrowdblleft 987
   /arrowdblup 603
   /arrowdblright 987
   /arrowdbldown 603
   /lozenge 494
   /angleleft 329
   /registersans 790
   /copyrightsans 790
   /trademarksans 786
   /summation 713
   /parenlefttp 384
   /parenleftex 384
   /parenleftbt 384
   /bracketlefttp 384
   /bracketleftex 384
   /bracketleftbt 384
   /bracelefttp 494
   /braceleftmid 494
   /braceleftbt 494
   /braceex 494
   /angleright 329
   /integral 274
   /integraltp 686
   /integralex 686
   /integralbt 686
   /parenrighttp 384
   /parenrightex 384
   /parenrightbt 384
   /bracketrighttp 384
   /bracketrightex 384
   /bracketrightbt 384
   /bracerighttp 494
   /bracerightmid 494
   /bracerightbt 494
   /apple 790
 >> def
 /ZapfDingbats
 <<
   /space 278
   /a1 974
   /a2 961
   /a202 974
   /a3 980
   /a4 719
   /a5 789
   /a119 790
   /a118 791
   /a117 690
   /a11 960
   /a12 939
   /a13 549
   /a14 855
   /a15 911
   /a16 933
   /a105 911
   /a17 945
   /a18 974
   /a19 755
   /a20 846
   /a21 762
   /a22 761
   /a23 571
   /a24 677
   /a25 763
   /a26 760
   /a27 759
   /a28 754
   /a6 494
   /a7 552
   /a8 537
   /a9 577
   /a10 692
   /a29 786
   /a30 788
   /a31 788
   /a32 790
   /a33 793
   /a34 794
   /a35 816
   /a36 823
   /a37 789
   /a38 841
   /a39 823
   /a40 833
   /a41 816
   /a42 831
   /a43 923
   /a44 744
   /a45 723
   /a46 749
   /a47 790
   /a48 792
   /a49 695
   /a50 776
   /a51 768
   /a52 792
   /a53 759
   /a54 707
   /a55 708
   /a56 682
   /a57 701
   /a58 826
   /a59 815
   /a60 789
   /a61 789
   /a62 707
   /a63 687
   /a64 696
   /a65 689
   /a66 786
   /a67 787
   /a68 713
   /a69 791
   /a70 785
   /a71 791
   /a72 873
   /a73 761
   /a74 762
   /a203 762
   /a75 759
   /a204 759
   /a76 892
   /a77 892
   /a78 788
   /a79 784
   /a81 438
   /a82 138
   /a83 277
   /a84 415
   /a97 392
   /a98 392
   /a99 668
   /a100 668
   /a89 390
   /a90 390
   /a93 317
   /a94 317
   /a91 276
   /a92 276
   /a205 509
   /a85 509
   /a206 410
   /a86 410
   /a87 234
   /a88 234
   /a95 334
   /a96 334
   /a101 732
   /a102 544
   /a103 544
   /a104 910
   /a106 667
   /a107 760
   /a108 760
   /a112 776
   /a111 595
   /a110 694
   /a109 626
   /a120 788
   /a121 788
   /a122 788
   /a123 788
   /a124 788
   /a125 788
   /a126 788
   /a127 788
   /a128 788
   /a129 788
   /a130 788
   /a131 788
   /a132 788
   /a133 788
   /a134 788
   /a135 788
   /a136 788
   /a137 788
   /a138 788
   /a139 788
   /a140 788
   /a141 788
   /a142 788
   /a143 788
   /a144 788
   /a145 788
   /a146 788
   /a147 788
   /a148 788
   /a149 788
   /a150 788
   /a151 788
   /a152 788
   /a153 788
   /a154 788
   /a155 788
   /a156 788
   /a157 788
   /a158 788
   /a159 788
   /a160 894
   /a161 838
   /a163 1016
   /a164 458
   /a196 748
   /a165 924
   /a192 748
   /a166 918
   /a167 927
   /a168 928
   /a169 928
   /a170 834
   /a171 873
   /a172 828
   /a173 924
   /a162 924
   /a174 917
   /a175 930
   /a176 931
   /a177 463
   /a178 883
   /a179 836
   /a193 836
   /a180 867
   /a199 867
   /a181 696
   /a200 696
   /a182 874
   /a201 874
   /a183 760
   /a184 946
   /a197 771
   /a185 865
   /a194 771
   /a198 888
   /a186 967
   /a195 888
   /a187 831
   /a188 873
   /a189 927
   /a190 970
   /a191 918
 >> def
 /Times-Roman
 <<
   /space 250
   /exclam 333
   /quotedbl 408
   /numbersign 500
   /dollar 500
   /percent 833
   /ampersand 778
   /quoteright 333
   /parenleft 333
   /parenright 333
   /asterisk 500
   /plus 564
   /comma 250
   /hyphen 333
   /period 250
   /slash 278
   /zero 500
   /one 500
   /two 500
   /three 500
   /four 500
   /five 500
   /six 500
   /seven 500
   /eight 500
   /nine 500
   /colon 278
   /semicolon 278
   /less 564
   /equal 564
   /greater 564
   /question 444
   /at 921
   /A 722
   /B 667
   /C 667
   /D 722
   /E 611
   /F 556
   /G 722
   /H 722
   /I 333
   /J 389
   /K 722
   /L 611
   /M 889
   /N 722
   /O 722
   /P 556
   /Q 722
   /R 667
   /S 556
   /T 611
   /U 722
   /V 722
   /W 944
   /X 722
   /Y 722
   /Z 611
   /bracketleft 333
   /backslash 278
   /bracketright 333
   /asciicircum 469
   /underscore 500
   /quoteleft 333
   /a 444
   /b 500
   /c 444
   /d 500
   /e 444
   /f 333
   /g 500
   /h 500
   /i 278
   /j 278
   /k 500
   /l 278
   /m 778
   /n 500
   /o 500
   /p 500
   /q 500
   /r 333
   /s 389
   /t 278
   /u 500
   /v 500
   /w 722
   /x 500
   /y 500
   /z 444
   /braceleft 480
   /bar 200
   /braceright 480
   /asciitilde 541
   /exclamdown 333
   /cent 500
   /sterling 500
   /fraction 167
   /yen 500
   /florin 500
   /section 500
   /currency 500
   /quotesingle 180
   /quotedblleft 444
   /guillemotleft 500
   /guilsinglleft 333
   /guilsinglright 333
   /fi 556
   /fl 556
   /endash 500
   /dagger 500
   /daggerdbl 500
   /periodcentered 250
   /paragraph 453
   /bullet 350
   /quotesinglbase 333
   /quotedblbase 444
   /quotedblright 444
   /guillemotright 500
   /ellipsis 1000
   /perthousand 1000
   /questiondown 444
   /grave 333
   /acute 333
   /circumflex 333
   /tilde 333
   /macron 333
   /breve 333
   /dotaccent 333
   /dieresis 333
   /ring 333
   /cedilla 333
   /hungarumlaut 333
   /ogonek 333
   /caron 333
   /emdash 1000
   /AE 889
   /ordfeminine 276
   /Lslash 611
   /Oslash 722
   /OE 889
   /ordmasculine 310
   /ae 667
   /dotlessi 278
   /lslash 278
   /oslash 500
   /oe 722
   /germandbls 500
   /Idieresis 333
   /eacute 444
   /abreve 444
   /uhungarumlaut 500
   /ecaron 444
   /Ydieresis 722
   /divide 564
   /Yacute 722
   /Acircumflex 722
   /aacute 444
   /Ucircumflex 722
   /yacute 500
   /scommaaccent 389
   /ecircumflex 444
   /Uring 722
   /Udieresis 722
   /aogonek 444
   /Uacute 722
   /uogonek 500
   /Edieresis 611
   /Dcroat 722
   /commaaccent 250
   /copyright 760
   /Emacron 611
   /ccaron 444
   /aring 444
   /Ncommaaccent 722
   /lacute 278
   /agrave 444
   /Tcommaaccent 611
   /Cacute 667
   /atilde 444
   /Edotaccent 611
   /scaron 389
   /scedilla 389
   /iacute 278
   /lozenge 471
   /Rcaron 667
   /Gcommaaccent 722
   /ucircumflex 500
   /acircumflex 444
   /Amacron 722
   /rcaron 333
   /ccedilla 444
   /Zdotaccent 611
   /Thorn 556
   /Omacron 722
   /Racute 667
   /Sacute 556
   /dcaron 588
   /Umacron 722
   /uring 500
   /threesuperior 300
   /Ograve 722
   /Agrave 722
   /Abreve 722
   /multiply 564
   /uacute 500
   /Tcaron 611
   /partialdiff 476
   /ydieresis 500
   /Nacute 722
   /icircumflex 278
   /Ecircumflex 611
   /adieresis 444
   /edieresis 444
   /cacute 444
   /nacute 500
   /umacron 500
   /Ncaron 722
   /Iacute 333
   /plusminus 564
   /brokenbar 200
   /registered 760
   /Gbreve 722
   /Idotaccent 333
   /summation 600
   /Egrave 611
   /racute 333
   /omacron 500
   /Zacute 611
   /Zcaron 611
   /greaterequal 549
   /Eth 722
   /Ccedilla 667
   /lcommaaccent 278
   /tcaron 326
   /eogonek 444
   /Uogonek 722
   /Aacute 722
   /Adieresis 722
   /egrave 444
   /zacute 444
   /iogonek 278
   /Oacute 722
   /oacute 500
   /amacron 444
   /sacute 389
   /idieresis 278
   /Ocircumflex 722
   /Ugrave 722
   /Delta 612
   /thorn 500
   /twosuperior 300
   /Odieresis 722
   /mu 500
   /igrave 278
   /ohungarumlaut 500
   /Eogonek 611
   /dcroat 500
   /threequarters 750
   /Scedilla 556
   /lcaron 344
   /Kcommaaccent 722
   /Lacute 611
   /trademark 980
   /edotaccent 444
   /Igrave 333
   /Imacron 333
   /Lcaron 611
   /onehalf 750
   /lessequal 549
   /ocircumflex 500
   /ntilde 500
   /Uhungarumlaut 722
   /Eacute 611
   /emacron 444
   /gbreve 500
   /onequarter 750
   /Scaron 556
   /Scommaaccent 556
   /Ohungarumlaut 722
   /degree 400
   /ograve 500
   /Ccaron 667
   /ugrave 500
   /radical 453
   /Dcaron 722
   /rcommaaccent 333
   /Ntilde 722
   /otilde 500
   /Rcommaaccent 667
   /Lcommaaccent 611
   /Atilde 722
   /Aogonek 722
   /Aring 722
   /Otilde 722
   /zdotaccent 444
   /Ecaron 611
   /Iogonek 333
   /kcommaaccent 500
   /minus 564
   /Icircumflex 333
   /ncaron 500
   /tcommaaccent 278
   /logicalnot 564
   /odieresis 500
   /udieresis 500
   /notequal 549
   /gcommaaccent 500
   /eth 500
   /zcaron 444
   /ncommaaccent 500
   /onesuperior 300
   /imacron 278
   /Euro 500
 >> def
 /Times-Italic
 <<
   /space 250
   /exclam 333
   /quotedbl 420
   /numbersign 500
   /dollar 500
   /percent 833
   /ampersand 778
   /quoteright 333
   /parenleft 333
   /parenright 333
   /asterisk 500
   /plus 675
   /comma 250
   /hyphen 333
   /period 250
   /slash 278
   /zero 500
   /one 500
   /two 500
   /three 500
   /four 500
   /five 500
   /six 500
   /seven 500
   /eight 500
   /nine 500
   /colon 333
   /semicolon 333
   /less 675
   /equal 675
   /greater 675
   /question 500
   /at 920
   /A 611
   /B 611
   /C 667
   /D 722
   /E 611
   /F 611
   /G 722
   /H 722
   /I 333
   /J 444
   /K 667
   /L 556
   /M 833
   /N 667
   /O 722
   /P 611
   /Q 722
   /R 611
   /S 500
   /T 556
   /U 722
   /V 611
   /W 833
   /X 611
   /Y 556
   /Z 556
   /bracketleft 389
   /backslash 278
   /bracketright 389
   /asciicircum 422
   /underscore 500
   /quoteleft 333
   /a 500
   /b 500
   /c 444
   /d 500
   /e 444
   /f 278
   /g 500
   /h 500
   /i 278
   /j 278
   /k 444
   /l 278
   /m 722
   /n 500
   /o 500
   /p 500
   /q 500
   /r 389
   /s 389
   /t 278
   /u 500
   /v 444
   /w 667
   /x 444
   /y 444
   /z 389
   /braceleft 400
   /bar 275
   /braceright 400
   /asciitilde 541
   /exclamdown 389
   /cent 500
   /sterling 500
   /fraction 167
   /yen 500
   /florin 500
   /section 500
   /currency 500
   /quotesingle 214
   /quotedblleft 556
   /guillemotleft 500
   /guilsinglleft 333
   /guilsinglright 333
   /fi 500
   /fl 500
   /endash 500
   /dagger 500
   /daggerdbl 500
   /periodcentered 250
   /paragraph 523
   /bullet 350
   /quotesinglbase 333
   /quotedblbase 556
   /quotedblright 556
   /guillemotright 500
   /ellipsis 889
   /perthousand 1000
   /questiondown 500
   /grave 333
   /acute 333
   /circumflex 333
   /tilde 333
   /macron 333
   /breve 333
   /dotaccent 333
   /dieresis 333
   /ring 333
   /cedilla 333
   /hungarumlaut 333
   /ogonek 333
   /caron 333
   /emdash 889
   /AE 889
   /ordfeminine 276
   /Lslash 556
   /Oslash 722
   /OE 944
   /ordmasculine 310
   /ae 667
   /dotlessi 278
   /lslash 278
   /oslash 500
   /oe 667
   /germandbls 500
   /Idieresis 333
   /eacute 444
   /abreve 500
   /uhungarumlaut 500
   /ecaron 444
   /Ydieresis 556
   /divide 675
   /Yacute 556
   /Acircumflex 611
   /aacute 500
   /Ucircumflex 722
   /yacute 444
   /scommaaccent 389
   /ecircumflex 444
   /Uring 722
   /Udieresis 722
   /aogonek 500
   /Uacute 722
   /uogonek 500
   /Edieresis 611
   /Dcroat 722
   /commaaccent 250
   /copyright 760
   /Emacron 611
   /ccaron 444
   /aring 500
   /Ncommaaccent 667
   /lacute 278
   /agrave 500
   /Tcommaaccent 556
   /Cacute 667
   /atilde 500
   /Edotaccent 611
   /scaron 389
   /scedilla 389
   /iacute 278
   /lozenge 471
   /Rcaron 611
   /Gcommaaccent 722
   /ucircumflex 500
   /acircumflex 500
   /Amacron 611
   /rcaron 389
   /ccedilla 444
   /Zdotaccent 556
   /Thorn 611
   /Omacron 722
   /Racute 611
   /Sacute 500
   /dcaron 544
   /Umacron 722
   /uring 500
   /threesuperior 300
   /Ograve 722
   /Agrave 611
   /Abreve 611
   /multiply 675
   /uacute 500
   /Tcaron 556
   /partialdiff 476
   /ydieresis 444
   /Nacute 667
   /icircumflex 278
   /Ecircumflex 611
   /adieresis 500
   /edieresis 444
   /cacute 444
   /nacute 500
   /umacron 500
   /Ncaron 667
   /Iacute 333
   /plusminus 675
   /brokenbar 275
   /registered 760
   /Gbreve 722
   /Idotaccent 333
   /summation 600
   /Egrave 611
   /racute 389
   /omacron 500
   /Zacute 556
   /Zcaron 556
   /greaterequal 549
   /Eth 722
   /Ccedilla 667
   /lcommaaccent 278
   /tcaron 300
   /eogonek 444
   /Uogonek 722
   /Aacute 611
   /Adieresis 611
   /egrave 444
   /zacute 389
   /iogonek 278
   /Oacute 722
   /oacute 500
   /amacron 500
   /sacute 389
   /idieresis 278
   /Ocircumflex 722
   /Ugrave 722
   /Delta 612
   /thorn 500
   /twosuperior 300
   /Odieresis 722
   /mu 500
   /igrave 278
   /ohungarumlaut 500
   /Eogonek 611
   /dcroat 500
   /threequarters 750
   /Scedilla 500
   /lcaron 300
   /Kcommaaccent 667
   /Lacute 556
   /trademark 980
   /edotaccent 444
   /Igrave 333
   /Imacron 333
   /Lcaron 611
   /onehalf 750
   /lessequal 549
   /ocircumflex 500
   /ntilde 500
   /Uhungarumlaut 722
   /Eacute 611
   /emacron 444
   /gbreve 500
   /onequarter 750
   /Scaron 500
   /Scommaaccent 500
   /Ohungarumlaut 722
   /degree 400
   /ograve 500
   /Ccaron 667
   /ugrave 500
   /radical 453
   /Dcaron 722
   /rcommaaccent 389
   /Ntilde 667
   /otilde 500
   /Rcommaaccent 611
   /Lcommaaccent 556
   /Atilde 611
   /Aogonek 611
   /Aring 611
   /Otilde 722
   /zdotaccent 389
   /Ecaron 611
   /Iogonek 333
   /kcommaaccent 444
   /minus 675
   /Icircumflex 333
   /ncaron 500
   /tcommaaccent 278
   /logicalnot 675
   /odieresis 500
   /udieresis 500
   /notequal 549
   /gcommaaccent 500
   /eth 500
   /zcaron 389
   /ncommaaccent 500
   /onesuperior 300
   /imacron 278
   /Euro 500
 >> def
 /Times-BoldItalic
 <<
   /space 250
   /exclam 389
   /quotedbl 555
   /numbersign 500
   /dollar 500
   /percent 833
   /ampersand 778
   /quoteright 333
   /parenleft 333
   /parenright 333
   /asterisk 500
   /plus 570
   /comma 250
   /hyphen 333
   /period 250
   /slash 278
   /zero 500
   /one 500
   /two 500
   /three 500
   /four 500
   /five 500
   /six 500
   /seven 500
   /eight 500
   /nine 500
   /colon 333
   /semicolon 333
   /less 570
   /equal 570
   /greater 570
   /question 500
   /at 832
   /A 667
   /B 667
   /C 667
   /D 722
   /E 667
   /F 667
   /G 722
   /H 778
   /I 389
   /J 500
   /K 667
   /L 611
   /M 889
   /N 722
   /O 722
   /P 611
   /Q 722
   /R 667
   /S 556
   /T 611
   /U 722
   /V 667
   /W 889
   /X 667
   /Y 611
   /Z 611
   /bracketleft 333
   /backslash 278
   /bracketright 333
   /asciicircum 570
   /underscore 500
   /quoteleft 333
   /a 500
   /b 500
   /c 444
   /d 500
   /e 444
   /f 333
   /g 500
   /h 556
   /i 278
   /j 278
   /k 500
   /l 278
   /m 778
   /n 556
   /o 500
   /p 500
   /q 500
   /r 389
   /s 389
   /t 278
   /u 556
   /v 444
   /w 667
   /x 500
   /y 444
   /z 389
   /braceleft 348
   /bar 220
   /braceright 348
   /asciitilde 570
   /exclamdown 389
   /cent 500
   /sterling 500
   /fraction 167
   /yen 500
   /florin 500
   /section 500
   /currency 500
   /quotesingle 278
   /quotedblleft 500
   /guillemotleft 500
   /guilsinglleft 333
   /guilsinglright 333
   /fi 556
   /fl 556
   /endash 500
   /dagger 500
   /daggerdbl 500
   /periodcentered 250
   /paragraph 500
   /bullet 350
   /quotesinglbase 333
   /quotedblbase 500
   /quotedblright 500
   /guillemotright 500
   /ellipsis 1000
   /perthousand 1000
   /questiondown 500
   /grave 333
   /acute 333
   /circumflex 333
   /tilde 333
   /macron 333
   /breve 333
   /dotaccent 333
   /dieresis 333
   /ring 333
   /cedilla 333
   /hungarumlaut 333
   /ogonek 333
   /caron 333
   /emdash 1000
   /AE 944
   /ordfeminine 266
   /Lslash 611
   /Oslash 722
   /OE 944
   /ordmasculine 300
   /ae 722
   /dotlessi 278
   /lslash 278
   /oslash 500
   /oe 722
   /germandbls 500
   /Idieresis 389
   /eacute 444
   /abreve 500
   /uhungarumlaut 556
   /ecaron 444
   /Ydieresis 611
   /divide 570
   /Yacute 611
   /Acircumflex 667
   /aacute 500
   /Ucircumflex 722
   /yacute 444
   /scommaaccent 389
   /ecircumflex 444
   /Uring 722
   /Udieresis 722
   /aogonek 500
   /Uacute 722
   /uogonek 556
   /Edieresis 667
   /Dcroat 722
   /commaaccent 250
   /copyright 747
   /Emacron 667
   /ccaron 444
   /aring 500
   /Ncommaaccent 722
   /lacute 278
   /agrave 500
   /Tcommaaccent 611
   /Cacute 667
   /atilde 500
   /Edotaccent 667
   /scaron 389
   /scedilla 389
   /iacute 278
   /lozenge 494
   /Rcaron 667
   /Gcommaaccent 722
   /ucircumflex 556
   /acircumflex 500
   /Amacron 667
   /rcaron 389
   /ccedilla 444
   /Zdotaccent 611
   /Thorn 611
   /Omacron 722
   /Racute 667
   /Sacute 556
   /dcaron 608
   /Umacron 722
   /uring 556
   /threesuperior 300
   /Ograve 722
   /Agrave 667
   /Abreve 667
   /multiply 570
   /uacute 556
   /Tcaron 611
   /partialdiff 494
   /ydieresis 444
   /Nacute 722
   /icircumflex 278
   /Ecircumflex 667
   /adieresis 500
   /edieresis 444
   /cacute 444
   /nacute 556
   /umacron 556
   /Ncaron 722
   /Iacute 389
   /plusminus 570
   /brokenbar 220
   /registered 747
   /Gbreve 722
   /Idotaccent 389
   /summation 600
   /Egrave 667
   /racute 389
   /omacron 500
   /Zacute 611
   /Zcaron 611
   /greaterequal 549
   /Eth 722
   /Ccedilla 667
   /lcommaaccent 278
   /tcaron 366
   /eogonek 444
   /Uogonek 722
   /Aacute 667
   /Adieresis 667
   /egrave 444
   /zacute 389
   /iogonek 278
   /Oacute 722
   /oacute 500
   /amacron 500
   /sacute 389
   /idieresis 278
   /Ocircumflex 722
   /Ugrave 722
   /Delta 612
   /thorn 500
   /twosuperior 300
   /Odieresis 722
   /mu 576
   /igrave 278
   /ohungarumlaut 500
   /Eogonek 667
   /dcroat 500
   /threequarters 750
   /Scedilla 556
   /lcaron 382
   /Kcommaaccent 667
   /Lacute 611
   /trademark 1000
   /edotaccent 444
   /Igrave 389
   /Imacron 389
   /Lcaron 611
   /onehalf 750
   /lessequal 549
   /ocircumflex 500
   /ntilde 556
   /Uhungarumlaut 722
   /Eacute 667
   /emacron 444
   /gbreve 500
   /onequarter 750
   /Scaron 556
   /Scommaaccent 556
   /Ohungarumlaut 722
   /degree 400
   /ograve 500
   /Ccaron 667
   /ugrave 556
   /radical 549
   /Dcaron 722
   /rcommaaccent 389
   /Ntilde 722
   /otilde 500
   /Rcommaaccent 667
   /Lcommaaccent 611
   /Atilde 667
   /Aogonek 667
   /Aring 667
   /Otilde 722
   /zdotaccent 389
   /Ecaron 667
   /Iogonek 389
   /kcommaaccent 500
   /minus 606
   /Icircumflex 389
   /ncaron 556
   /tcommaaccent 278
   /logicalnot 606
   /odieresis 500
   /udieresis 556
   /notequal 549
   /gcommaaccent 500
   /eth 500
   /zcaron 389
   /ncommaaccent 556
   /onesuperior 300
   /imacron 278
   /Euro 500
 >> def
 /Times-Bold
 <<
   /space 250
   /exclam 333
   /quotedbl 555
   /numbersign 500
   /dollar 500
   /percent 1000
   /ampersand 833
   /quoteright 333
   /parenleft 333
   /parenright 333
   /asterisk 500
   /plus 570
   /comma 250
   /hyphen 333
   /period 250
   /slash 278
   /zero 500
   /one 500
   /two 500
   /three 500
   /four 500
   /five 500
   /six 500
   /seven 500
   /eight 500
   /nine 500
   /colon 333
   /semicolon 333
   /less 570
   /equal 570
   /greater 570
   /question 500
   /at 930
   /A 722
   /B 667
   /C 722
   /D 722
   /E 667
   /F 611
   /G 778
   /H 778
   /I 389
   /J 500
   /K 778
   /L 667
   /M 944
   /N 722
   /O 778
   /P 611
   /Q 778
   /R 722
   /S 556
   /T 667
   /U 722
   /V 722
   /W 1000
   /X 722
   /Y 722
   /Z 667
   /bracketleft 333
   /backslash 278
   /bracketright 333
   /asciicircum 581
   /underscore 500
   /quoteleft 333
   /a 500
   /b 556
   /c 444
   /d 556
   /e 444
   /f 333
   /g 500
   /h 556
   /i 278
   /j 333
   /k 556
   /l 278
   /m 833
   /n 556
   /o 500
   /p 556
   /q 556
   /r 444
   /s 389
   /t 333
   /u 556
   /v 500
   /w 722
   /x 500
   /y 500
   /z 444
   /braceleft 394
   /bar 220
   /braceright 394
   /asciitilde 520
   /exclamdown 333
   /cent 500
   /sterling 500
   /fraction 167
   /yen 500
   /florin 500
   /section 500
   /currency 500
   /quotesingle 278
   /quotedblleft 500
   /guillemotleft 500
   /guilsinglleft 333
   /guilsinglright 333
   /fi 556
   /fl 556
   /endash 500
   /dagger 500
   /daggerdbl 500
   /periodcentered 250
   /paragraph 540
   /bullet 350
   /quotesinglbase 333
   /quotedblbase 500
   /quotedblright 500
   /guillemotright 500
   /ellipsis 1000
   /perthousand 1000
   /questiondown 500
   /grave 333
   /acute 333
   /circumflex 333
   /tilde 333
   /macron 333
   /breve 333
   /dotaccent 333
   /dieresis 333
   /ring 333
   /cedilla 333
   /hungarumlaut 333
   /ogonek 333
   /caron 333
   /emdash 1000
   /AE 1000
   /ordfeminine 300
   /Lslash 667
   /Oslash 778
   /OE 1000
   /ordmasculine 330
   /ae 722
   /dotlessi 278
   /lslash 278
   /oslash 500
   /oe 722
   /germandbls 556
   /Idieresis 389
   /eacute 444
   /abreve 500
   /uhungarumlaut 556
   /ecaron 444
   /Ydieresis 722
   /divide 570
   /Yacute 722
   /Acircumflex 722
   /aacute 500
   /Ucircumflex 722
   /yacute 500
   /scommaaccent 389
   /ecircumflex 444
   /Uring 722
   /Udieresis 722
   /aogonek 500
   /Uacute 722
   /uogonek 556
   /Edieresis 667
   /Dcroat 722
   /commaaccent 250
   /copyright 747
   /Emacron 667
   /ccaron 444
   /aring 500
   /Ncommaaccent 722
   /lacute 278
   /agrave 500
   /Tcommaaccent 667
   /Cacute 722
   /atilde 500
   /Edotaccent 667
   /scaron 389
   /scedilla 389
   /iacute 278
   /lozenge 494
   /Rcaron 722
   /Gcommaaccent 778
   /ucircumflex 556
   /acircumflex 500
   /Amacron 722
   /rcaron 444
   /ccedilla 444
   /Zdotaccent 667
   /Thorn 611
   /Omacron 778
   /Racute 722
   /Sacute 556
   /dcaron 672
   /Umacron 722
   /uring 556
   /threesuperior 300
   /Ograve 778
   /Agrave 722
   /Abreve 722
   /multiply 570
   /uacute 556
   /Tcaron 667
   /partialdiff 494
   /ydieresis 500
   /Nacute 722
   /icircumflex 278
   /Ecircumflex 667
   /adieresis 500
   /edieresis 444
   /cacute 444
   /nacute 556
   /umacron 556
   /Ncaron 722
   /Iacute 389
   /plusminus 570
   /brokenbar 220
   /registered 747
   /Gbreve 778
   /Idotaccent 389
   /summation 600
   /Egrave 667
   /racute 444
   /omacron 500
   /Zacute 667
   /Zcaron 667
   /greaterequal 549
   /Eth 722
   /Ccedilla 722
   /lcommaaccent 278
   /tcaron 416
   /eogonek 444
   /Uogonek 722
   /Aacute 722
   /Adieresis 722
   /egrave 444
   /zacute 444
   /iogonek 278
   /Oacute 778
   /oacute 500
   /amacron 500
   /sacute 389
   /idieresis 278
   /Ocircumflex 778
   /Ugrave 722
   /Delta 612
   /thorn 556
   /twosuperior 300
   /Odieresis 778
   /mu 556
   /igrave 278
   /ohungarumlaut 500
   /Eogonek 667
   /dcroat 556
   /threequarters 750
   /Scedilla 556
   /lcaron 394
   /Kcommaaccent 778
   /Lacute 667
   /trademark 1000
   /edotaccent 444
   /Igrave 389
   /Imacron 389
   /Lcaron 667
   /onehalf 750
   /lessequal 549
   /ocircumflex 500
   /ntilde 556
   /Uhungarumlaut 722
   /Eacute 667
   /emacron 444
   /gbreve 500
   /onequarter 750
   /Scaron 556
   /Scommaaccent 556
   /Ohungarumlaut 778
   /degree 400
   /ograve 500
   /Ccaron 722
   /ugrave 556
   /radical 549
   /Dcaron 722
   /rcommaaccent 444
   /Ntilde 722
   /otilde 500
   /Rcommaaccent 722
   /Lcommaaccent 667
   /Atilde 722
   /Aogonek 722
   /Aring 722
   /Otilde 778
   /zdotaccent 444
   /Ecaron 667
   /Iogonek 389
   /kcommaaccent 556
   /minus 570
   /Icircumflex 389
   /ncaron 556
   /tcommaaccent 333
   /logicalnot 570
   /odieresis 500
   /udieresis 556
   /notequal 549
   /gcommaaccent 500
   /eth 500
   /zcaron 444
   /ncommaaccent 556
   /onesuperior 300
   /imacron 278
   /Euro 500
 >> def
 /Helvetica
 <<
   /space 278
   /exclam 278
   /quotedbl 355
   /numbersign 556
   /dollar 556
   /percent 889
   /ampersand 667
   /quoteright 222
   /parenleft 333
   /parenright 333
   /asterisk 389
   /plus 584
   /comma 278
   /hyphen 333
   /period 278
   /slash 278
   /zero 556
   /one 556
   /two 556
   /three 556
   /four 556
   /five 556
   /six 556
   /seven 556
   /eight 556
   /nine 556
   /colon 278
   /semicolon 278
   /less 584
   /equal 584
   /greater 584
   /question 556
   /at 1015
   /A 667
   /B 667
   /C 722
   /D 722
   /E 667
   /F 611
   /G 778
   /H 722
   /I 278
   /J 500
   /K 667
   /L 556
   /M 833
   /N 722
   /O 778
   /P 667
   /Q 778
   /R 722
   /S 667
   /T 611
   /U 722
   /V 667
   /W 944
   /X 667
   /Y 667
   /Z 611
   /bracketleft 278
   /backslash 278
   /bracketright 278
   /asciicircum 469
   /underscore 556
   /quoteleft 222
   /a 556
   /b 556
   /c 500
   /d 556
   /e 556
   /f 278
   /g 556
   /h 556
   /i 222
   /j 222
   /k 500
   /l 222
   /m 833
   /n 556
   /o 556
   /p 556
   /q 556
   /r 333
   /s 500
   /t 278
   /u 556
   /v 500
   /w 722
   /x 500
   /y 500
   /z 500
   /braceleft 334
   /bar 260
   /braceright 334
   /asciitilde 584
   /exclamdown 333
   /cent 556
   /sterling 556
   /fraction 167
   /yen 556
   /florin 556
   /section 556
   /currency 556
   /quotesingle 191
   /quotedblleft 333
   /guillemotleft 556
   /guilsinglleft 333
   /guilsinglright 333
   /fi 500
   /fl 500
   /endash 556
   /dagger 556
   /daggerdbl 556
   /periodcentered 278
   /paragraph 537
   /bullet 350
   /quotesinglbase 222
   /quotedblbase 333
   /quotedblright 333
   /guillemotright 556
   /ellipsis 1000
   /perthousand 1000
   /questiondown 611
   /grave 333
   /acute 333
   /circumflex 333
   /tilde 333
   /macron 333
   /breve 333
   /dotaccent 333
   /dieresis 333
   /ring 333
   /cedilla 333
   /hungarumlaut 333
   /ogonek 333
   /caron 333
   /emdash 1000
   /AE 1000
   /ordfeminine 370
   /Lslash 556
   /Oslash 778
   /OE 1000
   /ordmasculine 365
   /ae 889
   /dotlessi 278
   /lslash 222
   /oslash 611
   /oe 944
   /germandbls 611
   /Idieresis 278
   /eacute 556
   /abreve 556
   /uhungarumlaut 556
   /ecaron 556
   /Ydieresis 667
   /divide 584
   /Yacute 667
   /Acircumflex 667
   /aacute 556
   /Ucircumflex 722
   /yacute 500
   /scommaaccent 500
   /ecircumflex 556
   /Uring 722
   /Udieresis 722
   /aogonek 556
   /Uacute 722
   /uogonek 556
   /Edieresis 667
   /Dcroat 722
   /commaaccent 250
   /copyright 737
   /Emacron 667
   /ccaron 500
   /aring 556
   /Ncommaaccent 722
   /lacute 222
   /agrave 556
   /Tcommaaccent 611
   /Cacute 722
   /atilde 556
   /Edotaccent 667
   /scaron 500
   /scedilla 500
   /iacute 278
   /lozenge 471
   /Rcaron 722
   /Gcommaaccent 778
   /ucircumflex 556
   /acircumflex 556
   /Amacron 667
   /rcaron 333
   /ccedilla 500
   /Zdotaccent 611
   /Thorn 667
   /Omacron 778
   /Racute 722
   /Sacute 667
   /dcaron 643
   /Umacron 722
   /uring 556
   /threesuperior 333
   /Ograve 778
   /Agrave 667
   /Abreve 667
   /multiply 584
   /uacute 556
   /Tcaron 611
   /partialdiff 476
   /ydieresis 500
   /Nacute 722
   /icircumflex 278
   /Ecircumflex 667
   /adieresis 556
   /edieresis 556
   /cacute 500
   /nacute 556
   /umacron 556
   /Ncaron 722
   /Iacute 278
   /plusminus 584
   /brokenbar 260
   /registered 737
   /Gbreve 778
   /Idotaccent 278
   /summation 600
   /Egrave 667
   /racute 333
   /omacron 556
   /Zacute 611
   /Zcaron 611
   /greaterequal 549
   /Eth 722
   /Ccedilla 722
   /lcommaaccent 222
   /tcaron 317
   /eogonek 556
   /Uogonek 722
   /Aacute 667
   /Adieresis 667
   /egrave 556
   /zacute 500
   /iogonek 222
   /Oacute 778
   /oacute 556
   /amacron 556
   /sacute 500
   /idieresis 278
   /Ocircumflex 778
   /Ugrave 722
   /Delta 612
   /thorn 556
   /twosuperior 333
   /Odieresis 778
   /mu 556
   /igrave 278
   /ohungarumlaut 556
   /Eogonek 667
   /dcroat 556
   /threequarters 834
   /Scedilla 667
   /lcaron 299
   /Kcommaaccent 667
   /Lacute 556
   /trademark 1000
   /edotaccent 556
   /Igrave 278
   /Imacron 278
   /Lcaron 556
   /onehalf 834
   /lessequal 549
   /ocircumflex 556
   /ntilde 556
   /Uhungarumlaut 722
   /Eacute 667
   /emacron 556
   /gbreve 556
   /onequarter 834
   /Scaron 667
   /Scommaaccent 667
   /Ohungarumlaut 778
   /degree 400
   /ograve 556
   /Ccaron 722
   /ugrave 556
   /radical 453
   /Dcaron 722
   /rcommaaccent 333
   /Ntilde 722
   /otilde 556
   /Rcommaaccent 722
   /Lcommaaccent 556
   /Atilde 667
   /Aogonek 667
   /Aring 667
   /Otilde 778
   /zdotaccent 500
   /Ecaron 667
   /Iogonek 278
   /kcommaaccent 500
   /minus 584
   /Icircumflex 278
   /ncaron 556
   /tcommaaccent 278
   /logicalnot 584
   /odieresis 556
   /udieresis 556
   /notequal 549
   /gcommaaccent 556
   /eth 556
   /zcaron 500
   /ncommaaccent 556
   /onesuperior 333
   /imacron 278
   /Euro 556
 >> def
 /Helvetica-Oblique
 <<
   /space 278
   /exclam 278
   /quotedbl 355
   /numbersign 556
   /dollar 556
   /percent 889
   /ampersand 667
   /quoteright 222
   /parenleft 333
   /parenright 333
   /asterisk 389
   /plus 584
   /comma 278
   /hyphen 333
   /period 278
   /slash 278
   /zero 556
   /one 556
   /two 556
   /three 556
   /four 556
   /five 556
   /six 556
   /seven 556
   /eight 556
   /nine 556
   /colon 278
   /semicolon 278
   /less 584
   /equal 584
   /greater 584
   /question 556
   /at 1015
   /A 667
   /B 667
   /C 722
   /D 722
   /E 667
   /F 611
   /G 778
   /H 722
   /I 278
   /J 500
   /K 667
   /L 556
   /M 833
   /N 722
   /O 778
   /P 667
   /Q 778
   /R 722
   /S 667
   /T 611
   /U 722
   /V 667
   /W 944
   /X 667
   /Y 667
   /Z 611
   /bracketleft 278
   /backslash 278
   /bracketright 278
   /asciicircum 469
   /underscore 556
   /quoteleft 222
   /a 556
   /b 556
   /c 500
   /d 556
   /e 556
   /f 278
   /g 556
   /h 556
   /i 222
   /j 222
   /k 500
   /l 222
   /m 833
   /n 556
   /o 556
   /p 556
   /q 556
   /r 333
   /s 500
   /t 278
   /u 556
   /v 500
   /w 722
   /x 500
   /y 500
   /z 500
   /braceleft 334
   /bar 260
   /braceright 334
   /asciitilde 584
   /exclamdown 333
   /cent 556
   /sterling 556
   /fraction 167
   /yen 556
   /florin 556
   /section 556
   /currency 556
   /quotesingle 191
   /quotedblleft 333
   /guillemotleft 556
   /guilsinglleft 333
   /guilsinglright 333
   /fi 500
/fl 500
/endash 556
/dagger 556
/daggerdbl 556
/periodcentered 278
/paragraph 537
/bullet 350
/quotesinglbase 222
/quotedblbase 333
/quotedblright 333
/guillemotright 556
/ellipsis 1000
/perthousand 1000
/questiondown 611
/grave 333
/acute 333
/circumflex 333
/tilde 333
/macron 333
/breve 333
/dotaccent 333
/dieresis 333
/ring 333
/cedilla 333
/hungarumlaut 333
/ogonek 333
/caron 333
/emdash 1000
/AE 1000
/ordfeminine 370
/Lslash 556
/Oslash 778
/OE 1000
/ordmasculine 365
/ae 889
/dotlessi 278
/lslash 222
/oslash 611
/oe 944
/germandbls 611
/Idieresis 278
/eacute 556
/abreve 556
/uhungarumlaut 556
/ecaron 556
/Ydieresis 667
/divide 584
/Yacute 667
/Acircumflex 667
/aacute 556
/Ucircumflex 722
/yacute 500
/scommaaccent 500
/ecircumflex 556
/Uring 722
/Udieresis 722
/aogonek 556
/Uacute 722
/uogonek 556
/Edieresis 667
/Dcroat 722
/commaaccent 250
/copyright 737
/Emacron 667
/ccaron 500
/aring 556
/Ncommaaccent 722
/lacute 222
/agrave 556
/Tcommaaccent 611
/Cacute 722
/atilde 556
/Edotaccent 667
/scaron 500
/scedilla 500
/iacute 278
/lozenge 471
/Rcaron 722
/Gcommaaccent 778
/ucircumflex 556
/acircumflex 556
/Amacron 667
/rcaron 333
/ccedilla 500
/Zdotaccent 611
/Thorn 667
/Omacron 778
/Racute 722
/Sacute 667
/dcaron 643
/Umacron 722
/uring 556
/threesuperior 333
/Ograve 778
/Agrave 667
/Abreve 667
/multiply 584
/uacute 556
/Tcaron 611
/partialdiff 476
/ydieresis 500
/Nacute 722
/icircumflex 278
/Ecircumflex 667
/adieresis 556
/edieresis 556
/cacute 500
/nacute 556
/umacron 556
/Ncaron 722
/Iacute 278
/plusminus 584
/brokenbar 260
/registered 737
/Gbreve 778
/Idotaccent 278
/summation 600
/Egrave 667
/racute 333
/omacron 556
/Zacute 611
/Zcaron 611
/greaterequal 549
/Eth 722
/Ccedilla 722
/lcommaaccent 222
/tcaron 317
/eogonek 556
/Uogonek 722
/Aacute 667
/Adieresis 667
/egrave 556
/zacute 500
/iogonek 222
/Oacute 778
/oacute 556
/amacron 556
/sacute 500
/idieresis 278
/Ocircumflex 778
/Ugrave 722
/Delta 612
/thorn 556
/twosuperior 333
/Odieresis 778
/mu 556
/igrave 278
/ohungarumlaut 556
/Eogonek 667
/dcroat 556
/threequarters 834
/Scedilla 667
/lcaron 299
/Kcommaaccent 667
/Lacute 556
/trademark 1000
/edotaccent 556
/Igrave 278
/Imacron 278
/Lcaron 556
/onehalf 834
/lessequal 549
/ocircumflex 556
/ntilde 556
/Uhungarumlaut 722
/Eacute 667
/emacron 556
/gbreve 556
/onequarter 834
/Scaron 667
/Scommaaccent 667
/Ohungarumlaut 778
/degree 400
/ograve 556
/Ccaron 722
/ugrave 556
/radical 453
/Dcaron 722
/rcommaaccent 333
/Ntilde 722
/otilde 556
/Rcommaaccent 722
/Lcommaaccent 556
/Atilde 667
/Aogonek 667
/Aring 667
/Otilde 778
/zdotaccent 500
/Ecaron 667
/Iogonek 278
/kcommaaccent 500
/minus 584
/Icircumflex 278
/ncaron 556
/tcommaaccent 278
/logicalnot 584
/odieresis 556
/udieresis 556
/notequal 549
/gcommaaccent 556
/eth 556
/zcaron 500
/ncommaaccent 556
/onesuperior 333
/imacron 278
/Euro 556
>> def
/Helvetica-BoldOblique
<<
/space 278
/exclam 333
/quotedbl 474
/numbersign 556
/dollar 556
/percent 889
/ampersand 722
/quoteright 278
/parenleft 333
/parenright 333
/asterisk 389
/plus 584
/comma 278
/hyphen 333
/period 278
/slash 278
/zero 556
/one 556
/two 556
/three 556
/four 556
/five 556
/six 556
/seven 556
/eight 556
/nine 556
/colon 333
/semicolon 333
/less 584
/equal 584
/greater 584
/question 611
/at 975
/A 722
/B 722
/C 722
/D 722
/E 667
/F 611
/G 778
/H 722
/I 278
/J 556
/K 722
/L 611
/M 833
/N 722
/O 778
/P 667
/Q 778
/R 722
/S 667
/T 611
/U 722
/V 667
/W 944
/X 667
/Y 667
/Z 611
/bracketleft 333
/backslash 278
/bracketright 333
/asciicircum 584
/underscore 556
/quoteleft 278
/a 556
/b 611
/c 556
/d 611
/e 556
/f 333
/g 611
/h 611
/i 278
/j 278
/k 556
/l 278
/m 889
/n 611
/o 611
/p 611
/q 611
/r 389
/s 556
/t 333
/u 611
/v 556
/w 778
/x 556
/y 556
/z 500
/braceleft 389
/bar 280
/braceright 389
/asciitilde 584
/exclamdown 333
/cent 556
/sterling 556
/fraction 167
/yen 556
/florin 556
/section 556
/currency 556
/quotesingle 238
/quotedblleft 500
/guillemotleft 556
/guilsinglleft 333
/guilsinglright 333
/fi 611
/fl 611
/endash 556
/dagger 556
/daggerdbl 556
/periodcentered 278
/paragraph 556
/bullet 350
/quotesinglbase 278
/quotedblbase 500
/quotedblright 500
/guillemotright 556
/ellipsis 1000
/perthousand 1000
/questiondown 611
/grave 333
/acute 333
/circumflex 333
/tilde 333
/macron 333
/breve 333
/dotaccent 333
/dieresis 333
/ring 333
/cedilla 333
/hungarumlaut 333
/ogonek 333
/caron 333
/emdash 1000
/AE 1000
/ordfeminine 370
/Lslash 611
/Oslash 778
/OE 1000
/ordmasculine 365
/ae 889
/dotlessi 278
/lslash 278
/oslash 611
/oe 944
/germandbls 611
/Idieresis 278
/eacute 556
/abreve 556
/uhungarumlaut 611
/ecaron 556
/Ydieresis 667
/divide 584
/Yacute 667
/Acircumflex 722
/aacute 556
/Ucircumflex 722
/yacute 556
/scommaaccent 556
/ecircumflex 556
/Uring 722
/Udieresis 722
/aogonek 556
/Uacute 722
/uogonek 611
/Edieresis 667
/Dcroat 722
/commaaccent 250
/copyright 737
/Emacron 667
/ccaron 556
/aring 556
/Ncommaaccent 722
/lacute 278
/agrave 556
/Tcommaaccent 611
/Cacute 722
/atilde 556
/Edotaccent 667
/scaron 556
/scedilla 556
/iacute 278
/lozenge 494
/Rcaron 722
/Gcommaaccent 778
/ucircumflex 611
/acircumflex 556
/Amacron 722
/rcaron 389
/ccedilla 556
/Zdotaccent 611
/Thorn 667
/Omacron 778
/Racute 722
/Sacute 667
/dcaron 743
/Umacron 722
/uring 611
/threesuperior 333
/Ograve 778
/Agrave 722
/Abreve 722
/multiply 584
/uacute 611
/Tcaron 611
/partialdiff 494
/ydieresis 556
/Nacute 722
/icircumflex 278
/Ecircumflex 667
/adieresis 556
/edieresis 556
/cacute 556
/nacute 611
/umacron 611
/Ncaron 722
/Iacute 278
/plusminus 584
/brokenbar 280
/registered 737
/Gbreve 778
/Idotaccent 278
/summation 600
/Egrave 667
/racute 389
/omacron 611
/Zacute 611
/Zcaron 611
/greaterequal 549
/Eth 722
/Ccedilla 722
/lcommaaccent 278
/tcaron 389
/eogonek 556
/Uogonek 722
/Aacute 722
/Adieresis 722
/egrave 556
/zacute 500
/iogonek 278
/Oacute 778
/oacute 611
/amacron 556
/sacute 556
/idieresis 278
/Ocircumflex 778
/Ugrave 722
/Delta 612
/thorn 611
/twosuperior 333
/Odieresis 778
/mu 611
/igrave 278
/ohungarumlaut 611
/Eogonek 667
/dcroat 611
/threequarters 834
/Scedilla 667
/lcaron 400
/Kcommaaccent 722
/Lacute 611
/trademark 1000
/edotaccent 556
/Igrave 278
/Imacron 278
/Lcaron 611
/onehalf 834
/lessequal 549
/ocircumflex 611
/ntilde 611
/Uhungarumlaut 722
/Eacute 667
/emacron 556
/gbreve 611
/onequarter 834
/Scaron 667
/Scommaaccent 667
/Ohungarumlaut 778
/degree 400
/ograve 611
/Ccaron 722
/ugrave 611
/radical 549
/Dcaron 722
/rcommaaccent 389
/Ntilde 722
/otilde 611
/Rcommaaccent 722
/Lcommaaccent 611
/Atilde 722
/Aogonek 722
/Aring 722
/Otilde 778
/zdotaccent 500
/Ecaron 667
/Iogonek 278
/kcommaaccent 556
/minus 584
/Icircumflex 278
/ncaron 611
/tcommaaccent 333
/logicalnot 584
/odieresis 611
/udieresis 611
/notequal 549
/gcommaaccent 611
/eth 611
/zcaron 500
/ncommaaccent 611
/onesuperior 333
/imacron 278
/Euro 556
>> def
/Helvetica-Bold
<<
/space 278
/exclam 333
/quotedbl 474
/numbersign 556
/dollar 556
/percent 889
/ampersand 722
/quoteright 278
/parenleft 333
/parenright 333
/asterisk 389
/plus 584
/comma 278
/hyphen 333
/period 278
/slash 278
/zero 556
/one 556
/two 556
/three 556
/four 556
/five 556
/six 556
/seven 556
/eight 556
/nine 556
/colon 333
/semicolon 333
/less 584
/equal 584
/greater 584
/question 611
/at 975
/A 722
/B 722
/C 722
/D 722
/E 667
/F 611
/G 778
/H 722
/I 278
/J 556
/K 722
/L 611
/M 833
/N 722
/O 778
/P 667
/Q 778
/R 722
/S 667
/T 611
/U 722
/V 667
/W 944
/X 667
/Y 667
/Z 611
/bracketleft 333
/backslash 278
/bracketright 333
/asciicircum 584
/underscore 556
/quoteleft 278
/a 556
/b 611
/c 556
/d 611
/e 556
/f 333
/g 611
/h 611
/i 278
/j 278
/k 556
/l 278
/m 889
/n 611
/o 611
/p 611
/q 611
/r 389
/s 556
/t 333
/u 611
/v 556
/w 778
/x 556
/y 556
/z 500
/braceleft 389
/bar 280
/braceright 389
/asciitilde 584
/exclamdown 333
/cent 556
/sterling 556
/fraction 167
/yen 556
/florin 556
/section 556
/currency 556
/quotesingle 238
/quotedblleft 500
/guillemotleft 556
/guilsinglleft 333
/guilsinglright 333
/fi 611
/fl 611
/endash 556
/dagger 556
/daggerdbl 556
/periodcentered 278
/paragraph 556
/bullet 350
/quotesinglbase 278
/quotedblbase 500
/quotedblright 500
/guillemotright 556
/ellipsis 1000
/perthousand 1000
/questiondown 611
/grave 333
/acute 333
/circumflex 333
/tilde 333
/macron 333
/breve 333
/dotaccent 333
/dieresis 333
/ring 333
/cedilla 333
/hungarumlaut 333
/ogonek 333
/caron 333
/emdash 1000
/AE 1000
/ordfeminine 370
/Lslash 611
/Oslash 778
/OE 1000
/ordmasculine 365
/ae 889
/dotlessi 278
/lslash 278
/oslash 611
/oe 944
/germandbls 611
/Idieresis 278
/eacute 556
/abreve 556
/uhungarumlaut 611
/ecaron 556
/Ydieresis 667
/divide 584
/Yacute 667
/Acircumflex 722
/aacute 556
/Ucircumflex 722
/yacute 556
/scommaaccent 556
/ecircumflex 556
/Uring 722
/Udieresis 722
/aogonek 556
/Uacute 722
/uogonek 611
/Edieresis 667
/Dcroat 722
/commaaccent 250
/copyright 737
/Emacron 667
/ccaron 556
/aring 556
/Ncommaaccent 722
/lacute 278
/agrave 556
/Tcommaaccent 611
/Cacute 722
/atilde 556
/Edotaccent 667
/scaron 556
/scedilla 556
/iacute 278
/lozenge 494
/Rcaron 722
/Gcommaaccent 778
/ucircumflex 611
/acircumflex 556
/Amacron 722
/rcaron 389
/ccedilla 556
/Zdotaccent 611
/Thorn 667
/Omacron 778
/Racute 722
/Sacute 667
/dcaron 743
/Umacron 722
/uring 611
/threesuperior 333
/Ograve 778
/Agrave 722
/Abreve 722
/multiply 584
/uacute 611
/Tcaron 611
/partialdiff 494
/ydieresis 556
/Nacute 722
/icircumflex 278
/Ecircumflex 667
/adieresis 556
/edieresis 556
/cacute 556
/nacute 611
/umacron 611
/Ncaron 722
/Iacute 278
/plusminus 584
/brokenbar 280
/registered 737
/Gbreve 778
/Idotaccent 278
/summation 600
/Egrave 667
/racute 389
/omacron 611
/Zacute 611
/Zcaron 611
/greaterequal 549
/Eth 722
/Ccedilla 722
/lcommaaccent 278
/tcaron 389
/eogonek 556
/Uogonek 722
/Aacute 722
/Adieresis 722
/egrave 556
/zacute 500
/iogonek 278
/Oacute 778
/oacute 611
/amacron 556
/sacute 556
/idieresis 278
/Ocircumflex 778
/Ugrave 722
/Delta 612
/thorn 611
/twosuperior 333
/Odieresis 778
/mu 611
/igrave 278
/ohungarumlaut 611
/Eogonek 667
/dcroat 611
/threequarters 834
/Scedilla 667
/lcaron 400
/Kcommaaccent 722
/Lacute 611
/trademark 1000
/edotaccent 556
/Igrave 278
/Imacron 278
/Lcaron 611
/onehalf 834
/lessequal 549
/ocircumflex 611
/ntilde 611
/Uhungarumlaut 722
/Eacute 667
/emacron 556
/gbreve 611
/onequarter 834
/Scaron 667
/Scommaaccent 667
/Ohungarumlaut 778
/degree 400
/ograve 611
/Ccaron 722
/ugrave 611
/radical 549
/Dcaron 722
/rcommaaccent 389
/Ntilde 722
/otilde 611
/Rcommaaccent 722
/Lcommaaccent 611
/Atilde 722
/Aogonek 722
/Aring 722
/Otilde 778
/zdotaccent 500
/Ecaron 667
/Iogonek 278
/kcommaaccent 556
/minus 584
/Icircumflex 278
/ncaron 611
/tcommaaccent 333
/logicalnot 584
/odieresis 611
/udieresis 611
/notequal 549
/gcommaaccent 611
/eth 611
/zcaron 500
/ncommaaccent 611
/onesuperior 333
/imacron 278
/Euro 556
>> def
 /Courier-Bold
 <<
   /ToTS 600
 >> def
 /Courier-BoldOblique
 <<
   /ToTS 600
 >> def
 /Courier-Oblique
 <<
   /ToTS 600
 >> def
 /Courier
 <<
   /ToTS 600
 >> def
 end
 %% fi de definicio de les 14 PDF Core Fonts x la possible manca de Widths

 %% definim l'algorisme per rexifrar el CMap de ToUnicode cap un Encoding de 256 caracters
 /DeCMapA256
 {  %% de fet segur q ens trobarem amb la necessitat d'ampliar aquesta array al joc que controla l'AdobeGlyphList si mai volem tractar fitxers amb xifrat complexe
  CMapIntern  %% ens diu si el CMap es definit dins el PDF o es un recurs extern de l'interpret
  {
   ElCMapToUnicode  %% cerquem el dict del CMap ToUnicode
   /aCercar exch def
   %% pesquem la branca ...
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup aCercar known {aCercar get exit}{pop}ifelse 
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
   %%% test especial
   %%ElCMapToUnicode /38____0 eq
   %%{ nomPS == (FontXl'Aandi)==} if
   %%nomPS (PJIFAH+LucidaBright-Demi) eq {ElCMapToUnicode == (CMapXl'Aandi) ==} if
   %%%
   dup /Filter known  %% es comprimit ?
   {
    dup /Filter get /elFiltre exch def /fesFiltre true def /XIU get /CMapToUnicodeXIU exch def
   }
   {
    /fesFiltre false def /XIU get /CMapToUnicodeXIU exch def
   }ifelse
  }
  {  %% si no s'executa el procediment, es un recurs extern de l'interpret (ara nomes contemplem Identity-H)
   BRoSSa2 /CMapToUnicodeXIU exch def
   /fesFiltre false def
  }ifelse
  %% decida256.ps
  %% recodifica els caracters d'una font CID (Type 0 o d'altres amb CMap)
  %% des del CMap particular desat a l'objecte ToUnicode
  %% o dels CMaps predefinits com /Identity-H, /Roman, /Adobe-GB1-1, etc.
  %% cap a una array normal de 256 caracters
  %% d'on traurem el nom del caracter a mapejar
  %% aqui hi havia /WinAnsiEncoding i /StandardEncoding (ara es definit a %20%)

  %%WinAnsiEncoding 256 array copy
  /ENCpAqUEt 256 array def 0 1 255 {ENCpAqUEt exch /.notdef put}for  %% array plena de /.notdef
  %% /ENCpAqUEt exch def  % la nova posicio del nom del caracter a mapejar
  %% estrategia per decodificar i avaluar els bytes del CMap de ToUnicodeg
  CMapToUnicodeXIU
  %% (r) file
  %% comprovem si l'stream es un path dins una array o una string de dades directe
  dup type /arraytype eq
  {
   %CMapToUnicodeXIU
   0 get (r) file  %% convertim a fitxer des del path sense decodificar
  }
  {  %% convertim a fitxer la cadena sense decodificar
   0 () /SubFileDecode filter
  } ifelse
  <<
    fesFiltre {/Filter elFiltre} if
  >> /ReusableStreamDecode filter
  dup /fitxerCMap exch def bytesavailable /CMapbytes exch def
  %%% haurem de cercar dos rangs de dades possibles
  %%% (beginbfchar) ... (endbfchar) i (beginbfrange) ... (endbfrange)
  %%% cerquem el primer rang
  (beginbfchar)  %% clau d'inici de bASE fONT charARCTERS
  /aCeRCaR1 exch def
  (endbfchar)  %% clau final de bASE fONT charARCTERS
  /aCeRCaR2 exch def
  /araEts 0 def  %% comptador total de posicio de fitxer
  fitxerCMap
  {  %% loop general
   dup 0 aCeRCaR1  /SubFileDecode filter  %% busquem la posicio (byte) d'inici de (beginbfchar)
   %% comptem els bytes llegits fins a (beginbfchar)
   /posObj 0 def
   {  %% loop
    dup
    65535 string readstring not
    {
     length posObj add /posObj exch def closefile exit
    }if 
    length posObj add /posObj exch def
   } loop
   posObj araEts add /araEts exch def  %% actualitzem
   fitxerCMap dup araEts
   dup CMapbytes ge {pop pop pop pop exit}if  %% som al final del fitxer?
   11 add setfileposition  %% ens posem just despres de (beginbfchar)
   %% tibem el paquet (beginbfchar) fins a (endbfchar)
   <<
     /Filter /SubFileDecode /DecodeParms <</EODCount 0 /EODString aCeRCaR2>>
   >> /ReusableStreamDecode filter /rangCID exch def
   %%% deixem les linies dels rangs de la CID a la pila
   %%% i aquesta es una forma mes simple d'avaluar els codis a mapejar a la nova cadena de 256
   mark rangCID cvx exec
   {  %%loop 2
    dup type /marktype eq  %% som al final ?
    {
     pop exit
    }
    {
     dup dup
     type /nametype eq  %% es una string hexa o un nom de caracter ?
     {  %% un nom de caracter
      %% <20> /space
      %% el segon element es el nom literal del caracter, l'index de posicio ens la dona
      %% la primera string hexa. Ho incrustem a ENCpAqUEt. Aquesta array sera la que ha
      %% de bastir d'alguna manera el paquet /traductorEncoding o EncNETiPLANXAT
      pop 
      %% pesquem el byte de la primera string hexa que sera l'index
      %% per incrustar el nom del caracter dins EncNETiPLANXAT o traductorEncoding
      exch
      dup length 1 eq 
      {  %% si l'index ve amb byte senzill possiblement el contingut de les strings de text tambe hi vingui
       /esUnicode false def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
       0
      }
      {  %% si l'index ve amb doble byte possiblement el contingut de les strings de text tambe hi vingui
       /esUnicode true def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
       1
      }ifelse
      get exch ENCpAqUEt 3 1 roll put  %% incrustem a la posicio final del mapejat de traduccio
     }
     {  %% una string hexa
      0 get 0 eq  %% detecta si l'Unicode es fora del rang 256
      {
       %% % es l'index del nou encoding /traductorEncoding	% es l'index per pescar el nom del caracter a la taula ISOLatin1Encoding o l'AdobeGlyphList?
       %% <0002>							<0020>
       %%   <01> 						<0002>
       %% El segon byte del segon string hexa es l'index del caracter que cal anar a pescar el nom
       %% al /StandardEncoding (ISOLatin1Encoding) i l'incrustarem, de moment dins del WinAnsiEncoding (ENCpAqUEt),
       %% a la posicio que ens dona la primera string hexa. Aquesta array sera la que ha
       %% de bastir d'alguna manera el paquet /traductorEncoding o EncNETiPLANXAT
       1 get  %% llegim el segon byte del segon string hexa (q suposem sempre te 2 bytes)
       StandardEncoding exch get  %% pesquem el nom del caracter
       %% o tambe podriem anar a pescar directament el nom d'aquest encoding tractat com un
       %% diccionari a WinAnsiEncoding2Bytes (q haviem implementat pels strings Unicode de les
       %% Layers de PDF a FemFum_CaLi2CoPi_034.pdf) o quan implementessim l'AdobeGlyphList
       %% sencera, pero caldria en ambdos casos posar la clau amb delimitadors hexa i no amb
       %% parentesi com fem ara.
       %% Pesquem el byte de la primera string hexa que sera l'index (q pot tenir 1 o 2 bytes!)
       %% per incrustar el nom del caracter dins EncNETiPLANXAT o traductorEncoding
       %% fins ara nomes haviem tractat strings de posicio d'1 byte (aqui es on petava provaManyo_DPNO.pdf)
       %% aquest index pot ser 0 o 1, doncs l'string de posicio pot tenir 1 o 2 bytes!
       exch
       dup length 1 eq 
       {  %% si l'index ve amb byte senzill possiblement el contingut de les strings de text tambe hi vingui
        /esUnicode false def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
        0
       }
       {  %% si l'index ve amb doble byte possiblement el contingut de les strings de text tambe hi vingui
        /esUnicode true def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
        1
       }ifelse
       get exch ENCpAqUEt 3 1 roll put  %% incrustem a la posicio final del mapejat de traduccio
      }
      {
       %%(\n\nAquest Unicode Es Fora de Rang 256 i No Te Equivalent Ascii\n\n) ==
       %% aqui ho canalitzem posant /_SOFIglyphs com a nom de caracter desconegut dins a /traductorEncoding
       pop /_SOFIglyphs
       %% pesquem el byte de la primera string hexa que sera l'index
       %% per incrustar el nom del caracter desconegut /_SOFIglyphs dins EncNETiPLANXAT o traductorEncoding
       exch
       dup length 1 eq 
       {  %% si l'index ve amb byte senzill possiblement el contingut de les strings de text tambe hi vingui
        /esUnicode false def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
        0
       }
       {  %% si l'index ve amb doble byte possiblement el contingut de les strings de text tambe hi vingui
        /esUnicode true def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
        1
       }ifelse
       get exch ENCpAqUEt 3 1 roll put  %% incrustem a la posicio final del mapejat de traduccio
      }ifelse  %% ens assegurem que l'unicode esta dins el rang del 256
     } ifelse  %% una string hexa o un nom de caracter ?
    } ifelse  %% som al final ?
   } loop  %% 2
   %% posicio actual del fitxer despres de la cerca
   fitxerCMap fileposition /araEts exch def
   %% som al final del CMap ?
   araEts CMapbytes ge
   {
    pop exit  %% sortim del loop general
   }if
  } loop  %% general
  %%% hem d'inicialitzar el fitxer d'una manera mes simple?
  %% estrategia per decodificar i avaluar els bytes del CMap de ToUnicode
  CMapToUnicodeXIU
  %% (r) file
  %% comprovem si l'stream es un path dins una array o una string de dades directe
  type /arraytype eq
  {
   CMapToUnicodeXIU 0 get (r) file  %% convertim a fitxer des del path sense decodificar
  }
  {  %% convertim a fitxer de la cadena sense decodificar
   CMapToUnicodeXIU 0 () /SubFileDecode filter
  } ifelse
  <<
    fesFiltre {/Filter elFiltre} if
  >> /ReusableStreamDecode filter
  dup /fitxerCMap exch def bytesavailable /CMapbytes exch def
  (beginbfrange)  %% clau d'inici de bASE fONT charARCTERS
  /aCeRCaR1 exch def
  (endbfrange)  %% clau final de bASE fONT charARCTERS
  /aCeRCaR2 exch def
  /araEts 0 def  %% comptador total de posicio de fitxer
  fitxerCMap
  {  %% loop general
   dup 0 aCeRCaR1  /SubFileDecode filter  %% busquem la posicio (byte) d'inici de (beginbfrange)
   %% comptem els bytes llegits fins a (beginbfrange)
   /posObj 0 def
   {  %% loop
    dup
    65535 string readstring not
    {
     length posObj add /posObj exch def closefile exit
    }if 
    length posObj add /posObj exch def
   } loop
   posObj araEts add /araEts exch def  %% actualitzem
   fitxerCMap dup araEts
   dup CMapbytes ge {pop pop pop pop exit}if  %% som al final del fitxer?
   12 add setfileposition  %% ens posem just despres de (beginbfrange)
   %% tibem el paquet (beginbfrange) fins a (endbfrange)
   <<
     /Filter /SubFileDecode /DecodeParms <</EODCount 0 /EODString aCeRCaR2>>
   >> /ReusableStreamDecode filter /rangCID exch def
   %%% deixem les linies dels rangs de la CID a la pila
   %%% forma mes simple d'avaluar els codis a mapejar a la nova cadena de 256
   mark rangCID cvx exec
   {  %% loop 2
    dup type /marktype eq  %% som al final ?
    {
     pop exit
    }
    {
     dup type /stringtype eq  %% es un codi dins una cadena o sino es un array de caracters ?
     {  %% es un codi dins una cadena
      dup length 2 eq
      {
       /esUnicode true def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
      }
      {
       /esUnicode false def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
      }ifelse
      %%esUnicode (:-/)pstack quit
      /dstCodeLo exch def  %% capturem el codi del caracter
      dstCodeLo 0 get 0 eq  %% ens assegurem que l'unicode esta dins el rang del 256
      {
       dstCodeLo 1 get /dstCodeLo exch def  %% agafem el segon byte
       dup length 1 sub get /fiRang exch def  %%byte de fi del rang
       dup length 2 eq
       {  %% es doble byte
        dup 0 get 0 eq  %% ens assegurem que l'unicode esta dins el rang del 256
        {
         1 get /iniRang exch def  %%byte d'inici del rang
         {  %% loop 3
          ENCpAqUEt iniRang StandardEncoding dstCodeLo get put  %% incrustem el nou mapejat
          dstCodeLo 1 add /dstCodeLo exch def  %% fem correr el codi de desti
          iniRang fiRang eq {exit}if
          iniRang 1 add /iniRang exch def
         } loop  %% 3
        }
        {
         %%(\n\nAquest Index Unicode Es Fora de Rang 256\n\n) ==
         pop
         %% l'eliminem i l'ignorem
        }ifelse  %% ens assegurem que l'unicode esta dins el rang del 256
       }
       {  %% es byte senzill
        0 get /iniRang exch def  %%byte d'inici del rang
        {  %% loop 3
         ENCpAqUEt iniRang StandardEncoding dstCodeLo get put  %% incrustem el nou mapejat
         dstCodeLo 1 add /dstCodeLo exch def  %% fem correr el codi de desti
         iniRang fiRang eq {exit}if
         iniRang 1 add /iniRang exch def
        } loop  %% 3
       } ifelse
      }
      {
       %%(\n\nAquest Unicode Es Fora de Rang 256 i No Te Equivalent Ascii\n\n) ==
       %% aqui ho canalitzem posant /_SOFIglyphs com a nom de caracter desconegut dins a /traductorEncoding
       dup length 1 sub get /fiRang exch def  %%byte de fi del rang
       dup length 2 eq
       {  %% es doble byte
        dup 0 get 0 eq  %% ens assegurem que l'unicode esta dins el rang del 256
        {
         1 get /iniRang exch def  %%byte d'inici del rang
         {  %% loop 3
          ENCpAqUEt iniRang /_SOFIglyphs put  %% l'incrustem al nou mapejat
          iniRang fiRang eq {exit}if
          iniRang 1 add /iniRang exch def
         } loop  %% 3
        }
        {
         %%(\n\nAquest Index Unicode Es Fora de Rang 256\n\n) ==
         pop
         %% l'eliminem i l'ignorem
        }ifelse  %% ens assegurem que l'unicode esta dins el rang del 256
       }
       {  %% es byte senzill
        0 get /iniRang exch def  %%byte d'inici del rang
        {  %% loop 3
         ENCpAqUEt iniRang /_SOFIglyphs put  %% l'incrustem al nou mapejat
         iniRang fiRang eq {exit}if
         iniRang 1 add /iniRang exch def
        }loop  %% 3
       }ifelse
      }ifelse  %% ens assegurem que l'unicode esta dins el rang del 256
     }
     {  %% es un array de caracters
      /dstArray exch def  %% capturem el paquet de caracters
      0 /dstArrayX exch def  %% index per pitllar els caracters dins el paquet
      dup length 1 sub get /fiRang exch def  %%byte de fi del rang
      dup length 2 eq
      {  %% es doble byte
       /esUnicode true def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
       dup 0 get 0 eq  %% ens assegurem que l'unicode esta dins el rang del 256
       {
        1 get /iniRang exch def  %%byte d'inici del rang
        {  %% loop 3
         ENCpAqUEt iniRang dstArray dstArrayX get put  %% incrustem el nou mapejat
         iniRang fiRang eq {exit}if
         iniRang 1 add /iniRang exch def
         dstArrayX 1 add /dstArrayX exch def
        } loop  %% 3
       }
       {
        %%(\n\nAquest Index Unicode Es Fora de Rang 256\n\n) ==
        pop
        %% l'eliminem i l'ignorem
       }ifelse  %% ens assegurem que l'unicode esta dins el rang del 256
      }
      {  %% es byte senzill
       /esUnicode false def  %% gatell x saber si hem d'extraure el text de 2 en 2 octets
       0 get /iniRang exch def  %%byte d'inici del rang
       {  %% loop 3
        ENCpAqUEt iniRang dstArray dstArrayX get put  %% incrustem el nou mapejat
        iniRang fiRang eq {exit}if
        iniRang 1 add /iniRang exch def
        dstArrayX 1 add /dstArrayX exch def
       } loop  %% 3
      } ifelse
     }ifelse
    }ifelse  %% som al final ?
   }loop  %% 2
   %% posicio actual del fitxer despres de la cerca
   fitxerCMap fileposition /araEts exch def
   %% som al final del CMap ?
   araEts CMapbytes ge
   {
    pop exit  %% sortim del loop general
   }if
  } loop  %% general
  ENCpAqUEt  %% deixem el nou encoding a la pila
  %%% fins aqui decida256.ps
 } bind def
 %% fins aqui l'algorisme DeCMapA256 per recodificar el CMap

 %% hem constatat que tant CalaixDeTipus com Champollion han d'anar paginats doncs es perfectament
 %% possible que els noms interns PDF del tipus estiguin duplicats dins el mateix document i
 %% en canvi apuntin a tipografies ben diferents (pe: TypoTechnica2007_FontProduction_at_Adobe.pdf)
 %% CalaixDeTipus emmagatzema el nom PDF de cada font de TOT el document amb una array amb 5 elements: el nom PS, el FirstChar, l'array de Widths, esUnicode, width+grAn
 /CalaixDeTipus <<>> def
 %% Emmagatzemem el nom PDF de cada font de TOT el document i el seu encoding (sempre net i planxat començant pel FirstChar?) al dict Champollion
 /Champollion <<>> def

 %% :-Z array detector de documents sense text (+1 plana per manegar millor els índex)
 %% on tots els elements valdran 1 menys l'index 0 que vadrà zero
 quinaPlana length 1 add dup dup array /SenseText exch def
 {1 sub dup SenseText exch 1 put}repeat SenseText exch 0 put

 %% {  % stopped  % x test
 %% explorem com a %26% els Resources pagina a pagina per l'analisi tipografic KTCS
 quinaPlana
 {  %% forall
  /actGina exch def /araPlana exch def  %% desem el literal del num d'obj /Page i l'ordinal de la plana a la que correspon
  %% pesquem la branca ...
  /iDimoni 0 def
  {  %% loop d'interrogacio dels dicts de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   %% el diccionari de l'objecte
   dup actGina known {actGina get exit}{pop}ifelse 
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% d'interrogacio dels dicts de COMdimoni
  %% 05.03.09 aquesta solucio de la cerca recursiva del dic Resources considerant el null i el diccionari buit cal implementar-la arreu on calgui!
  %% anem cercant cap enrera els Parent en cas de no trobar Resources dins la mateixa pagina
  {  %% loop
   dup /Resources known  %% hi ha Resources?
   {  %% Resources es a /Page o /Pages ?
    %% descartem la possibilitat de que la ref indirecte sigui un null o un dict buit
    %% pel que llavors tindria els Resources heretats i continuariem el loop enrera ...
    /Resources get dup type /nametype eq
    {
     /aCercar exch def  %% nom amb la ref ind del dic Resources
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dics de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
     dup length 0 eq
     {  %% pagina amb Resources heretats i continuem el loop enrera
      pop
     }
     {
      exit  %% sortim del loop amb el dic Resources a l'stack
     }ifelse
    }
    {
     dup null eq
     {  %% pagina amb Resources heretats i continuem el loop enrera
      pop
     }
     {  %% no pot ser altra cosa que un dic directe
      dup length 0 eq
      {  %% pagina amb Resources heretats i continuem el loop enrera
       pop
      }
      {
       exit  %% sortim del loop amb el dic Resources a l'stack
      }ifelse
     }ifelse
    }ifelse
   }
   {  %% Resources podria estar a /Pages!
    dup /Parent known
    {
     dup /Parent get
     /aCercar exch def
     %% pesquem la branca ...
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse 
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }
    {  %% aquesta pagina no te Resources!
     BaBeL 33 get print flush
actGina == (1)==
     %% informem dels fitxers del tmp
     BaBeL 50 get print flush
     clear stop  %%quit
%%UBpliegOMaker
    }ifelse
   }ifelse
  }loop
  %% a l'stack tenim el dic Resources de la plana que explorem ara
  %%% KTCS de l'explorador de tipografies
  %% hi ha fonts ?
  dup /Font known
  {
   /Font get  %% es un diccionari directe o una ind ref ?
   dup type /nametype eq
   {
    /aCercar exch def  %% nom amb la ref ind del dic Font
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
   }if
   %%IEDiBaBOP
  
   %% DESACTIVAT
   %% /esUNICODE <<>> def

   %% gatell per defecte de si duu el CMap definit dins el PDF o es un recurs extern 
   /CMapIntern true def

   %% ACTIVAT com el quart element de l'array de valors que hem implementat dins a CalaixDeTipus
   /esUnicode false def  %% valor x defecte inicial x saber si la cadena cal llegir-la amb 1 o 2 caracters
  
   dup /sesFonts exch def  %% diccionari amb els parells nom pdf de la font / diccionari o ref ind de l'objecte /Type /Font

%% UUUEEE
%/hoES false def

   %%% cal veure tambe que passa quan filtrem una OT directament incrustada!
   {  %% forall del dict de /Font

%1 index /Type0TTF2 eq
%{
% /hoES true def
%}if

    dup type /nametype eq
    {
     /aCercar exch def  %% nom amb la ref ind del tipus
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }if
    %% pesquem el diccionari del tipus de lletra ...
    %% ... i posem un filtre per descartar les fonts asiatiques (que algunes no podem decodificar a ascii a l'extractor de textos)
    %% Type0 CIDFontType0 i CIDFontType2
    dup /Subtype get dup /Type0 eq
    {
     /SMBLC false def  %% valor per defecte del pestell SMBLC
     /FontTipus exch def  %% capturem el /Subtype per posteriors interrogacions
     %% detector de l'entrada ToUnicode
     dup /ToUnicode known
     {
      /HiHaToUnicode true def
      %% posem un gatell per activar, si no hi ha /Encoding, el nou algorisme
      %% que recodifica el CMap a un Encoding 256
      dup /ToUnicode get
      dup /Identity-H eq
      {
       /CMapIntern false def
       /esUnicode true def  %% avisa que les cadenes venen en doble octet
      }
      {
       /CMapIntern true def
      }ifelse
      /ElCMapToUnicode exch def
      %% aqui si te /DescendantFonts, li donem prioritat per pescar el nom PS
      %% doncs el nom de BaseFont d'aquest primer nivell a voltes pot no ser normatiu
      %% i en canvi el /BaseFont del descendent te l'obligació de ser-ho
      %% i això pot ser fatal x detectar correctament p.e. les 14 PDF Core fonts
      dup /DescendantFonts known
      {
       dup
       /DescendantFonts get
       {  %% loop x controlar una certa recursivitat ...
        dup type /arraytype eq
        {  %% en cas sigui un paquet ...
         0 get  %% ... agafem la primera que trobem (doncs suposem que en cas d'haver-n'hi mes, haurien de compartir el mateix nom despres del +)
        }if
        /aCercar exch def  %% la ref ind
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        } loop  %% d'interrogacio dels dicts de COMdimoni
        %% evitem una certa recursivitat ...
        dup type /arraytype eq
        {  %% en cas sigui un paquet ...
         0 get  %% ... agafem la primera que trobem (doncs suposem que en cas d'haver-n'hi mes, haurien de compartir el mateix nom despres del +)
        }{exit}ifelse
       }loop
%%       /aCercar exch def  % la ref ind
%%       /iDimoni 0 def
%%       {  % loop d'interrogacio dels dicts de COMdimoni
%%        currentdict iDimoni 4 string cvs cvn get
%%        % el diccionari de l'objecte
%%        dup aCercar known {aCercar get exit}{pop}ifelse
%%        iDimoni 1 add /iDimoni exch def
%%        iDimoni MaxDimoni eq {exit} if
%%       } loop  % d'interrogacio dels dicts de COMdimoni
%%% ESTEM DAVANT D'UN CAS DE Descendantfonts recursiu ?
%%{== ==}forall
       /BaseFont get  %% aquesta ha de ser la bona
      }
      {
       dup /BaseFont get
      }ifelse
      /nomPS exch def
      DeCMapA256  %% executem l'algorisme que passa CMap a 256 (de fet segur q ens trobarem amb la necessitat d'ampliar aquesta array al joc que controla l'AdobeGlyphList si mai volem tractar fitxers amb xifrat complex)
      exch  %% posem sota el dict l'encoding (ja ben desat a /ENCpAqUEt) que deixa a la pila l'algorisme
     }
     {
      /CMapIntern false def
      %% si no hi ha ToUnicode, el CMap es dins a /Encoding
      dup /Encoding known
      {
       dup /Encoding get
       /Identity-H eq  %% de moment nomes contemplem Identity-H
       {
        {  %% stopped
%% Procediment de com saber el path intern d'un recurs de l'interpret (Resource)
%% definit com a fitxer a disc (p.e. pels CMaps aixo es molt important)
%% Vegeu el capitol 3.9.4 del PLRM (Resources as Files)
%% cridem el diccionari corresponent a l'implementacio de la categoria que volem
%% /CMap /Category findresource  % dic d'implementacio dels CMaps
%%begin
%% /Identity-H 256 string ResourceFileName  % aquesta clau ens posa a la pila el path del fitxer dins una cadena
%%end
%% /CMapToUnicodeXIU exch def  % path de l'arxiu CMap per a l'algorisme conversor /DeCMapA256
         dup /BaseFont get /nomPS exch def
         %%COMdimoni
         userdict
%% ara hem corregit aquest xifrat ...
         /WinAnsiEncoding2Identity-H
%% ... i cal adaptar-lo si cal guiats per l'entrada W de la metrica a les posicions correctes
         get  %% pesquem l'Identity-H i en fem una copia descontaminada ...
         dup length array copy

         %% intent de muntar un CMap x Identity-H fix i a mida
         %%liNka (w) file dup (/CIDInit /ProcSet findresource begin 12 dict begin begincmap /CIDSystemInfo << /Registry (MRCTFemFum_Coromines_IEDiBa+0) def /Ordering (MRCTFemFum_Coromines_IEDiBa) def /Supplement 0 def>> def /CMapName /MRCTFemFum_Coromines_IEDiBa+0 def 1 begincodespacerange <01> <ff> endcodespacerange 1 beginbfrange <01> <ff> <0001> endbfrange endcmap CMapName currentdict /CMap defineresource pop end end) writestring closefile
         %%DeCMapA256  % executem l'algorisme que passa CMap a 256
         /esUnicode true def  %% avisa que les cadenes venen en doble octet
         exch  %% posem sota el dict l'encoding (ja ben desat a /ENCpAqUEt) que deixa a la pila l'algorisme
         %%(!!!) pstack quit
        }stopped 
        {  %% si no troba el recurs, donem un error fatal ...
         BaBeL 44 get print flush stop  %%quit
        }if
       }
       {  %% si el CMap no es Identity-H, pleguem (els podem suportar tots pero ho deixem aqui x controlar-ho)
        BaBeL 44 get print flush stop  %%quit
       }ifelse
      }
      {  %% si no hi ha ni ToUnicode ni Encoding donem un error fatal ...
       BaBeL 44 get print flush stop  %%quit
      }ifelse
     }ifelse
    }
    {
     dup /CIDFontType0 eq
     {
      /FontTipus exch def  %% capturem el /Subtype per posteriors interrogacions
      /aSia exch  %% deixem el literal com a valor del resource name que ha d'activar l'Alerta Groga
     }
     {
      dup /CIDFontType2 eq
      {
       /FontTipus exch def  %% capturem el /Subtype per posteriors interrogacions
       /aSia exch  %% deixem el literal com a valor del resource name que ha d'activar l'Alerta Groga
      }
      {
%%(:::JBC!TT2)pstack quit
       %%% no es cap font asiatica (composite font)
       %%% ara activem el detectors de fonts CFF + Symbolic per Type1 i TrueType
       %%% les Symbolic fonts tenen molt numeros de no poder ser decodificades
       /CFF false def  %% valor per defecte del pestell CFF
       /SMBLC false def %% valor per defecte del pestell SMBLC
       /Tipus3 false def
       %% aqui hi havia FlagsFontDescriptor      
       /FontTipus exch def  %% capturem el /Subtype per posteriors interrogacions
       %%% detector CFF + Symbolic per a Type1 + MMType1
       FontTipus /Type1 eq FontTipus /MMType1 eq or
       {
        %%% pantalleta suprimit
        %% (Type1\n) print flush
        %% detector de l'entrada ToUnicode
        dup /ToUnicode known
        {
         %% posem un gatell per activar, si no hi ha /Encoding, el nou algorisme
         %% que recodifica el CMap a un Encoding 256
         /HiHaToUnicode true def
         dup /ToUnicode get /ElCMapToUnicode exch def
        }
        {
         /HiHaToUnicode false def
        }ifelse
        %% captura del nom PS de la font
        dup /BaseFont get /nomPS exch def
        dup /FontDescriptor known
        {
         dup /FontDescriptor get  %% ref ind del dict
         /aCercar exch def  %% nom amb la ref ind del tipus
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
         dup /FontFile3 known
         {
          /FontFile3 get dup type /nametype eq
          {
           /aCercar exch def  %% nom amb la ref ind del tipus
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           } loop  %% d'interrogacio dels dicts de COMdimoni  
           /Subtype get
          }
          {
           /Subtype get
          }ifelse  %% no fos cas que no sigui una ref ind
          /Type1C eq
          {
           /CFF true def
           %%% pantalleta suprimit
           %% (CFF\n) print flush
          }if  %% es una CFF !!
         }
         {
          %% es una Symbolic ?
          /Flags get  %% tibem el flag de la font
          %% analisi del Flags (miraflags.ps)
          /x exch def
          mark
          {  %% loop
           x 2 mod
           x 2 idiv dup /x exch def 0 eq {exit} if
          } loop
          counttomark array astore  %% deixem a la pila el desgranat binari en una array
          exch pop  %% ens carreguem mark
          %%% estrategia per la lectura de Flags (avalua els bits 1)
          /quinBIT 0 def  %% index del bit
          {  %% forall
           1 eq
           {
            %%% EP! aixo ens interessa pel verificador 10!
            %% quinBIT 1 add ==  % treu el valor de posicio del bit
            %%% pantalleta suprimit
            FlagsFontDescriptor quinBIT get cvx exec  %% extreu literariament el valor del Flag
            %% executa /SMBLC als bit 3 i/o 6
           }if quinBIT 1 add /quinBIT exch def 
          }forall
         %% fi de miraflags.ps
         } ifelse
        }if
       }if
       %%% fi del detector CFF + Symbolic per a Type1
       %%% detector de Type3
       FontTipus /Type3 eq
       {
        %%% pantalleta suprimit
        %% (Type3\n) print flush
        /Tipus3 true def
        %% captura del nom PS de la font
        %% per les Type 3 si no hi ha /BaseFont hi posem el de la clau /Name (obsoleta a partir de 1.3 ?)
        dup /BaseFont known
        {
         dup /BaseFont get /nomPS exch def
        }
        {
         dup /Name known  %% no és una entrada obligatòria
         {
          dup /Name get /nomPS exch def
         }
         {
          1 index /nomPS exch def  %% si no te nom propi li deixem l'intern del PDF
         }ifelse
        }ifelse
        %% detector de l'entrada ToUnicode
        dup /ToUnicode known
        {
         %% posem un gatell per activar, si no hi ha /Encoding, el nou algorisme
         %% que recodifica el CMap a un Encoding 256
         /HiHaToUnicode true def
         dup /ToUnicode get /ElCMapToUnicode exch def
        }
        {
         /HiHaToUnicode false def
        }ifelse
       } if
       %%% detector CFF + Symbolic per a TrueType
       FontTipus /TrueType eq
       {
        %%% pantalleta suprimit
        %% (TrueType\n) print flush
        %% detector de l'entrada ToUnicode
        dup /ToUnicode known
        {
         %% posem un gatell per activar, si no hi ha /Encoding, el nou algorisme
         %% que recodifica el CMap a un Encoding 256
         /HiHaToUnicode true def
         dup /ToUnicode get /ElCMapToUnicode exch def
        }
        {
         /HiHaToUnicode false def
        }ifelse
        %% captura del nom PS de la font
        dup /BaseFont get /nomPS exch def
        dup /FontDescriptor known
        {
         dup /FontDescriptor get  %% ref ind del dict
         /aCercar exch def  %% nom amb la ref ind
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni 
         dup /FontFile3 known
         {
          /FontFile3 get dup type /nametype eq
          {
           /aCercar exch def  %% nom amb la ref ind del tipus
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           } loop  %% d'interrogacio dels dicts de COMdimoni
           /Subtype get
          }
          {
           /Subtype get
          }ifelse  %% no fos cas que no sigui una ref ind
          /Type1C eq
          {
           /CFF true def
           %%% pantalleta suprimit
           %% (CFF\n) print flush
          }if  %% es una CFF !!
         }
         {
          %% es una Symbolic ?
          /Flags get  %% tibem el flag de la font
          %% analisi del Flags (miraflags.ps)
          /x exch def
          mark
          {  %% loop
           x 2 mod
           x 2 idiv dup /x exch def 0 eq {exit} if
          } loop
          counttomark array astore  %% deixem a la pila el desgranat binari en una array
          exch pop  %% ens carreguem mark
          %%% estrategia per la lectura de Flags (avalua els bits 1)
          /quinBIT 0 def  %% index del bit
          {  %% forall
           1 eq
           {  %%% EP! aixo ens interessa pel verificador 10!
            %%quinBIT 1 add ==  % treu el valor de posicio del bit
            %%% pantalleta suprimit
            FlagsFontDescriptor quinBIT get cvx exec  %% extreu literariament el valor del Flag
            %% executa /SMBLC als bit 3 i/o 6
           }if
           quinBIT 1 add /quinBIT exch def 
          }forall
          %% fi de miraflags.ps
         } ifelse
        }if
       }if
       %%% fi del detector CFF + Symbolic per a TrueType
      }ifelse
     }ifelse
    }ifelse
    %%% KTCS
    %% aqui es on hi va l'analitzador de Widths de la Font on tibar dels preestablerts
    %% en cas que fos alguna de les predefinides HTSZ

    FontTipus /Type0 eq
    {
     %% aquesta clau es necessaria x detectar els xifrats esoterics!
     dup /ToUnicode known{/HiHaToUnicode true def}{/HiHaToUnicode false def}ifelse
     dup /DescendantFonts get  %% dins l'entrada obligatoria de la font derivada hi hauriem de trobar els widths
     dup type /nametype eq
     {
      /aCercar exch def  %% nom amb la ref ind del tipus
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     %% aqui sempre hi haura d'haver una array d'1 sol element (ref ind q apunta al dic de la CID)
     0 get
     /aCercar exch def  %% nom amb la ref ind del tipus
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
     %% aqui hem de tenir el CIDFont dictionary ...
     %% preventivament interroguem si existeix l'entrada CIDToGIDMap doncs aquest seria un altre metode
     %% que potser ens cal implementar per mapejar correctament el paquet del xifrat (Encoding) ...

     dup /CIDToGIDMap known
/CIDToGIDMapStream false def  %% gatell per filtrar els casos com la KozGoPr6N de Masats
     {
      %% ens queda el dubte de si l'entrada CIDToGIDMap ens hauria d'obligar a refer l'encoding de Champollion en la font
      %% on correspongui, en cas dugui com a valor el nom /Identity, gairebé segur que no serà així, però en cas sigui un
      %% Stream de dades, l'experiència ens dirà si Champollion ja duu l'encoding segons el mapa de CIDs, si no fos així
      %% hauríem de llegir el tou de dades segons s'explica a la taula 5.14 del diccionari CIDFont (CIDToGIDMap_masats.txt)
      dup /CIDToGIDMap get /Identity eq
      {
       (\n ... hi ha CIDToGIDMap com a Identity ... no ens caldrà refer Champollion\n) print flush
      }
      {
       %% (\n ... hi ha CIDToGIDMap com a Stream ... ens caldrà refer Champollion?\n) print flush
%%Aquí és on muntem l'encoding específic en base a un raonament que hem de veure si és consistent:
%% 1 cal comprovar si l'entrada /Ordering al dic /CIDSystemInfo és (Identity), doncs si no estariem davant d'una font oriental
%% 2 si és així (doncs si no aturem la feina), podem fer dues coses:
%% A o decodifiquem i llegim l'objecte /CIDToGIDMap de manera que establim on és el FirtsChar (índex 1 de la font a CalaixDeTipus)
%% B o posem a pinyó fix que és a 31 i muntem l'encoding en base a la l'estructura de l'objecte /CIDToGIDMap
%% C o directament hi posem l'encoding WinANsi i el FirtsChar a 31 si veiem que només el fem servir pels Widths??
dup /CIDSystemInfo get
dup type /nametype eq
     {
      /aCercar exch def  %% nom amb la ref ind del tipus
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     %% aqui sempre hi haura d'haver un diccionari
/Ordering get (Identity) eq
{
 /CIDToGIDMapStream true def  %% gatell per filtrar els casos com la KozGoPr6N de Masats
%%Seria prudent aquí decodificar el tou de dades de l'objecte /CIDToGIDMap i repicar l'encoding si no és WinAnsi?
%%Vegeu: Mai hi haurà excepcions si duu l'objecte CIDToGIDMap com a stream?
}
{  %% aturem la feina doncs som davant d'una font oriental amb un encoding especial a implementar
 (\n\n >>>> som davant d'una font Type0 amb un encoding especial a implementar... pleguem!\n\n)print flush quit
}ifelse

      }ifelse
     }if
     dup /W known
     {
      dup /W get
dup type /nametype eq
     {
      /aCercar exch def  %% nom amb la ref ind del tipus
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     %% aqui sempre hi haura d'haver una array

      /CIDcintures exch def
      dup /DW known
      {  %% ample per defecte fixat per DW
       /DW get /ampleFix exch def
      }
      {  %% ample per defecte si DW no hi és
       pop /ampleFix 1000 def
      }ifelse

%% aquest mètode de càlcul del length de W era erroni:
%      %% com que és possible que l'array vagi més enllà dels 256, l'ajustem a la mida del darrer
%      %% índex definit, extraient els dos darrers elements i fent el càlcul d'aquesta array
%      CIDcintures dup length 2 sub 2 getinterval aload pop
%%Es aqui on tenim l'error del length a la C0_0 de MASATSonplora 
%4 index /C0_0 eq {/Emasats true def}{/Emasats false def}ifelse
%Emasats{(SOMvius)pstack quit}if

%      length add  %% calculem la mida màxima que tindrà aquest paquet d'amples de caràcter
%dup 256 gt
%{  %% si va més enllà del rang de 8 bits, el deixem intacte
%}
%{  %% si no hi arriba o és igual, l'acotem a 256
% pop 256
%}ifelse
%      /FAcintures exch def

%% per saber de veritat el valor del length final de W (FAcintures):
%% primer interrogarem el seu darrer element (length inicial de W -1)
CIDcintures dup length 1 sub dup /iDarrer exch def get
%% mirarem si és una array
dup type /arraytype eq
{  %% si ho és: el length final de W serà el valor de l'índex que precedeix l'array més el length d'aquesta array
 length CIDcintures iDarrer 1 sub get add /FAcintures exch def  %% length final de W
}
{  %% si no és una array, el length final de W serà el valor de l'anterior al que hem interrogat +1
 pop CIDcintures iDarrer 1 sub get 1 add /FAcintures exch def  %% length final de W
}ifelse

      /cintures FAcintures array def  %% paquet d'ample normalitzat tal com el necessitem
      0 1 FAcintures 1 sub{cintures exch ampleFix put}for  %% farcim el paquet d'amples fixos de valor DW
      CIDcintures length /maxWCID exch def
      CIDcintures 0 get
      %% cacem el primer index dels amples per avaluar el que seria el FirstChar
      %% i comprovem si correspon a /space doncs si no molt probablement som davant d'un xifrat esoteric!
      2 index exch dup
      /iCw exch def  %% desem el q seria l'equivalent a FirstChar x posar-lo despres a CalaixDeTipus
      get /space ne  %% si no es l'espai no estariem complint l'estructura de la Identity-H (idem WinAnsi)
      %% i si som aqui es que l'Encoding obligatoriament es un Identity-H, llavors ens guiem de la metrica
      %% per, si cal, corregir l'array WinAnsiEncoding2Identity-H doncs de moment es l'unic metode
      %% que tenim per fer-ho: entenem q l'index iCw correspon al primer caracter del xifrat estandard
      %% WinAnsi (Identity-H), o sigui 32 (/space), llavors si iCw no es 32 reposicionem tot el paquet en
      %% funcio del nou index iCw començant per /space (32) ... llavors ens queden dos camins a seguir:
      %% o nomes reposicionem els index (caracters) que surten a W, o enretirem a sac tota l'array?
      %% aixo darrer te el risc que sortim fora del rang del 255 ... pero fem aixo xq es + senzill ...
%%Atenció: hi ha l'excepció de CIDToGIDMapStream!
      {  %% ens cal corregir el xifrat (s'haura d'estudiar amb deteniment si compleix amb tots els casos)
       HiHaToUnicode
       {
        %%(\n >>> PROBABLEMENT hem detectat un xifrat esoteric! <<<\n\n)print flush
        (\n ... hi ha ToUnicode\n)print flush
       }
       {
        (\n >>> hem detectat un xifrat esoteric SEGUR! <<<\n)print flush
       }ifelse
CIDToGIDMapStream 
{
 (\n ... hi ha l'excepció de CIDToGIDMapStream\n)print flush
}
{
%%Si duu CMapIntern aquesta operació NO pot fer-se doncs el modifica erròniament!
%%Cal acabar d'esbrinar en quins casos aquest darrer recodificat ens interessa realment
CMapIntern not
{
       %% com q encara tenim l'encoding WinAnsiEncoding2Identity-H a la pila ...
       exch 32 256 32 sub getinterval  %% extraiem del primer al darrer codi definit
       /XiFRaT 256 array def 0 1 255 {XiFRaT exch /.notdef put}for  %% definim una array plena de /.notdef
       XiFRaT exch iCw exch putinterval  %% reincrustem l'ordre dels signes a partir de iCw
       XiFRaT exch  %% tornem l'encoding al seu lloc
}if

}ifelse
      }if
      /iWCID 0 def  %% index de l'array especial W d'amples de la font CID
      {  %% loop on muntem l'array dels Widths
       CIDcintures dup iWCID get /araCID exch def
       iWCID 1 add get dup type /arraytype eq
       {  %% es un paquet d'amples consecutius a partir d'araCID
        iWCID 2 add /iWCID exch def
        %% afegim a cintures els amples apartir d'araCID
        {cintures exch araCID exch put araCID 1 add /araCID exch def}forall
       }
       {  %% es un rang d'inici i final de dos codis amb el mateix ample
        araCID exch 1 exch  %% preparem el trident pel for
        CIDcintures iWCID 2 add get /ampleFix exch def  %% aquest es l'ample fix per al rang
        {cintures exch ampleFix put}for  %% desem a cintures
        iWCID 3 add /iWCID exch def
       }ifelse
       iWCID maxWCID eq {exit}if  %% hem explorat tot el paquet CIDcintures?
      }loop
      /noTEw false def  %% gatell x saber q en te
     }
     {  %% podria dur DW x tipus d'espaiat fix
      dup /DW known
      {
       /iCw 0 def  %% desem el q seria l'equivalent al FirstChar x posar-lo despres al CalaixDeTipus
       /DW get /ampleFix exch def
       %% 256 és un valor estable aquí?
       /cintures 256 array def
       0 1 255{cintures exch ampleFix put}for  %% farcim el paquet d'amples fixos de valor DW
       /noTEw false def  %% gatell x saber q en te
      }
      {
       %% com que no te Widths caldria saber si es d'alguna de les 14 PDF Core fonts
       %% tampoc no avaluem si duu W2 i DW2 doncs deixarem x+ endavant l'escriptura vertical
       /noTEw true def  %% gatell per saber q no en te i avaluar-ho + endavant
      }ifelse
     }ifelse
    }
    {
     dup /Widths known
     {  %% l'array dels Widths necessita ser controlat primer per mitja de l'index de /FirstChar
        %% doncs actuara com a restador de l'index del caracter per posicionar-nos a l'array Widths
        %% despres veurem si surt a compte traduir-ho a un dic amb els noms dels caracters
      dup /Widths get
      %% ens assegurem que hi sem l'array directe i no la seva ref ind
      dup type /nametype eq
      {
       /aCercar exch def  %% nom amb la ref ind
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get  %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
      }if
      /cintures exch def  %% el desem x posar-lo despres al CalaixDeTipus
      dup /FirstChar get /iCw exch def  %% el desem x posar-lo despres al CalaixDeTipus
      %%(\n\nTE widths\n) print flush
      /noTEw false def  %% gatell x saber q en te
     }
     {  %% com que no te Widths caldria saber si es d'alguna de les 14 PDF Core fonts
      /noTEw true def  %% gatell per saber q no en te i avaluar-ho + endavant
     }ifelse
    }ifelse
    %%% algorisme per muntar l'Encoding net i planxat al resource name dins de Champollion
    dup /Encoding known  %% hi ha /Encoding ?
    {  %% SI hi es pot ser un literal d'un encoding prefedefinit a COMdimoni o una ind ref d'un dict o un dict directe
     %% si hi ha Encoding hem d'assegurar-nos de no tenir activat el gatell de SMBLC, doncs malgrat estigui
     %% classificada aixi el comportament del seu xifrat es conegut i ens cal desactivar el flag xq treballi B
     SMBLC {/SMBLC false def}if
     /Encoding get dup type /dicttype eq
     {  %% es un dict directe
      dup /BaseEncoding known
      {  %% hi ha /BaseEncoding
       dup /BaseEncoding get
       /aCercar exch def  %% nom amb la ref ind
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni

       256 array copy /ENCpAqUEt exch def  %% encoding de la font
       dup /Differences known
       {
        /Differences get
        %% detector de caracters descrits en hexa (/G##), decimal (/G###) o nom literal (/quotesingle)
        %% els HEXA sempre tindran 3 caracters, els noms literals en tindran mes de 4
        /FuiG false def
        /NOMlit false def
        /HeXa true def
        dup
        {  %% forall
         dup type /integertype eq
         {
          pop
         }
         {
          %%% canviem el sistema per saber si els noms dels caracters son en literal, hexa o decimal
          /hiETS exch def
          PDFDocEncoding
          {  %% forall
           hiETS eq
           {
            /NOMlit true def /HeXa false def /FuiG true def exit
           }if
          } forall
          FuiG {exit} if
         }ifelse
        }forall
        %%HeXa {(\nES HEXA\n) print flush quit}{(\nES DECIMAL\n) print flush quit}ifelse
        %%NOMlit {(\nES un NOM Literal\n) print flush quit}{(\nES DECIMAL\n) print flush quit}ifelse
        %%% per detectar noms literals personalitzats i inexistents als encodings estandard
        %%% segurament nomes en fonts type3
        HeXa
        {
         hiETS 100 string cvs length 4 gt {/NOMlit true def /HeXa false def}if
         %% ara comprovem si el segon caracter no es numeric (mes xic de 48 'el 0' i mes gran de 57 'el 9')
         hiETS 100 string cvs 1 get dup 57 gt exch 48 lt or
         {
          /NOMlit true def /HeXa false def
         }  %% ES un literal doncs no es numeric
         {
          /NOMlit false def /HeXa true def
         }ifelse  %% NO es literal
        }if
        %% per saber si el nom de la lletra es decimal o hexa
        HeXa
        {
         dup
         {  %% forall
          dup type /integertype eq
          {
           pop
          }
          {
           4 string cvs length
           3 ne {/HeXa false def exit}{/HeXa true def}ifelse
          }ifelse
         } forall
        } if
        {  %% forall que munta les Differences dins l'encoding de la font ENCpAqUEt
         dup type /integertype eq
         {
          /NDeX exch def
         }
         {
          %% test i conversor de noms CFF
          CFF
          {
           HeXa
           {
            3 string cvs 1 2 getinterval  %% capturem en una cadena les dues darreres xifres hexa
            /ASCIIHexDecode filter 3 string readstring pop 0 get  %% decodifiquem a decimal la cadena hexa
            ISOLatin1Encoding exch get  %% anem a buscar el nom del caracter per posar-lo a l'encoding
           }
           {
            NOMlit
            {
             %% cadena buida doncs ja es el nom del caracter directament
            }
            {  %% es decimal
             4 string cvs dup length 1 exch 1 sub getinterval  %% capturem en una cadena les xifres decimals
             cvi  %% passem de cadena a xifra
             ISOLatin1Encoding exch get  %% anem a buscar el nom del caracter per posar-lo a l'encoding
            }ifelse
           }ifelse
          } if
          %% test de Symbolic font, podriem farcir d'asteriscs per anellar-les
          %% de moment apliquem el metode de sumar 29 al codi de la font Symbolic
          SMBLC
          {
           pop  %% ens carreguem el nom del caracter
           WinAnsiEncoding
           NDeX 29 add get  %% tibem el nom del caracter que suposem respon al metode -29
          } if
          Tipus3
          {  %% test per a Type3 amb codificacio privada (similar a SMBLC)
           /TaT exch def  %% capturem el nom del caracter
           WinAnsiEncoding
           /HIets true def  %% valor per defecte del detector de noms extranys
           {  %% forall
            TaT eq {/HIets false def exit}if
           }forall  %% per saber si el nom del caracter es conegut
           HIets
           {
            WinAnsiEncoding
            NDeX 29 add get
           }  %% tibem el nom del caracter que suposem respon al metode -29
           {
            TaT
           } ifelse  %% deixem el que hi havia
          } if
          ENCpAqUEt exch NDeX exch put NDeX 1 add /NDeX exch def
         }ifelse
        } forall
        ENCpAqUEt
        %% l'estatus d'Encoding
       }
       {  %% no hi ha Differences i deixem l'encoding igual
        pop ENCpAqUEt
        %% l'estatus d'Encoding
       }ifelse
      }
      {  %% no hi ha /BaseEncoding
       StandardEncoding 256 array copy /ENCpAqUEt exch def  %% encoding de a font
       SMBLC
       {
        SMBLCEncoding 410 array copy /ENCpAqUEt exch def  %% encoding de a font
       } if
       dup /Differences known
       {
        /Differences get
        %% detector de caracters descrits en hexa (/G##), decimal (/G###) o nom literal (/quotesingle)
        %% els HEXA sempre tindran 3 caracters, els noms literals en tindran mes de 4
        /FuiG false def
        /NOMlit false def
        /HeXa true def
        dup
        {
         dup type /integertype eq
         {
          pop
         }
         {
          %%% canviem el sistema per saber si els noms dels caracters son en literal, hexa o decimal
          /hiETS exch def
          PDFDocEncoding
          {  %% forall
           hiETS eq {/NOMlit true def /HeXa false def /FuiG true def exit}if
          } forall
          FuiG {exit} if
         }ifelse
        }forall
        %%HeXa {(\nES HEXA\n) print flush quit}{(\nES DECIMAL\n) print flush quit}ifelse
        %%NOMlit {(\nES un NOM Literal\n) print flush quit}{(\nES DECIMAL\n) print flush quit}ifelse
        %%% per detectar noms literals personalitzats i inexistents als encodings estandard
        %%% segurament nomes en fonts type3
        HeXa
        {
         hiETS 100 string cvs length 4 gt {/NOMlit true def /HeXa false def}if
         %% ara comprovem si el segon caracter no es numeric (mes xic de 48 'el 0' i mes gran de 57 'el 9')
         hiETS 100 string cvs 1 get dup 57 gt exch 48 lt or
         {
          /NOMlit true def /HeXa false def
         }  %% ES un literal doncs no es numeric
         {
          /NOMlit false def /HeXa true def
         }ifelse  %% NO es literal
        }if
        %% per saber si el nom de la lletra es decimal o hexa
        HeXa
        {
         dup
         {  %% forall
          dup type /integertype eq
          {
           pop
          }
          {
           4 string cvs length
           3 ne {/HeXa false def exit}{/HeXa true def}ifelse
          }ifelse
         } forall
        } if
        {  %% forall que munta les Differences dins l'encoding de la font ENCpAqUEt
         dup type /integertype eq
         {
          /NDeX exch def
         }
         {
          %% test i conversor de noms CFF
          CFF
          {
           HeXa
           {
            3 string cvs 1 2 getinterval  %% capturem en una cadena les dues darreres xifres hexa
            /ASCIIHexDecode filter 3 string readstring pop 0 get  %% decodifiquem a decimal la cadena hexa
            ISOLatin1Encoding exch get  %% anem a buscar el nom del caracter per posar-lo a l'encoding
           }
           {
            NOMlit
            {
             %% cadena buida doncs ja es el nom del caracter directament
            }
            {  %% es decimal
             4 string cvs dup length 1 exch 1 sub getinterval  %% capturem en una cadena les xifres decimals
             cvi  %% passem de cadena a xifra
             ISOLatin1Encoding exch get  %% anem a buscar el nom del caracter per posar-lo a l'encoding
            }ifelse
           }ifelse
          } if
          %% test de Symbolic font, podriem farcir d'asteriscs per anellar-les
          %% de moment apliquem el metode de sumar 29 al codi de la font Symbolic
          SMBLC
          {
           pop  %% ens carreguem el nom del caracter
           WinAnsiEncoding
           NDeX 29 add get  %% tibem el nom del caracter que suposem respon al metode -29
          } if
          Tipus3
          {  %% test per a Type3 amb codificacio privada (similar a SMBLC)
           /TaT exch def  %% capturem el nom del caracter
           WinAnsiEncoding
           /HIets true def  %% valor per defecte del detector de noms extranys
           {  %% forall
            TaT eq {/HIets false def exit}if
           }forall  %% per saber si el nom del caracter es conegut
           HIets
           {
            WinAnsiEncoding
            NDeX 29 add get
           }  %% tibem el nom del caracter que suposem respon al metode -29
           {
            TaT
           } ifelse  %% deixem el que hi havia
          } if
          ENCpAqUEt exch NDeX exch put NDeX 1 add /NDeX exch def
         }ifelse
        } forall
        ENCpAqUEt
        %% l'estatus d'Encoding
       }
       {  %% no hi ha Differences i deixem l'encoding igual
        pop ENCpAqUEt
        %% l'estatus d'Encoding
       }ifelse
      }ifelse
     }
     {
      %% pot ser el nom d'un encoding directe (false) o una ref ind (true)
      dup length 16 eq
      {
       dup 16 string cvs 10 get 95 eq{true}{false}ifelse
      }
      {
       false
      }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
      {  %% es una ref ind
       /aCercar exch def  %% nom amb la ref ind
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get true exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {false exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
      }
      {  %% pot ser un encoding predefinit
       %% existeix? (doncs si no es que es un literal d'un encoding d'una CID tipus /Identity-H
       dup currentdict exch known
       {
        cvx exec  %% executem el literal de l'encoding doncs ja el tenim definit segur (%20%)
        true
       }
       {
        false
       }ifelse
      }ifelse
      %% deixa un boolea de si existeix ... doncs si no, es que es un literal d'un encoding d'una CID tipus /Identity-H
      %% NOU 21.10.03
      {
       %%exch pop  % ens carreguem la clau q hem buscat
       dup type /dicttype eq
       {
        dup /BaseEncoding known
        {  %% hi ha /BaseEncoding
         dup /BaseEncoding get
         %% pot ser el literal d'un encoding directe (q se suposa ja tenim definit!) o una ref ind
         userdict 1 index known
         {
          userdict exch get
         }
         {
          /aCercar exch def  %% nom amb la ref ind
          /iDimoni 0 def
          {  %% loop d'interrogacio dels dicts de COMdimoni
           currentdict iDimoni 4 string cvs cvn get
           %% el diccionari de l'objecte
           dup aCercar known {aCercar get exit}{pop}ifelse
           iDimoni 1 add /iDimoni exch def
           iDimoni MaxDimoni eq {exit} if
          } loop  %% d'interrogacio dels dicts de COMdimoni
         }ifelse         
         256 array copy /ENCpAqUEt exch def  %% encoding de a font
         SMBLC
         {
          SMBLCEncoding 410 array copy /ENCpAqUEt exch def  %% encoding de a font
         } if
         dup /Differences known
         {
          /Differences get
          %% detector de caracters descrits en hexa (/G##), decimal (/G###) o nom literal (/quotesingle)
          %% els HEXA sempre tindran 3 caracters, els noms literals en tindran mes de 4
          /FuiG false def
          /NOMlit false def
          /HeXa true def
          dup
          {  %% forall
           dup type /integertype eq
           {
            pop
           }
           {
            %%% canviem el sistema per saber si els noms dels caracters son en literal, hexa o decimal
            /hiETS exch def PDFDocEncoding
            {  %% forall
             hiETS eq {/NOMlit true def /HeXa false def /FuiG true def exit}if
            } forall
            FuiG {exit} if
           }ifelse
          }forall
          HeXa {(\nES HEXA\n) print flush}{(\nES DECIMAL\n) print flush}ifelse
          NOMlit {(\nES un NOM Literal\n) print flush}{(\nES DECIMAL\n) print flush}ifelse
          %%% per detectar noms literals personalitzats i inexistents als encodings estandard
          %%% segurament nomes en fonts type3
          HeXa
          {
           hiETS 100 string cvs length 4 gt {/NOMlit true def /HeXa false def}if
           %% ara comprovem si el segon caracter no es numeric (mes xic de 48 'el 0' i mes gran de 57 'el 9')
           hiETS 100 string cvs 1 get dup 57 gt exch 48 lt or
           {
            /NOMlit true def /HeXa false def
           }  %% ES un literal doncs no es numeric
           {
            /NOMlit false def /HeXa true def
           }ifelse  %% NO es literal
          }if
          %% per saber si el nom de la lletra es decimal o hexa
          HeXa
          {
           dup
           {  %% forall
            dup type /integertype eq
            {
             pop
            }
            {
             4 string cvs length
             3 ne
             {
              /HeXa false def exit
             }
             {
              /HeXa true def
             }ifelse
            }ifelse
           } forall
          } if
          {  %% forall que munta les Differences dins l'encoding de la font ENCpAqUEt
           dup type /integertype eq
           {
            /NDeX exch def
           }
           {
            %% test i conversor de noms CFF
            CFF
            {
             HeXa
             {
              3 string cvs 1 2 getinterval  %% capturem en una cadena les dues darreres xifres hexa
              /ASCIIHexDecode filter 3 string readstring pop 0 get  %% decodifiquem a decimal la cadena hexa
              ISOLatin1Encoding exch get  %% anem a buscar el nom del caracter per posar-lo a l'encoding
             }
             {
              NOMlit
              {
               %% cadena buida doncs ja es el nom del caracter directament
              }
              {  %% es decimal
               4 string cvs dup length 1 exch 1 sub getinterval  %% capturem en una cadena les xifres decimals
               cvi %% passem de cadena a xifra
               ISOLatin1Encoding exch get  %% anem a buscar el nom del caracter per posar-lo a l'encoding
              }ifelse
             }ifelse
            } if
            %% test de Symbolic font, podriem farcir d'asteriscs per anellar-les
            %% de moment apliquem el metode de sumar 29 al codi de la font Symbolic
            SMBLC
            {
             pop  %% ens carreguem el nom del caracter
             WinAnsiEncoding
             NDeX 29 add get  %% tibem el nom del caracter que suposem respon al metode -29
            }if
            Tipus3
            {  %% test per a Type3 amb codificacio privada (similar a SMBLC)
             /TaT exch def  %% capturem el nom del caracter
             WinAnsiEncoding
             /HIets true def  %% valor per defecte del detector de noms extranys
             {  %% forall
              TaT eq {/HIets false def exit}if
             }forall  %% per saber si el nom del caracter es conegut
             HIets
             {  %% extraiem el nom del caràcter del que s'anomena «predefined encoding»
              WinAnsiEncoding NDeX
              %% 29 add  %% havíem detectat un metode anomenat -29 que feiem servir per extraure el nom del caràcter
              get
             }  %% tibem el nom del caràcter (el metode -29 no pot ser correcte per una Type3)
             {
              TaT
             }ifelse  %% deixem el que hi havia
            }if
            ENCpAqUEt exch NDeX exch put NDeX 1 add /NDeX exch def
           }ifelse
          }forall
          ENCpAqUEt
          %% l'estatus d'Encoding
         }
         {  %% no hi ha Differences i deixem l'encoding igual
          pop ENCpAqUEt
          %% l'estatus d'Encoding
         }ifelse
        }
        {  %% no hi ha /BaseEncoding
         StandardEncoding 256 array copy /ENCpAqUEt exch def  %% encoding de la font
         SMBLC
         {
          SMBLCEncoding 410 array copy /ENCpAqUEt exch def  %% encoding de a font
         } if
         dup /Differences known
         {
          /Differences get
          %% detector de caracters descrits en hexa (/G##), decimal (/G###) o nom literal (/quotesingle)
          %% els HEXA sempre tindran 3 caracters, els noms literals en tindran mes de 4
          /FuiG false def
          /NOMlit false def
          /HeXa true def
          dup
          {  %% forall
           dup type /integertype eq
           {
            pop
           }	
           {
            %%% canviem el sistema per saber si els noms dels caracters son en literal, hexa o decimal
            /hiETS exch def PDFDocEncoding
            {  %% forall
             hiETS eq {/NOMlit true def /HeXa false def /FuiG true def exit}if
            } forall
            FuiG {exit} if
           }ifelse
          }forall
          %% HeXa {(\nES HEXA\n) print flush}{(\nES DECIMAL\n) print flush}ifelse
          %% NOMlit {(\nES un NOM Literal\n) print flush}{(\nES DECIMAL\n) print flush}ifelse
          %%% per detectar noms literals personalitzats i inexistents als encodings estandard
          %%% segurament nomes en fonts type3
          HeXa
          {
           hiETS 100 string cvs length 4 gt {/NOMlit true def /HeXa false def}if
           %% ara comprovem si el segon caracter no es numeric (mes xic de 48 'el 0' i mes gran de 57 'el 9')
           hiETS 100 string cvs 1 get dup 57 gt exch 48 lt or
           {
            /NOMlit true def /HeXa false def
           }  %% ES un literal doncs no es numeric
           {
            /NOMlit false def /HeXa true def
           }ifelse  %% NO es literal
          }if
          %% per saber si el nom de la lletra es decimal o hexa
          HeXa
          {
           dup
           {  %% forall
            dup type /integertype eq
            {
             pop
            }
            {
             4 string cvs length
             3 ne {/HeXa false def exit}{/HeXa true def}ifelse
            }ifelse
           } forall
          } if
          {  %% forall que munta les Differences dins l'encoding de la font ENCpAqUEt
           dup type /integertype eq
           {
            /NDeX exch def
           }
           {
            %% test i conversor de noms CFF
            CFF
            {
             HeXa
             {
              3 string cvs 1 2 getinterval  %% capturem en una cadena les dues darreres xifres hexa
              /ASCIIHexDecode filter 3 string readstring pop 0 get  %% decodifiquem a decimal la cadena hexa
              ISOLatin1Encoding exch get  %% anem a buscar el nom del caracter per posar-lo a l'encoding
             }
             {
              NOMlit
              {
               %% cadena buida doncs ja es el nom del caracter directament
              }
              {  %% es decimal
               4 string cvs dup length 1 exch 1 sub getinterval  %% capturem en una cadena les xifres decimals
               cvi  %% passem de cadena a xifra
               ISOLatin1Encoding
               exch get  %% anem a buscar el nom del caracter per posar-lo a l'encoding
              }ifelse
             }ifelse
            }if
            %% test de Symbolic font, podriem farcir d'asteriscs per anellar-les
            %% de moment apliquem el metode de sumar 29 al codi de la font Symbolic
            SMBLC
            {
             pop  %% ens carreguem el nom del caracter
             WinAnsiEncoding
             NDeX 29 add get  %% tibem el nom del caracter que suposem respon al metode -29
            }if
            %%% (***) aqui i lloc similars haurem de tractar millor les tipus 3 quan poguem
            Tipus3
            {  %% test per a Type3 amb codificacio privada (similar a SMBLC)
             /TaT exch def  %% capturem el nom del caracter
             WinAnsiEncoding
             /HIets true def  %% valor per defecte del detector de noms extranys
             {  %% forall
              TaT eq {/HIets false def exit}if
             }forall  %% per saber si el nom del caracter es conegut
             HIets
             {  %% extraiem el nom del caràcter del que s'anomena «predefined encoding»
              WinAnsiEncoding NDeX
              %% 29 add  %% havíem detectat un metode anomenat -29 que feiem servir per extraure el nom del caràcter
              get
             }
             {
              TaT
             }ifelse  %% deixem el que hi havia
            }if
            ENCpAqUEt exch NDeX exch put NDeX 1 add /NDeX exch def
           }ifelse
          }forall
          ENCpAqUEt
          %% l'estatus d'Encoding
         }
         {  %% no hi ha Differences i deixem l'encoding igual
          pop ENCpAqUEt
          %% l'estatus d'Encoding
         }ifelse
        }ifelse
       }if  %% ets un dict ?
       %% NOU 21.10.03
      }
      {  %% es que es un literal d'un encoding d'una CID tipus /Identity-H?
       %% ens carreguem el nom de l'encoding
       /Identity-H eq
       {
        %% aquí podria ser que encara tinguessim l'encoding nu?
        dup /ncdngNU true def
        {  %% forall per detectar si tot són .notdef
         /.notdef ne
         {
          /ncdngNU false def
          exit
         }if
        }forall
        ncdngNU
        {  %% bescanviem l'encoding nu per l'ídem a WinAnsiEncoding
%%Mai hi haurà excepcions si duu l'objecte CIDToGIDMap com a stream?
         pop WinAnsiEncoding2Identity-H
        }if
       }
       {  %% CMap predefinit no suportat encara
        BaBeL 44 get print flush stop  %%quit
       }ifelse
      } ifelse
     }ifelse
    }
    {  %% si Encoding NO hi es...
     /aDins exch def  %% ens carreguem el dict de la font
     HiHaToUnicode
     {
      %% (\n\n ... Passo Per Aqui Doncs No Hi Ha /Encoding ... \n\n) print
      %% ( ... i el CMap de ToUnicode existeix ... \n\n) print
      %% flush
      DeCMapA256  %% executem l'algorisme que passa CMap a 256
      %% si hi ha ToUnicode hem d'assegurar-nos de no tenir activat el gatell de SMBLC, doncs malgrat estigui
      %% classificada aixi el comportament del seu xifrat es conegut i ens cal desactivar el flag xq treballi B
      SMBLC {/SMBLC false def}if
     }
     {
      QueLiFemFer 16 eq  %:16 cerca i substitució de text
      {
       nomPS
       %% extirpem el nom de la font original despres del + (si hi es)
       128 string cvs (+) search {pop pop}if
       RISCaFORASTERES exch known
       {  %% com que no duu Encoding i és una estàndard 14 font...
        aDins /Encoding /WinAnsiEncoding put  %% incrustem el WinAnsi a l'objecte /Font
        WinAnsiEncoding 256 array copy
%%(OSTRES!)pstack quit
       }
       {
        StandardEncoding 256 array copy  %% aquest és de debò i deixem l'array encoding davant el resource name
       }ifelse
      }  %/16 cerca i substitució de text
      {     
       %% cridem l'ISOLatin1Encoding a traves de la clau /StandardEncoding
       StandardEncoding 256 array copy  %% deixem l'array encoding davant el resource name
       SMBLC
       {
        pop SMBLCEncoding 410 array copy  %% encoding de a font
       }if
      }ifelse
     }ifelse
     %%(*** passo per aqui ***) ==
    }ifelse  %% de si hi ha Encoding
    Champollion 3 1 roll
    %% desem el nom PDF i el nom PS de la font a CalaixDeTipus
    1 index CalaixDeTipus exch nomPS 256 string cvs
    %%% KTCS
    noTEw  %% te Widths?
    {  %% com que no te Widths caldria saber si es d'alguna de les 14 PDF Core fonts
     nomPS
     %% extirpem el nom de la font original despres del + (si hi es)
     128 string cvs (+) search {pop pop}if
     dup 14PDFcoreFonts exch known
     { 
      /iCw 0 def  %% aqui l'index del primer caracter (/FirstChar) sera sempre zero
      (\n\nno te Widths, pero ES UNA 14 Core Font ... per tant els regenerem\n) print flush
      14PDFcoreFonts exch get  %% pesquem el dic dels Widths
      4 index  %% ara anem a cercar l'encoding que utilitza i muntem un paquet amb el Widths en funcio d'aquest
      /iEaW 0 def  %% index per reescriure l'array cintures amb els Widths
      dup length array /cintures exch def  %% muntem una array igual de llarga pels Widths
      {  %% forall x tot l'array de l'encoding final
       dup dup /.notdef eq
       {  %% si no es definit duu un ample de zero
        pop pop
        cintures iEaW 0 put
       }
       {
        2 index exch known
        {  %% incrustem a cintures el Width que li toca en funcio del seu index
         1 index exch get cintures exch iEaW exch put
        }
        {  %% si no es un caracter conegut ...
         %% ... podria tractar-se de la familia Courier d'espaiat fix (i llavors tots els caracters fan segons /ToTS)
         2 index (Courier) search
         {
          %% detector d'amplada fixa (Fixed Width o Fixed Pitch)
          /mqndscrr true def
          pop pop pop  %% desfeta de la cerca
          pop dup /ToTS get  %% treiem l'unic valor fix d'aquest dic
          %% incrustem a cintures el Width que li toca de forma fix
          cintures exch iEaW exch put
         }
         {  %% ... o tenim un problema!

%%% cal solucionar el problema dels amples de la Zapf i de la deteccio dels seus signes
%%[/.notdef /a1 /a2 /a3 /a4 /a5 /a6 /a7 /a8 /a9 /a10 /a11 /a12 /a13 /a14 /a15 /a16 /a17 /a18 /a19 /a20 /a21 /a22 /a23 /a24 /a25 /a26 /a27 /a28 /a29 /a30 /a31 /space /a33 /a34 /a35 /a36 /a37 /a38 /a39 /a40 /a41 /a42 /a43 /a44 /a45 /a46 /a47 /a48 /a49 /a50 /a51 /a52 /a53 /a54 /a55 /a56 /a57 /a58 /a59 /a60 /a61 /a62 /a63 /a64 /a65 /a66 /a67 /a68 /a69 /a70 /a71 /a72 /a73 /a74 /a75 /a76 /a77 /a78 /a79 /.notdef /a81 /a82 /a83 /a84 /a85 /a86 /a87 /a88 /a89 /a90 /a91 /a92 /a93 /a94 /a95 /a96 /a97 /a98 /a99 /a100 /a101 /a102 /a103 /a104 /a105 /a106 /a107 /a108 /a109 /a110 /a111 /a112 /.notdef /.notdef /.notdef /.notdef /a117 /a118 /a119 /a120 /a121 /a122 /a123 /a124 /a125 /a126 /a127 /a128 /a129 /a130 /a131 /a132 /a133 /a134 /a135 /a136 /a137 /a138 /a139 /a140 /a141 /a142 /a143 /a144 /a145 /a146 /a147 /a148 /a149 /a150 /a151 /a152 /a153 /a154 /a155 /a156 /a157 /a158 /a159 /a160 /a161 /a162 /a163 /a164 /a165 /a166 /a167 /a168 /a169 /a170 /a171 /a172 /a173 /a174 /a175 /a176 /a177 /a178 /a179 /a180 /a181 /a182 /a183 /a184 /a185 /a186 /a187 /a188 /a189 /a190 /a191 /a192 /a193 /a194 /a195 /a196 /a197 /a198 /a199 /a200 /a201 /a202 /a203 /a204 /a205 /a206 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef]
%%% aquest encoding provisional l'hem fabricat amb faZapfXifrat.ps

          pop  %% ens carreguem la copia de la cadena cercada
          ==  %% treiem el possible nom del signe x la pantalleta
          (\n\n ... hem detectat un caracter que no es a la llista oficial dels Widths ... \n ... llavors li atorguem un ample teoric de 600 ... i continuem!\n\n) print flush
          cintures iEaW 600 put
         }ifelse
        }ifelse
       }ifelse
       iEaW 1 add /iEaW exch def
      }forall
      pop  %% ens carreguem la copia del dic dels Widths tret de 14PDFcoreFonts
     }
     {  %% i en el cas de que no fos cap de les 14 llavors s'hauria d'avisar o donar un error greu
      == (\n\nNO te Widths i NO ES cap de les 14 Core Fonts\n) print flush
      ( ... com que aquest PDF no s'adiu al format, SORTIM!\n\n) print flush stop  %%quit
     }ifelse
    }if  %% x si no te Widths

    %% aqui es on muntem el nou array per /CalaixDeTipus
    %% 0 = nom PS de la font, 1 = index del primer caracter, 2 = paquet de Widths, 3 = gatell del doble octet, 4 = el width mitjà de l'array (com un null encara), 5 = diccionari o ref ind de l'objecte /Type /Font
    iCw cintures esUnicode null sesFonts 6 index get

    6 array astore
    %% UiX
    2 index araPlana known  %% hi ha el dic de la plana dins el dic CalaixDeTipus?
    {
     3 -1 roll araPlana get 3 1 roll  %% x desar a calaixDeTipus
    }
    {
     2 dict /araPD exch def araPD 3 1 roll put araPlana araPD  %% x desar a calaixDeTipus
    }ifelse
    put  %% desem a CalaixDeTipus com a valor de la clau del nom PDF de la font a la plana q toca
    %% UiX
    2 index araPlana known  %% hi ha el dic de la plana dins el dic Champollion?
    {
     3 -1 roll araPlana get 3 1 roll  %% x desar a Champollion
    }
    {
     2 dict /araPD exch def araPD 3 1 roll put araPlana araPD  %% x desar a Champollion
    }ifelse 
    put  %% desem a Champollion el nom PDF i l'encoding net i planxat a la plana q toca
   }forall  %% del dict de /Font
   %%% test a Champollion
   %%Champollion {== ==} forall
   %%% test a CalaixDeTipus
   %%CalaixDeTipus {== ==} forall
  }  %% hi ha /Font
  {  %% NO hi ha /Font
   BaBeL 43 get print flush
   pop  %% ens carreguem el dic Resources
   (:::JBC:::pagina sense TEXT) ==  %% cal veure com marquem les pagines sense text?
   %% ref ind i num de pag
   actGina == araPlana dup ==

   %% :-Z posem el detector numèric 0 a l'array SenseText per assenyalar que no en duu
   6 string cvs cvx exec SenseText exch 0 put

   %%<</Gina actGina /NOtxt true>> /Champollion exch def
  } ifelse
  %%% fi d'explorador de tipografies KTCS
 } forall  %% fi del forall x pagines
 %% x test
 %% }stopped {araPlana (aquiESonPloraLaCritura)pstack quit}if

 %% avaluem si un document no duu text per tal de decidir què fem
 0 SenseText {add}forall
 0 eq
 {  %% no duu text
  %% fitxer TXT de control del resultat pel web+PHP
  (NO.txt)  %% si HI HA aquest arxiu donarem un error de manca de text
   dup length faPath add string dup /pAthXiU exch def
  0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
  pAthXiU (w) file dup 32 write closefile
  (\n\n ... com que aquest PDF no duu text, SORTIM!\n\n) print flush stop
 }if
 %% SenseText (:-Z!)pstack quit

 %#%20bis2% de cada tipografia deduim el width+mig (la mitja de tots) x desar-lo a l'índex 4 de l'array de CalaixDeTipus
 (%#%20bis2%)==

 %% CalaixDeTipus
 %% {
 %%  dup
 %%  2 get
 %%  0 /width+grAn exch def
 %%  {  % avaluem el valor + gran de l'array de widths
 %%   dup width+grAn gt {/width+grAn exch def}{pop}ifelse
 %%  }forall
 %%  4 width+grAn put
 %%  pop
 %% }forall

 CalaixDeTipus
 {  %% forall x plana
  %% UiX
  exch pop
  {  %% forall x font
   dup
   2 get
   0 /width+mig exch def
   {  %% canmas de 2 de l'array de widths
    dup null eq
    {
     pop
    }
    {
     width+mig add 2 div /width+mig exch def
    }ifelse
   }forall
   4 width+mig put
   pop
  }forall
 }forall

%% CalaixDeTipus {== ==}forall  (*?*)== quit
}if  %/16 cerca i substitució de text
     %/12 arbre jeràrquic
     %/08 ETIQUETA TEXT
     %/05 dada variable
     %/04 ANÀLISI TEXTUAL
     %/03 CORRECTOR TIPOGRÀFIC

%% Champollion/1 get{== ==}forall
%% (...U...)== quit

%% llindar del valor de Prosa (kerning) per sobre del qual considerarem que separa mots
%% aquest paràmetre l'hauríem de fer dinàmic en funció la tipografia de treball consultant la mètrica de /space
/suaraKern 185 def

%% gatell per saber si hem de menjar-nos els nulls, però ara sense ús, però l'utilitzaríem
%% per exemple, per menjar-nos els nulls amb la prosa que està per sota del valor de suaraKern
/deixaNull true def

%#%21% diccionari per replicar de forma idèntica els Contents (OpContents_QueLiFemFer1)
(%#%21%)==
%% aquest diccionari redefineix els operadors PDF per reescriure la informacio
%% de forma identica o amb modificacions al contingut de l'stream Content
%% versio actual 1.7
%% canviem l'espai de separacio del final d'operador per \015 (CR)
%% aixi facilitarem la reescriptura dels streams trencats
%% filtrem tots el nums reals amb risc de tenir molts decimals x evitar notacions exponencials tipus 123.6e10
%% no suportades pel PDF ...ho deixem a 4 zeros (amb més pot donar exponencials!), fent: 10000 mul truncate 10000 div 

/OpContents_QueLiFemFer1
<<
%#%21bis% activem els valors d'índex corresponents a QueLiFemFer
(%#%21bis%)==
  %%% x activar la corresponent redefinicio de cada operador
  [
   {  %% 0 reescriptura idem
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 1 separació de tintes
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 1 def
    /i_G 1 def
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 1 def
    /i_SC 1 def
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 1 def
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 2 marques de tall
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 3 corrector tipogràfic
    /i_q 2 def
    /i_Q 2 def
    /i_cm 2 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 2 def
    /i_Tw 2 def
    /i_Tz 2 def
    /i_TL 2 def
    /i_Tf 2 def
    /i_Tr 1 def
    /i_Ts 2 def
    /i_BT 2 def
    /i_ET 2 def
    /i_Td 2 def
    /i_TD 2 def
    /i_Tm 2 def
    /i_T* 2 def
    /i_Tj 2 def
    /i_' 2 def
    /i_" 2 def
    /i_TJ 2 def
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 4 anàlisi textual
    /i_q 2 def
    /i_Q 2 def
    /i_cm 2 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 2 def
    /i_Tw 2 def
    /i_Tz 2 def
    /i_TL 2 def
    /i_Tf 2 def
    /i_Tr 1 def  %% cal afegir com a minim un detector de text ocult x decidir q fem
    /i_Ts 2 def
    /i_BT 2 def
    /i_ET 2 def
    /i_Td 2 def  %% nova redefinicio x l'analitzador textual (JBC)
    /i_TD 2 def  %% nova redefinicio x l'analitzador textual (JBC)
    /i_Tm 2 def
    /i_T* 2 def
    /i_Tj 3 def  %% nova redefinicio x l'analitzador textual (JBC)
    /i_' 3 def  %% nova redefinicio x l'analitzador textual (JBC)
    /i_" 3 def  %% nova redefinicio x l'analitzador textual (JBC)
    /i_TJ 3 def  %% nova redefinicio x l'analitzador textual (JBC)
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 5 dada variable
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 2 def  %% anàlisi textual per bastir tipusDADAv
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 4 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 3 def
    /i_EMC 3 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 6 cosit d'imatges
    /i_q 2 def
    /i_Q 2 def
    /i_cm 2 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 2 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 7 reinsereix imatges JPEG
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 3 def
    /i_BI 2 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 8 etiqueta text
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 9 extrau imatges JPEG
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 3 def
    /i_BI 2 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 10 preflight amb capes
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def
    /i_G 0 def
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def
    /i_SC 0 def
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 2 def  %% activa les llesques dels vectorials
    /i_c 2 def  %% activa les llesques dels vectorials
    /i_v 2 def  %% activa les llesques dels vectorials
    /i_y 2 def  %% activa les llesques dels vectorials
    /i_re 2 def  %% activa les llesques dels vectorials
    /i_h 1 def
    /i_n 2 def  %% activa les llesques dels vectorials
    /i_s 2 def  %% activa les llesques dels vectorials
    /i_S 2 def  %% activa les llesques dels vectorials
    /i_f 2 def  %% activa les llesques dels vectorials
    /i_F 2 def  %% activa les llesques dels vectorials
    /i_f* 2 def  %% activa les llesques dels vectorials
    /i_b 2 def  %% activa les llesques dels vectorials
    /i_B 2 def  %% activa les llesques dels vectorials
    /i_b* 2 def  %% activa les llesques dels vectorials
    /i_B* 2 def  %% activa les llesques dels vectorials
    /i_sh 2 def  %% activa les llesques dels Shading Patterns
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 3 def  %% activa les llesques de Text
    /i_ET 3 def  %% activa les llesques de Text
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 4 def  %% activa les llesques d'imatge XObject + Form
    /i_BI 3 def  %% activa les llesques d'imatge inLine
    /i_ID 3 def  %% activa les llesques d'imatge inLine
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 2 def  %% activa l'esquilat de llesques
    /i_BDC 2 def  %% activa l'esquilat de llesques
    /i_EMC 2 def  %% activa l'esquilat de llesques
    /i_MP 1 def
    /i_DP 1 def
   }
   null  %% 11 torsimany 4+8
   {  %% 12 arbre jeràrquic: suma de #00 + #04
    /i_q 2 def
    /i_Q 2 def
    /i_cm 0 def  %% suma 1+2
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 2 def
    /i_Tw 2 def
    /i_Tz 2 def
    /i_TL 0 def  %% suma 1+2
    /i_Tf 2 def
    /i_Tr 1 def
    /i_Ts 2 def
    /i_BT 2 def
    /i_ET 2 def
    /i_Td 0 def  %% suma 1+2
    /i_TD 0 def  %% suma 1+2
    /i_Tm 0 def  %% suma 1+2
    /i_T* 0 def  %% suma 1+2
    /i_Tj 0 def  %% suma 1+3
    /i_' 0 def  %% suma 1+3
    /i_" 0 def  %% suma 1+3
    /i_TJ 0 def  %% suma 1+3
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 13 eliminem continguts de pàgina ... idem 10 preflight amb capes
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def
    /i_G 0 def
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def
    /i_SC 0 def
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 2 def  %% activa les llesques dels vectorials
    /i_c 2 def  %% activa les llesques dels vectorials
    /i_v 2 def  %% activa les llesques dels vectorials
    /i_y 2 def  %% activa les llesques dels vectorials
    /i_re 2 def  %% activa les llesques dels vectorials
    /i_h 1 def
    /i_n 2 def  %% activa les llesques dels vectorials
    /i_s 2 def  %% activa les llesques dels vectorials
    /i_S 2 def  %% activa les llesques dels vectorials
    /i_f 2 def  %% activa les llesques dels vectorials
    /i_F 2 def  %% activa les llesques dels vectorials
    /i_f* 2 def  %% activa les llesques dels vectorials
    /i_b 2 def  %% activa les llesques dels vectorials
    /i_B 2 def  %% activa les llesques dels vectorials
    /i_b* 2 def  %% activa les llesques dels vectorials
    /i_B* 2 def  %% activa les llesques dels vectorials
    /i_sh 2 def  %% activa les llesques dels Shading Patterns
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 3 def  %% activa les llesques de Text
    /i_ET 3 def  %% activa les llesques de Text
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 4 def  %% activa les llesques d'imatge XObject + Form
    /i_BI 3 def  %% activa les llesques d'imatge inLine
    /i_ID 3 def  %% activa les llesques d'imatge inLine
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 2 def  %% activa l'esquilat de llesques
    /i_BDC 2 def  %% activa l'esquilat de llesques
    /i_EMC 2 def  %% activa l'esquilat de llesques
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13 (de moment idem a 13)
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def
    /i_G 0 def
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def
    /i_SC 0 def
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 2 def  %% activa les llesques dels vectorials
    /i_c 2 def  %% activa les llesques dels vectorials
    /i_v 2 def  %% activa les llesques dels vectorials
    /i_y 2 def  %% activa les llesques dels vectorials
    /i_re 2 def  %% activa les llesques dels vectorials
    /i_h 1 def
    /i_n 2 def  %% activa les llesques dels vectorials
    /i_s 2 def  %% activa les llesques dels vectorials
    /i_S 2 def  %% activa les llesques dels vectorials
    /i_f 2 def  %% activa les llesques dels vectorials
    /i_F 2 def  %% activa les llesques dels vectorials
    /i_f* 2 def  %% activa les llesques dels vectorials
    /i_b 2 def  %% activa les llesques dels vectorials
    /i_B 2 def  %% activa les llesques dels vectorials
    /i_b* 2 def  %% activa les llesques dels vectorials
    /i_B* 2 def  %% activa les llesques dels vectorials
    /i_sh 2 def  %% activa les llesques dels Shading Patterns
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 3 def  %% activa les llesques de Text
    /i_ET 3 def  %% activa les llesques de Text
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 4 def  %% activa les llesques d'imatge XObject + Form
    /i_BI 3 def  %% activa les llesques d'imatge inLine
    /i_ID 3 def  %% activa les llesques d'imatge inLine
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 2 def  %% activa l'esquilat de llesques
    /i_BDC 2 def  %% activa l'esquilat de llesques
    /i_EMC 2 def  %% activa l'esquilat de llesques
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 15 ... eliminem continguts (MASATS)
    /i_q 3 def
    /i_Q 3 def
    /i_cm 3 def
    /i_i 2 def
    /i_J 2 def
    /i_d 2 def
    /i_j 2 def
    /i_w 2 def
    /i_M 2 def
    /i_gs 2 def
    /i_g 2 def
    /i_G 2 def
    /i_rg 2 def
    /i_RG 2 def
    /i_k 2 def
    /i_K 2 def
    /i_cs 2 def
    /i_CS 2 def
    /i_sc 2 def  %%MASATS08 (desactivat x Vectorworks 2015) corregim les mancances de definició d'espai de color canviant a rg i RG
    /i_SC 2 def  %%MASATS08
    /i_scn 2 def  %%MASATS08 (desactivat x Vectorworks 2015) ídem anterior però prevenint que no es cridi un Pattern via literal
    /i_SCN 2 def  %%MASATS08
    /i_ri 2 def
    /i_m 2 def
    /i_l 3 def
    /i_c 3 def
    /i_v 3 def
    /i_y 3 def
    /i_re 3 def
    /i_h 2 def
    /i_n 3 def
    /i_s 3 def
    /i_S 3 def
    /i_f 3 def
    /i_F 3 def
    /i_f* 3 def
    /i_b 3 def
    /i_B 3 def
    /i_b* 3 def
    /i_B* 3 def
    /i_sh 3 def
    /i_W 2 def
    /i_W* 2 def
    /i_Tc 3 def
    /i_Tw 3 def
    /i_Tz 3 def
    /i_TL 3 def
    /i_Tf 3 def
    /i_Tr 2 def
    /i_Ts 3 def
    /i_BT 4 def
    /i_ET 4 def
    /i_Td 3 def
    /i_TD 3 def
    /i_Tm 3 def
    /i_T* 3 def
    /i_Tj 5 def
    /i_' 4 def
    /i_" 4 def
    /i_TJ 4 def
    /i_Do 5 def
    /i_BI 4 def
    /i_ID 4 def
    /i_d0 2 def
    /i_d1 2 def
    /i_BX 2 def
    /i_EX 1 def  %% en realitat no es defineix
    /i_BMC 3 def
    /i_BDC 4 def
    /i_EMC 4 def
    /i_MP 2 def
    /i_DP 2 def
   }
   {  %% 16 ara ídem 12 (arbre jeràrquic: suma de #00 + #04) cerca i substtitució de text en unes condicions concretes (MASATS)
%% reorganitzem els operadors segons s'ordenen i s'agrupen a la darrera versió de pdf, la 1.7, validada per ISO
%% Compatibility 3.7.1 Content Streams
    /i_BX 1 def
    %%/i_EX 1 def  %% se'l menja BX
%% 4.3.3 Graphics State Operators
    /i_q 2 def
    /i_Q 2 def
    /i_cm 0 def  %% suma 1+2
    /i_w 1 def
    /i_J 1 def
    /i_j 1 def
    /i_M 1 def
    /i_d 1 def
    /i_ri 1 def
    /i_i 1 def
    /i_gs 1 def
%% (no implementats) 4.3.4 Graphics State Parameter Dictionaries
%% 4.4.1 Path Construction Operators
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_h 1 def
    /i_re 1 def
%% 4.4.2 Path-Painting Operators
    /i_S 1 def
    /i_s 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_B 1 def
    /i_B* 1 def
    /i_b 1 def
    /i_b* 1 def
    /i_n 1 def
%% 4.4.3 Clipping Path Operators
    /i_W 1 def
    /i_W* 1 def
%% 4.5.7 Color Operators
    /i_CS 1 def
    /i_cs 1 def
    /i_SC 0 def  %% refet pel repicat idem
    /i_SCN 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_G 0 def  %% refet pel repicat idem
    /i_g 0 def  %% refet pel repicat idem
    /i_RG 1 def
    /i_rg 1 def
    /i_K 1 def
    /i_k 1 def
%% 4.6 Shading Patterns
    /i_sh 1 def
%% XObjects 4.8 Images 4.9 Form XObjects
    /i_Do 1 def
%% 4.8.6 Inline Images
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    %%/i_EI 0 def  %% se'l menja ID
%% 5.2 Text State Parameters and Operators
    /i_Tc 2 def
    /i_Tw 2 def
    /i_Tz 2 def
    /i_TL 0 def  %% suma 1+2
    /i_Tf 2 def
    /i_Tr 1 def
    /i_Ts 2 def
%% 5.3.1 Text-Positioning Operators
    /i_Td 0 def  %% suma 1+2
    /i_TD 0 def  %% suma 1+2
    /i_Tm 0 def  %% suma 1+2
    /i_T* 0 def  %% suma 1+2
%% 5.3.2 Text-Showing Operators
    /i_Tj 0 def  %% suma 1+3
    /i_' 0 def  %% suma 1+3
    /i_" 0 def  %% suma 1+3
    /i_TJ 0 def  %% suma 1+3
%% Text object
    /i_BT 2 def
    /i_ET 2 def
%% Type 3 fonts
    /i_d0 1 def
    /i_d1 1 def
%% 10.5 Marked Content
    /i_MP 1 def
    /i_DP 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
   }
   {  %% 17 %%MASATSencvlct idèntic a reescriptura idem
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 0 def  %% refet pel repicat idem
    /i_G 0 def  %% refet pel repicat idem
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 0 def  %% refet pel repicat idem
    /i_SC 0 def  %% refet pel repicat idem
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 2 def  %% no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
  ] QueLiFemFer get cvx exec

  %% inicialitzem les funcions dels valors actuals de ...
  /csARA [null] def  %% Espai de Color actual per fill
  /CSARA [null] def  %% Espai de Color actual per stroke
  /gsARA [null] def  %% Estat Grafic actual
  /tintARA [null] def  %% valor de Tinta actual
  /Tfill 0 def  %% valor inical del gatell (suposem que no afecta) per saber si el valor de tinta es per fill (0) o stroke (1)
  /Tzero false def  %% valor inicial del gatell x saber si hem pintat amb tinta zero (blanc)
  /NomesUn true def  %% valor inicial del gatell x saber si nomes treballem amb un espai de color d'1 sol component
  %% ... dins el dic d'OpContents

  %%% desem de moment la rutina conversora de la gamma de colors en aquest mateix dic
  %% rutina x emmagatzemar el color (modificacio de faPaletaCMYK utilitzada a l'aTLeS x tractar Pantones) en hexa a la cadena els8vals
  /faPaletaCMYK2Hexa
  {
   %% emmagatzemem els 4 colors en una string primer en binari
   4 string /els4vals exch def
   %% i despres en hexa
   8 string /els8vals exch def
   4 copy  %% copiem els colors actuals
   %% els desem passant a valors entre 0 i 255
   255 mul round cvi /araFaK exch def
   255 mul round cvi /araFaY exch def
   255 mul round cvi /araFaM exch def
   255 mul round cvi /araFaC exch def
   els4vals /NullEncode filter  %% string com a fitxer x bin
   dup araFaC write
   dup araFaM write
   dup araFaY write
   dup araFaK write
   flushfile
   els8vals /NullEncode filter  %% string com a fitxer x hexa
   dup els4vals writehexstring
   flushfile
  } bind def

  %% solucio DeviceGray
  %% rutina x emmagatzemar el color (modificacio de faPaletaCMYK utilitzada a l'aTLeS x tractar Pantones) en hexa a la cadena elval
  /faPaletaG2Hexa
  {
   %% % emmagatzemem 1 color en una string primer en binari
   %% 1 string /elval exch def
   %% % i despres en hexa
   %% 2 string /els2vals exch def
   %% dup  % copiem el color actual
   %% % el desem passant a valors entre 0 i 255
   %% 255 mul round cvi /araFaK exch def
   %% elval /NullEncode filter  % string com a fitxer x bin
   %% dup araFaK write
   %% flushfile
   %% els2vals /NullEncode filter  % string com a fitxer x hexa
   %% dup elval writehexstring
   %% flushfile

   %% emmagatzemem els 4 colors en una string primer en binari
   4 string /els4vals exch def
   %% i despres en hexa
   8 string /els8vals exch def
   0 exch 0 exch 0 exch  %% farcim amb els 3 colors que mancarien x ser CMYK
   1 exch sub  %% invertim el color DGray (va a l'inreves q el CMYK)
   4 copy  %% i en fem una copia
   %% els desem passant a valors entre 0 i 255
   255 mul round cvi /araFaK exch def
   255 mul round cvi /araFaY exch def
   255 mul round cvi /araFaM exch def
   255 mul round cvi /araFaC exch def
   els4vals /NullEncode filter  %% string com a fitxer x bin
   dup araFaC write
   dup araFaM write
   dup araFaY write
   dup araFaK write
   flushfile
   els8vals /NullEncode filter  %% string com a fitxer x hexa
   dup els4vals writehexstring
   flushfile
  } bind def
  %% solucio DeviceGray

  /iiLine 0 def  %% numerador pels noms de les imatges InLine

%% (PDF Ref 1.7) %% Compatibility 3.7.1 Content Streams
%% (PDF Ref ?) 8.10.2 Compatibility operators
  [  %% BX
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %% els operadors BX EX s'haurien d'utilitzar nomes per marcar parts del tou de dades que no s'adiuen amb la sintaxi de
    %% PDF o per blindar incompatibilitats dins de la mateixa evolucio de format (hi ha fitxers que n'abusen!)
    (\n\n ... tou de dades blindat amb BX ... EX i amb possibles incompatibilitats\n) print flush  %% n'avisem
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (BX\012) writestring
    %% llegim les definicions fins a EX i comprovem si es codi compatible per mitja d'stopped
    %% si NO ho es el reescrivim de forma identica sense interpretar-lo i SI ho es l'interpretem
    currentfile
    <<
      /Filter /SubFileDecode
      /DecodeParms <</EODCount 0 /EODString (EX)>>
    >> /ReusableStreamDecode filter
    dup dup flushfile {cvx exec} stopped  %% peta?
    {  %% NO es compatible
     dup 0 setfileposition  %% ens posicionem a l'inici del tou de dades per reescriure'l sense interpretar
     {
      65535 string readstring
      {sEdAs exch writestring}{sEdAs exch writestring sEdAs (EX\012) writestring exit}ifelse
     }loop
    }
    {  %% SI es compatible
     dup 0 setfileposition  %% ens posicionem a l'inici del tou de dades per interpretar-lo
     cvx exec
     sEdAs (EX\012) writestring
    } ifelse
    }stopped{( ... peta BX 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     %% llegim el tou de dades fins a EX sense escriure re
     currentfile
     <<
       /Filter /SubFileDecode
       /DecodeParms <</EODCount 0 /EODString (EX)>>
     >> /ReusableStreamDecode filter
     dup flushfile closefile
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %%{  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    %% els operadors BX EX s'haurien d'utilitzar nomes per marcar parts del tou de dades que no s'adiuen amb la sintaxi de
    %% PDF o per blindar incompatibilitats dins de la mateixa evolucio de format (hi ha fitxers que n'abusen!)
    (\n\n ... tou de dades blindat amb BX ... EX i amb possibles incompatibilitats\n) print flush  %% n'avisem
    sEdAs (BX\012) writestring
    %% llegim les definicions fins a EX i comprovem si es codi compatible per mitja d'stopped
    %% si NO ho es el reescrivim de forma identica sense interpretar-lo i SI ho es l'interpretem
    currentfile
    <<
      /Filter /SubFileDecode
      /DecodeParms <</EODCount 0 /EODString (EX)>>
    >> /ReusableStreamDecode filter
    dup dup flushfile {cvx exec} stopped  %% peta?
    {  %% NO es compatible
     dup 0 setfileposition  %% ens posicionem a l'inici del tou de dades per reescriure'l sense interpretar
     {
      65535 string readstring
      {sEdAs exch writestring}{sEdAs exch writestring sEdAs (EX\012) writestring exit}ifelse
     }loop
    }
    {  %% SI es compatible
     dup 0 setfileposition  %% ens posicionem a l'inici del tou de dades per interpretar-lo
     cvx exec
     sEdAs (EX\012) writestring
    } ifelse
    %%}{
    %%  currentfile 0 (EX) /SubFileDecode filter
    %%  closefile  % ens carreguem tot el que hi hagi entre BX/EX
    %% }ifelse  % de la tinta que toca ara
    %%}stopped{( ... peta BX) == quit}if
    }ifelse
   }
  ] i_BX get /BX exch bind def

  %% [  % EX
  %% {  % 0 (idem)
  %% }
  %% {  % 1 (separacions) redefinicio generada pel projecte WebProof
  %%  %%test
  %%  %{  % stopped
  %%  %sEdAs (EX\015) writestring
  %%  %%test
  %%  %}stopped{( ... peta EX) == quit}if
  %% }  % no cal definir-lo doncs sempre ens el mengem llegint BX
  %% ] i_EX get /EX exch bind def

  %% (PDF Ref ?) 8.3.2 Special Graphics State operators
  %% (PDF Ref 1.7) 4.3.3 Graphics State Operators
  [  %% q
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)

    %% l'operador 'q' sempre afegira un nou element null a la posicio 0 de l'array
    %% del valor actual que, actuant com una pila, augmentara en 1 element (tret que originalment nomes hi hagi 1 sol valor)
    csARA 0 get null ne  %% actuem sobre el ColorSpace actual per fill
    {
     csARA length 1 add array dup
     1 csARA putinterval
     dup 0 null put /csARA exch def
    } if
    CSARA 0 get null ne  %% actuem sobre el ColorSpace actual per stroke
    {
     CSARA length 1 add array dup
     1 CSARA putinterval
     dup 0 null put /CSARA exch def
    } if

    sEdAs (q\012) writestring
    %%}stopped{( ... peta q) == quit}if
   }
   {  %% 2 (relliga imatges + correccio L·L + analisi textual) | gatells: 16
    {  %% stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)

    %% l'operador 'q' sempre afegira un nou element null a la posicio 0 de l'array
    %% del valor actual que, actuant com una pila, augmentara en 1 element (tret que originalment nomes hi hagi 1 sol valor)
    csARA 0 get null ne  %% actuem sobre el ColorSpace actual per fill
    {
     csARA length 1 add array dup
     1 csARA putinterval
     dup 0 null put /csARA exch def
    } if
    CSARA 0 get null ne  %% actuem sobre el ColorSpace actual per stroke
    {
     CSARA length 1 add array dup
     1 CSARA putinterval
     dup 0 null put /CSARA exch def
    } if

    sEdAs (q\012) writestring

    %%% KTCS
    %% EP! cal veure si ens interessa mes aquesta estrategia de la copia identica q no pas iniciar un diccionari buit que
    %% l'aniriem omplint d'elements de l'estat grafic a mida que anessin sortint, d'aquesta manera sempre podrem saber en
    %% quin context s'ha produit un determinat valor que ens interessi avaluar (de moment aixo nomes ho activem per #6 i a OpContents_QueLiFemFer2)

    EstatGrafic dup iEG get dup length dict copy  %% deixem a la pila una copia identica (desvinculada) del dic de l'estat grafic actual
    %% ampliarem el paquet EstatGrafic per posar-hi el nou dic
    exch dup length 1 add array dup 3 -1 roll 0 exch putinterval
    
    iEG 1 add /iEG exch def  %% actualitzem l'index del dic de l'estat grafic actiu
    %% afegim la copia del dic de l'estat grafic anterior (ara ja es l'actual!) a la darrera posicio
    dup 3 -1 roll  
    iEG exch put
    /EstatGrafic exch def  %% desem el paquet ampliat dels dics l'estat grafic
    }stopped{( ... peta q 2) pstack stop}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
    }
    {
     /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (q\012) writestring
    }ifelse
    %%}stopped{( ... peta q) == quit}if
   }
  ] i_q get /q exch bind def

  [  %% Q
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)

    %% l'operador 'Q' sempre restara l'element de la posicio 0 de l'array
    %% del valor actual que, actuant com una pila, minvara d'1 element
    %% i si originalment nomes hi ha 1 sol valor, hi posara un null al seu lloc
    csARA 0 get null ne  %% actuem sobre el ColorSpace actual per fill
    {
     csARA length 1 sub
     0 eq {/csARA [null] def}
     {
      csARA dup length 1 sub 1 exch getinterval
      /csARA exch def
     }ifelse
    } if
    CSARA 0 get null ne  %% actuem sobre el ColorSpace actual per stroke
    {
     CSARA length 1 sub
     0 eq {/CSARA [null] def}
     {
      CSARA dup length 1 sub 1 exch getinterval
      /CSARA exch def
     }ifelse
    } if

    sEdAs (Q\012) writestring
    %%}stopped{( ... peta Q) == quit}if
   }
   {  %% 2 (relliga imatges + correccio L·L + analisi textual) | gatells: 16
    {  %% stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)

    %% l'operador 'Q' sempre restara l'element de la posicio 0 de l'array
    %% del valor actual que, actuant com una pila, minvara d'1 element
    %% i si originalment nomes hi ha 1 sol valor, hi posara un null al seu lloc
    csARA 0 get null ne  %% actuem sobre el ColorSpace actual per fill
    {
     csARA length 1 sub
     0 eq {/csARA [null] def}
     {
      csARA dup length 1 sub 1 exch getinterval
      /csARA exch def
     }ifelse
    } if
    CSARA 0 get null ne  %% actuem sobre el ColorSpace actual per stroke
    {
     CSARA length 1 sub
     0 eq {/CSARA [null] def}
     {
      CSARA dup length 1 sub 1 exch getinterval
      /CSARA exch def
     }ifelse
    } if

    sEdAs (Q\012) writestring

    %%% KTCS
    %% retallem el paquet EstatGrafic a -1 eliminant el darrer dic de l'estat grafic
    EstatGrafic dup length 1 sub 0 exch getinterval /EstatGrafic exch def
    iEG 1 sub /iEG exch def  %% actualitzem l'index del dic de l'estat grafic actiu
    
    %% reexecutem els valors de l'estat grafic restablert x redefinir-ne les variables
    EstatGrafic iEG get  %% recuperem del dic de l'estat grafic actiu
    {def}forall  %% redefinim les variables
    }stopped{( ... peta Q 2) pstack stop}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
    }
    {
     /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (Q\012) writestring
    }ifelse
    %%}stopped{( ... peta Q) == quit}if
   }
  ] i_Q get /Q exch bind def

  [  %% cm
   {  %% 0 (arbre jeràrquic) | gatells: 16
    {  % stopped
    6 copy
    6 array astore
    {
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    }forall
    sEdAs (cm\012) writestring
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% desactivem l'escriptura, doncs aqui es no la utilizem per a res!
    /eixcmGirat false def
    %% el valor de posicio Y actual necesssita ser multiplicada per l'escala Y del cm anterior
    EstatGrafic iEG get /cmSy get mul
    %% i despres necesssita ser sumat per la posicio Y del cm anterior
    EstatGrafic iEG get /cmPy get add
    dup EstatGrafic iEG get exch /cmPy exch put
    /cmPy exch def  %% valor absolut de posicio Y de l'origen de l'eix de coordenades
    %% el valor de posicio X actual necesssita ser multiplicada per l'escala X del cm anterior
    EstatGrafic iEG get /cmSx get mul
    %% i despres necesssita ser sumat per la posicio X del cm anterior
    EstatGrafic iEG get /cmPx get add
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmPx exch put
    /cmPx exch def  %% valor absolut de posicio X de l'origen de l'eix de coordenades
    EstatGrafic iEG get /cmSy get mul  %% la nova escala Y cal multiplicar per l'escala Y d'abans!
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmSy exch put
    /cmSy exch def  %% multiplicador d'escala Y de l'eix de coordenades
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cm_tanBsin exch put
    /cm_tanBsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un esbiaixat
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cm_tanAsin exch put
    /cm_tanAsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un esbiaixat
    %% d moment multiplicarem sempre aquest valor a SxTm i ...
    EstatGrafic iEG get /cmSx get mul  %% la nova escala X cal multiplicar per l'escala X d'abans!
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmSx exch put
    /cmSx exch def  %% multiplicador d'escala X de l'eix de coordenades
    %% redefinim dins /acm els valors de cm aqui, doncs podrien haver canviat per l'accio d'una altra cm
    [
     EstatGrafic iEG get /cmSx get  %% escala X a cm
     EstatGrafic iEG get /cm_tanAsin get  %% valor de la tangent o del sinus de l'angle a cm
     EstatGrafic iEG get /cm_tanBsin get  %% valor de la tangent o del sinus de l'angle a cm
     EstatGrafic iEG get /cmSy get  %% escala Y a cm
     EstatGrafic iEG get /cmPx get  %% X de l'origen de l'eix de coordenades a cm
     EstatGrafic iEG get /cmPy get  %% Y de l'origen de l'eix de coordenades a cm
    ]
    /acm exch def  %% desem l'array de la cm en aquesta variable x
    %% si algun dels valors 2 i 3 de l'array es diferent de zero llavors avisem doncs l'eix duu manipulat 
    cm_tanBsin abs cm_tanAsin abs add 0 ne
    {  %% eix amb manipulacio
%% esbrinem si es una rotacio neta a 90 graus ...
cmSx cmSy add 0 eq  %% si es true llavors cm_tanBsin i cm_tanAsin son valors del d'escala
{  %% es una rotacio neta a 90 graus!
cm_tanBsin  %%cmSy mul  % NO multipliquem el valor provinent de cm
dup abs dup /cmSy exch def  %% nou valor d'escala Y cm establert pel sinus
EstatGrafic iEG get exch /cmSy exch put  %% desem al dic de l'estat grafic
%%cos_ mul abs /CyTm exch def  % (valor absolut!) redefinim el valor del cos vertical de la lletra
cm_tanAsin %%cmSx mul  % NO multipliquem el valor provinent de cm
dup abs dup /cmSx exch def  %% nou valor d'escala X cm establert pel sinus
EstatGrafic iEG get exch /cmSx exch put  %% desem al dic de l'estat grafic
%%cos_ mul abs /CxTm exch def  % (valor absolut!) redefinim el valor del cos horitzontal de la lletra
%% gatell x detectar girs nets de 90 graus pel sinus
/90NET true def
%% esbrinem el signe de l'angle i desem el valor
EstatGrafic iEG get /A_cm 90 cm_tanAsin 0 lt
{
neg dup /A_cm exch def
}
{
dup /A_cm exch def
}ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa

/eixcmGirat true def
}
{  %% ha de ser una rotacio d'un altre valor
%% llavors l'escala pren altra cop puntualment el valor d'1 (no cal desar-ho a l'estat grafic?)
/cmSx 1 def  %% nou valor d'escala cm per les X
/cmSy 1 def  %% nou valor d'escala cm per les Y
%% gatell x detectar girs nets de 90 graus pel sinus
/90NET false def

     (EP!: eix cm rotat o esbiaixat!) ==
     %% discriminem el tipus de rotacio o esbiaixat ...
     acm 0 4 getinterval aload pop  %% extraiem els quatre primers valors que ens interessen
     4 1 roll add 0 eq
     {  %% es una rotacio normal (sinus contraposats)
      pop pop
      ( ... es una rotacio normal) ==
      %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
      /girNOcontrolat false def
      EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
     }
     {
      %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
      /girNOcontrolat true def
      EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
      add 0 eq
      {  %% es una imatge mirall (cosinus contraposats)
       ( ... es una rotacio cm d'espill ... EP!)==  %% quit
      }
      {
       ( ... es un esbiaixat cm de l'eix ... EP!)==  %% quit
      }ifelse
     }ifelse
     /eixcmGirat true def
     girNOcontrolat not
     {  %% nomes analitzem l'angle si es tracta d'una rotacio normal
%%% EP! HEM CANVIAT L'ESTRATEGIA PER L'OPERADOR atan
      %%% aqui fem el calcul de l'angle de rotacio (graus i signe!)
      acm dup 1 get /Asinus exch def  %% si el sinus es positiu: l'angle sera positiu (direccio contrarellotge)
      0 get /Acosinus exch def  %% pesquem el cosinus
%%      /anglES null def  % no fos q no el trobem
%%      /Acrement .001 def  % suficient per q la precisio d'angle no hagi d'iterar + d'1 cop?
%%      {  % loop
       Asinus 0 lt  %% si l'angle es negatiu (ho controlem amb l'index 1 de l'array Tm o cm)
       {
%%        -360 Acrement 0  
Asinus Acosinus atan neg /anglES exch def
       }
       {
%%        0 Acrement 360
Asinus Acosinus atan /anglES exch def
       }ifelse
%%       {  % for
%%        dup dup sin 10000 mul truncate 10000 div Asinus 10000 mul truncate 10000 div eq
%%        exch cos 10000 mul truncate 10000 div Acosinus 10000 mul truncate 10000 div eq
%%        and
%%        {  % donat que l'error es mil·limetric, donem x bo el primer angle q compleixi la condicio
%%           % (pero n'hi poden haver +!)
%%         /anglES exch def exit
%%        }
%%        {
%%         pop
%%        }ifelse
%%       }for
%%       anglES null eq  % iterem?
%%       {  % si la precisio no es suficient li afegim 1 decimal!
%%        Acrement 10 div /Acrement exch def
%%        (no es prou acurat ... TORNEM-HI!) ==
%%       }
%%       {  % donem x bo el primer angle q compleixi la condicio (pero n'hi poden haver +!)
        anglES /A_cm exch def
        EstatGrafic iEG get /A_cm A_cm put  %% al desem al dic de l'estat grafic actiu
%%        exit
%%       }ifelse
%%      }loop
      %%% fi del calcul de l'angle
     }if  %% nomes analitzem l'angle si es tracta d'una rotacio normal

}ifelse  %% es una rotacio neta a 90 graus o d'un altre valor?

    }
    {
     %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
     /girNOcontrolat false def
     EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
    }ifelse
    }stopped{( ... peta cm 0) pstack stop}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write}forall
    sEdAs (cm\012) writestring
    %%test
    %%}stopped{( ... peta cm) == quit}if
   }
   {  %% 2 (relliga imatges + correccio L·L + analisi textual)
%%    {  % stopped
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% desactivem l'escriptura, doncs aqui es no la utilizem per a res!
    /eixcmGirat false def
    %% el valor de posicio Y actual necesssita ser multiplicada per l'escala Y del cm anterior
    EstatGrafic iEG get /cmSy get mul
    %% i despres necesssita ser sumat per la posicio Y del cm anterior
    EstatGrafic iEG get /cmPy get add
    dup EstatGrafic iEG get exch /cmPy exch put
    /cmPy exch def  %% valor absolut de posicio Y de l'origen de l'eix de coordenades
    %% el valor de posicio X actual necesssita ser multiplicada per l'escala X del cm anterior
    EstatGrafic iEG get /cmSx get mul
    %% i despres necesssita ser sumat per la posicio X del cm anterior
    EstatGrafic iEG get /cmPx get add
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmPx exch put
    /cmPx exch def  %% valor absolut de posicio X de l'origen de l'eix de coordenades
    EstatGrafic iEG get /cmSy get mul  %% la nova escala Y cal multiplicar per l'escala Y d'abans!
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmSy exch put
    /cmSy exch def  %% multiplicador d'escala Y de l'eix de coordenades
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cm_tanBsin exch put
    /cm_tanBsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un esbiaixat
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cm_tanAsin exch put
    /cm_tanAsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un esbiaixat
    %% d moment multiplicarem sempre aquest valor a SxTm i ...
    EstatGrafic iEG get /cmSx get mul  %% la nova escala X cal multiplicar per l'escala X d'abans!
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmSx exch put
    /cmSx exch def  %% multiplicador d'escala X de l'eix de coordenades
    %% redefinim dins /acm els valors de cm aqui, doncs podrien haver canviat per l'accio d'una altra cm
    [
     EstatGrafic iEG get /cmSx get  %% escala X a cm
     EstatGrafic iEG get /cm_tanAsin get  %% valor de la tangent o del sinus de l'angle a cm
     EstatGrafic iEG get /cm_tanBsin get  %% valor de la tangent o del sinus de l'angle a cm
     EstatGrafic iEG get /cmSy get  %% escala Y a cm
     EstatGrafic iEG get /cmPx get  %% X de l'origen de l'eix de coordenades a cm
     EstatGrafic iEG get /cmPy get  %% Y de l'origen de l'eix de coordenades a cm
    ]
    /acm exch def  %% desem l'array de la cm en aquesta variable x
    %% si algun dels valors 2 i 3 de l'array es diferent de zero llavors avisem doncs l'eix duu manipulat 
    cm_tanBsin abs cm_tanAsin abs add 0 ne
    {  %% eix amb manipulacio
%% esbrinem si es una rotacio neta a 90 graus ...
cmSx cmSy add 0 eq  %% si es true llavors cm_tanBsin i cm_tanAsin son valors del d'escala
{  %% es una rotacio neta a 90 graus!
cm_tanBsin  %%cmSy mul  % NO multipliquem el valor provinent de cm
dup abs dup /cmSy exch def  %% nou valor d'escala Y cm establert pel sinus
EstatGrafic iEG get exch /cmSy exch put  %% desem al dic de l'estat grafic
%%cos_ mul abs /CyTm exch def  % (valor absolut!) redefinim el valor del cos vertical de la lletra
cm_tanAsin %%cmSx mul  % NO multipliquem el valor provinent de cm
dup abs dup /cmSx exch def  %% nou valor d'escala X cm establert pel sinus
EstatGrafic iEG get exch /cmSx exch put  %% desem al dic de l'estat grafic
%%cos_ mul abs /CxTm exch def  % (valor absolut!) redefinim el valor del cos horitzontal de la lletra
%% gatell x detectar girs nets de 90 graus pel sinus
/90NET true def
%% esbrinem el signe de l'angle i desem el valor
EstatGrafic iEG get /A_cm 90 cm_tanAsin 0 lt
{
neg dup /A_cm exch def
}
{
dup /A_cm exch def
}ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa

/eixcmGirat true def
}
{  %% ha de ser una rotacio d'un altre valor
%% llavors l'escala pren altra cop puntualment el valor d'1 (no cal desar-ho a l'estat grafic?)
/cmSx 1 def  %% nou valor d'escala cm per les X
/cmSy 1 def  %% nou valor d'escala cm per les Y
%% gatell x detectar girs nets de 90 graus pel sinus
/90NET false def

     (EP!: eix cm rotat o esbiaixat!) ==
     %% discriminem el tipus de rotacio o esbiaixat ...
     acm 0 4 getinterval aload pop  %% extraiem els quatre primers valors que ens interessen
     4 1 roll add 0 eq
     {  %% es una rotacio normal (sinus contraposats)
      pop pop
      ( ... es una rotacio normal) ==
      %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
      /girNOcontrolat false def
      EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
     }
     {
      %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
      /girNOcontrolat true def
      EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
      add 0 eq
      {  %% es una imatge mirall (cosinus contraposats)
       ( ... es una rotacio cm d'espill ... EP!)==  %% quit
      }
      {
       ( ... es un esbiaixat cm de l'eix ... EP!)==  %% quit
      }ifelse
     }ifelse
     /eixcmGirat true def
     girNOcontrolat not
     {  %% nomes analitzem l'angle si es tracta d'una rotacio normal
%%% EP! HEM CANVIAT L'ESTRATEGIA PER L'OPERADOR atan
      %%% aqui fem el calcul de l'angle de rotacio (graus i signe!)
      acm dup 1 get /Asinus exch def  %% si el sinus es positiu: l'angle sera positiu (direccio contrarellotge)
      0 get /Acosinus exch def  %% pesquem el cosinus
%%      /anglES null def  % no fos q no el trobem
%%      /Acrement .001 def  % suficient per q la precisio d'angle no hagi d'iterar + d'1 cop?
%%      {  % loop
       Asinus 0 lt  %% si l'angle es negatiu (ho controlem amb l'index 1 de l'array Tm o cm)
       {
%%        -360 Acrement 0  
Asinus Acosinus atan neg /anglES exch def
       }
       {
%%        0 Acrement 360
Asinus Acosinus atan /anglES exch def
       }ifelse
%%       {  % for
%%        dup dup sin 10000 mul truncate 10000 div Asinus 10000 mul truncate 10000 div eq
%%        exch cos 10000 mul truncate 10000 div Acosinus 10000 mul truncate 10000 div eq
%%        and
%%        {  % donat que l'error es mil·limetric, donem x bo el primer angle q compleixi la condicio
%%           % (pero n'hi poden haver +!)
%%         /anglES exch def exit
%%        }
%%        {
%%         pop
%%        }ifelse
%%       }for
%%       anglES null eq  % iterem?
%%       {  % si la precisio no es suficient li afegim 1 decimal!
%%        Acrement 10 div /Acrement exch def
%%        (no es prou acurat ... TORNEM-HI!) ==
%%       }
%%       {  % donem x bo el primer angle q compleixi la condicio (pero n'hi poden haver +!)
        anglES /A_cm exch def
        EstatGrafic iEG get /A_cm A_cm put  %% al desem al dic de l'estat grafic actiu
%%        exit
%%       }ifelse
%%      }loop
      %%% fi del calcul de l'angle
     }if  %% nomes analitzem l'angle si es tracta d'una rotacio normal

}ifelse  %% es una rotacio neta a 90 graus o d'un altre valor?

    }
    {
     %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
     /girNOcontrolat false def
     EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
    }ifelse
%%    }stopped{( ... peta cm) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop pop pop pop pop pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
      %%TiNTeM {  % es la tinta que toca ara ?
      6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write}forall
      sEdAs (cm\012) writestring
      %%}{6 {pop}repeat}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta cm) pstack quit}if
   }
  ] i_cm get /cm exch bind def

  %% 8.4.5 Line width
  [  %% w
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (w\012) writestring
    %%test
    }stopped{( ... peta w 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
      %%TiNTeM {  % es la tinta que toca ara ?
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (w\012) writestring
      %%}{pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta w) == quit}if
   }
  ] i_w get /w exch bind def

  %% 8.4.2 Line cap style
  [  %% J
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    1 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (J\012) writestring
    %%test
    }stopped{( ... peta J 1) pstack stop}if
   }
   {  %% 2 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     1 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (J\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta J) == quit}if
   }
  ] i_J get /J exch bind def

  %% 8.4.4 Line join style
  [  %% j
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    1 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (j\012) writestring
    %%test
    }stopped{( ... peta j 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     1 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (j\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta j) == quit}if
   }
  ] i_j get /j exch bind def

  %% 8.4.6 Miter limit
  [  %% M
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (M\012) writestring
    %%test
    }stopped{( ... peta M 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (M\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta M) == quit}if
   }
  ] i_M get /M exch bind def

  %% 8.4.3 Line dash pattern
  [  %% d
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /phase exch def
    sEdAs ([ ) writestring
    {10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write} forall
    sEdAs (] ) writestring
    phase 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    sEdAs (d\012) writestring
    %%test
    }stopped{( ... peta d 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     /phase exch def
     sEdAs ([ ) writestring
     {
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     } forall
     sEdAs (] ) writestring
     phase 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     sEdAs (d\012) writestring
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta d) == quit}if
   }
  ] i_d get /d exch bind def

  %% 8.5.2.3 Color rendering intent
  [  %% ri
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (ri\012) writestring
    %%test
    }stopped{( ... peta ri 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (ri\012) writestring
    }ifelse
    %%}stopped{( ... peta ri) == quit}if
   }
  ] i_ri get /ri exch bind def

  %% 8.4.1 Flatness
  [  %% i
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    sEdAs (i\012) writestring
    %%test
    }stopped{( ... peta i 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     sEdAs (i\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta i) == quit}if
   }
  ] i_i get /i exch bind def

  %% 8.4.7 Generic Graphics State operator
  [  %% gs
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)

    dup XRay /EstatsGrafics get /Desconeguts get exch null put  %% desem a XRay els estats grafics utilitzats

    sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs ( gs\012) writestring
    %%test
    }stopped{( ... peta gs 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%test
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs ( gs\012) writestring
    }ifelse
    %%test
    %%}stopped{( ... peta gs) == quit}if
   }
  ] i_gs get /gs exch bind def

%% (no implementats) 4.3.4 Graphics State Parameter Dictionaries

%% (PDF Ref ?) 8.6.1 Path segment operators
%% (PDF Ref 1.7) 4.4.1 Path Construction Operators
  [  %% m
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (m\012) writestring
    %%test
    }stopped{( ... peta m 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
      %%dup 292.218 eq {/nYaca true def}{/nYaca false def}ifelse
      %%TiNTeM {  % es la tinta que toca ara ?
      exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (m\012) writestring
      %%}{pop pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta m) pstack quit}if
   }
  ] i_m get /m exch bind def

  [  %% l
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (l\012) writestring
    %%test
    }stopped{( ... peta l 1) pstack stop}if
   }
   {  %% 2 projecte de verificacio de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    VectorViu not  %% sempre q NO estigui obert
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs dup dup (/OC ) writestring
     llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
     1 get writestring ( BDC\012) writestring
     /VectorViu true def  %% obrim el gatell de l'anellat vectorial
    }if
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (l\012) writestring
    %%test
    %%}stopped{( ... peta l) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (l\012) writestring
    }ifelse
   }
  ] i_l get /l exch bind def

  [  %% c
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    6 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (c\012) writestring
    %%test
    }stopped{( ... peta c 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    VectorViu not  %% sempre q NO estigui obert
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs dup dup (/OC ) writestring
     llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
     1 get writestring ( BDC\012) writestring
     /VectorViu true def  %% obrim el gatell de l'anellat vectorial
    }if
    6 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (c\012) writestring
    %%test
    %%}stopped{( ... peta c) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     pop pop pop pop pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     6 dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs (c\012) writestring
    }ifelse
   }
  ] i_c get /c exch bind def

  [  %% v
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (v\012) writestring
    %%test
    }stopped{( ... peta v 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    VectorViu not  %% sempre q NO estigui obert
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs dup dup (/OC ) writestring
     llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
     1 get writestring ( BDC\012) writestring
     /VectorViu true def  %% obrim el gatell de l'anellat vectorial
    }if
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (v\012) writestring
    %%test
    %%}stopped{( ... peta v) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     pop pop pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     4 dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs (v\012) writestring
    }ifelse
   }
  ] i_v get /v exch bind def

  [  %% y
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (y\012) writestring
    %%test
    }stopped{( ... peta y 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    VectorViu not  %% sempre q NO estigui obert
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs dup dup (/OC ) writestring
     llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
     1 get writestring ( BDC\012) writestring
     /VectorViu true def  %% obrim el gatell de l'anellat vectorial
    }if
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (y\012) writestring
    %%test
    %%}stopped{( ... peta y) pstack stop}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     pop pop pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     4 dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs (y\012) writestring
    }ifelse
   }
  ] i_y get /y exch bind def

  [  %% h
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (h\012) writestring
    %%test
    }stopped{( ... peta h 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs (h\012) writestring
     %%}if  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta h) == quit}if
   }
  ] i_h get /h exch bind def

  [  %% re
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (re\012) writestring
    %%test
    }stopped{( ... peta re 1) pstack stop}if
   }
   {  %% 2 verificacio del PDF del Col·legi
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    VectorViu not  %% sempre q NO estigui obert
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs dup dup (/OC ) writestring
     llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
     1 get writestring ( BDC\012) writestring
     /VectorViu true def  %% obrim el gatell de l'anellat vectorial
    }if
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (re\012) writestring
    %%test
    %%}stopped{( ... peta re) pstack stop}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     pop pop pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     4 dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs (re\012) writestring
    }ifelse
   }
  ] i_re get /re exch bind def

%% (PDF Ref ?) 8.6.2 Path painting operators
%% (PDF Ref 1.7) 4.4.2 Path-Painting Operators
  [  %% S
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (S\012) writestring
    %%test
    }stopped{( ... peta S 1) pstack stop}if
   }
   {  %% 2 verificacio de PDF del Col·legi
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (S\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta S) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
    }
    {
     /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (S\012) writestring
    }ifelse
    %%}stopped{( ... peta S) == quit}if
   }
  ] i_S get /S exch bind def

  [  %% s
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (s\012) writestring
    %%test
    }stopped{( ... peta s 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (s\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta s) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (s\012) writestring
    }ifelse
   }
  ] i_s get /s exch bind def

  [  %% f
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (f\012) writestring
    %%test
    }stopped{( ... peta f 1) pstack stop}if
   }
   {  %% 2 projecte de verificacio de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (f\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta f) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (f\012) writestring
    }ifelse
   }
  ] i_f get /f exch bind def

  [  %% F
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (F\012) writestring
    %%test
    }stopped{( ... peta F 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (F\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta F) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (F\012) writestring
    }ifelse
   }
  ] i_F get /F exch bind def

  [  %% f*
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (f*\012) writestring
    %%test
    }stopped{( ... peta f* 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (f*\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta f*) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (f*\012) writestring
    }ifelse
   }
  ] i_f* get /f* exch bind def

  [  %% B
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (B\012) writestring
    %%test
    }stopped{( ... peta B 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (B\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta B) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (B\012) writestring
    }ifelse
   }
  ] i_B get /B exch bind def

  [  %% B*
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (B*\012) writestring
    %%test
    }stopped{( ... peta B* 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (B*\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta B*) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (B*\012) writestring
    }ifelse
   }
  ] i_B* get /B* exch bind def

  [  %% b
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (b\012) writestring
    %%test
    }stopped{( ... peta b 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (b\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta b) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (b\012) writestring
    }ifelse
   }
  ] i_b get /b exch bind def

  [  %% b*
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (b*\012) writestring
    %%test
    }stopped{( ... peta b* 1) pstack stop}if
   }
   {  %% 2 verificador de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (b*\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta b*) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (b*\012) writestring
    }ifelse
   }
  ] i_b* get /b* exch bind def

  [  %% n
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (n\012) writestring
    %%test
    }stopped{( ... peta n 1) pstack stop}if
   }
   {  %% 2 projecte de verificacio de PDF
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (n\012EMC\012) writestring
    /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    %%test
    %%}stopped{( ... peta n) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (n\012) writestring
    }ifelse
   }
  ] i_n get /n exch bind def

%% (PDF Ref ?) 8.6.3 Path clipping operators
%% (PDF Ref 1.7) 4.4.3 Clipping Path Operators
  [  %% W
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (W\012) writestring
    %%test
    }stopped{( ... peta W 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (W\012) writestring
    }ifelse
    %%}stopped{( ... peta W) == quit}if
   }
  ] i_W get /W exch bind def

  [  %% W*
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (W*\012) writestring
    %%test
    }stopped{( ... peta W* 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (W*\012) writestring
    }ifelse
    %%}stopped{( ... peta W*) == quit}if
   }
  ] i_W* get /W* exch bind def

%% (PDF Ref 1.7) 4.5.7 Color Operators
%% (PDF Ref ?) 8.5.2.2 Generic color space operators
  [  %% CS
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    dup dup
    <<
      %%       /DeviceGray [/NoName2 ( DeviceGray Color Space Not Supported)]
      /DeviceRGB [/NoName3 ( DeviceRGB Color Space Not Supported)]
      %%      /Pattern [/NoName4 ( Pattern Color Space Not Supported)]
    >> dup 3 -1 roll known
    {  %% afegim l'error a Errades amb un nom anonim de color
     %% sobreixidor x saber on es crida l'espai de color q encara no tractem
     %%(-- AQUI es crida:CS: DeviceRGB) ==
     exch get XRay /EspaisDeColor get /Errades get exch aload pop put
     /araCS null def  %% aquesta variable ens ha de dir: si null es que l'espai de color es erroni i llavors scn/SCN o sc/SC no escriuran res, si es un nom hi desaran el valor dins una array
    }
    {
     pop
     dup /Pattern eq
     {  %% una crida d'espai de color al literal /Pattern en realitat no pinta res i nomes ens diu que es tracta d'un 'Colored Pattern' on les crides de color son dins l'objecte /Pattern
      XRay /EspaisDeColor get /Utilitzats get exch
      null put  %% hi desem temporalment un null xq a %33% no desem res a TiV
      /araCS null def  %% desem un null x indicar q no cal processar per scn/SCN+
      CSARA 0 null put  %% afegim a la posicio 0 un null x indicar q no cal processar per scn/SCN
     }
     {
      %% solucio DeviceGray
      dup <</DeviceGray null>> exch known
      {  %% si un cs crida l'espai DeviceGray de forma directe ...
       %%(-- AQUI es crida:CS: DeviceGray) ==
       pop XRay /EspaisDeColor get /Utilitzats get dup
       /DeviceGray known
       {
        pop
        userdict /HiHaForms known
        {
         HiHaForms
         {
          %%(CS executat dins un Form) ==
          XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
          FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic DeviceGray al form q toca dins de FormsiColorSpaces
         }if
        }if  %% gatell x saber-ho
       }
       {
        /DeviceGray
        <<
          /Tipus /PureCMYK /NomExtern /Black /FTipus null
          /Paleta << >>
          /TanX100 []  %% hi desarem en arrays la gamma de valors
        >> put
        userdict /HiHaForms known
        {
         HiHaForms
         {
          %%(CS executat dins un Form) ==
          XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
          FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic DeviceGray al form q toca dins de FormsiColorSpaces
         }if
        }if  %% gatell x saber-ho
       } ifelse
       /araCS /DeviceGray def  %% desem el nom de l'espai de color actual
       CSARA 0 /DeviceGray put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
       %% solucio DeviceGray
      }
      {      
       dup <</DeviceCMYK null>> exch known
       {  %% si un CS crida l'espai CMYK de forma directe ...
        pop XRay /EspaisDeColor get /Utilitzats get dup
        /NoName9 known
        {
         pop
         userdict /HiHaForms known
         {
          HiHaForms
          {
           %%(CS executat dins un Form) ==
           XRay /EspaisDeColor get /Utilitzats get /NoName9 get
           FormsiColorSpaces araNomXForm get exch /NoName9 exch put  %% incrustem el dic NoName9 al form q toca dins de FormsiColorSpaces
          }if
         }if  %% gatell x saber-ho
        }
        {
         /NoName9 <<
                    /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
                    /Paleta << >>
                    /TanX100 []  %% hi desarem en arrays la gamma de valors scn/SCN usats
                  >> put
         userdict /HiHaForms known
         {
          HiHaForms
          {
           %%(CS executat dins un Form) ==
           XRay /EspaisDeColor get /Utilitzats get /NoName9 get
           FormsiColorSpaces araNomXForm get exch /NoName9 exch put  %% incrustem el dic NoName9 al form q toca dins de FormsiColorSpaces
          }if
         }if  %% gatell x saber-ho
        } ifelse
        /araCS /NoName9 def  %% desem el nom de l'espai de color actual
        CSARA 0 /NoName9 put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       }
       {
        XRay /EspaisDeColor get /Desconeguts get dup 3 -1 roll dup 3 -2 roll
        known
        {
         dup CSARA 0 3 -1 roll put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
         /araCS exch def
         pop
        }  %% si ja l'hem definit desem el nom de l'espai de color actual a la variable que utilitzara sc/SC o scn/SCN
        {
         dup CSARA 0 3 -1 roll put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
         dup /araCS exch def  %% desem el nom de l'espai de color actual
         []  %% ara li posem de valor l'array on desarem la gamma de percentatges
         put  %% desem a XRay els espais de color utilitzats
        } ifelse
       }ifelse
      }ifelse
     }ifelse  %% es un Pattern ?
    }ifelse
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (CS\012) writestring
    %%test
    }stopped{( ... peta CS 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (CS\012) writestring
    }ifelse
    %%}stopped{( ... peta CS) == quit}if
   }
  ] i_CS get /CS exch bind def

  [  %% cs
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    dup dup
    <<
      %%       /DeviceGray [/NoName2 ( DeviceGray Color Space Not Supported)]
      /DeviceRGB [/NoName3 ( DeviceRGB Color Space Not Supported)]
      %%      /Pattern [/NoName4 ( Pattern Color Space Not Supported)]
    >> dup 3 -1 roll known
    {  %% afegim l'error a Errades amb un nom anonim de color
     %% sobreixidor x saber on es crida l'espai de color q encara no tractem
     %%(-- AQUI es crida:cs: DeviceRGB) ==
     exch get XRay /EspaisDeColor get /Errades get exch aload pop put
     /ARAcs null def  %% aquesta variable ens ha de dir: si null es que l'espai de color es erroni i llavors scn/SCN o sc/SC no escriuran res, si es un nom hi desaran el valor dins una array
    }
    {
     pop
     dup /Pattern eq
     {  %% una crida d'espai de color al literal /Pattern en realitat no pinta res i nomes ens diu que es tracta d'un 'Colored Pattern' on les crides de color son dins l'objecte /Pattern
      XRay /EspaisDeColor get /Utilitzats get exch
      null put  %% hi desem temporalment un null xq a %33% no desem res a TiV
      /ARAcs null def  %% desem un null x indicar q no cal processar per scn/SCN
      csARA 0 null put  %% afegim a la posicio 0 un null x indicar q no cal processar per scn/SCN+
     }
     {
      %% solucio DeviceGray
      dup <</DeviceGray null>> exch known
      {  %% si un cs crida l'espai DeviceGray de forma directe ...
       %%(-- AQUI es crida:cs: DeviceGray) ==
       pop XRay /EspaisDeColor get /Utilitzats get dup
       /DeviceGray known
       {
        pop
        userdict /HiHaForms known
        {
         HiHaForms
         {
          %%(cs executat dins un Form) ==
          XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
          FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic DeviceGray al form q toca dins de FormsiColorSpaces
         }if
        }if  %% gatell x saber-ho
       }
       {
        /DeviceGray
        <<
          /Tipus /PureCMYK /NomExtern /Black /FTipus null
          /Paleta << >>
          /TanX100 []  %% hi desarem en arrays la gamma de valors
        >> put
        userdict /HiHaForms known
        {
         HiHaForms
         {
          %%(cs executat dins un Form) ==
          XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
          FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic DeviceGray al form q toca dins de FormsiColorSpaces
         }if
        }if  %% gatell x saber-ho
       } ifelse
       /ARAcs /DeviceGray def  %% desem el nom de l'espai de color actual
       csARA 0 /DeviceGray put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
       %% solucio DeviceGray
      }
      {
       dup <</DeviceCMYK null>> exch known
       {  %% si un cs crida l'espai CMYK de forma directe ...
        pop XRay /EspaisDeColor get /Utilitzats get dup
        /NoName9 known
        {
         pop
         userdict /HiHaForms known
         {
          HiHaForms
          {
           %%(cs executat dins un Form) ==
           XRay /EspaisDeColor get /Utilitzats get /NoName9 get
           FormsiColorSpaces araNomXForm get exch /NoName9 exch put  %% incrustem el dic NoName9 al form q toca dins de FormsiColorSpaces
          }if
        }if  %% gatell x saber-ho
        }
        {
         /NoName9 <<
                    /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
                    /Paleta << >>
                    /TanX100 []  %% hi desarem en arrays la gamma de valors scn/SCN usats
                  >> put
         userdict /HiHaForms known
         {
          HiHaForms
          {
           %%(cs executat dins un Form) ==
           XRay /EspaisDeColor get /Utilitzats get /NoName9 get
           FormsiColorSpaces araNomXForm get exch /NoName9 exch put  %% incrustem el dic NoName9 al form q toca dins de FormsiColorSpaces
          }if
         }if  %% gatell x saber-ho
        } ifelse
        /ARAcs /NoName9 def  %% desem el nom de l'espai de color actual
        csARA 0 /NoName9 put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
       }
       {
        XRay /EspaisDeColor get /Desconeguts get dup 3 -1 roll dup 3 -2 roll
        known
        {
         dup csARA 0 3 -1 roll put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
         /ARAcs exch def pop
        }  %% si ja l'hem definit desem el nom de l'espai de color actual a la variable que utilitzara sc/SC o scn/SCN
        {
         dup csARA 0 3 -1 roll put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
         dup /ARAcs exch def  %% desem el nom de l'espai de color actual
         []  %% ara li posem de valor l'array on desarem la gamma de percentatges
         put  %% desem a XRay els espais de color utilitzats
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% es un Pattern ?
    } ifelse
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (cs\012) writestring
    %%test
    }stopped{( ... peta cs 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (cs\012) writestring
    }ifelse
    %%}stopped{( ... peta cs) == quit}if
   }
  ] i_cs get /cs exch bind def

  [  %% SC
   {  %% 0 repiquem idem, pero mantenim l'analisi d'Xray | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /aTxC () def
    %%% solucio DeviceGray
    %%araCS /DeviceGray eq  % si l'espai de color actual es /DeviceGray ...
    %%{
    %% 0 exch 0 exch 0 exch  % farcim amb els 3 colors que mancarien x ser CMYK
    %% 1 exch sub  % invertim el color DGray (va a l'inreves q el CMYK)
    %%}if
    %%% solucio DeviceGray
    count dup /RoLL exch def
    {  %% repeat
     RoLL -1 roll 10000 mul truncate 10000 div
     araCS type /nulltype ne
     {  %% incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
      dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
      1 add  %% separem els valors amb espais en blanc
      dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
      ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
      laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
     } if
     64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (SC\012) writestring
    araCS type /nulltype ne
    {  %% incrustem l'array de gamma de color al dic que toqui
     CSARA 0 get dup null eq{pop}{/araCS exch def}ifelse  %% rectifiquem el valor del color actual per CSARA (tret que no sigui un null!) que segur que treballa B (amb ARAcs no teniem en compte si era per fill o per stroke!)
     XRay /EspaisDeColor get dup /Desconeguts get araCS known
     {  %% si l'espai es a Desconeguts ...
      /Desconeguts get araCS get
      /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
      dup {aTxC eq {/jaHIes true def exit}if}forall
      jaHIes
      {
       pop
      }
      {
       aTxC /valG exch def
       dup length 1 add dup 1 sub /Dmes exch def
       array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
       XRay /EspaisDeColor get /Desconeguts get araCS 3 -1 roll
       put  %% incrustem el seguent valor de gamma a l'array de valors
      }ifelse
     }
     {  %% si no, mirem si es a Utilitzats, si no, No fem res ...
      /Utilitzats get araCS known
      {
       XRay /EspaisDeColor get /Utilitzats get araCS get
       /TanX100 get
       /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
       dup {aTxC eq {/jaHIes true def exit}if}forall
       jaHIes
       {
        pop
       }
       {
        aTxC /valG exch def
        dup length 1 add dup 1 sub /Dmes exch def
        array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
        XRay /EspaisDeColor get /Utilitzats get araCS get /TanX100  3 -1 roll put  %% incrustem el seguent valor de gamma a l'array de valors
       }ifelse
      }if
     }ifelse
    } if
    %%test
    }stopped{( ... peta SC 0) pstack quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /aTxC () def
    %% solucio DeviceGray
    araCS /DeviceGray eq  %% si l'espai de color actual es /DeviceGray ...
    {
     0 exch 0 exch 0 exch  %% farcim amb els 3 colors que mancarien x ser CMYK
     1 exch sub  %% invertim el color DGray (va a l'inreves q el CMYK)
    }if
    %% solucio DeviceGray
    count dup /RoLL exch def
    {  %% repeat
     RoLL -1 roll 10000 mul truncate 10000 div
     araCS type /nulltype ne
     {  %% incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
      dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
      1 add  %% separem els valors amb espais en blanc
      dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
      ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
      laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
     } if
     64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (SC\012) writestring
    araCS type /nulltype ne
    {  %% incrustem l'array de gamma de color al dic que toqui
     CSARA 0 get dup null eq{pop}{/araCS exch def}ifelse  %% rectifiquem el valor del color actual per CSARA (tret que no sigui un null!) que segur que treballa B (amb ARAcs no teniem en compte si era per fill o per stroke!)
     XRay /EspaisDeColor get dup /Desconeguts get araCS known
     {  %% si l'espai es a Desconeguts ...
      /Desconeguts get araCS get
      /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
      dup {aTxC eq {/jaHIes true def exit}if}forall
      jaHIes
      {
       pop
      }
      {
       aTxC /valG exch def
       dup length 1 add dup 1 sub /Dmes exch def
       array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
       XRay /EspaisDeColor get /Desconeguts get araCS 3 -1 roll
       put  %% incrustem el seguent valor de gamma a l'array de valors
      }ifelse
     }
     {  %% si no, mirem si es a Utilitzats, si no, No fem res ...
      /Utilitzats get araCS known
      {
       XRay /EspaisDeColor get /Utilitzats get araCS get
       /TanX100 get
       /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
       dup {aTxC eq {/jaHIes true def exit}if}forall
       jaHIes
       {
        pop
       }
       {
        aTxC /valG exch def
        dup length 1 add dup 1 sub /Dmes exch def
        array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
        XRay /EspaisDeColor get /Utilitzats get araCS get /TanX100  3 -1 roll put  %% incrustem el seguent valor de gamma a l'array de valors
       }ifelse
      }if
     }ifelse
    } if
    %%test
    }stopped{( ... peta SC 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     count {pop} repeat
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs (SC\012) writestring
     %%sEdAs (RG\012) writestring  %%MASATS08 x la manca de /ColorSpace <</tal /DeviceRGB>> a Resources i a Contents /tal cs
    }ifelse
    %%}stopped{( ... peta SC) == quit}if
   }
  ] i_SC get /SC exch bind def

  [  %% SCN
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /aTxC () def
    dup type /nametype eq
    {  %% si duu nom es que esta pintant un Pattern
     dup XRay /Patterns&Shadings get /Desconeguts get exch 3 array dup 2 araCS put put  %% desem el Pattern/Shading i l'espai de color actiu
     /elNOM exch def
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      araCS type /nulltype ne
      {  %% incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
       dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
       1 add  %% separem els valors amb espais en blanc
       dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
       ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
       laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
      } if
      64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
     elNOM sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     %% /ARAcs null def  % ho posem a null, doncs en aquest cas no ens interessa escriure res
    }
    {       
     count dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div
      araCS type /nulltype ne
      {  %% incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
       dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
       1 add  %% separem els valors amb espais en blanc
       dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
       ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
       laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
      } if
      64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
    }ifelse
    sEdAs (SCN\012) writestring
    araCS type /nulltype ne
    {  %% incrustem l'array de gamma de color al dic que toqui
     CSARA 0 get dup null eq{pop}{/araCS exch def}ifelse  %% rectifiquem el valor del color actual per CSARA (tret que no sigui un null!) que segur que treballa B (amb ARAcs no teniem en compte si era per fill o per stroke!)+
     XRay /EspaisDeColor get dup /Desconeguts get
     araCS known
     {  %% si l'espai es a Desconeguts ...
      nomDtp null ne
      {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
       XRay /Patterns&Shadings get /Utilitzats get
       nomDtp get 2 araCS put  %% ... primer incrustem el nom de l'espai de color a l'array del Pattern, despres de %30% el canviarem pel seu nom extern
      }if
      /Desconeguts get araCS get
      /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
      dup {aTxC eq {/jaHIes true def exit}if}forall
      jaHIes
      {
       pop
      }
      {
       aTxC /valG exch def
       dup length 1 add dup 1 sub /Dmes exch def
       array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
       XRay /EspaisDeColor get /Desconeguts get araCS 3 -1 roll
       put  %% incrustem el seguent valor de gamma a l'array de valors
      }ifelse
     }
     {  %% si no, mirem si es a Utilitzats, si no, No fem res ...
      /Utilitzats get araCS known
      {
       nomDtp null ne
       {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
        XRay /Patterns&Shadings get /Utilitzats get
        nomDtp get 2 araCS put  %% ... primer incrustem el nom de l'espai de color a l'array del Pattern, despres de %30% el canviarem pel seu nom extern
       }if
       XRay /EspaisDeColor get /Utilitzats get araCS get
       /TanX100 get
       /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
       dup {aTxC eq {/jaHIes true def exit}if}forall
       jaHIes
       {
        pop
       }
       {
        aTxC /valG exch def
        dup length 1 add dup 1 sub /Dmes exch def
        array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
        XRay /EspaisDeColor get /Utilitzats get araCS get /TanX100  3 -1 roll put  %% incrustem el seguent valor de gamma a l'array de valors
       }ifelse
      }if
     }ifelse
    } if
    %%test
    }stopped{( ... peta SCN 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     count {pop} repeat
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     dup type /nametype eq
     {  %% si duu nom es que esta pintant un Pattern
      /elNOM exch def
      count dup /RoLL exch def
      {  %% repeat
       RoLL -1 roll 10000 mul truncate 10000 div
       64 string cvs sEdAs exch writestring sEdAs 32 write
       RoLL 1 sub /RoLL exch def
      }repeat
      elNOM sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
      sEdAs (SCN\012) writestring
     }
     {
      count dup /RoLL exch def
      {  %% repeat
       RoLL -1 roll 10000 mul truncate 10000 div
       64 string cvs sEdAs exch writestring sEdAs 32 write
       RoLL 1 sub /RoLL exch def
      }repeat
      sEdAs (SCN\012) writestring
      %%sEdAs (RG\012) writestring  %%MASATS08 x la manca de /ColorSpace <</tal /DeviceRGB>> a Resources i a Contents /tal cs
     }ifelse
    }ifelse
    %%}stopped{( ... peta SCN) == quit}if
   }
  ] i_SCN get /SCN exch bind def

  [  %% sc
   {  %% 0 repiquem idem, pero mantenim l'analisi d'Xray | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /aTxC () def
    %%% solucio DeviceGray
    %%ARAcs /DeviceGray eq  % si l'espai de color actual es /DeviceGray ...
    %%{
    %% 0 exch 0 exch 0 exch  % farcim amb els 3 colors que mancarien x ser CMYK
    %% 1 exch sub  % invertim el color DGray (va a l'inreves q el CMYK)
    %%}if
    %%% solucio DeviceGray
    count dup /RoLL exch def
    {  %% repeat
     RoLL -1 roll 10000 mul truncate 10000 div
     ARAcs type /nulltype ne
     {  %% incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
      dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
      1 add  %% separem els valors amb espais en blanc
      dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
      ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
      laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
     } if
     64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (sc\012) writestring
    ARAcs type /nulltype ne
    {  %% incrustem l'array de gamma de color al dic que toqui
     csARA 0 get dup null eq{pop}{/ARAcs exch def}ifelse  %% rectifiquem el valor del color actual per csARA (tret que no sigui un null!) que segur que treballa B (amb ARAcs no teniem en compte si era per fill o per stroke!)
     XRay /EspaisDeColor get dup /Desconeguts get ARAcs known
     {  %% si l'espai es a Desconeguts ...
      /Desconeguts get ARAcs get
      /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
      dup {aTxC eq {/jaHIes true def exit}if}forall
      jaHIes
      {
       pop
      }
      {
       aTxC /valG exch def
       dup length 1 add dup 1 sub /Dmes exch def
       array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
       XRay /EspaisDeColor get /Desconeguts get ARAcs 3 -1 roll
       put  %% incrustem el seguent valor de gamma a l'array de valors
      }ifelse
     }
     {  %% si no, mirem si es a Utilitzats, si no, No fem res ...
      /Utilitzats get ARAcs known
      {
       XRay /EspaisDeColor get /Utilitzats get ARAcs get
       /TanX100 get
       /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
       dup {aTxC eq {/jaHIes true def exit}if}forall
       jaHIes
       {
        pop
       }
       {
        aTxC /valG exch def
        dup length 1 add dup 1 sub /Dmes exch def
        array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
        XRay /EspaisDeColor get /Utilitzats get ARAcs get /TanX100  3 -1 roll put  %% incrustem el seguent valor de gamma a l'array de valors
       }ifelse
      }if
     }ifelse
    } if
    %%test
    }stopped{( ... peta sc 0) pstack stop}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /aTxC () def
    %% solucio DeviceGray
    ARAcs /DeviceGray eq  %% si l'espai de color actual es /DeviceGray ...
    {
     0 exch 0 exch 0 exch  %% farcim amb els 3 colors que mancarien x ser CMYK
     1 exch sub  %% invertim el color DGray (va a l'inreves q el CMYK)
    }if
    %% solucio DeviceGray
    count dup /RoLL exch def
    {  %% repeat
     RoLL -1 roll 10000 mul truncate 10000 div
     ARAcs type /nulltype ne
     {  %% incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
      dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
      1 add  %% separem els valors amb espais en blanc
      dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
      ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
      laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
     } if
     64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (sc\012) writestring
    ARAcs type /nulltype ne
    {  %% incrustem l'array de gamma de color al dic que toqui
     csARA 0 get dup null eq{pop}{/ARAcs exch def}ifelse  %% rectifiquem el valor del color actual per csARA (tret que no sigui un null!) que segur que treballa B (amb ARAcs no teniem en compte si era per fill o per stroke!)
     XRay /EspaisDeColor get dup /Desconeguts get ARAcs known
     {  %% si l'espai es a Desconeguts ...
      /Desconeguts get ARAcs get
      /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
      dup {aTxC eq {/jaHIes true def exit}if}forall
      jaHIes
      {
       pop
      }
      {
       aTxC /valG exch def
       dup length 1 add dup 1 sub /Dmes exch def
       array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
       XRay /EspaisDeColor get /Desconeguts get ARAcs 3 -1 roll
       put  %% incrustem el seguent valor de gamma a l'array de valors
      }ifelse
     }
     {  %% si no, mirem si es a Utilitzats, si no, No fem res ...
      /Utilitzats get ARAcs known
      {
       XRay /EspaisDeColor get /Utilitzats get ARAcs get
       /TanX100 get
       /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
       dup {aTxC eq {/jaHIes true def exit}if}forall
       jaHIes
       {
        pop
       }
       {
        aTxC /valG exch def
        dup length 1 add dup 1 sub /Dmes exch def
        array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
        XRay /EspaisDeColor get /Utilitzats get ARAcs get /TanX100  3 -1 roll put  %% incrustem el seguent valor de gamma a l'array de valors
       }ifelse
      }if
     }ifelse
    } if
    %%test
    }stopped{( ... peta sc 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     count {pop} repeat
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
     sEdAs (sc\012) writestring
     %%sEdAs (rg\012) writestring  %%MASATS08 x la manca de /ColorSpace <</tal /DeviceRGB>> a Resources i a Contents /tal cs
    }ifelse
    %%}stopped{( ... peta sc) == quit}if
   }
  ] i_sc get /sc exch bind def

  [  %% scn
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /aTxC () def
    dup type /nametype eq
    {  %% si duu nom es que esta pintant un Pattern
     dup XRay /Patterns&Shadings get /Desconeguts get exch 3 array dup 2 ARAcs put put  %% desem el Pattern/Shading i l'espai de color actiu
     /elNOM exch def
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      ARAcs type /nulltype ne
      {  %% incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
       dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
       1 add  %% separem els valors amb espais en blanc
       dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
       ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
       laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
      } if
      64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
     elNOM sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     %% /ARAcs null def  % ho posem a null, doncs en aquest cas no ens interessa escriure res
    }
    {
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      ARAcs type /nulltype ne
      {  %% incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
       dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
       1 add  %% separem els valors amb espais en blanc
       dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
       ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
       laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
      } if
      64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
    }ifelse
    sEdAs (scn\012) writestring
    ARAcs type /nulltype ne
    {  %% incrustem l'array de gamma de color al dic que toqui
     csARA 0 get dup null eq{pop}{/ARAcs exch def}ifelse  %% rectifiquem el valor del color actual per csARA (tret que no sigui un null!) que segur que treballa B (amb ARAcs no teniem en compte si era per fill o per stroke!)
     XRay /EspaisDeColor get dup /Desconeguts get
     ARAcs known
     {  %% si l'espai es a Desconeguts ...
      nomDtp null ne
      {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
       XRay /Patterns&Shadings get /Utilitzats get
       nomDtp get 2 ARAcs put  %% ... primer incrustem el nom de l'espai de color a l'array del Pattern, despres de %30% el canviarem pel seu nom extern
      }if
      /Desconeguts get ARAcs get
      /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
      dup {aTxC eq {/jaHIes true def exit}if}forall
      jaHIes
      {
       pop
      }
      {
       aTxC /valG exch def
       dup length 1 add dup 1 sub /Dmes exch def
       %% pot entrar en conflicte amb (:-T)
       array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
       XRay /EspaisDeColor get /Desconeguts get ARAcs 3 -1 roll
       put  %% incrustem el seguent valor de gamma a l'array de valors
      }ifelse                                 
     }
     {  %% si no, mirem si es a Utilitzats, si no, No fem res ...
      /Utilitzats get ARAcs known
      {
       XRay /EspaisDeColor get /Utilitzats get ARAcs get
       nomDtp null ne
       {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
        XRay /Patterns&Shadings get /Utilitzats get
        nomDtp get 2 ARAcs put  %% ... primer incrustem el nom de l'espai de color a l'array del Pattern, despres de %30% el canviarem pel seu nom extern
       }if
       /TanX100 get
       /jaHIes false def  %% aqui mirem si ja hem desat el to a l'array de colors
       dup {aTxC eq {/jaHIes true def exit}if}forall
       jaHIes
       {
        pop
       }
       {
        aTxC /valG exch def
        dup length 1 add dup 1 sub /Dmes exch def
        array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
        XRay /EspaisDeColor get /Utilitzats get ARAcs get /TanX100  3 -1 roll put  %% incrustem el seguent valor de gamma a l'array de valors
       }ifelse
      }if
     }ifelse
    } if
    %%test
    }stopped{( ... peta scn 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     count {pop} repeat
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     dup type /nametype eq
     {  %% si duu nom es que esta pintant un Pattern
      /elNOM exch def
      count dup /RoLL exch def
      {  %% repeat
       RoLL -1 roll 10000 mul truncate 10000 div
       64 string cvs sEdAs exch writestring sEdAs 32 write
       RoLL 1 sub /RoLL exch def
      } repeat
      elNOM sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
      sEdAs (scn\012) writestring
     }
     {
      count dup /RoLL exch def
      {  %% repeat
       RoLL -1 roll 10000 mul truncate 10000 div
       64 string cvs sEdAs exch writestring sEdAs 32 write
       RoLL 1 sub /RoLL exch def
      } repeat
      sEdAs (scn\012) writestring
      %%sEdAs (rg\012) writestring  %%MASATS08 x la manca de /ColorSpace <</tal /DeviceRGB>> a Resources i a Contents /tal cs
     }ifelse
    }ifelse
    %%}stopped{( ... peta scn) == quit}if
   }
  ] i_scn get /scn exch bind def

%% (PDF Ref ?) 8.5.2.1 Device-dependent color space operators
  [  %% G
   {  %% 0 repiquem idem, pero mantenim l'analisi d'Xray | gatells: 16
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% solucio DeviceGray (transformat a Black del CMYK)
    %% sobreixidor x saber on es crida l'espai de color q posarem en tractament progressivament
    %%(-- AQUI es crida:G: DeviceGray) ==
    %% en capturem el valor de forma compacte en una string hexa per fer-lo treballar com a clau del dic Paleta de /DeviceGray
    dup  %% dupliquem x repicar G
    faPaletaG2Hexa
    %% si el color DeviceGray es descrit de forma directe en desem els seus valors sota /DeviceGray (pero com a component /Black del CMYK) ...
    XRay /EspaisDeColor get /Utilitzats get dup /DeviceGray known
    {  %% ja existeix perque abans l'espai /DeviceGray ha estat cridat (un SC o G) ?
     /DeviceGray get /Paleta get els8vals /Directe put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(G executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
       FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic /DeviceGray al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /DeviceGray put
     }if
    }
    {  %% si no hi es, el creem de nou
     /DeviceGray
     <<
       /Tipus /PureCMYK /NomExtern /Black /FTipus null
       /Paleta << els8vals /Directe >>
       /TanX100 []  %% hi desarem en arrays la gamma de valors usats
     >> put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(G executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
       FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic /DeviceGray al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /DeviceGray put
     }if
    }ifelse
    pop pop pop pop  %% ens carreguem la copia produida per la transformacio a CMYK feta per faPaletaG2Hexa
    %% reescrivim identic com a G
    10000 mul truncate 10000 div 64 string cvs
    sEdAs exch writestring sEdAs 32 write sEdAs (G\012) writestring
    %%test
    }stopped{( ... peta G 0) pstack stop}if
   }  %% 0 repiquem idem, pero mantenim l'analisi d'Xray
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%test
    %%{  % stopped

    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% solucio DeviceGray (transformat a Black del CMYK)
    %% sobreixidor x saber on es crida l'espai de color q posarem en tractament progressivament
    %%(-- AQUI es crida:G: DeviceGray) ==

    %%    %% comprovarem al proper 'G' q el valor actual d'espai de color tingui el component /Black, ara nomes funciona en una Separation (hauria de funcionar tambe amb un DeviceN o un valor CMYK)
    %%    %% x solucionar el problema de la crida en DeviceGray apliquem una solucio similar a la de l'operador sc/SC
    %%    ARAcs type /nulltype eq
    %%    {  % si tinguessim q definir a traves de g un nou espai de color (o sigui q encara no en tenim cap de definit) continuarem donan error
    %%     XRay /EspaisDeColor get /Errades get /NoName6 ( DeviceGray Color Space Not Supported) put
    %%     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (G\015) writestring
    %%    }
    %%    {
    %%     /aTxC () def
    %%     count dup /RoLL exch def
    %%     {
    %%      RoLL -1 roll 10000 mul truncate 10000 div
    %%      ARAcs type /nulltype ne
    %%      {  % incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
    %%       dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
    %%       1 add  % separem els valors amb espais en blanc
    %%       dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
    %%       ToTa {laC 32 write} repeat  % ens assegurem que la cadena no dugui nulls!
    %%       laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
    %%      } if
    %%      64 string cvs sEdAs exch writestring sEdAs 32 write
    %%      RoLL 1 sub /RoLL exch def
    %%     } repeat
    %%     sEdAs (G\015) writestring
    %%     ARAcs type /nulltype ne
    %%     {  % incrustem l'array de gamma de color al dic que toqui
    %%      CSARA 0 get dup null eq{pop}{/ARAcs exch def}ifelse  % rectifiquem el valor del color actual per csARA (tret que no sigui un null!) que segur que treballa B (amb ARAcs no teniem en compte si era per fill o per stroke!)
    %%      XRay /EspaisDeColor get dup /Desconeguts get ARAcs known
    %%      {  % si l'espai es a Desconeguts ...
    %%       /Desconeguts get ARAcs get
    %%       /jaHIes false def  % aqui mirem si ja hem desat el to a l'array de colors
    %%       dup {aTxC eq {/jaHIes true def exit}if}forall
    %%       jaHIes {pop}
    %%       {
    %%        aTxC /valG exch def
    %%        dup length 1 add dup 1 sub /Dmes exch def
    %%        array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
    %%        XRay /EspaisDeColor get /Desconeguts get ARAcs 3 -1 roll
    %%        put  % incrustem el seguent valor de gamma a l'array de valors
    %%       }ifelse
    %%      }
    %%      {  % si no, mirem si es a Utilitzats, si no, No fem res ...
    %%       /Utilitzats get ARAcs known
    %%       {
    %%        XRay /EspaisDeColor get /Utilitzats get ARAcs get
    %%        /TanX100 get
    %%        /jaHIes false def  % aqui mirem si ja hem desat el to a l'array de colors
    %%        dup {aTxC eq {/jaHIes true def exit}if}forall
    %%	jaHIes
    %%	{
    %%	 pop
    %%	}
    %%        {
    %%         aTxC /valG exch def
    %%         dup length 1 add dup 1 sub /Dmes exch def
    %%         array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
    %%         XRay /EspaisDeColor get /Utilitzats get ARAcs get /TanX100  3 -1 roll put  % incrustem el seguent valor de gamma a l'array de valors
    %%        }ifelse
    %%       }if
    %%      }ifelse
    %%     } if
    %%    } ifelse

    %% en capturem el valor de forma compacte en una string hexa per fer-lo treballar com a clau del dic Paleta de /DeviceGray
    faPaletaG2Hexa
    %% si el color DeviceGray es descrit de forma directe en desem els seus valors sota /DeviceGray (pero com a component /Black del CMYK) ...
    XRay /EspaisDeColor get /Utilitzats get dup /DeviceGray known
    {  %% ja existeix perque abans l'espai /DeviceGray ha estat cridat (un SC o G) ?
     /DeviceGray get /Paleta get els8vals /Directe put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(G executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
       FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic /DeviceGray al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /DeviceGray put
     }if
    }
    {  %% si no hi es, el creem de nou
     /DeviceGray
     <<
       /Tipus /PureCMYK /NomExtern /Black /FTipus null
       /Paleta << els8vals /Directe >>
       /TanX100 []  %% hi desarem en arrays la gamma de valors usats
     >> put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(G executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
       FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic /DeviceGray al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /DeviceGray put
     }if
    }ifelse

    %%    % NO reescrivim identic com a G
    %%    10000 mul truncate 10000 div 64 string cvs
    %%    sEdAs exch writestring sEdAs 32 write sEdAs (G\015) writestring

    %% reescrivim identic com a K
    4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (K\012) writestring
    %% solucio DeviceGray (transformat a Black del CMYK)

    %%test
    %%}stopped{( ... peta G) == quit}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %% reescrivim identic com a G
     10000 mul truncate 10000 div 64 string cvs
     sEdAs exch writestring sEdAs 32 write sEdAs (G\012) writestring
    }ifelse
    %%}stopped{( ... peta G) == quit}if
   }
  ] i_G get /G exch bind def

  [  %% g
   {  %% 0 repiquem idem, pero mantenim l'analisi d'Xray | gatells: 16
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% solucio DeviceGray (transformat a Black del CMYK)
    %%(-- AQUI es crida:g: DeviceGray) ==
    %% en capturem el valor de forma compacte en una string hexa per fer-lo treballar com a clau del dic Paleta de /DeviceGray
    dup  %% dupliquem per repicar g
    faPaletaG2Hexa
    %% si el color DeviceGray es descrit de forma directe en desem els seus valors sota /DeviceGray (pero com a component /Black del CMYK) ...
    XRay /EspaisDeColor get /Utilitzats get dup /DeviceGray known
    {  %% ja existeix perque abans l'espai /DeviceGray ha estat cridat (un sc o g) ?
     /DeviceGray get /Paleta get els8vals /Directe put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(g executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
       FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic /DeviceGray al form q toca dins de FormsiColorSpaces
      }if
     }if %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /DeviceGray put
     }if
    }
    {  %% si no hi es, el creem de nou
     /DeviceGray
     <<
       /Tipus /PureCMYK /NomExtern /Black /FTipus null
       /Paleta << els8vals /Directe >>
       /TanX100 []  %% hi desarem en arrays la gamma de valors usats
     >> put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(g executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
       FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic /DeviceGray al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /DeviceGray put
     }if
    }ifelse
    pop pop pop pop  %% ens carreguem la copia produida per la transformacio a CMYK feta per faPaletaG2Hexa
    %% reescrivim identic com a g
    10000 mul truncate 10000 div 64 string cvs
    sEdAs exch writestring sEdAs 32 write sEdAs (g\012) writestring
    %%test
    }stopped{( ... peta g 0) pstack stop}if
   }  %% 0 repiquem idem, pero mantenim l'analisi d'Xray
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% solucio DeviceGray (transformat a Black del CMYK)
    %%(-- AQUI es crida:g: DeviceGray) ==
    %%    %% comprovarem al proper 'g' q el valor actual d'espai de color tingui el component /Black, ara nomes funciona en una Separation (hauria de funcionar tambe amb un DeviceN o un valor CMYK)
    %%    %% x solucionar el problema de la crida en DeviceGray apliquem una solucio similar a la de l'operador sc/SC
    %%    ARAcs type /nulltype eq
    %%    {  % si tinguessim q definir a traves de g un nou espai de color (o sigui q encara no en tenim cap de definit) continuarem donan error
    %%     XRay /EspaisDeColor get /Errades get /NoName5 ( DeviceGray Color Space Not Supported) put
    %% en capturem el valor de forma compacte en una string hexa per fer-lo treballar com a clau del dic Paleta de /DeviceGray
    faPaletaG2Hexa
    %% si el color DeviceGray es descrit de forma directe en desem els seus valors sota /DeviceGray (pero com a component /Black del CMYK) ...
    XRay /EspaisDeColor get /Utilitzats get dup /DeviceGray known
    {  %% ja existeix perque abans l'espai /DeviceGray ha estat cridat (un sc o g) ?
     /DeviceGray get /Paleta get els8vals /Directe put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(g executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
       FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic /DeviceGray al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /DeviceGray put
     }if
    }
    {  %% si no hi es, el creem de nou
     /DeviceGray
     <<
       /Tipus /PureCMYK /NomExtern /Black /FTipus null
       /Paleta << els8vals /Directe >>
       /TanX100 []  %% hi desarem en arrays la gamma de valors usats
     >> put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(g executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /DeviceGray get
       FormsiColorSpaces araNomXForm get exch /DeviceGray exch put  %% incrustem el dic /DeviceGray al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /DeviceGray put
     }if
    }ifelse

    %%    % NO reescrivim identic com a g
    %%    10000 mul truncate 10000 div 64 string cvs
    %%    sEdAs exch writestring sEdAs 32 write sEdAs (g\015) writestring
    %% reescrivim identic com a k
    4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (k\012) writestring

    %%    }
    %%    {
    %%     /aTxC () def
    %%     count dup /RoLL exch def
    %%     {
    %%      RoLL -1 roll 10000 mul truncate 10000 div
    %%      ARAcs type /nulltype ne
    %%      {  % incrustem els valors de color a la cadena aTxC x despres posar-la al dic que toqui
    %%       dup 64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
    %%       1 add  % separem els valors amb espais en blanc
    %%       dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
    %%       ToTa {laC 32 write} repeat  % ens assegurem que la cadena no dugui nulls!
    %%       laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
    %%      } if
    %%      64 string cvs sEdAs exch writestring sEdAs 32 write
    %%      RoLL 1 sub /RoLL exch def
    %%     } repeat     
    %%     sEdAs (g\015) writestring
    %%     ARAcs type /nulltype ne
    %%     {  % incrustem l'array de gamma de color al dic que toqui
    %%      csARA 0 get dup null eq{pop}{/ARAcs exch def}ifelse  % rectifiquem el valor del color actual per csARA (tret que no sigui un null!) que segur que treballa B (amb ARAcs no teniem en compte si era per fill o per stroke!)
    %%      XRay /EspaisDeColor get dup /Desconeguts get ARAcs known
    %%      {  % si l'espai es a Desconeguts ...
    %%       /Desconeguts get ARAcs get
    %%       /jaHIes false def  % aqui mirem si ja hem desat el to a l'array de colors
    %%       dup {aTxC eq {/jaHIes true def exit}if}forall
    %%       jaHIes
    %%       {
    %%        pop
    %%       }
    %%       {
    %%        aTxC /valG exch def
    %%        dup length 1 add dup 1 sub /Dmes exch def
    %%        array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
    %%        XRay /EspaisDeColor get /Desconeguts get ARAcs 3 -1 roll
    %%        put  % incrustem el seguent valor de gamma a l'array de valors
    %%       }ifelse
    %%      }
    %%      {  % si no, mirem si es a Utilitzats, si no, No fem res ...
    %%       /Utilitzats get ARAcs known
    %%       {
    %%        XRay /EspaisDeColor get /Utilitzats get ARAcs get
    %%        /TanX100 get
    %%        /jaHIes false def  % aqui mirem si ja hem desat el to a l'array de colors
    %%        dup {aTxC eq {/jaHIes true def exit}if}forall
    %%	jaHIes
    %%	{
    %%	 pop
    %%	}
    %%        {
    %%         aTxC /valG exch def
    %%         dup length 1 add dup 1 sub /Dmes exch def
    %%         array dup dup 4 -1 roll 0 exch putinterval Dmes valG put
    %%         XRay /EspaisDeColor get /Utilitzats get ARAcs get /TanX100  3 -1 roll put  % incrustem el seguent valor de gamma a l'array de valors
    %%        }ifelse
    %%       }if
    %%      }ifelse
    %%     } if
    %%    } ifelse
    %% solucio DeviceGray (transformat a Black del CMYK)
    %%test
    %%}stopped{( ... peta g) == quit}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %% reescrivim identic com a g
     10000 mul truncate 10000 div 64 string cvs
     sEdAs exch writestring sEdAs 32 write sEdAs (g\012) writestring
    }ifelse
    %%}stopped{( ... peta g) == quit}if
   }
  ] i_g get /g exch bind def

  [  %% RG
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    XRay /EspaisDeColor get /Errades get /NoName8 ( DeviceRGB Color Space Not Supported) put
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (RG\012) writestring
    %%test
    }stopped{( ... peta RG 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (RG\012) writestring
    }ifelse
    %%}stopped{( ... peta RG) == quit}if
   }
  ] i_RG get /RG exch bind def

  [  %% rg
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    XRay /EspaisDeColor get /Errades get /NoName7 ( DeviceRGB Color Space Not Supported) put
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (rg\012) writestring
    %%test
    }stopped{( ... peta rg 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop pop pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
      3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (rg\012) writestring
     }ifelse
    }stopped{( ... peta rg) == quit}if
   }
  ] i_rg get /rg exch bind def

  [  %% K
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% en capturem el valor de forma compacte en una string hexa per fer-lo treballar com a clau del dic Paleta de NoName9
    faPaletaCMYK2Hexa
    %% si el color CMYK es descrit de forma directe en desem els seus valors sota NoName9 ...
    XRay /EspaisDeColor get /Utilitzats get dup /NoName9 known
    {  %% ja existeix perque abans l'espai CMYK ha estat cridat (un SC o K) ?
     /NoName9 get /Paleta get els8vals /Directe put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(K executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /NoName9 get
       FormsiColorSpaces araNomXForm get exch /NoName9 exch put  %% incrustem el dic NoName9 al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /PureCMYK put
     }if
    }
    {  %% si no hi es, el creem de nou
     /NoName9 <<
                /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
                /Paleta << els8vals /Directe >>
                /TanX100 []  %% hi desarem en arrays la gamma de valors scn/SCN usats
              >> put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(K executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /NoName9 get
       FormsiColorSpaces araNomXForm get exch /NoName9 exch put  %% incrustem el dic NoName9 al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /PureCMYK put
     }if
    }ifelse
    4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (K\012) writestring
    %%test
    }stopped{( ... peta K 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (K\012) writestring
    }ifelse
    %%}stopped{( ... peta K) == quit}if
   }
  ] i_K get /K exch bind def

  [  %% k
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% en capturem el valor de forma compacte en una string hexa per fer-lo treballar com a clau del dic Paleta de NoName9
    faPaletaCMYK2Hexa
    %% si el color CMYK es descrit de forma directe en desem els seus valors sota NoName9 ...
    XRay /EspaisDeColor get /Utilitzats get dup /NoName9 known
    {  %% ja existeix perque abans l'espai CMYK ha estat cridat (un sc o k) ?
     /NoName9 get /Paleta get els8vals /Directe put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(k executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /NoName9 get
       FormsiColorSpaces araNomXForm get exch /NoName9 exch put  %% incrustem el dic NoName9 al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho

     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /PureCMYK put
     }if
    }
    {  %% si no hi es, el creem de nou
     /NoName9 <<
                /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
                /Paleta << els8vals /Directe >>
                /TanX100 []  %% hi desarem en arrays la gamma de valors scn/SCN usats
              >> put
     userdict /HiHaForms known
     {
      HiHaForms
      {
       %%(k executat dins un Form) ==
       XRay /EspaisDeColor get /Utilitzats get /NoName9 get
       FormsiColorSpaces araNomXForm get exch /NoName9 exch put  %% incrustem el dic NoName9 al form q toca dins de FormsiColorSpaces
      }if
     }if  %% gatell x saber-ho
     nomDtp null ne
     {  %% classifiquem l'espai de color del Pattern concret nomes quan s'executen les redefinicions d'OpContents per l'stream del Pattern
      XRay /Patterns&Shadings get /Utilitzats get
      nomDtp get 2 /PureCMYK put
     }if
    }ifelse
    4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (k\012) writestring
    %%test
    }stopped{( ... peta k 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (k\012) writestring
    }ifelse
    %%}stopped{( ... peta k) == quit}if
   }
  ] i_k get /k exch bind def

%% (PDF Ref 1.7) 4.6 Shading Patterns
  [  %% sh
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% desem a XRay els Shading Patterns que de moment no tractarem
    %%dup XRay /EspaisDeColor get /Errades get exch ( Shading Pattern Operator Not Supported) put
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (sh\012) writestring
    %%test
    }stopped{( ... peta sh 1) pstack stop}if
   }
   {  %% 2 projecte de verificacio de PDF del Col·legi
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% desem a XRay els Shading Patterns que de moment no tractarem
    %%dup XRay /EspaisDeColor get /Errades get exch ( Shading Pattern Operator Not Supported) put
    %% anellem la llesca sense destriar, de moment, els Forms
    sEdAs dup dup (/OC ) writestring
    llesques 4 get dup 0 true put  %% marquem els Shading Patterns com actius
    1 get writestring ( BDC\012) writestring
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (sh\012EMC\012) writestring
    %%test
    %%}stopped{( ... peta sh) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs ( sh\012) writestring
    }ifelse
   }
  ] i_sh get /sh exch bind def

%% (PDF Ref 1.7) XObjects 4.8 Images 4.9 Form XObjects
%% (PDF Ref ?) 8.8.1 XObject operators
  [  %% Do
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    dup dup /ARAxo exch def XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }ifelse
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring
    sEdAs ( Do\012) writestring
    }stopped{( ... peta Do 1) pstack stop}if
   }
   {  %% 2 (relliga imatges)
    %%{  % stopped
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    dup dup /ARAxo exch def XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
        %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
        %%QueLiFemFer 6 eq
        %%{
        %% (%17bis%)==
        %% i quin problema hi ha si el deixem de forma fixa?
        /trEncAclOsqUEs <<>>
        %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }ifelse
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring
    sEdAs ( Do\012) writestring
    %%}stopped{( ... peta Do) == quit}if
    %% KTCSa3copiseny test
    (<--- imatge!) ==
    i4cantons araPlana known
    {  %% ja hi es ...
     i4cantons araPlana get dup
    }
    {  %% el diccionari encara no existeix ...
     <<>> dup
    }ifelse
    3 -1 roll  %% pesquem el nom de la imatge
    [  %% coordenades dels 4 xamfrans de la imatge x ordre de lectura
     [
      cmPx round  %% si arrodonim corregim petites desviacions de menys d'1 punt?
      cmPy cmSy add round
     ]  %% x,y ul
     [
      cmPx cmSx add round
      cmPy cmSy add round
     ]  %% x,y ur
     [
      cmPx round
      cmPy round
     ]  %% x,y ll
     [
      cmPx cmSx add round
      cmPy round
     ]  %% x,y lr
     %% passa res si desem un cinque element al paquet amb la matriu original de la imatge?
     [ cmSx cm_tanAsin cm_tanBsin cmSy cmPx cmPy]
    ]
    put  %% incrustem sota el nom de la imatge el paquet amb les coordenades dels 4 xamfrans de la imatge x ordre de lectura
    i4cantons exch araPlana exch put  %% reincrustem refet el diccionari de la pagina a i4cantons, doncs aixi blindem els continguts pagina a pagina
   }
   {  %% 3 (reinsereix/exporta imatges)
    dup  %% dupliquem x desar el nom de la imatge a imatgesXordre
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    dup dup /ARAxo exch def XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }ifelse
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring
    sEdAs ( Do\012) writestring

    %% cal incrustar els noms de les imatges en una array x ordre (imatgesXordre) i x num de pagina
    araPlana 4 string cvs cvx exec 1 add XRay /PeDeEfa get /imatgesXordre get length
    gt  %% amb el length sabem si el num d pagina existeix o no
    {  %% no existeix el num de pagina i per aixo hem d'ampliar l'array del document fins on demani
     araPlana 4 string cvs cvx exec 1 add XRay /PeDeEfa get /imatgesXordre get length sub
     XRay /PeDeEfa get /imatgesXordre get length add array dup XRay /PeDeEfa get /imatgesXordre get 0 exch putinterval
     XRay /PeDeEfa get exch /imatgesXordre exch put [ exch ]  %% afegim el nom de la imatge al primer lloc de l'array de pagina
     XRay /PeDeEfa get /imatgesXordre get exch araPlana 4 string cvs cvx exec exch put  %% i ara la nova array de pagina al paquet imatgesXordre
    }
    {  %% podria existir o no
     XRay /PeDeEfa get /imatgesXordre get araPlana 4 string cvs cvx exec get dup null eq
     {  %% no existeix l'array de pagina
      pop XRay /PeDeEfa get /imatgesXordre get exch [ exch ]  %% afegim el nom de la imatge al primer lloc de l'array de pagina
      araPlana 4 string cvs cvx exec exch put  %% afegim la nova array de pagina
     }
     {  %% ja hi es
      %% aqui comprovem que el nom de la imatge no estigui repetit
      /iidem false def
      %% doncs llavors vol dir q comparteix el mateix tou de dades i no cal tornar-li a posar!
      dup {ARAxo eq{/iidem true def}if}forall
      iidem
      {  %% es idem i llavors no fem re
       pop pop
      }
      {
       dup length dup 1 add array dup 4 -1 roll 0 exch putinterval dup 3 -1 roll 4 -1 roll put  %% afegim la nova imatge x ordre a l'array de pagina
       XRay /PeDeEfa get /imatgesXordre get exch araPlana 4 string cvs cvx exec exch put  %% la redesem a imatgesXordre
      }ifelse
     }ifelse
    }ifelse
   }
   {  %% 4 projecte verificador de PDF del Col·legi
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    dup dup /ARAxo exch def XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }ifelse
    %% anellem la llesca sense destriar, de moment, els Forms
    sEdAs dup dup (/OC ) writestring
    llesques 0 get dup 0 true put  %% marquem els XObjects com actius
    1 get writestring ( BDC\012) writestring
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring
    sEdAs ( Do\012EMC\012) writestring
    %%}stopped{( ... peta Do) == quit}if
   }
   {  %% 5 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    dup dup /ARAxo exch def XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Desconeguts get exch null put  %% desem a XRay els Objectes X utilitzats
    }ifelse
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring
     sEdAs ( Do\012) writestring
    }ifelse
    %%}stopped{( ... peta Do 3) == quit}if
   }
  ] i_Do get /Do exch bind def

%% (PDF Ref 1.7) 4.8.6 Inline Images
%% (PDF Ref ?) 8.9 In-line image objects
  [  %% BI
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (BI\012) writestring mark
    %%test
    }stopped{( ... peta BI 1) pstack stop}if
   }
   {  %% 2 reinserit d'imatges JPEG exportades previament
%%(___HI HA inLine !___)==
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (BI\012) writestring mark
    %% cal incrustar els noms de les imatges en una array x ordre (imatgesXordre) i x num de pagina
    araPlana 4 string cvs cvx exec 1 add XRay /PeDeEfa get /imatgesXordre get length
    gt  %% amb el length sabem si el num d pagina existeix o no
    {  %% no existeix el num de pagina i per aixo hem d'ampliar l'array del document fins on demani
     araPlana 4 string cvs cvx exec 1 add XRay /PeDeEfa get /imatgesXordre get length sub
     XRay /PeDeEfa get /imatgesXordre get length add array dup XRay /PeDeEfa get /imatgesXordre get 0 exch putinterval
     XRay /PeDeEfa get exch /imatgesXordre exch put [ null ]  %% afegim null, x indicar q la imatge cal saltar-se-la, al primer lloc de l'array de pagina
     XRay /PeDeEfa get /imatgesXordre get exch araPlana 4 string cvs cvx exec exch put  %% i ara la nova array de pagina al paquet imatgesXordre
    }
    {  %% podria existir o no
     XRay /PeDeEfa get /imatgesXordre get araPlana 4 string cvs cvx exec get dup null eq
     {  %% no existeix l'array de pagina
      pop XRay /PeDeEfa get /imatgesXordre get [ null ]  %% afegim null, x indicar q la imatge cal saltar-se-la, al primer lloc de l'array de pagina
      araPlana 4 string cvs cvx exec exch put  %% afegim la nova array de pagina
     }
     {  %% ja hi es
      dup length dup 1 add array dup 4 -1 roll 0 exch putinterval dup 3 -1 roll null put  %% afegim null, x indicar q la imatge cal saltar-se-la, x ordre a l'array de pagina
      XRay /PeDeEfa get /imatgesXordre get exch araPlana 4 string cvs cvx exec exch put  %% la redesem a imatgesXordre
     }ifelse
    }ifelse
    %%}stopped{( ... peta BI) == quit}if
   }
   {  %% 3 verificacio de PDF pel Col·legi
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %% anellem la llesca sense destriar, de moment, els Forms
    sEdAs dup dup (/OC ) writestring
    llesques 2 get dup 0 true put  %% marquem les inLine com actives
    1 get writestring ( BDC\012) writestring
    sEdAs (BI\012) writestring mark
    %%test
    %%}stopped{( ... peta BI) == quit}if
   }
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     mark
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (BI\012) writestring mark
    }ifelse
   }
  ] i_BI get /BI exch bind def

  [  %% ID
%%% de com xarrupa el binari de dades d'imatge:
%%% (1) cal saber despres de l'operador corresponent (BI/stream) com enten l'espai de separacio per començar a llegir dades (i quan no en fa cas)
%%% (2) cal saber si el protocol de lectura sempre es: donat l'ample i alt en pixels, la fondaria d'imatge i el nombre de
%%% canals: aixo dona un nombre de bytes a consumir. Un cop xarrupats, descarta la resta de dades d'imatge que hi pugui
%%% haver i tot seguit va a cercar l'operador de tancament de dades d'imatge (EI/endstream)

   {  %% 0 (idem)
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    counttomark
    iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
    /ELdic << >> def
%% dup
    /alDIC exch def
%% copy
    alDIC 2 idiv {ELdic 3 1 roll put}repeat
    XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }ifelse
    ELdic dup /CS known  %% pot no haver-hi CS (sobretot amb plomes inLine)
    {
     /CS get dup
    }
    {  %% si desconeixem l'espai de color l'interroguem x la fondaria
     %% sense resoldre encara el problema, de moment, desviem el problema
     /BPC get 1 eq {/PLoMa dup}{/DeSCoNeGuT dup}ifelse
    }ifelse
    <<
      %% /G [/NoName10 ( DeviceGray Color Space Not Supported)]
      /PLoMa [/NoName13 ( Unknown Color Space)]
      /DeSCoNeGuT [/NoName13 ( Unknown Color Space)]
      
      /RGB [/NoName11 ( DeviceRGB Color Space Not Supported)]
      /I [/NoName12 ( Indexed Color Space Not Supported)]
    >> dup 3 -1 roll known
    {  %% afegim l'error a Errades amb un nom anonim de color
     %% sobreixidor x saber on es crida l'espai de color q encara no tractem
     %%(-- AQUI es crida:Inline: DeviceRGB, Indexed, PLoMa o DeSCoNeGuT) ==
     exch get XRay /EspaisDeColor get /Errades get exch aload pop put
     %% /ARAcs null def  % aquesta variable ens ha de dir: si null es que l'espai de color es erroni i llavors scn/SCN o sc/SC no escriuran res, si es un nom hi desaran el valor dins una array
    }
    {
     pop
     dup <</CMYK null>> exch known
     {  %% si un CS crida l'espai CMYK de forma directe ...
      pop XRay /EspaisDeColor get /Utilitzats get dup
      /NoName9 known
      {
       pop
      }
      {
       /NoName9
       <<
         /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
         /Paleta <<ARAxo null >>
         /TanX100 []  %% hi desarem en strings la gamma de valors scn/SCN usats
       >> put
      } ifelse
      %%       /ARAcs /NoName9 def  % desem el nom de l'espai de color actual
      %%       CSARA 0 /NoName9 put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
     }
     {
      XRay /EspaisDeColor get /Desconeguts get dup 3 -1 roll dup 3 -2 roll
      known
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              /ARAcs exch def
       pop pop
      }  %% si ja l'hem definit desem el nom de l'espai de color actual a la variable que utilitzara sc/SC o scn/SCN
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              dup /ARAcs exch def  % desem el nom de l'espai de color actual
       []  %% ara li posem de valor l'array on desarem la gamma de percentatges
       put  %% desem a XRay els espais de color utilitzats
      } ifelse
     } ifelse
    } ifelse    
%%    counttomark
%%    dup /RoLL exch def
%%    {  % repeat
%%     RoLL -1 roll
%%     dup type /nametype eq
%%     {
%%      sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%     }
%%     {
%%      dup type /arraytype eq
%%      {
%%       sEdAs ([ ) writestring
%%       {  % forall
%%        dup type /nametype eq
%%        {
%%         sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%        }
%%        {
%%         64 string cvs sEdAs exch writestring sEdAs 32 write
%%        } ifelse
%%       } forall
%%       sEdAs (] ) writestring
%%      }
%%      {
%%       64 string cvs sEdAs exch writestring sEdAs 32 write
%%      } ifelse
%%     } ifelse
%%     RoLL 1 sub /RoLL exch def
%%    } repeat

    ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
    sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
    /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

    %% hem tret l'identificador d'inlines per l'opcio del repicat
    %%% posem davant ID el nom de la inLine (ARAxo) x poder-la identificar a l'hora d'escriure la separacio de colors
    %%sEdAs (\015) writestring
    %%sEdAs (/) writestring
    %%sEdAs ARAxo 128 string cvs writestring
    sEdAs (\012ID\012) writestring
    %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
    %% una altra solucio seria utilitzar, si s'escau, els mateixos filtres per desenflatar la imatge per calcular-ne
    %% la seva llargada en funcio de l'ample+alt+bitsxpixelxcanal
    %%currentfile << /EODCount 0 /EODString (EI) >> /SubFileDecode filter
    %%dup
    %%{  %% codi escapçat

    %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
    %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
    %%% llegimOctetAoctetXquadrar1patro.ps
    /Toctets 0 def  %% total d'octets llegits
    /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
    /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
    /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
    /3veritats
    [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
     [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
      10  %% Line Feed
      12  %% Form Feed
      13  %% Carriage Return
%%      32  % Space
     ]
     [
      69  %% caracter E
     ]
     [
      73  %% caracter I
     ]
    ] def
    %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
    %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
    /maxB 4 1024 mul def
    /maxIL maxB string def
    /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
    currentfile
    3
    {  %% posara els 3 primer bytes a l'array
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
      i3o 1 add /i3o exch def       
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
%%UBpliegOMaker
     }ifelse
    } repeat
    /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
    {  %% loop
     0 1 2
     {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
     }for
     3Boctets
     aload pop  %% desmuntem l'array
     and and  %% els 3 estan a true ?
     {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
      pop exit  %% ... sortim
     }
     {  %% com q encara no l'hem trobat ...
      %% enretirem 1 posicio cap a l'esquerra el paquet ...
      3Bytes 1 2 getinterval
      %% ... i escrivim el caracter sortint al buffer del repicat
      3Bytes 0 get iBuffer exch write
      %% recol·loquem l'enretirat
      /3Bytes 3 array def
      3Bytes exch 0 exch putinterval
     }ifelse
     3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
     Toctets 1 add /Toctets exch def  %% total d'octets llegits
     Toctets maxB gt {pop BaBeL 41 get print flush stop}if
%%UBpliegOMaker
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
%%UBpliegOMaker
     }ifelse
    }loop
    iBuffer closefile
    %%3Bytes 3Boctets
    maxIL 0 Toctets getinterval
    %%% fi de llegimOctetAoctetXquadrar1patro.ps
    dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
    sEdAs exch writestring sEdAs
    (\015\012EI\015\012) writestring
%%    (\012EI\012) writestring
%%(EI\012\012\012\012) writestring  % prevenim un aqui possible trepitjat de la Q de tancament en una segona interpretacio del codi (#6 i altres)
%%sEdAs dup 1B write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador

    %%}loop
    %%closefile  % tanquem el fitxer
    ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
    dup dup length 4 sub (.obj) putinterval  %% creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
    dup length faPathA add string dup
    /pAthA exch def 0 tEmp putinterval
    pAthA exch faPathA exch putinterval
    pAthA (w) file dup SiLi writestring closefile  %% utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
    pop  %% ens carreguem la mark
    %% desem sempre el path del raw de la inLine al dic ELdic
    ELdic /XIU pAthA put
    iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    %%test
    %%}stopped{( ... peta ID) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    counttomark
    iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
    /ELdic << >> def
%% dup
    /alDIC exch def
%% copy
    alDIC 2 idiv {ELdic 3 1 roll put}repeat
    XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }ifelse
    ELdic dup /CS known  %% pot no haver-hi CS (sobretot amb plomes inLine)
    {
     /CS get dup
    }
    {  %% si desconeixem l'espai de color l'interroguem x la fondaria
     %% sense resoldre encara el problema, de moment, desviem el problema
     /BPC get 1 eq {/PLoMa dup}{/DeSCoNeGuT dup}ifelse
    }ifelse
    <<
      %% /G [/NoName10 ( DeviceGray Color Space Not Supported)]
      /PLoMa [/NoName13 ( Unknown Color Space)]
      /DeSCoNeGuT [/NoName13 ( Unknown Color Space)]
      
      /RGB [/NoName11 ( DeviceRGB Color Space Not Supported)]
      /I [/NoName12 ( Indexed Color Space Not Supported)]
    >> dup 3 -1 roll known
    {  %% afegim l'error a Errades amb un nom anonim de color
     %% sobreixidor x saber on es crida l'espai de color q encara no tractem
     %%(-- AQUI es crida:Inline: DeviceRGB, Indexed, PLoMa o DeSCoNeGuT) ==
     exch get XRay /EspaisDeColor get /Errades get exch aload pop put
     %% /ARAcs null def  % aquesta variable ens ha de dir: si null es que l'espai de color es erroni i llavors scn/SCN o sc/SC no escriuran res, si es un nom hi desaran el valor dins una array
    }
    {
     pop
     dup <</CMYK null>> exch known
     {  %% si un CS crida l'espai CMYK de forma directe ...
      pop XRay /EspaisDeColor get /Utilitzats get dup
      /NoName9 known
      {
       pop
      }
      {
       /NoName9
       <<
         /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
         /Paleta <<ARAxo null >>
         /TanX100 []  %% hi desarem en strings la gamma de valors scn/SCN usats
       >> put
      } ifelse
      %%       /ARAcs /NoName9 def  % desem el nom de l'espai de color actual
      %%       CSARA 0 /NoName9 put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
     }
     {
      XRay /EspaisDeColor get /Desconeguts get dup 3 -1 roll dup 3 -2 roll
      known
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              /ARAcs exch def
       pop pop
      }  %% si ja l'hem definit desem el nom de l'espai de color actual a la variable que utilitzara sc/SC o scn/SCN
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              dup /ARAcs exch def  % desem el nom de l'espai de color actual
       []  %% ara li posem de valor l'array on desarem la gamma de percentatges
       put  %% desem a XRay els espais de color utilitzats
      } ifelse
     } ifelse
    } ifelse
%%    counttomark
%%    dup /RoLL exch def
%%    {  % repeat
%%     RoLL -1 roll
%%     dup type /nametype eq
%%     {
%%      sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%     }
%%     {
%%      dup type /arraytype eq
%%      {
%%       sEdAs ([ ) writestring
%%       {  % forall
%%        dup type /nametype eq
%%        {
%%         sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%        }
%%        {
%%         64 string cvs sEdAs exch writestring sEdAs 32 write
%%        } ifelse
%%       } forall
%%       sEdAs (] ) writestring
%%      }
%%      {
%%       64 string cvs sEdAs exch writestring sEdAs 32 write
%%      } ifelse
%%     } ifelse
%%     RoLL 1 sub /RoLL exch def
%%    } repeat

    ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
    sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
    /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

    %% posem davant ID el nom de la inLine (ARAxo) x poder-la identificar a l'hora d'escriure la separacio de colors
    sEdAs (\012) writestring
    sEdAs (/) writestring
    sEdAs ARAxo 128 string cvs writestring sEdAs
    (\012ID\012) writestring
    %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
    %% una altra solucio seria utilitzar els mateixos filtres per la lectura
    %%currentfile 0 (\012EI) /SubFileDecode filter
    %%dup
    %%{  %% codi escapçat

    %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
    %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
    %%% llegimOctetAoctetXquadrar1patro.ps
    /Toctets 0 def  %% total d'octets llegits
    /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
    /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
    /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
    /3veritats
    [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
     [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
      10  %% Line Feed
      12  %% Form Feed
      13  %% Carriage Return
%%      32  % Space
     ]
     [
      69  %% caracter E
     ]
     [
      73  %% caracter I
     ]
    ] def
    %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
    %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
    /maxB 4 1024 mul def
    /maxIL maxB string def
    /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
    currentfile
    3
    {  %% posara els 3 primer bytes a l'array
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
      i3o 1 add /i3o exch def       
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    } repeat
    /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
    {  %% loop
     0 1 2
     {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
     }for
     3Boctets
     aload pop  %% desmuntem l'array
     and and  %% els 3 estan a true ?
     {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
      pop exit  %% ... sortim
     }
     {  %% com q encara no l'hem trobat ...
      %% enretirem 1 posicio cap a l'esquerra el paquet ...
      3Bytes 1 2 getinterval
      %% ... i escrivim el caracter sortint al buffer del repicat
      3Bytes 0 get iBuffer exch write
      %% recol·loquem l'enretirat
      /3Bytes 3 array def
      3Bytes exch 0 exch putinterval
     }ifelse
     3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
     Toctets 1 add /Toctets exch def  %% total d'octets llegits
     Toctets maxB gt {pop BaBeL 41 get print flush stop}if
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    }loop
    iBuffer closefile
    %%3Bytes 3Boctets
    maxIL 0 Toctets getinterval
    %%% fi de llegimOctetAoctetXquadrar1patro.ps
    dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
    sEdAs exch writestring sEdAs
    (\015\012EI\015\012) writestring
%%    (\012EI\012) writestring
%%(EI\012\012\012\012) writestring  % prevenim un aqui possible trepitjat de la Q de tancament en una segona interpretacio del codi (#6 i altres)
%%sEdAs dup 1B write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador

    %%}loop
    %%closefile  % tanquem el fitxer
    ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
    dup dup length 4 sub (.obj) putinterval  %% creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
    dup length faPathA add string dup
    /pAthA exch def 0 tEmp putinterval
    pAthA exch faPathA exch putinterval
    pAthA (w) file dup SiLi writestring closefile  %% utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
    pop  %% ens carreguem la mark
    %% desem sempre el path del raw de la inLine al dic ELdic
    ELdic /XIU pAthA put
    iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    %%test
    %%}stopped{( ... peta ID) == quit}if
   } 
   {  %% 2  aqui eliminem el repicat a disc de les dades d'imatge
    %%test
    {  %% stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    counttomark
    iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
    /ELdic << >> def
%% dup
    /alDIC exch def
%% copy
    alDIC 2 idiv {ELdic 3 1 roll put}repeat
    XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }ifelse
    ELdic dup /CS known  %% pot no haver-hi CS (sobretot amb plomes inLine)
    {
     /CS get dup
    }
    {  %% si desconeixem l'espai de color l'interroguem x la fondaria
     %% sense resoldre encara el problema, de moment, desviem el problema
     /BPC get 1 eq {/PLoMa dup}{/DeSCoNeGuT dup}ifelse
    }ifelse
    <<
      %% /G [/NoName10 ( DeviceGray Color Space Not Supported)]
      /PLoMa [/NoName13 ( Unknown Color Space)]
      /DeSCoNeGuT [/NoName13 ( Unknown Color Space)]
      
      /RGB [/NoName11 ( DeviceRGB Color Space Not Supported)]
      /I [/NoName12 ( Indexed Color Space Not Supported)]
    >> dup 3 -1 roll known
    {  %% afegim l'error a Errades amb un nom anonim de color
     %% sobreixidor x saber on es crida l'espai de color q encara no tractem
     %%(-- AQUI es crida:Inline: DeviceRGB, Indexed, PLoMa o DeSCoNeGuT) ==
     exch get XRay /EspaisDeColor get /Errades get exch aload pop put
     %% /ARAcs null def  % aquesta variable ens ha de dir: si null es que l'espai de color es erroni i llavors scn/SCN o sc/SC no escriuran res, si es un nom hi desaran el valor dins una array
    }
    {
     pop
     dup <</CMYK null>> exch known
     {  %% si un CS crida l'espai CMYK de forma directe ...
      pop XRay /EspaisDeColor get /Utilitzats get dup
      /NoName9 known
      {
       pop
      }
      {
       /NoName9
       <<
         /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
         /Paleta <<ARAxo null >>
         /TanX100 []  %% hi desarem en strings la gamma de valors scn/SCN usats
       >> put
      } ifelse
      %%       /ARAcs /NoName9 def  % desem el nom de l'espai de color actual
      %%       CSARA 0 /NoName9 put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
     }
     {
      XRay /EspaisDeColor get
      /Desconeguts get
      dup 3 -1 roll dup 3 -2 roll
      known
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              /ARAcs exch def
       pop pop
      }  %% si ja l'hem definit desem el nom de l'espai de color actual a la variable que utilitzara sc/SC o scn/SCN
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              dup /ARAcs exch def  % desem el nom de l'espai de color actual
       []  %% ara li posem de valor l'array on desarem la gamma de percentatges
       put  %% desem a XRay els espais de color utilitzats
      } ifelse
     } ifelse
    } ifelse    
%%    counttomark
%%    dup /RoLL exch def
%%    {  % repeat
%%     RoLL -1 roll
%%     dup type /nametype eq
%%     {
%%      sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%     }
%%     {
%%      dup type /arraytype eq
%%      {
%%       sEdAs ([ ) writestring
%%       {  % forall
%%        dup type /nametype eq
%%        {
%%         sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%        }
%%        {
%%         64 string cvs sEdAs exch writestring sEdAs 32 write
%%        } ifelse
%%       } forall
%%       sEdAs (] ) writestring
%%      }
%%      {
%%       64 string cvs sEdAs exch writestring sEdAs 32 write
%%      } ifelse
%%     } ifelse
%%     RoLL 1 sub /RoLL exch def
%%    } repeat

    ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
    sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
    /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

    %% hem tret l'identificador d'inlines per l'opcio del repicat
    %%% posem davant ID el nom de la inLine (ARAxo) x poder-la identificar a l'hora d'escriure la separacio de colors
    %%sEdAs (\015) writestring
    %%sEdAs (/) writestring
    %%sEdAs ARAxo 128 string cvs writestring
    sEdAs (\012ID\012) writestring
    %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 

%%% al projecte de JBC hem trobat unes inLine molt poc normatives (26450.PDF 26281.PDF 26090.PDF)
%%% que fan +d8Mb! fetes amb el CAD de SolidWorks 2007 SP4.0 PDF Publisher
%% no tenim en compte que hi pot haver inLine que no facin servir noms abreujats (cap cas real?)
%% comprovem previament que el raw de la imatge NO excedeix els 4Kb normatius per les inLine
ELdic
dup dup /W get exch /H get mul exch  %% analitzem el nombre total de pixels
/BPC get mul 8 idiv  %% bytes totals de la imatge x a 1 component de color
ELdic /CS known  %% si no hi ha CS segur q es una imatge a 1 bit
{  %% si hi ha CS multipliquem pel nombre de components de color
<</RGB 3 /CMYK 4 /I 1 /G 1>> ELdic /CS get
dup 2 index exch known  %% podria ser un espai de color indirecte
{get mul}
{  %% si ho es falsifiquem la multiplicacio dels bytes totals per el valor maxim
%% doncs aqui desconeixem quina mena d'espai de color es
pop pop 4 mul
}ifelse
}if
dup 1024 4 mul gt
{  %% NO es una inLine normativa
%% les inLines que no són normatives, de moment mentre no les corregim nosaltres, es poden
%% reescriure com a XObject normal per mitjà d'un repicat a Ghostscript ...
%% gs -q -dNOSAFER -o surt.pdf -dCompatibilityLevel=1.5 -sDEVICE=pdfwrite -c .setpdfwrite -f entra.pdf
dup /raWbytes exch def  %% total de bytes de la imatge
(\n\n ... ATENCIO! imatge inLine de +d4Kb ... ) print flush
32 string cvs print flush ( Kb ... pot ser problematica\ni NO s'adiu a l'especificacio de PDF\n\n)print flush
save  %% imprescindible per la higiene dels fitxers?
currentfile dup << /EODCount raWbytes /EODString () >> /SubFileDecode filter
{  %% loop x repicar el raw passat de voltes en base als octets calculats
dup
65535 string readstring
{sEdAs exch writestring}
{sEdAs exch writestring pop exit}ifelse
}loop
{  %% loop x menjar-nos EI
dup read pop 73 eq {pop exit}if
}loop
%%(:-n)pstack quit
restore  %% impresindible per la higiene dels fitxers?
}
{  %% es una inLine normativa

    %% una altra solucio seria utilitzar, si s'escau, els mateixos filtres per desenflatar la imatge per calcular-ne
    %% la seva llargada en funcio de l'ample+alt+bitsxpixelxcanal
    %%currentfile << /EODCount 0 /EODString (EI) >> /SubFileDecode filter
    %%dup

    %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
    %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
    %%% llegimOctetAoctetXquadrar1patro.ps
    /Toctets 0 def  %% total d'octets llegits
    /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
    /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
    /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
    /3veritats
    [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
     [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
      10  %% Line Feed
      12  %% Form Feed
      13  %% Carriage Return
%%      32  % Space
     ]
     [
      69  %% caracter E
     ]
     [
      73  %% caracter I
     ]
    ] def
    %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
    %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
    /maxB 4 1024 mul def
    /maxIL maxB string def
    /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
    currentfile
    3
    {  %% posara els 3 primer bytes a l'array
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
      i3o 1 add /i3o exch def       
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    } repeat
    /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
    {  %% loop
     0 1 2
     {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
     }for
     3Boctets
     aload pop  %% desmuntem l'array
     and and  %% els 3 estan a true ?
     {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
      pop exit  %% ... sortim
     }
     {  %% com q encara no l'hem trobat ...
      %% enretirem 1 posicio cap a l'esquerra el paquet ...
      3Bytes 1 2 getinterval
      %% ... i escrivim el caracter sortint al buffer del repicat
      3Bytes 0 get iBuffer exch write
      %% recol·loquem l'enretirat
      /3Bytes 3 array def
      3Bytes exch 0 exch putinterval
     }ifelse
     3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
     Toctets 1 add /Toctets exch def  %% total d'octets llegits
     Toctets maxB gt {pop BaBeL 41 get print flush stop}if
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    }loop
    iBuffer closefile
    %%3Bytes 3Boctets
    maxIL 0 Toctets getinterval
    %%% fi de llegimOctetAoctetXquadrar1patro.ps
    dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
    sEdAs exch writestring

}ifelse  %% es o NO una inLine normativa?

    sEdAs (\015\012EI\015\012) writestring
%%    sEdAs (\012EI\012) writestring

%% prevenim un aqui possible trepitjat de la Q de tancament en una segona interpretacio del codi (#6 i altres)
%%    sEdAs dup 1B write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador
    %%closefile  % tanquem el fitxer
    
    %%% ARA ELIMINEM L'ESCRIPTURA A SAC
    %%ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
    %%dup dup length 4 sub (.obj) putinterval  % creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
    %%dup length faPathA add string dup
    %% /pAthA exch def 0 tEmp putinterval
    %%pAthA exch faPathA exch putinterval
    %%pAthA
    %%(w) file dup SiLi writestring closefile  % utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
    %%%
    
    clear  %% ens carreguem la mark i altra brossa que hi pugui haver
    %% desem sempre el path del raw de la inLine al dic ELdic
    ELdic /XIU pAthA put
    iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    %%test
    }stopped{( ... peta ID 2) pstack stop}if
   }  %% index 2

   {  %% 3 idem a 2 pero amb els afegits de verificacio de PDF pel Col·legi (eliminem el repicat a disc de les dades d'imatge)
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    counttomark
    iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
    /ELdic << >> def
%% dup
    /alDIC exch def
%% copy
    alDIC 2 idiv {ELdic 3 1 roll put}repeat
    XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }ifelse
    ELdic dup /CS known  %% pot no haver-hi CS (sobretot amb plomes inLine)
    {
     /CS get dup
    }
    {  %% si desconeixem l'espai de color l'interroguem x la fondaria
     %% sense resoldre encara el problema, de moment, desviem el problema
     /BPC get 1 eq {/PLoMa dup}{/DeSCoNeGuT dup}ifelse
    }ifelse
    <<
      %% /G [/NoName10 ( DeviceGray Color Space Not Supported)]
      /PLoMa [/NoName13 ( Unknown Color Space)]
      /DeSCoNeGuT [/NoName13 ( Unknown Color Space)]
      
      /RGB [/NoName11 ( DeviceRGB Color Space Not Supported)]
      /I [/NoName12 ( Indexed Color Space Not Supported)]
    >> dup 3 -1 roll known
    {  %% afegim l'error a Errades amb un nom anonim de color
     %% sobreixidor x saber on es crida l'espai de color q encara no tractem
     %%(-- AQUI es crida:Inline: DeviceRGB, Indexed, PLoMa o DeSCoNeGuT) ==
     exch get XRay /EspaisDeColor get /Errades get exch aload pop put
     %% /ARAcs null def  % aquesta variable ens ha de dir: si null es que l'espai de color es erroni i llavors scn/SCN o sc/SC no escriuran res, si es un nom hi desaran el valor dins una array
    }
    {
     pop
     dup <</CMYK null>> exch known
     {  %% si un CS crida l'espai CMYK de forma directe ...
      pop XRay /EspaisDeColor get /Utilitzats get dup
      /NoName9 known
      {
       pop
      }
      {
       /NoName9
       <<
         /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
         /Paleta <<ARAxo null >>
         /TanX100 []  %% hi desarem en strings la gamma de valors scn/SCN usats
       >> put
      } ifelse
      %%       /ARAcs /NoName9 def  % desem el nom de l'espai de color actual
      %%       CSARA 0 /NoName9 put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
     }
     {
      XRay /EspaisDeColor get /Desconeguts get dup 3 -1 roll dup 3 -2 roll
      known
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              /ARAcs exch def
       pop pop
      }  %% si ja l'hem definit desem el nom de l'espai de color actual a la variable que utilitzara sc/SC o scn/SCN
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              dup /ARAcs exch def  % desem el nom de l'espai de color actual
       []  %% ara li posem de valor l'array on desarem la gamma de percentatges
       put  %% desem a XRay els espais de color utilitzats
      } ifelse
     } ifelse
    } ifelse    
%%    counttomark
%%    dup /RoLL exch def
%%    {  % repeat
%%     RoLL -1 roll
%%     dup type /nametype eq
%%     {
%%      sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%     }
%%     {
%%      dup type /arraytype eq
%%      {
%%       sEdAs ([ ) writestring
%%       {  % forall
%%        dup type /nametype eq
%%        {
%%         sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%        }
%%        {
%%         64 string cvs sEdAs exch writestring sEdAs 32 write
%%        } ifelse
%%       } forall
%%       sEdAs (] ) writestring
%%      }
%%      {
%%       64 string cvs sEdAs exch writestring sEdAs 32 write
%%      } ifelse
%%     } ifelse
%%     RoLL 1 sub /RoLL exch def
%%    } repeat

    ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!

%% Aqui caldria comprovar q si podem deduir el nombre de bytes de forma planera fins a EI doncs ho fem i passem del
%% sistema de les 3veritats ... si no hi ha Filter ... WxHxCS/BPC
dup /F known
{  %% si duu filtres llavors cal anar pel metode de les 3veritats
 /llegimOctets false def
}
{
 dup /W get 1 index /H get mul
 1 index /CS get
 <<  %% canals
   /RGB 3
   /G 1
   /CMYK 4
   /I 1
 >>
 dup 2 index known
 {
  exch get mul 1 index /BPC get 8 exch div mul cvi /maxB exch def
  %% aquest es el nombre d'octets a llegir fins a EI !!!
  /llegimOctets true def
 }
 {  %% si no es cap d'aquests espais de color, llavors cal anar pel metode de les 3veritats
  pop pop pop /llegimOctets false def
 }ifelse
}ifelse

    sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
    /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

    %% hem tret l'identificador d'inlines per l'opcio del repicat
    %%% posem davant ID el nom de la inLine (ARAxo) x poder-la identificar a l'hora d'escriure la separacio de colors
    %%sEdAs (\015) writestring
    %%sEdAs (/) writestring
    %%sEdAs ARAxo 128 string cvs writestring
    sEdAs (\012ID\012) writestring
    %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
    %% una altra solucio seria utilitzar, si s'escau, els mateixos filtres per desenflatar la imatge per calcular-ne
    %% la seva llargada en funcio de l'ample+alt+bitsxpixelxcanal
    %%currentfile << /EODCount 0 /EODString (EI) >> /SubFileDecode filter
    %%dup
    %%{
    %%65535 string readstring
    %% {sEdAs exch writestring}{
    %%pop

llegimOctets
{
 /maxIL maxB string def
 %% /iBuffer maxIL /NullEncode filter def  % buffer del repicat total de la inLine
 currentfile
 dup maxIL readstring pop
 
 exch dup 0 (EI) /SubFileDecode filter
 pop closefile
 %%iBuffer exch writestring iBuffer closefile
 %%maxIL
 %%(!!!!!!!)pstack quit
}
{

    %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
    %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
    %%% llegimOctetAoctetXquadrar1patro.ps
    /Toctets 0 def  %% total d'octets llegits
    /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
    /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
    /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
    /3veritats
    [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
     [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
      10  %% Line Feed
      12  %% Form Feed
      13  %% Carriage Return
%%      32  % Space
     ]
     [
      69  %% caracter E
     ]
     [
      73  %% caracter I
     ]
    ] def
    %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
    %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
    /maxB 4 1024 mul def
    /maxIL maxB string def
    /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
    currentfile
    3
    {  %% posara els 3 primer bytes a l'array
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
      i3o 1 add /i3o exch def       
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    } repeat
    /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
    {  %% loop
     0 1 2
     {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
     }for
     3Boctets
     aload pop  %% desmuntem l'array
     and and  %% els 3 estan a true ?
     {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
      pop exit  %% ... sortim
     }
     {  %% com q encara no l'hem trobat ...
      %% enretirem 1 posicio cap a l'esquerra el paquet ...
      3Bytes 1 2 getinterval
      %% ... i escrivim el caracter sortint al buffer del repicat
      3Bytes 0 get iBuffer exch write
      %% recol·loquem l'enretirat
      /3Bytes 3 array def
      3Bytes exch 0 exch putinterval
     }ifelse
     3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
     Toctets 1 add /Toctets exch def  %% total d'octets llegits
     Toctets maxB gt {pop BaBeL 41 get print flush stop}if
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    }loop
    iBuffer closefile
    %%3Bytes 3Boctets
    maxIL 0 Toctets getinterval
    %%% fi de llegimOctetAoctetXquadrar1patro.ps

}ifelse
    
    dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
    sEdAs exch writestring sEdAs
%%(EI\012\012\012\012)
    (\015\012EI\015\012EMC\012) writestring
%%    (\012EI\012EMC\012) writestring
%% prevenim un aqui possible trepitjat de la Q de tancament en una segona interpretacio del codi (#6 i altres)
%%    sEdAs dup 1B write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador
    %%}loop
    %%closefile  % tanquem el fitxer
    
    %%% ARA ELIMINEM L'ESCRIPTURA A SAC
    %%ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
    %%dup dup length 4 sub (.obj) putinterval  % creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
    %%dup length faPathA add string dup
    %% /pAthA exch def 0 tEmp putinterval
    %%pAthA exch faPathA exch putinterval
    %%pAthA
    %%(w) file dup SiLi writestring closefile  % utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
    %%%
    
    pop  %% ens carreguem la mark
    %% desem sempre el path del raw de la inLine al dic ELdic
    ELdic /XIU pAthA put
    iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    %%test
    %%}stopped{( ... peta ID) == quit}if
   }  %% index 3
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
     cleartomark
     %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
     %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
     %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
     %%% llegimOctetAoctetXquadrar1patro.ps
     /Toctets 0 def  %% total d'octets llegits
     /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
     /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
     /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
     /3veritats
     [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
      [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
 %%      0  % Null
 %%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
       10  %% Line Feed
       12  %% Form Feed
       13  %% Carriage Return
 %%      32  % Space
      ]
      [
       69  %% caracter E
      ]
      [
       73  %% caracter I
      ]
     ] def
     %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
     %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
     /maxB 4 1024 mul def
     /maxIL maxB string def
     /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
     currentfile
     3
     {  %% posara els 3 primer bytes a l'array
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
       i3o 1 add /i3o exch def
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     } repeat
     /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
     {  %% loop
      0 1 2
      {  %% for on muntem l'array d'avaluacio 3Boctets
       dup /ara1B exch def
       3veritats exch get  %% treiem de l'array el comparatiu correlativament
       {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
       3Boctets ara1B hoES put
      }for
      3Boctets
      aload pop  %% desmuntem l'array
      and and  %% els 3 estan a true ?
      {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
       pop exit  %% ... sortim
      }
      {  %% com q encara no l'hem trobat ...
       %% enretirem 1 posicio cap a l'esquerra el paquet ...
       3Bytes 1 2 getinterval
       %% ... i escrivim el caracter sortint al buffer del repicat
       3Bytes 0 get iBuffer exch write
       %% recol·loquem l'enretirat
       /3Bytes 3 array def
       3Bytes exch 0 exch putinterval
      }ifelse
      3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
      Toctets 1 add /Toctets exch def  %% total d'octets llegits
      Toctets maxB gt {pop BaBeL 41 get print flush stop}if
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     }loop
     iBuffer closefile
    }
    {
     {  %% stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    counttomark
    iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
    /ELdic << >> def
%% dup
    /alDIC exch def
%% copy
    alDIC 2 idiv {ELdic 3 1 roll put}repeat
    XRay /ObjectesX get
    dup araPlana known  %% ja hem definit aquest plana?
    {
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }
    {
     dup araPlana  %% primer incrustem el nou diccionari d'XObjects lligat a la plana actual ...
     <<
       %%17bis% si analitzem el trencaclosques d'imatge afegim el diccionari trEncAclOsqUEs a ObjectesX d'XRay
       %%QueLiFemFer 6 eq
       %%{
       %% (%17bis%)==
       %% i quin problema hi ha si el deixem de forma fixa?
       /trEncAclOsqUEs <<>>
       %%}if
       /Desconeguts
       <<  %% diccionari on primer desarem el nom dels Objectes X utilitzats a l'stream dels Contents i despres a partir del XObject dic de Resources anirem donant de baixa els que hi coincideixin ...
       >>  %% ... de forma que si el dic no queda buit voldra dir que hi ha Objectes X desconeguts no definits a Resources
       /Utilitzats << >>
       /NoUtilitzats << >>
       /Errades
       <<  %% si el diccionari es buit voldra dir que no hi hauran hagut errors referents als Objectes X
       >>  %% diccionari on descriurem els errors amb el nom dels Objectes X que els produeixen ... /NomInternXObject (text de l'error)
     >> put
     %% ... i despres ...
     araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get dup  %% les inLine imatges les desem directament al dic d'utilizades
     ARAxo known
     {
      pop
     }
     {
      ARAxo ELdic put   %% desem sencer el dic de la imatge inLine x gestionar-ho mes endavant (ho detectarem xq les imatges normals duran un null com a valor)
     } ifelse
    }ifelse
    ELdic dup /CS known  %% pot no haver-hi CS (sobretot amb plomes inLine)
    {
     /CS get dup
    }
    {  %% si desconeixem l'espai de color l'interroguem x la fondaria
     %% sense resoldre encara el problema, de moment, desviem el problema
     /BPC get 1 eq {/PLoMa dup}{/DeSCoNeGuT dup}ifelse
    }ifelse
    <<
      %% /G [/NoName10 ( DeviceGray Color Space Not Supported)]
      /PLoMa [/NoName13 ( Unknown Color Space)]
      /DeSCoNeGuT [/NoName13 ( Unknown Color Space)]
      
      /RGB [/NoName11 ( DeviceRGB Color Space Not Supported)]
      /I [/NoName12 ( Indexed Color Space Not Supported)]
    >> dup 3 -1 roll known
    {  %% afegim l'error a Errades amb un nom anonim de color
     %% sobreixidor x saber on es crida l'espai de color q encara no tractem
     %%(-- AQUI es crida:Inline: DeviceRGB, Indexed, PLoMa o DeSCoNeGuT) ==
     exch get XRay /EspaisDeColor get /Errades get exch aload pop put
     %% /ARAcs null def  % aquesta variable ens ha de dir: si null es que l'espai de color es erroni i llavors scn/SCN o sc/SC no escriuran res, si es un nom hi desaran el valor dins una array
    }
    {
     pop
     dup <</CMYK null>> exch known
     {  %% si un CS crida l'espai CMYK de forma directe ...
      pop XRay /EspaisDeColor get /Utilitzats get dup
      /NoName9 known
      {
       pop
      }
      {
       /NoName9
       <<
         /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
         /Paleta <<ARAxo null >>
         /TanX100 []  %% hi desarem en strings la gamma de valors scn/SCN usats
       >> put
      } ifelse
      %%       /ARAcs /NoName9 def  % desem el nom de l'espai de color actual
      %%       CSARA 0 /NoName9 put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
     }
     {
      XRay /EspaisDeColor get
      /Desconeguts get
      dup 3 -1 roll dup 3 -2 roll
      known
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              /ARAcs exch def
       pop pop
      }  %% si ja l'hem definit desem el nom de l'espai de color actual a la variable que utilitzara sc/SC o scn/SCN
      {
       %%	      dup CSARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
       %%              dup /ARAcs exch def  % desem el nom de l'espai de color actual
       []  %% ara li posem de valor l'array on desarem la gamma de percentatges
       put  %% desem a XRay els espais de color utilitzats
      } ifelse
     } ifelse
    } ifelse    
    ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
    sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
    /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

    %% hem tret l'identificador d'inlines per l'opcio del repicat
    %%% posem davant ID el nom de la inLine (ARAxo) x poder-la identificar a l'hora d'escriure la separacio de colors
    %%sEdAs (\015) writestring
    %%sEdAs (/) writestring
    %%sEdAs ARAxo 128 string cvs writestring
    sEdAs (\012ID\012) writestring
    %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 

%%% al projecte de JBC hem trobat unes inLine molt poc normatives (26450.PDF 26281.PDF 26090.PDF)
%%% que fan +d8Mb! fetes amb el CAD de SolidWorks 2007 SP4.0 PDF Publisher
%% no tenim en compte que hi pot haver inLine que no facin servir noms abreujats (cap cas real?)
%% comprovem previament que el raw de la imatge NO excedeix els 4Kb normatius per les inLine
ELdic
dup dup /W get exch /H get mul exch  %% analitzem el nombre total de pixels
/BPC get mul 8 idiv  %% bytes totals de la imatge x a 1 component de color
ELdic /CS known  %% si no hi ha CS segur q es una imatge a 1 bit
{  %% si hi ha CS multipliquem pel nombre de components de color
<</RGB 3 /CMYK 4 /I 1 /G 1>> ELdic /CS get
dup 2 index exch known  %% podria ser un espai de color indirecte
{get mul}
{  %% si ho es falsifiquem la multiplicacio dels bytes totals per el valor maxim
%% doncs aqui desconeixem quina mena d'espai de color es
pop pop 4 mul
}ifelse
}if
dup 1024 4 mul gt
{  %% NO es una inLine normativa
%% les inLines que no són normatives, de moment mentre no les corregim nosaltres, es poden
%% reescriure com a XObject normal per mitjà d'un repicat a Ghostscript ...
%% gs -q -dNOSAFER -o surt.pdf -dCompatibilityLevel=1.5 -sDEVICE=pdfwrite -c .setpdfwrite -f entra.pdf
dup /raWbytes exch def  %% total de bytes de la imatge
(\n\n ... ATENCIO! imatge inLine de +d4Kb ... ) print flush
32 string cvs print flush ( Kb ... pot ser problematica\ni NO s'adiu a l'especificacio de PDF\n\n)print flush
save  %% imprescindible per la higiene dels fitxers?
currentfile dup << /EODCount raWbytes /EODString () >> /SubFileDecode filter
{  %% loop x repicar el raw passat de voltes en base als octets calculats
dup
65535 string readstring
{sEdAs exch writestring}
{sEdAs exch writestring pop exit}ifelse
}loop
{  %% loop x menjar-nos EI
dup read pop 73 eq {pop exit}if
}loop
%%(:-n)pstack quit
restore  %% impresindible per la higiene dels fitxers?
}
{  %% es una inLine normativa

    %% una altra solucio seria utilitzar, si s'escau, els mateixos filtres per desenflatar la imatge per calcular-ne
    %% la seva llargada en funcio de l'ample+alt+bitsxpixelxcanal

    %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
    %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
    %%% llegimOctetAoctetXquadrar1patro.ps
    /Toctets 0 def  %% total d'octets llegits
    /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
    /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
    /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
    /3veritats
    [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
     [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
      10  %% Line Feed
      12  %% Form Feed
      13  %% Carriage Return
%%      32  % Space
     ]
     [
      69  %% caracter E
     ]
     [
      73  %% caracter I
     ]
    ] def
    %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
    %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
    /maxB 4 1024 mul def
    /maxIL maxB string def
    /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
    currentfile
    3
    {  %% posara els 3 primer bytes a l'array
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
      i3o 1 add /i3o exch def       
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    } repeat
    /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
    {  %% loop
     0 1 2
     {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
     }for
     3Boctets
     aload pop  %% desmuntem l'array
     and and  %% els 3 estan a true ?
     {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
      pop exit  %% ... sortim
     }
     {  %% com q encara no l'hem trobat ...
      %% enretirem 1 posicio cap a l'esquerra el paquet ...
      3Bytes 1 2 getinterval
      %% ... i escrivim el caracter sortint al buffer del repicat
      3Bytes 0 get iBuffer exch write
      %% recol·loquem l'enretirat
      /3Bytes 3 array def
      3Bytes exch 0 exch putinterval
     }ifelse
     3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
     Toctets 1 add /Toctets exch def  %% total d'octets llegits
     Toctets maxB gt {pop BaBeL 41 get print flush stop}if
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    }loop
    iBuffer closefile
    %%3Bytes 3Boctets
    maxIL 0 Toctets getinterval
    %%% fi de llegimOctetAoctetXquadrar1patro.ps
    dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
    sEdAs exch writestring

}ifelse  %% es o NO una inLine normativa?

    sEdAs (\015\012EI\015\012) writestring
%%    sEdAs (\012EI\012) writestring
 
    clear  %% ens carreguem la mark i altra brossa que hi pugui haver
    %% desem sempre el path del raw de la inLine al dic ELdic
    ELdic /XIU pAthA put
    iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    %%test
    }stopped{( ... peta ID) == quit}if

    }ifelse
   }
  ] i_ID get /ID exch bind def

  %% /EI {} bind def  % no cal definir-lo doncs ens el mengem amb la lectura anterior

%% (PDF Ref 1.7) 5.2 Text State Parameters and Operators
%% (PDF Ref ?) 8.7.1.1 Character spacing
  [  %% Tc
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tc\012) writestring
    %%}stopped{( ... peta Tc) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual) | gatells: 16
    {  %% stopped
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tc\012) writestring

    %%% KTCS
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /ecTc exch put
    /ecTc exch def  %% desem el valor afegit d'espaiat entre caracters (es suma a cada caracter)
    }stopped{( ... peta Tc 2) pstack quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tc\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tc) == quit}if
   }
  ] i_Tc get /Tc exch bind def

  %% (PDF Ref ?) 8.7.1.2 Word spacing
  [  %% Tw
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tw\012) writestring
    %%}stopped{( ... peta Tw) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual)
    {  %% stopped
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tw\012) writestring
    
    %%% KTCS
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /epTw exch put
    /epTw exch def  %% desem el valor afegit d'espaiat entre paraules (nomes suma si hi ha /space)
    }stopped{( ... peta Tw 2) pstack quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tw\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tw) == quit}if
   }
  ] i_Tw get /Tw exch bind def

  %% (PDF Ref ?) 8.7.1.3 Horizontal scaling
  [  %% Tz
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tz\012) writestring
    %%}stopped{( ... peta Tz) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual) | gatells: 16
    {  %% stopped
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tz\012) writestring
    
    %%% KTCS
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /acTz exch put
    /acTz exch def  %% desem el valor del tant per cent d'ample del caracter
    %%CxTm mul 100 div  % apliquem l'escala horitzontal a tots els espaiats
    %% /CxTm exch def  % l'apliquem directament sobre l'X del caracter
    }stopped{( ... peta Tz 2) pstack stop}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tz\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tz) == quit}if
   }
  ] i_Tz get /Tz exch bind def

  %% (PDF Ref ?) 8.7.1.4 Leading
  [  %% TL
   {  %% 0 (arbre jeràrquic) | gatells: 16
    {  %% stopped
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (TL\012) writestring

%% desem el valor pur (sense multiplicar per SyTm i cmSy) de l'interliniat Y a l'estat grafic actiu
dup EstatGrafic iEG get exch /TLoTD exch put

    cmSy mul  %% multipliquem el valor provinent de cm
SyTm mul  %% multipliquem el valor provinent de Tm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /INTERli exch put
    /INTERli exch def  %% valor actual de l'interliniat (s'aplica amb T* " i ')
    }stopped{( ... peta TL 0) pstack stop}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (TL\012) writestring
    %%}stopped{( ... peta TL) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual)
    {  %% stopped
%%    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
%%    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (TL\012) writestring

%% desem el valor pur (sense multiplicar per SyTm i cmSy) de l'interliniat Y a l'estat grafic actiu
dup EstatGrafic iEG get exch /TLoTD exch put

    cmSy mul  %% multipliquem el valor provinent de cm
SyTm mul  %% multipliquem el valor provinent de Tm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /INTERli exch put
    /INTERli exch def  %% valor actual de l'interliniat (s'aplica amb T* " i ')
    }stopped{( ... peta TL) == stop}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
      %%TiNTeM {  % es la tinta que toca ara ?
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (TL\012) writestring
      %%}{pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta TL) == quit}if
   }
  ] i_TL get /TL exch bind def

  %% (PDF Ref ?) 8.7.1.5 Text font and size
  [  %% Tf
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
    128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tf\012) writestring
    %%}stopped{( ... peta Tf) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual) | gatells: 16
%%faDADAv {tipusDADAv {== ==}forall (xavierDsarrio)pstack quit}if
    {  %% stopped
    2 copy
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
    128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tf\012) writestring
    
    %%% KTCS
    dup /cos_ exch def  %% capturem el cos que multiplicara amb la matriu Tm (el desem en una altre variable per poder treballar quan a Tm hi han alteracions de l'eix de coordenades i llavors no actuen CxTm i CyTm
    dup
%% cal tenir en compte abans l'escala x!
EstatGrafic iEG get /SxTm get mul
    /CxTm exch def  %%% KTCS valor inicial del cos horitzontal de la lletra
%% cal tenir en compte abans l'escala y!
EstatGrafic iEG get /SyTm get mul
    /CyTm exch def  %%% KTCS valor inicial del cos vertical de la lletra
    Champollion
    exch dup /QuinaFONT exch def  %% nom PDF de la font actual
%% UiX
exch araPlana get exch  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
    get dup type /nametype eq  %% capturem l'encoding per la decodificacio de l'string o executem aSia
    {
     cvx exec
    }
    {
     %% test per l'encoding GID
     %%pop COMdimoni /GIDEncoding get 391 array copy
     400 array copy
     /EncNETiPLANXAT exch def
    }ifelse
    }stopped{( ... peta Tf 2) pstack stop}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     exch sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     128 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tf\012) writestring
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tf) == quit}if
   }
  ] i_Tf get /Tf exch bind def

  %% (PDF Ref ?) 8.7.1.7 Text rendering mode
  [  %% Tr
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    1 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tr\012) writestring
    }stopped{( ... peta Tr 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     1 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Tr\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tr) == quit}if
   }
  ] i_Tr get /Tr exch bind def

  %% (PDF Ref ?) 8.7.1.8 Text rise
  [  %% Ts
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Ts\012) writestring
    %%}stopped{( ... peta Ts) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual) | gatells: 16
    {  %% stopped
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Ts\012) writestring
    
    %%% KTCS
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTs exch put
    /TyTs exch def  %% desplacament vertical del text
    }stopped{( ... peta Ts 2) pstack stop}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Ts\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Ts) == quit}if
   }
  ] i_Ts get /Ts exch bind def

%% (PDF Ref 1.7) 5.3.1 Text-Positioning Operators
%% (PDF Ref ?) 8.7.3 Text positioning operators
  [  %% Td
   {  %% 0 (arbre jeràrquic)  | gatells: 16
    {  % stopped
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    2 copy
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Td\012) writestring

%% capturem les dades Td en estat pur
2 copy /YpurTd exch def /XpurTd exch def

    SyTm mul  %% multipliquem el valor Y x l'escala actual de Tm
    /ilyTd exch def  %% inici Y de la propera linia des de l'inici Y de l'anterior
    SxTm mul /ilxTd exch def  %% idem per les X
    %% posem a la pila el valor de desplaçament x,y de Td x avaluar
    ilxTd ilyTd


EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem


iTyTm add dup /iTyTm exch def  %% nou inici absolut de linia Y
/TyTm exch def  %% posicio actual d'Y
iTxTm add 

CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTd no sigui zero ...
ilyTd 0 ne and
{  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
0 ilyTd
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
pop add   %% valor X a corregir
}if
dup /iTxTm exch def  %% nou inici absolut de la linia X
/TxTm exch def  %% posicio actual d'X
}
{  %% normalitzem
    %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm

%%% hi manca?
%%iTyTm add dup /iTyTm exch def  % nou inici absolut de linia Y
%%dup /TyTm exch def  % posicio actual d'Y
%%exch iTxTm add exch


    gsave
    aTm

%%    dup dup 2 get SyTm mul 2 exch put
%%    dup dup 1 get SxTm mul 1 exch put

90NET
{
dup 1 get 0 lt
{  %% rotacio negativa
dup dup 1 -1 put 2 1 put
}
{  %% rotacio positiva
dup dup 1 1 put 2 -1 put
CursivaMentidera
{
%% eliminem els valors de generen la cursiva
dup 3 0 put
dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
dup dup 5 get YpurTd add 5 exch put
dup dup 4 get XpurTd add 4 exch put
}
{
    dup dup 5 iTyTm put 4 iTxTm put
}ifelse

}ifelse  %% sentit de la rotacio

}
{
    dup dup 5 iTyTm put 4 iTxTm put
}ifelse
    concat
    matrix currentmatrix  %% valor de la matriu rotada
    grestore
    transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
    itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

    dup /iTyTm exch def  %% nou inici absolut de linia Y
    /TyTm exch def  %% posicio actual d'Y

    dup /iTxTm exch def  %% nou inici absolut de la linia X
    /TxTm exch def  %% posicio actual d'X
}ifelse
    EstatGrafic iEG get dup dup dup
    /iTyTm iTyTm put
    /iTxTm iTxTm put
    /TyTm TyTm put
    /TxTm TxTm put

%% estratègia a TD i Td per tal d'afegir un separador null
%% entre paraules en cas que la Y de la línia que estem tractant ja existeixi, per tal d'afegir
%% l'espai separador, amb un null, i evitar s'enganxin paraules diferents. Si ja existeix, o sigui
%% que hi havia text abans, pot ser per dos motius: o som a final de línia (és el darrer mot) o som
%% davant d'un cas on s'enganxarien dues paraules per manca d'aquest control a TD i Td
yRENGS araPlana get dup dup
%% aquí és on comprovem si existeix la Y del reng en aquesta pàgina
TyTm
cvi %% EP!MASATS treballarem només amb l'enter
128 string cvs dup dup 3 index exch known
{
 3 -1 roll exch get  %% posem a l'stack
 /araRENG exch def
 %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
 null
 araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
 %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
 null
 araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
 %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
 null
 araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
 %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
 null
 araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
 araRENG put  %% desem al diccionari de la plana
 yRENGS exch araPlana exch put  %% desem al diccionari dels rengs
}
{
 %% (NOHIES!)==
 %% araRENG ==
 pop pop pop pop pop
}ifelse

    }stopped{( ... peta Td 0) pstack stop}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Td\012) writestring
    %%}stopped{( ... peta Td) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual) projecte JBC
%%    {  % stopped
    %% hem eliminat el repicat de dades al fitxer
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def

    %% capturem les dades Td en estat pur
    2 copy /YpurTd exch def /XpurTd exch def

    SyTm mul  %% multipliquem el valor Y x l'escala actual de Tm
    /ilyTd exch def  %% inici Y de la propera linia des de l'inici Y de l'anterior
    SxTm mul /ilxTd exch def  %% idem per les X
    %% posem a la pila el valor de desplaçament x,y de Td x avaluar
    ilxTd ilyTd

    EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
    Aeix 0 eq  %% si l'eix no es rotat ...
    {  %% no cal q la normalitzem
     iTyTm add dup /iTyTm exch def  %% nou inici absolut de linia Y
     /TyTm exch def  %% posicio actual d'Y
     iTxTm add 
     CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTd no sigui zero ...
     ilyTd 0 ne and
     {  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
      0 ilyTd
      gsave
      [1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
      dup dup 1 Amentidera sin neg put 2 Amentidera sin put
      dup dup 0 Amentidera cos put 3 Amentidera cos put
      concat
      matrix currentmatrix  %% valor de la matriu rotada
      grestore
      transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
      itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
      pop add   %% valor X a corregir
     }if
     dup /iTxTm exch def  %% nou inici absolut de la linia X
     /TxTm exch def  %% posicio actual d'X
    }
    {  %% normalitzem
     %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm

     %%% hi manca?
     %%iTyTm add dup /iTyTm exch def  % nou inici absolut de linia Y
     %%dup /TyTm exch def  % posicio actual d'Y
     %%exch iTxTm add exch

     gsave
     aTm

     %%    dup dup 2 get SyTm mul 2 exch put
     %%    dup dup 1 get SxTm mul 1 exch put

     90NET
     {
      dup 1 get 0 lt
      {  %% rotacio negativa
       dup dup 1 -1 put 2 1 put
      }
      {  %% rotacio positiva
       dup dup 1 1 put 2 -1 put
       CursivaMentidera
       {
        %% eliminem els valors de generen la cursiva
        dup 3 0 put
        dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
        dup dup 5 get YpurTd add 5 exch put
        dup dup 4 get XpurTd add 4 exch put
       }
       {
        dup dup 5 iTyTm put 4 iTxTm put
       }ifelse
      }ifelse  %% sentit de la rotacio
     }
     {
      dup dup 5 iTyTm put 4 iTxTm put
     }ifelse
     concat
     matrix currentmatrix  %% valor de la matriu rotada
     grestore
     transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
     itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

     dup /iTyTm exch def  %% nou inici absolut de linia Y
     /TyTm exch def  %% posicio actual d'Y

     dup /iTxTm exch def  %% nou inici absolut de la linia X
     /TxTm exch def  %% posicio actual d'X
    }ifelse
    EstatGrafic iEG get dup dup dup
    /iTyTm iTyTm put
    /iTxTm iTxTm put
    /TyTm TyTm put
    /TxTm TxTm put

%% estratègia a TD i Td per tal d'afegir un separador null
%% entre paraules en cas que la Y de la línia que estem tractant ja existeixi, per tal d'afegir
%% l'espai separador, amb un null, i evitar s'enganxin paraules diferents. Si ja existeix, o sigui
%% que hi havia text abans, pot ser per dos motius: o som a final de línia (és el darrer mot) o som
%% davant d'un cas on s'enganxarien dues paraules per manca d'aquest control a TD i Td
yRENGS araPlana get dup dup
%% aquí és on comprovem si existeix la Y del reng en aquesta pàgina
TyTm
cvi  %% EP!MASATS treballarem només amb l'enter
128 string cvs dup dup 3 index exch known
{
 3 -1 roll exch get  %% posem a l'stack
 /araRENG exch def
 %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
 null
 araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
 %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
 null
 araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
 %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
 null
 araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
 %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
 null
 araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
 araRENG put  %% desem al diccionari de la plana
 yRENGS exch araPlana exch put  %% desem al diccionari dels rengs
}
{
 %% (NOHIES!)==
 %% araRENG ==
 pop pop pop pop pop
}ifelse

%%    }stopped{( ... peta Td) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
      %%TiNTeM {  % es la tinta que toca ara ?
      exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (Td\012) writestring
      %%}{pop pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta Td) == quit}if
   }
  ] i_Td get /Td exch bind def

  [  %% TD
   {  %% 0 (arbre jeràrquic) | gatells: 16
    {  % stopped
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    2 copy
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (TD\012) writestring

%% desem el valor pur (sense multiplicar per SyTm i cmSy) de l'interliniat Y a l'estat grafic actiu
dup EstatGrafic iEG get exch neg  %% cal negativar-lo xq treballi correctament
/TLoTD exch put

%% capturem les dades TD en estat pur
2 copy /YpurTD exch def /XpurTD exch def

    SyTm mul  %% multipliquem el valor provinent de Tm
    dup neg
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /INTERli exch put
    /INTERli exch def  %% valor actual de l'interliniat (aqui es comporta negativat!)
    /ilyTD exch def  %% inici Y de la propera linia des de l'inici Y de l'anterior
    SxTm mul  %% multipliquem el valor provinent de Tm
    /ilxTD exch def  %% inici X de la propera linia des de l'inici X de l'anterior

ilxTD ilyTD 

EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q normalitzem
    iTyTm add 
    /TyTm exch def  %% rectifiquem la posicio absoluta de les Y
    %% cal que desem el valor de la coordenada d'inici de cadena, nomes utilitzada pels operadors ' i "
    TyTm /iTyTm exch def
    iTxTm add

CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTD no sigui zero ...
ilyTD 0 ne and
{  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
0 ilyTD
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
pop add   %% valor X a corregir
}if

dup
    /iTxTm exch def  %% rectifiquem la posicio absoluta de les X
    %% cal que desem el valor de la coordenada d'inici de cadena, nomes utilitzada pels operadors ' i "
%%    TxTm
     /TxTm exch def
}
{  %% normalitzem
    %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm
    gsave
    aTm
%%    dup dup 2 get SyTm mul 2 exch put
%%    dup dup 1 get SxTm mul 1 exch put

90NET
{
dup 1 get 0 lt
{  %% rotacio negativa
dup dup 1 -1 put 2 1 put
}
{  %% rotacio positiva
dup dup 1 1 put 2 -1 put
CursivaMentidera
{
%% eliminem els valors de generen la cursiva
dup 3 0 put
dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
dup dup 5 get YpurTD add 5 exch put
dup dup 4 get XpurTD add 4 exch put
}
{
    dup dup 5 iTyTm put 4 iTxTm put
}ifelse

}ifelse

}
{

    dup dup 5 iTyTm put 4 iTxTm put

}ifelse

    concat
    matrix currentmatrix  %% valor de la matriu rotada
    grestore
    transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
    itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
    dup /iTyTm exch def  %% nou inici absolut de linia Y
    /TyTm exch def  %% posicio actual d'Y
    dup /iTxTm exch def  %% nou inici absolut de la linia X
    /TxTm exch def  %% posicio actual d'X
}ifelse
    %% copiem aquest valor al dic de l'estat grafic actiu
    EstatGrafic iEG get /TyTm TyTm put
    %% copiem aquest valor al dic de l'estat grafic actiu
    EstatGrafic iEG get /iTyTm TyTm put
    %% copiem aquest valor al dic de l'estat grafic actiu
    EstatGrafic iEG get /TxTm TxTm put
    %% copiem aquest valor al dic de l'estat grafic actiu
    EstatGrafic iEG get /iTxTm TxTm put

%% estratègia a TD i Td per tal d'afegir un separador null
%% entre paraules en cas que la Y de la línia que estem tractant ja existeixi, per tal d'afegir
%% l'espai separador, amb un null, i evitar s'enganxin paraules diferents. Si ja existeix, o sigui
%% que hi havia text abans, pot ser per dos motius: o som a final de línia (és el darrer mot) o som
%% davant d'un cas on s'enganxarien dues paraules per manca d'aquest control a TD i Td
yRENGS araPlana get dup dup
%% aquí és on comprovem si existeix la Y del reng en aquesta pàgina
TyTm
cvi  %% EP!MASATS treballarem només amb l'enter
128 string cvs dup dup 3 index exch known
{
 3 -1 roll exch get  %% posem a l'stack
 /araRENG exch def
 %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
 null
 araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
 %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
 null
 araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
 %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
 null
 araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
 %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
 null
 araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
 araRENG put  %% desem al diccionari de la plana
 yRENGS exch araPlana exch put  %% desem al diccionari dels rengs
}
{
 %% (NOHIES!)==
 %% araRENG ==
 pop pop pop pop pop
}ifelse

    }stopped{( ... peta TD 0) pstack stop}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (TD\012) writestring
    %%}stopped{( ... peta TD) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual)
%%    {  % stopped
    %% desactivem l'escriptura a disc de les dades
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def

%% desem el valor pur (sense multiplicar per SyTm i cmSy) de l'interliniat Y a l'estat grafic actiu
dup EstatGrafic iEG get exch neg  %% cal negativar-lo xq treballi correctament
/TLoTD exch put

%% capturem les dades TD en estat pur
2 copy /YpurTD exch def /XpurTD exch def

    SyTm mul  %% multipliquem el valor provinent de Tm
    dup neg
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /INTERli exch put
    /INTERli exch def  %% valor actual de l'interliniat (aqui es comporta negativat!)
    /ilyTD exch def  %% inici Y de la propera linia des de l'inici Y de l'anterior
    SxTm mul  %% multipliquem el valor provinent de Tm
    /ilxTD exch def  %% inici X de la propera linia des de l'inici X de l'anterior

ilxTD ilyTD 

EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q normalitzem
    iTyTm add 
    /TyTm exch def  %% rectifiquem la posicio absoluta de les Y
    %% cal que desem el valor de la coordenada d'inici de cadena, nomes utilitzada pels operadors ' i "
    TyTm /iTyTm exch def
    iTxTm add

CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTD no sigui zero ...
ilyTD 0 ne and
{  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
0 ilyTD
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
pop add   %% valor X a corregir
}if

dup
    /iTxTm exch def  %% rectifiquem la posicio absoluta de les X
    %% cal que desem el valor de la coordenada d'inici de cadena, nomes utilitzada pels operadors ' i "
%%    TxTm
     /TxTm exch def
}
{  %% normalitzem
    %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm
    gsave
    aTm
%%    dup dup 2 get SyTm mul 2 exch put
%%    dup dup 1 get SxTm mul 1 exch put

90NET
{
dup 1 get 0 lt
{  %% rotacio negativa
dup dup 1 -1 put 2 1 put
}
{  %% rotacio positiva
dup dup 1 1 put 2 -1 put
CursivaMentidera
{
%% eliminem els valors de generen la cursiva
dup 3 0 put
dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
dup dup 5 get YpurTD add 5 exch put
dup dup 4 get XpurTD add 4 exch put
}
{
    dup dup 5 iTyTm put 4 iTxTm put
}ifelse

}ifelse

}
{

    dup dup 5 iTyTm put 4 iTxTm put

}ifelse

    concat
    matrix currentmatrix  %% valor de la matriu rotada
    grestore
    transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
    itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
    dup /iTyTm exch def  %% nou inici absolut de linia Y
    /TyTm exch def  %% posicio actual d'Y
    dup /iTxTm exch def  %% nou inici absolut de la linia X
    /TxTm exch def  %% posicio actual d'X
}ifelse
    %% copiem aquest valor al dic de l'estat grafic actiu
    EstatGrafic iEG get /TyTm TyTm put
    %% copiem aquest valor al dic de l'estat grafic actiu
    EstatGrafic iEG get /iTyTm TyTm put
    %% copiem aquest valor al dic de l'estat grafic actiu
    EstatGrafic iEG get /TxTm TxTm put
    %% copiem aquest valor al dic de l'estat grafic actiu
    EstatGrafic iEG get /iTxTm TxTm put

%% estratègia a TD i Td per tal d'afegir un separador null
%% entre paraules en cas que la Y de la línia que estem tractant ja existeixi, per tal d'afegir
%% l'espai separador, amb un null, i evitar s'enganxin paraules diferents. Si ja existeix, o sigui
%% que hi havia text abans, pot ser per dos motius: o som a final de línia (és el darrer mot) o som
%% davant d'un cas on s'enganxarien dues paraules per manca d'aquest control a TD i Td
yRENGS araPlana get dup dup
%% aquí és on comprovem si existeix la Y del reng en aquesta pàgina
TyTm
cvi  %% EP!MASATS treballarem només amb l'enter
128 string cvs dup dup 3 index exch known
{
 3 -1 roll exch get  %% posem a l'stack
 /araRENG exch def
 %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
 null
 araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
 %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
 null
 araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
 %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
 null
 araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
 %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
 null
 araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
 0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
 araRENG put  %% desem al diccionari de la plana
 yRENGS exch araPlana exch put  %% desem al diccionari dels rengs
}
{
 %% (NOHIES!)==
 %% araRENG ==
 pop pop pop pop pop
}ifelse

%%    }stopped{( ... peta TD) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (TD\012) writestring
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta TD) == quit}if
   }
  ] i_TD get /TD exch bind def

  [  %% Tm
   {  %% 0 (arbre jeràrquic) | gatells: 16
    {  %% stopped
     6 copy
     6 /RoLL 6 def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
     sEdAs (Tm\012) writestring
    EstatGrafic iEG get
    /girNOcontrolat get
    {  %% si cm duu un gir no controlat encara en aquesta implementacio, pleguem
     ( ... cm ... duu un gir NO controlat ... PLEGUEM!)== stop  %%quit
    }if
/CursivaMentidera false def  %% gatell per la falsa italica
    6 copy
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% eliminem l'escriptura a disc, doncs aqui no ens serveix per a res!
    6 array astore /aTm exch def  %% desem l'array de la Tm
    /eixTmGirat false def
    /suaraTm true def  %% x saber si es la primera vegada q executem un operador de text despres d'executar Tm
    cmSy mul  %% multipliquem el valor provinent de cm
    cmPy add  %% hi sumem el valor provinent de cm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def  %% valor absolut de posicio Y del text
    cmSx mul  %% multipliquem el valor provinent de cm
    cmPx add  %% hi sumem el valor provinent de cm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TxTm exch put
    /TxTm exch def  %% valor absolut de posicio X del text
    cmSy mul  %% multipliquem el valor provinent de cm
    dup cos_ mul /CyTm exch def  %% valor del cos vertical de la lletra
    %% multiplicador d'escala Y del cos del text (seria el que al manual s'anomena com a 'text space unit')
    /iSyTm exch def  %% valor inicial que ratificarem + endavant
    /tanBsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un cursivat
    /tanAsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un cursivat
    cmSx mul  %% multipliquem el valor provinent de cm
    dup cos_ mul /CxTm exch def  %% valor del cos horitzontal de la lletra
    %% multiplicador d'escala X del cos del text (seria el que al manual s'anomena com a 'text space unit')
    /iSxTm exch def  %% valor inicial que ratificarem + endavant
    EstatGrafic iEG get /A_Tm 0 put  %% valor x defecte al dic de l'estat grafic actiu
    %% si algun dels dos valors (2 i 3 de l'array) es diferent de zero llavors actua el cos definit per Tf
    tanBsin abs tanAsin abs add 0 ne
    {  %% l'eix Tm es aparentment rotat (podria no ser-ho degut a les falses cursives!)
%% esbrinem si duu falses cursives ...
tanAsin 0 eq
{
(\n ... cursiva mentidera de ... )print flush tanBsin iSyTm atan dup /Amentidera exch def 128 string cvs print flush
( ... graus\n)print flush
%% llistem el nom PS del tipus de lletra que la duu?
%% hauríem de polir millor aquesta crida ...
 CalaixDeTipus araPlana get QuinaFONT get 0 get ==  %% (:-?)pstack quit
%% si l'eix Tm no es rotat llavors ...
%% copiem aquest valor al dic de l'estat grafic actiu
EstatGrafic iEG get /SyTm iSyTm put
%% ratifiquem ... iSyTm ... com a ... SyTm
/SyTm iSyTm def
%% copiem aquest valor al dic de l'estat grafic actiu
EstatGrafic iEG get /SxTm iSxTm put
%% ratifiquem ... iSxTm ... com a ... SxTm
/SxTm iSxTm def
/CursivaMentidera true def  %% gatell per la falsa italica
}
{
/CursivaMentidera false def  %% gatell per la falsa italica
     %% esbrinem si es una rotacio neta a 90 graus ...
     %% de la mateixa manera que en condicions normals d'escriptura (linia de base en horitzontal)
     %% el cos del tipus es multiplicat pel cosinus d'aquest angle (0 graus = 1) doncs quan la linia de base
     %% es vertical el sinus (90 graus = 1) pot multiplicar tambe el cos del tipus i donar aquestes dues dades
     iSxTm iSyTm add 0 eq  %% si es true llavors tanBsin i tanAsin son valors del cos
     {  %% es una rotacio neta a 90 graus!
      tanBsin cmSy mul  %% multipliquem el valor provinent de cm
dup abs dup /SyTm exch def  %% nou valor d'escala Tm establert pel sinus
EstatGrafic iEG get exch /SyTm exch put  %% desen al dic de l'estat grafic
      cos_ mul abs /CyTm exch def  %% (valor absolut!) redefinim el valor del cos vertical de la lletra
      tanAsin cmSx mul  %% multipliquem el valor provinent de cm
dup abs dup /SxTm exch def  %% nou valor d'escala Tm establert pel sinus
EstatGrafic iEG get exch /SxTm exch put  %% desen al dic de l'estat grafic
      cos_ mul abs /CxTm exch def  %% (valor absolut!) redefinim el valor del cos horitzontal de la lletra
      %% gatell x detectar girs nets de 90 graus pel sinus
      /90NET true def
      %% esbrinem el signe de l'angle i desem el valor
      EstatGrafic iEG get /A_Tm 90 tanAsin 0 lt
      {
       neg dup /A_Tm exch def
      }
      {
       dup /A_Tm exch def
      }ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa
      /eixTmGirat true def
     }
     {  %% ha de ser una rotacio d'un altre valor
%% llavors l'escala pren altra cop puntualment el valor d'1 (no cal desar-ho a l'estat grafic?)
/SxTm 1 def  %% nou valor d'escala Tm per les X
/SyTm 1 def  %% nou valor d'escala Tm per les Y
      %% restablim els valors d'escala desats a l'anterior Tm
      %%EstatGrafic iEG get dup /SxTm get /SxTm exch def /SyTm get /SyTm exch def
      %% gatell x detectar girs nets de 90 graus pel sinus
      /90NET false def
      cos_ cmSx mul /CxTm exch def cos_ cmSy mul /CyTm exch def
      (EP: text Tm rotat o falses cursives!) ==
      %% discriminem el tipus de rotacio o esbiaixat ...
      aTm 0 4 getinterval aload pop  %% extraiem els quatre primers valors que ens interessen
      4 1 roll add 0 eq
      { %% es una rotacio normal (sinus contraposats)?
       %% o pot ser tambe una falsa cursiva rotada ...
0 eq
{
/CursivaMentidera true def  %% gatell per la falsa italica
(\n ... cursiva mentidera de ... )print flush tanBsin abs atan dup /Amentidera exch def 128 string cvs print flush( ... graus\n)print flush 
%% llistem el nom PS del tipus de lletra que la duu?
%% hauríem de polir millor aquesta crida ...
 CalaixDeTipus araPlana get QuinaFONT get 0 get ==  %% (:-?)pstack quit
%% es una rotacio neta a 90 graus!
tanBsin cmSy mul  %% multipliquem el valor provinent de cm
dup abs dup /SyTm exch def  %% nou valor d'escala Tm establert pel sinus
EstatGrafic iEG get exch /SyTm exch put  %% desen al dic de l'estat grafic
cos_ mul abs /CyTm exch def  %% (valor absolut!) redefinim el valor del cos vertical de la lletra
tanAsin cmSx mul  %% multipliquem el valor provinent de cm
dup abs dup /SxTm exch def  %% nou valor d'escala Tm establert pel sinus
EstatGrafic iEG get exch /SxTm exch put  %% desen al dic de l'estat grafic
cos_ mul abs /CxTm exch def  %% (valor absolut!) redefinim el valor del cos horitzontal de la lletra
%% gatell x detectar girs nets de 90 graus pel sinus
/90NET true def
%% esbrinem el signe de l'angle i desem el valor
EstatGrafic iEG get /A_Tm 90 tanAsin 0 lt
{
neg dup /A_Tm exch def
}
{
dup /A_Tm exch def
}ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa
/eixTmGirat true def
/NOescairat false def  %% gatell x saber si cal cercar l'angle de rotacio
}
{
/CursivaMentidera false def  %% gatell per la falsa italica
/NOescairat true def  %% gatell x saber si cal cercar l'angle de rotacio
pop
       ( ... es una rotacio normal) ==
}ifelse
      }
      {
       add 0 eq
       {  %% es una imatge mirall (cosinus contraposats)
        ( ... es una rotacio d'espill ... PLEGUEM!)pstack stop  %%quit
       }
       {  %% aqui tenim una falsa cursiva en rotacio NO escairada
        %%( ... es un esbiaixat de l'eix NO controlat ... PLEGUEM!)
(\n ... cursiva mentidera rotada i no escairada ... \n\n)print flush
%%% DEDUCCIONS X FER
%% podem deduir l'angle de la linia de base restant 90 graus positius, fent ...
aTm 0 2 getinterval aload pop atan 90 exch sub
%% podem deduir l'angle vertical de les cursives (comptant des de la linia de base) fent ...
%%aTm 2 2 getinterval aload pop atan ==
%% fi de DEDUCCIONS
%% aquest valor d'atan s'en deduiex el segon i tercer valor d'aTm
%%aTm 3 get tanBsin abs atan
%%tanBsin iSyTm atan pstack stop %quit
/NOescairat false def  %% desactivem el gatell x saber si cal cercar l'angle de rotacio
dup /anglES exch def /A_Tm exch def
EstatGrafic iEG get /A_Tm A_Tm put  %% el desem al dic de l'estat grafic actiu
/CursivaMentidera true def  %% gatell per la falsa italica
       }ifelse
      }ifelse
NOescairat  %% cal cercar l'angle de rotacio?
{
%% CANVIEM L'ESTRATEGIA DEL CALCUL PER L'OPERADOR atan
      /eixTmGirat true def
      %% aqui fem el calcul de l'angle de rotacio (graus i signe!)
      aTm

      dup 1 get /Asinus exch def  %% si el sinus es positiu: l'angle sera positiu (direccio contrarellotge)
      0 get /Acosinus exch def  %% pesquem el cosinus
%%      /anglES null def  % no fos q no el trobem
%%      /Acrement .001 def  % suficient per q la precisio d'angle no hagi d'iterar + d'1 cop?
%%      {  % loop
       Asinus 0 lt  %% si l'angle es negatiu (ho controlem amb l'index 1 de l'array Tm o cm)
       {
%%        -360 Acrement 0  
Asinus Acosinus atan neg /anglES exch def
       }
       {
%%        0 Acrement 360
Asinus Acosinus atan /anglES exch def
       }ifelse
%%       {  % for
%%        dup dup sin 10000 mul truncate 10000 div Asinus 10000 mul truncate 10000 div eq
%%        exch cos 10000 mul truncate 10000 div Acosinus 10000 mul truncate 10000 div eq
%%        and
%%        {  % donat que l'error es mil·limetric, donem x bo el primer angle q compleixi la condicio
%%           % (pero n'hi poden haver +!)
%%         /anglES exch def exit
%%        }
%%        {
%%         pop
%%        }ifelse
%%       }for
%%       anglES null eq  % iterem?
%%       {  % si la precisio no es suficient li afegim 1 decimal!
%%        Acrement 10 div /Acrement exch def
%%        (no es prou acurat ... TORNEM-HI!) ==
%%       }
%%       {  % donem x bo el primer angle q compleixi la condicio (pero n'hi poden haver +!)
        anglES /A_Tm exch def
        EstatGrafic iEG get /A_Tm A_Tm put  %% el desem al dic de l'estat grafic actiu
%%        exit
%%       }ifelse
%%      }loop
}if  %% cal cercar l'angle de rotacio?

     }ifelse  %% es una rotacio neta a 90 graus o una altre?

}ifelse  %% cursiva mentidera?

    }
    {  %% si l'eix Tm no es rotat llavors ...
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /SyTm iSyTm put
     %% ratifiquem ... iSyTm ... com a ... SyTm
     /SyTm iSyTm def
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /SxTm iSxTm put
     %% ratifiquem ... iSxTm ... com a ... SxTm
     /SxTm iSxTm def
    }ifelse
    %% cal que desem els valors de la coordenada d'inici de cadena, nomes utilitzades pels operadors ' " T* Td
    TxTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTxTm exch put
    /iTxTm exch def
    TyTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def

%% aqui es on controlem l'herencia dels valors de rotacio de cm
%% primer interroguem si cm duu cap tipus de rotacio
A_cm 0 ne
{  %% si la duu, llavors ho sumem a A_Tm i en calculem el cos i el sin
A_cm A_Tm add dup /A_TOT exch def
%% el calcul del sin/cos cal fer-lo amb el valor absolut de l'angle
abs dup dup cos /A_cosTOT exch def sin /A_sinTOT exch def
%% modifiquem, si cal, la variable 90NET
truncate  %% desestimem els decimals?
abs 90 eq {/90NET true def}{/90NET false def}ifelse
%% modifiquem els cosinus la matriu de treball de Tm
aTm dup dup dup 0 A_cosTOT put 3 A_cosTOT put
%% modifiquem el sinus de la matriu Tm tenint en compte el sentit de l'angle
A_TOT 0 lt {1 A_sinTOT neg put 2 A_sinTOT put}{1 A_sinTOT put 2 A_sinTOT neg put}ifelse
}if

%% reactualitzem l'interliniat (TL o TD q podria haver estat definit abans) ...
EstatGrafic iEG get
dup /TLoTD get  %% ... a partir del valor pur de l'interliniat desat a l'estat grafic actiu
cmSy mul SyTm mul dup /INTERli exch def /INTERli exch put

    }stopped{( ... peta Tm 0) pstack stop}if
    %%% test
%% CxTm CyTm
%%[SxTm tanAsin tanBsin SyTm TxTm TyTm]
%%aTm
%% A_cm A_Tm(:::)pstack quit  % cos i paquet comparatiu
    %% /isiGne 0 def
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    6 /RoLL 6 def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs (Tm\012) writestring
    }stopped{( ... peta Tm) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual)
    {  %% stopped
    EstatGrafic iEG get
    /girNOcontrolat get
    {  %% si cm duu un gir no controlat encara en aquesta implementacio, pleguem
     ( ... cm ... duu un gir NO controlat ... PLEGUEM!)== stop  %%quit
    }if
/CursivaMentidera false def  %% gatell per la falsa italica
    6 copy
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% eliminem l'escriptura a disc, doncs aqui no ens serveix per a res!
    6 array astore /aTm exch def  %% desem l'array de la Tm
    /eixTmGirat false def
    /suaraTm true def  %% x saber si es la primera vegada q executem un operador de text despres d'executar Tm
    cmSy mul  %% multipliquem el valor provinent de cm
    cmPy add  %% hi sumem el valor provinent de cm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def  %% valor absolut de posicio Y del text
    cmSx mul  %% multipliquem el valor provinent de cm
    cmPx add  %% hi sumem el valor provinent de cm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TxTm exch put
    /TxTm exch def  %% valor absolut de posicio X del text
    cmSy mul  %% multipliquem el valor provinent de cm
    dup cos_ mul /CyTm exch def  %% valor del cos vertical de la lletra
    %% multiplicador d'escala Y del cos del text (seria el que al manual s'anomena com a 'text space unit')
    /iSyTm exch def  %% valor inicial que ratificarem + endavant
    /tanBsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un cursivat
    /tanAsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un cursivat
    cmSx mul  %% multipliquem el valor provinent de cm
    dup cos_ mul /CxTm exch def  %% valor del cos horitzontal de la lletra
    %% multiplicador d'escala X del cos del text (seria el que al manual s'anomena com a 'text space unit')
    /iSxTm exch def  %% valor inicial que ratificarem + endavant
    EstatGrafic iEG get /A_Tm 0 put  %% valor x defecte al dic de l'estat grafic actiu
    %% si algun dels dos valors (2 i 3 de l'array) es diferent de zero llavors actua el cos definit per Tf
    tanBsin abs tanAsin abs add 0 ne
    {  %% l'eix Tm es aparentment rotat (podria no ser-ho degut a les falses cursives!)
%% esbrinem si duu falses cursives ...
tanAsin 0 eq
{
(\n ... cursiva mentidera de ... )print flush tanBsin iSyTm atan dup /Amentidera exch def 128 string cvs print flush
( ... graus\n)print flush
%% llistem el nom PS del tipus de lletra que la duu?
%% hauríem de polir millor aquesta crida ...
 CalaixDeTipus araPlana get QuinaFONT get 0 get ==  %% (:-?)pstack quit
%% si l'eix Tm no es rotat llavors ...
%% copiem aquest valor al dic de l'estat grafic actiu
EstatGrafic iEG get /SyTm iSyTm put
%% ratifiquem ... iSyTm ... com a ... SyTm
/SyTm iSyTm def
%% copiem aquest valor al dic de l'estat grafic actiu
EstatGrafic iEG get /SxTm iSxTm put
%% ratifiquem ... iSxTm ... com a ... SxTm
/SxTm iSxTm def
/CursivaMentidera true def  %% gatell per la falsa italica
}
{
/CursivaMentidera false def  %% gatell per la falsa italica
     %% esbrinem si es una rotacio neta a 90 graus ...
     %% de la mateixa manera que en condicions normals d'escriptura (linia de base en horitzontal)
     %% el cos del tipus es multiplicat pel cosinus d'aquest angle (0 graus = 1) doncs quan la linia de base
     %% es vertical el sinus (90 graus = 1) pot multiplicar tambe el cos del tipus i donar aquestes dues dades
     iSxTm iSyTm add 0 eq  %% si es true llavors tanBsin i tanAsin son valors del cos
     {  %% es una rotacio neta a 90 graus!
      tanBsin cmSy mul  %% multipliquem el valor provinent de cm
dup abs dup /SyTm exch def  %% nou valor d'escala Tm establert pel sinus
EstatGrafic iEG get exch /SyTm exch put  %% desen al dic de l'estat grafic
      cos_ mul abs /CyTm exch def  %% (valor absolut!) redefinim el valor del cos vertical de la lletra
      tanAsin cmSx mul  %% multipliquem el valor provinent de cm
dup abs dup /SxTm exch def  %% nou valor d'escala Tm establert pel sinus
EstatGrafic iEG get exch /SxTm exch put  %% desen al dic de l'estat grafic
      cos_ mul abs /CxTm exch def  %% (valor absolut!) redefinim el valor del cos horitzontal de la lletra
      %% gatell x detectar girs nets de 90 graus pel sinus
      /90NET true def
      %% esbrinem el signe de l'angle i desem el valor
      EstatGrafic iEG get /A_Tm 90 tanAsin 0 lt
      {
       neg dup /A_Tm exch def
      }
      {
       dup /A_Tm exch def
      }ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa
      /eixTmGirat true def
     }
     {  %% ha de ser una rotacio d'un altre valor
%% llavors l'escala pren altra cop puntualment el valor d'1 (no cal desar-ho a l'estat grafic?)
/SxTm 1 def  %% nou valor d'escala Tm per les X
/SyTm 1 def  %% nou valor d'escala Tm per les Y
      %% restablim els valors d'escala desats a l'anterior Tm
      %%EstatGrafic iEG get dup /SxTm get /SxTm exch def /SyTm get /SyTm exch def
      %% gatell x detectar girs nets de 90 graus pel sinus
      /90NET false def
      cos_ cmSx mul /CxTm exch def cos_ cmSy mul /CyTm exch def
      (EP: text Tm rotat o falses cursives!) ==
      %% discriminem el tipus de rotacio o esbiaixat ...
      aTm 0 4 getinterval aload pop  %% extraiem els quatre primers valors que ens interessen
      4 1 roll add 0 eq
      { %% es una rotacio normal (sinus contraposats)?
       %% o pot ser tambe una falsa cursiva rotada ...
0 eq
{
/CursivaMentidera true def  %% gatell per la falsa italica
(\n ... cursiva mentidera de ... )print flush tanBsin abs atan dup /Amentidera exch def 128 string cvs print flush( ... graus\n)print flush 
%% llistem el nom PS del tipus de lletra que la duu?
%% hauríem de polir millor aquesta crida ...
 CalaixDeTipus araPlana get QuinaFONT get 0 get ==  %% (:-?)pstack quit
%% es una rotacio neta a 90 graus!
tanBsin cmSy mul  %% multipliquem el valor provinent de cm
dup abs dup /SyTm exch def  %% nou valor d'escala Tm establert pel sinus
EstatGrafic iEG get exch /SyTm exch put  %% desen al dic de l'estat grafic
cos_ mul abs /CyTm exch def  %% (valor absolut!) redefinim el valor del cos vertical de la lletra
tanAsin cmSx mul  %% multipliquem el valor provinent de cm
dup abs dup /SxTm exch def  %% nou valor d'escala Tm establert pel sinus
EstatGrafic iEG get exch /SxTm exch put  %% desen al dic de l'estat grafic
cos_ mul abs /CxTm exch def  %% (valor absolut!) redefinim el valor del cos horitzontal de la lletra
%% gatell x detectar girs nets de 90 graus pel sinus
/90NET true def
%% esbrinem el signe de l'angle i desem el valor
EstatGrafic iEG get /A_Tm 90 tanAsin 0 lt
{
neg dup /A_Tm exch def
}
{
dup /A_Tm exch def
}ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa
/eixTmGirat true def
/NOescairat false def  %% gatell x saber si cal cercar l'angle de rotacio
}
{
/CursivaMentidera false def  %% gatell per la falsa italica
/NOescairat true def  %% gatell x saber si cal cercar l'angle de rotacio
pop
       ( ... es una rotacio normal) ==
}ifelse
      }
      {
       add 0 eq
       {  %% es una imatge mirall (cosinus contraposats)
        ( ... es una rotacio d'espill ... PLEGUEM!)pstack stop  %%quit
       }
       {  %% aqui tenim una falsa cursiva en rotacio NO escairada
        %%( ... es un esbiaixat de l'eix NO controlat ... PLEGUEM!)
(\n ... cursiva mentidera rotada i no escairada ... \n\n)print flush
%% DEDUCCIONS X FER
%% podem deduir l'angle de la linia de base restant 90 graus positius, fent ...
aTm 0 2 getinterval aload pop atan 90 exch sub
%% podem deduir l'angle vertical de les cursives (comptant des de la linia de base) fent ...
%%aTm 2 2 getinterval aload pop atan ==
%% fi de DEDUCCIONS
%% aquest valor d'atan s'en deduiex el segon i tercer valor d'aTm
%%aTm 3 get tanBsin abs atan
%%tanBsin iSyTm atan pstack stop %quit
/NOescairat false def  %% desactivem el gatell x saber si cal cercar l'angle de rotacio
dup /anglES exch def /A_Tm exch def
EstatGrafic iEG get /A_Tm A_Tm put  %% el desem al dic de l'estat grafic actiu
/CursivaMentidera true def  %% gatell per la falsa italica
       }ifelse
      }ifelse
NOescairat  %% cal cercar l'angle de rotacio?
{
%% CANVIEM L'ESTRATEGIA DEL CALCUL PER L'OPERADOR atan
      /eixTmGirat true def
      %% aqui fem el calcul de l'angle de rotacio (graus i signe!)
      aTm

      dup 1 get /Asinus exch def  %% si el sinus es positiu: l'angle sera positiu (direccio contrarellotge)
      0 get /Acosinus exch def  %% pesquem el cosinus
%%      /anglES null def  % no fos q no el trobem
%%      /Acrement .001 def  % suficient per q la precisio d'angle no hagi d'iterar + d'1 cop?
%%      {  % loop
       Asinus 0 lt  %% si l'angle es negatiu (ho controlem amb l'index 1 de l'array Tm o cm)
       {
%%        -360 Acrement 0  
Asinus Acosinus atan neg /anglES exch def
       }
       {
%%        0 Acrement 360
Asinus Acosinus atan /anglES exch def
       }ifelse
%%       {  % for
%%        dup dup sin 10000 mul truncate 10000 div Asinus 10000 mul truncate 10000 div eq
%%        exch cos 10000 mul truncate 10000 div Acosinus 10000 mul truncate 10000 div eq
%%        and
%%        {  % donat que l'error es mil·limetric, donem x bo el primer angle q compleixi la condicio
%%           % (pero n'hi poden haver +!)
%%         /anglES exch def exit
%%        }
%%        {
%%         pop
%%        }ifelse
%%       }for
%%       anglES null eq  % iterem?
%%       {  % si la precisio no es suficient li afegim 1 decimal!
%%        Acrement 10 div /Acrement exch def
%%        (no es prou acurat ... TORNEM-HI!) ==
%%       }
%%       {  % donem x bo el primer angle q compleixi la condicio (pero n'hi poden haver +!)
        anglES /A_Tm exch def
        EstatGrafic iEG get /A_Tm A_Tm put  %% el desem al dic de l'estat grafic actiu
%%        exit
%%       }ifelse
%%      }loop
}if  %% cal cercar l'angle de rotacio?

     }ifelse  %% es una rotacio neta a 90 graus o una altre?

}ifelse  %% cursiva mentidera?

    }
    {  %% si l'eix Tm no es rotat llavors ...
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /SyTm iSyTm put
     %% ratifiquem ... iSyTm ... com a ... SyTm
     /SyTm iSyTm def
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /SxTm iSxTm put
     %% ratifiquem ... iSxTm ... com a ... SxTm
     /SxTm iSxTm def
    }ifelse
    %% cal que desem els valors de la coordenada d'inici de cadena, nomes utilitzades pels operadors ' " T* Td
    TxTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTxTm exch put
    /iTxTm exch def
    TyTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def

%% aqui es on controlem l'herencia dels valors de rotacio de cm
%% primer interroguem si cm duu cap tipus de rotacio
A_cm 0 ne
{  %% si la duu, llavors ho sumem a A_Tm i en calculem el cos i el sin
A_cm A_Tm add dup /A_TOT exch def
%% el calcul del sin/cos cal fer-lo amb el valor absolut de l'angle
abs dup dup cos /A_cosTOT exch def sin /A_sinTOT exch def
%% modifiquem, si cal, la variable 90NET
truncate  %% desestimem els decimals?
abs 90 eq {/90NET true def}{/90NET false def}ifelse
%% modifiquem els cosinus la matriu de treball de Tm
aTm dup dup dup 0 A_cosTOT put 3 A_cosTOT put
%% modifiquem el sinus de la matriu Tm tenint en compte el sentit de l'angle
A_TOT 0 lt {1 A_sinTOT neg put 2 A_sinTOT put}{1 A_sinTOT put 2 A_sinTOT neg put}ifelse
}if

%% reactualitzem l'interliniat (TL o TD q podria haver estat definit abans) ...
EstatGrafic iEG get
dup /TLoTD get  %% ... a partir del valor pur de l'interliniat desat a l'estat grafic actiu
cmSy mul SyTm mul dup /INTERli exch def /INTERli exch put

    }stopped{( ... peta Tm) == quit}if
    %%% test
%% CxTm CyTm
%%[SxTm tanAsin tanBsin SyTm TxTm TyTm]
%%aTm
%% A_cm A_Tm(:::)pstack quit  % cos i paquet comparatiu
    %% /isiGne 0 def
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop pop pop pop pop pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
      %%TiNTeM {  % es la tinta que toca ara ?
      6 /RoLL 6 def
      {
       RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
       RoLL 1 sub /RoLL exch def
      }repeat
      sEdAs (Tm\012) writestring
      %%}{6{pop}repeat}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta Tm) == quit}if
   }
  ] i_Tm get /Tm exch bind def

  [  %% T*
   {  %% 0 (arbre jeràrquic) | gatells: 16
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (T*\012) writestring

INTERli 0 eq  %% tret que l'interliniat sigui zero
{  %% TxTm agafa el valor de iTxTm
 %% cada cop que es crida /T* cal reinicialitzar el valor de TxTm pel de iTxTm i idem x Y
 EstatGrafic iEG get dup /iTxTm get dup /TxTm exch def /TxTm exch put
 EstatGrafic iEG get dup /iTyTm get dup /TyTm exch def /TyTm exch put 
}
{

EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
%% posem a la pila el valor de desplaçament (interliniat) y definit per TD x redefinir
iTyTm INTERli sub
dup /iTyTm exch def  %% nou inici absolut de linia Y
/TyTm exch def  %% posicio actual d'Y

CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTd no sigui zero ...
{  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
0
INTERli neg
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

pop iTxTm add   %% valor X a corregir
dup /iTxTm exch def  %% nou inici absolut de la linia X
/TxTm exch def  %% l'inici absolut de la linia X
}
{
 %% cada cop que es crida /T* cal reinicialitzar el valor de TxTm pel de iTxTm i idem x Y
 EstatGrafic iEG get dup /iTxTm get dup /TxTm exch def /TxTm exch put
 EstatGrafic iEG get dup  %%dup dup /iTxTm iTxTm put /TxTm iTxTm put
 /TyTm iTyTm put /iTyTm iTyTm put
}ifelse
}
{  %% normalitzem
0 INTERli neg
    %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm
    gsave
    aTm
%%    dup dup 2 get tanBsin add 2 exch put
%%    dup dup 1 get SxTm mul 1 exch put

90NET
{

dup 1 get 0 lt
{  %% rotacio negativa
dup dup 1 -1 put 2 1 put
}
{  %% rotacio positiva
dup dup 1 1 put 2 -1 put
}ifelse

CursivaMentidera
{
%% eliminem els valors de generen la cursiva
dup 3 0 put
dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
%%dup dup 5 get YpurTd add 5 exch put
%%dup dup 4 get XpurTd add 4 exch put
}if

}if

    dup dup 5 iTyTm put 4 iTxTm put
    concat
    matrix currentmatrix  %% valor de la matriu rotada
    grestore
   transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
    itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

CursivaMentidera
{
0
INTERli neg
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

pop  %% la distorsio angular X de la falsa cursiva aplicada a la posicio i l'angle Aeix
0
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio d'Aeix al punt q toca
dup 5 -1 roll 5 exch put
dup 5 -1 roll 4 exch put
dup dup 1 Aeix sin put 2 Aeix sin neg put
dup dup 0 Aeix cos put 3 Aeix cos put

concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

dup /iTyTm exch def  %% nou inici absolut de la linia Y
/TyTm exch def  %% l'inici absolut de la linia Y

dup /iTxTm exch def  %% nou inici absolut de la linia X
/TxTm exch def  %% l'inici absolut de la linia X

}
{
    dup /iTyTm exch def  %% nou inici absolut de linia Y
    /TyTm exch def  %% posicio actual d'Y
    dup /iTxTm exch def  %% nou inici absolut de la linia X
    /TxTm exch def  %% posicio actual d'X
}ifelse

}ifelse

}ifelse  %% tret que l'interliniat sigui zero

%% TyTm iTyTm (:-l)pstack quit
    }stopped{( ... peta T*) pstack stop}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (T*\012) writestring
    %%}stopped{( ... peta T*) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual)
%%    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
%%    sEdAs (T*\012) writestring

INTERli 0 eq  %% tret que l'interliniat sigui zero
{  %% TxTm agafa el valor de iTxTm
 %% cada cop que es crida /T* cal reinicialitzar el valor de TxTm pel de iTxTm i idem x Y
 EstatGrafic iEG get dup /iTxTm get dup /TxTm exch def /TxTm exch put
 EstatGrafic iEG get dup /iTyTm get dup /TyTm exch def /TyTm exch put 
}
{

EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
%% posem a la pila el valor de desplaçament (interliniat) y definit per TD x redefinir
iTyTm INTERli sub
dup /iTyTm exch def  %% nou inici absolut de linia Y
/TyTm exch def  %% posicio actual d'Y

CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTd no sigui zero ...
{  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
0
INTERli neg
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

pop iTxTm add   %% valor X a corregir
dup /iTxTm exch def  %% nou inici absolut de la linia X
/TxTm exch def  %% l'inici absolut de la linia X
}
{
 %% cada cop que es crida /T* cal reinicialitzar el valor de TxTm pel de iTxTm i idem x Y
 EstatGrafic iEG get dup /iTxTm get dup /TxTm exch def /TxTm exch put
 EstatGrafic iEG get dup  %%dup dup /iTxTm iTxTm put /TxTm iTxTm put
 /TyTm iTyTm put /iTyTm iTyTm put
}ifelse
}
{  %% normalitzem
0 INTERli neg
    %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm
    gsave
    aTm
%%    dup dup 2 get tanBsin add 2 exch put
%%    dup dup 1 get SxTm mul 1 exch put

90NET
{

dup 1 get 0 lt
{  %% rotacio negativa
dup dup 1 -1 put 2 1 put
}
{  %% rotacio positiva
dup dup 1 1 put 2 -1 put
}ifelse

CursivaMentidera
{
%% eliminem els valors de generen la cursiva
dup 3 0 put
dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
%%dup dup 5 get YpurTd add 5 exch put
%%dup dup 4 get XpurTd add 4 exch put
}if

}if

    dup dup 5 iTyTm put 4 iTxTm put
    concat
    matrix currentmatrix  %% valor de la matriu rotada
    grestore
   transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
    itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

CursivaMentidera
{
0
INTERli neg
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

pop  %% la distorsio angular X de la falsa cursiva aplicada a la posicio i l'angle Aeix
0
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio d'Aeix al punt q toca
dup 5 -1 roll 5 exch put
dup 5 -1 roll 4 exch put
dup dup 1 Aeix sin put 2 Aeix sin neg put
dup dup 0 Aeix cos put 3 Aeix cos put

concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

dup /iTyTm exch def  %% nou inici absolut de la linia Y
/TyTm exch def  %% l'inici absolut de la linia Y

dup /iTxTm exch def  %% nou inici absolut de la linia X
/TxTm exch def  %% l'inici absolut de la linia X

}
{
    dup /iTyTm exch def  %% nou inici absolut de linia Y
    /TyTm exch def  %% posicio actual d'Y
    dup /iTxTm exch def  %% nou inici absolut de la linia X
    /TxTm exch def  %% posicio actual d'X
}ifelse

}ifelse

}ifelse  %% tret que l'interliniat sigui zero

%% TyTm iTyTm (:-l)pstack quit
%%    }stopped{( ... peta T*) == quit}if
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs (T*\012) writestring
     %%}if  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta T*) == quit}if
   }
  ] i_T* get /T* exch bind def

%% (PDF Ref 1.7) 5.3.2 Text-Showing Operators
%% (PDF Ref ?) 8.7.5 Text string operators
  [  %% Tj
   {  %% 0 (arbre jeràrquic) + MASATS | gatells: 16
    {  %% stopped
     esUNAlayer
     {
      xSiFosBuida /quinOC exch def  %% desem el nom del possible Optional Content (capa)
     }
     {
      /MRCT_capOC /quinOC exch def  %% desem el nom que ens diu que NO som a cap Optional Content (capa)
     }ifelse
     %% XRay/Lleixes get/nomIE get{== ==}forall
     /EStrepitgen false def  %% gatell per saber si dues línies de text coincident duen caràcters que es trepitgen

     %% ens cal interrogar explícitament la font aquí per saber si és Unicode!
     CalaixDeTipus araPlana get QuinaFONT get 3 get /esUnicode exch def

     dup dup length string copy  %% fem una còpia descontaminada per salvaparent i l'escriptura
     %% salvaparent2.ps
     %% de com reescriure una string x solucionar el problema de no deixar-nos
     %% el backslash \ i els parentesi () sense el \ que els marca com a caracters
     %% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
     /fora
     [  %% paquet de caracters a cercar
      (\134)  %% \ backslash
      (\050)  %% ( left parenthesis
      (\051)  %% ) right parenthesis
      (\012)  %% \n line feed (LF)
      (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
      (\011)  %% \t horizontal tab
      (\010)  %% \b backspace
      (\014)  %% \f form feed (FF)
     ] def
     /FAfora fora length def  %% pestell de sortida del loop
     /foraX
     [  %% paquet de substitucio de caracter
      (\\\\)  %% backslash
      (\\\()  %% left parenthesis
      (\\\))  %% right parenthesis
      (\\n)  %% line feed (LF)
      (\\r)  %% carriage return (CR)
      (\\t)  %% horizontal tab
      (\\b)  %% backspace
      (\\f)  %% form feed (FF)
     ] def
     /ifora 0 def  %% index de fora
     %% aqui la cadena a reescriure correctament
     %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
     mark exch
     {  %% loop general
      {  %% loop cerca/subs de caracters
       fora ifora get search
       {
        exch pop
        dup length dup 2 add
        string dup 3 -1 roll foraX ifora get putinterval
        dup 3 -1 roll 0 exch putinterval
       }
       {
        exit
       }ifelse
       exch
      }loop
      %% aquest loop capgira tots els elements trobats a l'stack mentre n'hi hagi mes d'un
      counttomark 1 gt
      {
       counttomark /atura't exch def
       /ici 2 def
       {
        ici -1 roll ici 1 add /ici exch def ici atura't gt
        {
         exit
        }if
       } loop
       {  %% loop empalmador de les cadenes trobades en 1 sola
        dup length dup 3 index length add string dup 4 -1 roll
        0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
        counttomark 1 eq {exit} if
       }loop
      }if
      ifora 1 add /ifora exch def
      FAfora ifora eq {exit}if
     }loop
     exch pop  %% ens carreguem mark
     %% posem els caracters ( ... ) com a cadena
     dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
     dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
     %% fi de salvaparent2.ps
     sEdAs exch writestring
     sEdAs 32 write sEdAs (Tj\012) writestring
     %% el first character de l'encoding es erroni
     %% cal substituir el forall pel loop x manegar B l'unicode
     %% 0 2 getinterval /cU 4 string def cU /NullEncode filter /ASCIIHexEncode filter dup 3 -1 roll
     %% writestring flushfile
     %% {==}forall
     %% length ==
     %% EncNETiPLANXAT ==
     %% WinAnsiEncoding2Bytes (0020) get 
     %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     /LleixaBuida false def
     %% computem el valor del Ts (text rise)
     TyTs SyTm mul TyTm add
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup dup EstatGrafic iEG get exch /TyTm exch put /TyTm exch def
     %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia dels valors:
     %% coordenada y i l'angle, d forma que els dos hauran de coincidir x considerar-los dins el mateix reng
     %% eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
     EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
     {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
      %% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat    
      90NET
      {  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
       cvi  %% EP!MASATS treballarem només amb l'enter
       256 string cvs
       EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
       TxTm
       cvi  %% EP!MASATS treballarem només amb l'enter
       256 string cvs  %% ara lliguem la X en ves de l'angle
       1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
       6 -1 roll 0 exch putinterval
       UndeR (_) putinterval
       UndeR 1 add 4 -1 roll putinterval
      }
      {
       cvi  %% EP!MASATS treballarem només amb l'enter
       256 string cvs
       EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
       1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
       6 -1 roll 0 exch putinterval
       UndeR (_) putinterval
       UndeR 1 add 4 -1 roll putinterval
      }ifelse
     }
     {
      /Aeix 0 def
      cvi  %% EP!MASATS treballarem només amb l'enter
      128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
     }ifelse

     %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
     yRENGS araPlana get dup 2 index known
     {  %% existeix
      exch dup /quinRENG exch def  %% desem la clau del valor Y del reng per control de possibles trepitjats
      get /araRENG exch def  %% capturem l'array amb els elements del reng
      %% es creuen fem una còpia descontaminada per si l'hem de preservar en cas de trepitjat de text
      /CLONaraRENG araRENG dup length array copy def
      %% muntem el rectangle per presentar-lo caràcter a caràcter i saber si es trepitja en algun punt
      CLONaraRENG 0 get  %% l'array de coordenades de cada caràcter
      dup length /maxTrep exch def /Trep exch def
      Trep
      {  %% forall per extraure les coordenades del primer caràcter
       dup null eq
       {
        pop
       }
       {
        dup 2 get /AxTrepLL exch def  %% LowerLeft X del primer caràcter de l'àrea del mot que avaluarem de si trepitja
        3 get /AyTrepLL exch def  %% LowerLeft Y del primer caràcter de l'àrea del mot que avaluarem de si trepitja
        exit  %% i sortim perquè ja tenim la X,Y d'inici del primer caràcter
       }ifelse
      }forall
      maxTrep 1 sub -1 0
      {  %% for per extraure les coordenades del darrer caràcter
       Trep exch get dup null eq
       {
        pop
       }
       {
        dup 4 get /AxTrepLR exch def  %% LowerRight X del darrer caràcter de l'àrea del mot que avaluarem de si trepitja
        5 get /AyTrepLR exch def  %% LowerRight Y del darrer caràcter de l'àrea del mot que avaluarem de si trepitja
        exit  %% i sortim perquè ja tenim la X,Y del final del darrer caràcter
       }ifelse 
      }for
      /TrepA  %% userpath d'avaluació de la caixa del mot per presentar-lo caràcter a caràcter i saber si es trepitja en algun punt
      {  %% fem el rectangle començant per LL i en direcció a les agulles
       AxTrepLL AyTrepLL moveto
       AxTrepLL AyTrepLL 2 add lineto  %% l'altura de la caixa del mot és irrellevant per crear el rectangle d'avaluació
       AxTrepLR AyTrepLR 2 add lineto
       AxTrepLR AyTrepLR lineto
       closepath true upath cvlit  %% en fem un userpath
      }def

      /HiHaY true def  %% el reng ja existeix
     }
     {  %% l'hem de crear
      exch
      [  %% array d'elements pel reng, on tots el seus index coincidiran!
       []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
       %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
       %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
       %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
       %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
       []  %% 1: el segon, una array amb els literals dels signes ordenats segons codi (pot no coincidir amb l'ordre de lectura)
       %% correctament on, si hi hagues una separacio (espai o no), contindria un null
       []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
       []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
       Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
       {
        null  %% 4: el cinque, ens indica si la linia es rotada (null=NO angle=SI)
       }
       {
        Aeix  %% valor de l'angle
       }ifelse
       quinOC  %% 5: el sisè, ens diu el nom de la capa (Optional Content), si no és a cap durà /MRCT_capOC
      ]
      dup /araRENG exch def
      put  %% la desem al dic de la pagina
      /HiHaY false def  %% el reng NO existeix
      %% valors inicials de la translacio Tm de control signe a signe x concat
      /transX TxTm def
      /transY TyTm def
     }ifelse
     %% array de caracter amb les posicions:
     %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
     %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
     %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
     %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
     %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
     %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
     /iXfX 6 array def  %% ara de 6 posicions!

     dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena

     /iEStrepitgen 0 def  %% gatell per saber si haurem generat una nova araRENG per un mot trepitjat
     {  %% loop pels mots que es trepitgen
      /iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)
      {  %% loop per cadascun dels caràcters de la cadena de text dins Tj
       %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
       maxLoop 0 eq
       {
        pop exit
       }if
       dup iU esUnicode
       {
        2 getinterval 1 get
       }
       {
        1 getinterval 0 get
       }ifelse
       /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
       %% posicio x,y d'inici de caracter
       TxTm
       %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
       Aeix 0 eq
       {
        dup iXfX exch 0 exch put  %% x JBC
       }
       {
        dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
        {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
         pop
        }
        {
         div
        }ifelse
        iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
       }ifelse

       Aeix 0 eq  %% si l'eix no es rotat ...
       {  %% no cal q la normalitzem
        iXfX exch 2 exch put  %% coordenada X d'inici del signe
        iXfX 3 TyTm put  %% coordenada Y d'inici del signe
       }
       {  %% normalitzem
        %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
        gsave
        aTm
        %% si es un angle net de 90 graus, hem de treballar a escala 1
        90NET
        {
         dup 1 get 0 lt
         {
          dup dup 1 -1 put 2 1 put
         }
         {
          dup dup 1 1 put 2 -1 put
         }ifelse
        }if
        %% la translacio q ens interessa es la del x,y d'origen del signe
        dup 3 -1 roll 4 exch put  %% posicio X d'inici
        dup 5 TyTm put  %% posicio Y d'inici
        %% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
        0 exch 0 exch
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
        /transY exch def  %% desem pel proper concat?
        /transX exch def  %% desem pel proper concat?
        iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
        iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
       }ifelse

       %%(\n)print flush
       %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
       %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush

       %% treiem l'ample (Width metrics) de cada caracter ...
       CalaixDeTipus
       araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
       QuinaFONT get

       esUnicode
       {
%%Aquí hi ha un problema: treballant a 1 byte no ajustem l'índex pel valor de FirstChar!
        1 index exch
       }
       {
        dup 1 get 2 index exch sub exch
       }ifelse

       2 get  %% extraiem el paquet de la mètrica
       exch
       %% pot ser que li arribi un valor d'índex en negatiu?
       abs  %% té lògica?
       %% dup 0 lt{(valor IMAGINARI!)pstack quit}if
       %% l'altra problema és que l'encoding de Widths no té tot el rang a 256 (tot i ser Identity-H) doncs la font està escapçada
       %% si al descendantFont hi ha /DW llavors podriem posar-hi aquest valor?
       %% tirem pel dret:
       %% mirem si sortim de rang a l'encoding de Widths i si és així apliquem el valor de l'índex 4 de la font a CalaixDeTipus
       2 copy exch length ge
       {  %% el codi del caràcter és fora de rang de l'encoding de Widths
        pop pop
        CalaixDeTipus
        araPlana get
        QuinaFONT get 4 get  %% ara fem servir el valor mitjà de mètrica calculat
       }
       { 
        get
       }ifelse

       %% QuinaFONT /Type0TTF1 eq{(MMMMMMMM)pstack quit}if

       %% multipliquem l'ample d la metrica pel cos i dividim x1000+TxTm x saber la posicio del caracter seguent
       CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       mul 1000 div
       %% es suma a cada caracter el valor definit per Tc
       ecTc SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       mul add  %% aquest factor definit per Tc va multiplicat pel multiplicador d'escala X del cos del text
       dup /aS exch def  %% nomes l'ample del signe
       Aeix 0 eq
       {
        TxTm add  %% sumem el valor anterior ara
       }
       {
        dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
        /XfLB exch def  %% desem la posicio X final del signe d linia d base x si hem d fer la correccio d'espai
        TxTm add  %% sumem el valor anterior ara
       }ifelse
       %% copiem aquest valor al dic de l'estat grafic actiu
       dup EstatGrafic iEG get exch /TxTm exch put
       /TxTm exch def
       EncNETiPLANXAT exch get
       dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
       {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
        epTw SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
        mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
        Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
        {
         dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
         dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
        }if
        TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
        %% copiem aquest valor al dic de l'estat grafic actiu
        dup EstatGrafic iEG get exch /TxTm exch put
        /TxTm exch def
       }if

       Aeix 0 eq  %% si l'eix no es rotat ...
       {  %% no cal q la normalitzem
        %% posicio x,y de final de caracter
        TxTm
        dup iXfX exch 1 exch put
        iXfX exch 4 exch put  %% coordenada X de final del signe
        TyTm
        iXfX exch 5 exch put  %% coordenada Y de final del signe
       }
       {  %% normalitzem
        %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
        gsave
        %% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
        aS abs  %% hem d'anul·lar el signe de l'amplada xq la coordenada corregida es calculi correctament
        0
        aTm
        %% si es un angle net de 90 graus, hem de treballar a escala 1
        90NET
        {
         dup 1 get 0 lt
         {
          dup dup 1 -1 put 2 1 put
         }
         {
          dup dup 1 1 put 2 -1 put
         }ifelse
        }if
        %% la translacio q ens interessa es identica a l'aTm anterior tret q sigui un angle net de 90 graus
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
        dup /transY exch def  %% desem pel proper concat?
        /TyTm exch def  %% nova posisico Y d'inici pel proper signe
        dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
        /transX exch def  %% desem pel proper concat?
        iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
        iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
        %% desem la coordenada X de final de caracter mesurada en horitzontal
        Aeix 0 ne
        {  %% si es rotada
         iXfX 1 XfLB put
        }
        {  %% sense rotar
         iXfX 1 TxTm put
        }ifelse
       }ifelse

       %% iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
       %% iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
       %% (Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush

       /nullExtra false def

       %% cal fer una primer interrogació de si HiHaY per saber si es creuen amb el rectangle de tast d'araRENG
       HiHaY
       {
        iXfX dup 2 get /CxTrepLL exch def  %% LowerLeft X del primer caràcter de l'àrea del mot que avaluarem de si trepitja
        3 get /CyTrepLL exch def  %% LowerLeft Y del primer caràcter de l'àrea del mot que avaluarem de si trepitja
        iXfX dup 4 get /CxTrepLR exch def  %% LowerRight X del darrer caràcter de l'àrea del mot que avaluarem de si trepitja
        5 get /CyTrepLR exch def  %% LowerRight Y del darrer caràcter de l'àrea del mot que avaluarem de si trepitja

        /TrepC  %% userpath de la caixa del caràcter per comparar-lo amb /TrepA i saber si es trepitja en algun punt
        {  %% fem el rectangle començant per LL i en direcció a les agulles
         CxTrepLL CyTrepLL moveto
         CxTrepLL CyTrepLL 2 add lineto  %% l'altura de la caixa del caràcter és irrellevant per crear el rectangle d'avaluació
         CxTrepLR CyTrepLR 2 add lineto
         CxTrepLR CyTrepLR lineto
         closepath true upath cvlit  %% en fem un userpath
        }def
        %% test de trepitjat
        gsave
        %% generem primer l'àrea de clip amb el mateix upath /TrepA que duplicarem perquè quedi com a valor a l'stack
        newpath TrepA dup uappend clip newpath
        TrepC  %% el segon upath és el que ens dirà si es creua amb el clip del primer i per tant trepitja o no
        inufill  %% interroga l'area de dos userpath, si es creuen dóna true i si no ho fan dóna false
        grestore
        %% si es creuen, sortim del loop i activem l'algorisme de... el reng NO existeix ...via el gatell EStrepitgen
        {
         /EStrepitgen true def
         exit
        }if
       }if

       HiHaY
       {  %% el reng existeix
        araRENG 0 get
        {  %% forall de l'array de posicions
         dup type /nulltype eq
         {
          pop
         }
         {
          0 get dup  %% l'inici del primer caracter de la cadena q ja tenim ...
          iXfX 0 get ge  %% ... es + gran o igual q el l'inici del signe q volem situar ...
          {  %% componem cap a l'esquerra
           pop
           araRENG 0 get  %% treiem l'array de posicions
           /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
           0 /EnRETIRA exch def  %% index posicionador x defecte?
           %% extraiem el darrer array NO null començant per l'index n-1
           %% que el seu origen es igualat o superat per l'origen de iXfX
           dup length 1 sub -1 0
           {  %% for
            dup /iSuara exch def  %% desem l'index
            1 index exch get dup type /nulltype eq
            {
             pop
            }
            {
             dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
             {
              iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
              /aSuara exch def
             }
             {
              pop exit
             }ifelse
            }ifelse
           }for
           pop
           aSuara 0 get
           iXfX 0 get sub
           %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
           %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
           %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
           iXfX dup 1 get exch 0 get sub
           %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
           dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
           {
            pop pop 0
           }
           {
            div cvi abs
           }ifelse
           EnRETIRA sub
           dup 0 lt
           {  %% filtrem els valors negatius (fan petar l'algorisme!)
            pop 0
            /NOmaseguis false def
           }if

           %% fi del tram on podem afinar la tolerancia 
           %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
           /NOmaseguis true def
           dup 0 eq
           {
            araRENG 1 get iSuara get /space eq
            {
             %% pop /NOmaseguis false def  % l'aixafem!
             %% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
             %% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
             %% consequencies dins la localitzacio de coordenades dels signes
             pop 1
            }
            {
             pop 1
            }ifelse
           }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
           %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
           NOmaseguis
           {  %% un anira darrera l'altre
            %% ampliem el primer array d'araRENG, de posicions X, EnRETIRA + x l'esquerra ...
            /EnRETIRA exch def  %% desem l'index posicionador
            araRENG 0 get dup length EnRETIRA add array dup 3 -1 roll
            EnRETIRA exch putinterval dup
            iXfX dup length array copy  %% x profilaxi!
            0 exch put  %% sempre sera a ZERO ?
            araRENG exch 0 exch put  %% desem
            %% ampliem el segon array d'araRENG, de noms de signes, EnRETIRA + x l'esquerra ...
            araRENG 1 get dup length EnRETIRA add array dup 3 -1 roll
            EnRETIRA exch putinterval dup 3 -1 roll
            0 exch put  %% sempre sera a ZERO ?
            araRENG exch 1 exch put  %% desem
            %% ampliem el tercer array d'araRENG, de tipus, EnRETIRA + x l'esquerra ...
            araRENG 2 get dup length EnRETIRA add array dup 3 -1 roll
            EnRETIRA exch putinterval dup
            0 QuinaFONT put  %% sempre sera a ZERO ?
            araRENG exch 2 exch put  %% desem
            %% ampliem el quart array d'araRENG, de cossos, EnRETIRA + x l'esquerra ...
            araRENG 3 get dup length EnRETIRA add array dup 3 -1 roll
            EnRETIRA exch putinterval dup
            0 CyTm put  %% sempre sera a ZERO ?
            araRENG exch 3 exch put  %% desem
           }
           {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
            %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
            %% componem a l'index iSuara el primer array d'araRENG, de posicions X
            araRENG 0 get dup
            iXfX dup length array copy  %% x profilaxi!
            iSuara exch put
            araRENG exch 0 exch put  %% desem
            %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
            araRENG 1 get dup
            3 -1 roll
            iSuara exch put
            araRENG exch 1 exch put  %% desem
            %% componem a l'index iSuara el tercer array d'araRENG, de tipus
            araRENG 2 get dup
            QuinaFONT
            iSuara exch put
            araRENG exch 2 exch put  %% desem
            %% componem a l'index iSuara el quart array d'araRENG, de cossos
            araRENG 3 get dup
            CyTm
            iSuara exch put
            araRENG exch 3 exch put  %% desem
           }ifelse
           exit  %% sortim doncs ja hem compost el signe te tocava
          }
          {  %% componem cap a la dreta
           /nullExtra true def
           pop
           araRENG 0 get  %% treiem l'array de posicions
           /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
           dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
           %% extraiem el darrer array NO null començant per l'index 0
           %% que el seu origen es igualat o superat per l'origen de iXfX
           0 1 EnRETIRA
           {  %% for
            dup /iSuara exch def  %% desem l'index
            1 index exch get dup type /nulltype eq
            {
             pop
             %% iSuara /EnRETIRA exch def  %% desem l'índex posicionador definitiu
            }
            {
             dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
             {
              iSuara /EnRETIRA exch def  %% desem l'índex posicionador definitiu
              %% que és el del darrer mot que és més petit o igual que el que estem situant, o dit
              %% d'una altra manera: el mot que està immediatament a l'esquerra del que situem
              /aSuara exch def
             }
             {
              pop exit
             }ifelse
            }ifelse
           }for
           pop

           %% no apliquem això ara:
           %% comptem quants nulls hi ha entremig del mot de més a l'esquerra i el de més a la dreta
           %% iU 0 eq
           %% {  %% només un cop i a l'inici de la cadena Tj
           %% /hihaNulls 0 def
           %% araRENG 0 get dup length 1 sub  %% final
           %% EnRETIRA 1 add  %% inici
           %% exch
           %% 1 exch  %% salt
           %% {  %% for
           %%  1 index exch get
           %%  type /nulltype eq
           %%  { 
           %%   hihaNulls 1 add /hihaNulls exch def
           %%  }
           %%  {
           %%   exit
           %%  }ifelse
           %% }for
           %% pop  %% ens carreguem l'array
           %% }if  %% només un cop i a l'inici de la cadena Tj

           %% aqui es on cal estudiar si en tots els casos cal anar a buscar l'X correcte a ...
           %% l'index 0 d'araRENG treure'n la darrera array i pescar l'index 2: posicio X d'inici del
           %% darrer signe, doncs la linia de sota no tindria cap sentit (interroga el mateix signe!)
           %% araRENG 0 get dup length 1 sub get 2 get ... aixo no va com ens pensem

           aSuara 1 get

           iXfX 1 get sub
           %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
           %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
           %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
           iXfX dup 1 get exch 0 get sub
           %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
           dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
           {
            pop pop 0
           }
           {
            div cvi abs
           }ifelse
           %% fi del tram on podem afinar la tolerancia
           %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
           /NOmaseguis true def
           dup 0 eq
           {
            araRENG 1 get iSuara get /space eq
            {
             %% pop /NOmaseguis false def  % l'aixafem!
             %% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
             %% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
             %% consequencies dins la localitzacio de coordenades dels signes
             pop 1
            }
            {
             pop 1
            }ifelse
           }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
           NOmaseguis
           {  %% un anira darrera l'altre
            %% no apliquem això ara:
            %% iU 0 eq
            %% {  %% només un cop i a l'inici de la cadena Tj
            %% si hi ha prous nulls entremig per contenir exactament la cadena que situem ara
            %% 2 index length 2 add hihaNulls le
            %% {  %% llavors, la situem immediatament després del mot de més a l'esquerra separada per un null
            %%  pop 2  %% sumaran dues posicions cap a la dreta per que hi quedi un null entremig
            %%  }if
            %% }if  %% només un cop i a l'inici de la cadena Tj

            EnRETIRA add
            /EnRETIRA exch def  %% fixem finalment l'index real posicionador
            %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
            araRENG 0 get length EnRETIRA le
            {  %% aqui ampliem els arrays segons la diferencia d'index amb EnRETIRA
             EnRETIRA araRENG 0 get length 1 sub sub /Eixamplem exch def  %% de quant ampliem l'array?
             %% ampliem el primer array d'araRENG, de posicions X, Eixamplem + x la dreta
             araRENG 0 get dup length Eixamplem add array
             dup 3 -1 roll 0 exch putinterval
             %% ... i afegim el nom desat a comPARA
             dup EnRETIRA iXfX dup length array copy put  %% x profilaxi!
             araRENG exch 0 exch put  %% desem
             %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem + x la dreta
             araRENG 1 get dup length Eixamplem add array
             dup 3 -1 roll 0 exch putinterval
             %% ... i afegim el nom desat a comPARA
             dup EnRETIRA 4 -1 roll put
             araRENG exch 1 exch put  %% desem
             %% ampliem el tercer array d'araRENG, de tipus, Eixamplem + x la dreta
             araRENG 2 get dup length Eixamplem add array
             dup 3 -1 roll 0 exch putinterval
             %% ... i afegim el nom desat a comPARA
             dup EnRETIRA QuinaFONT put
             araRENG exch 2 exch put  %% desem
             %% ampliem el quart array d'araRENG, de cossos, Eixamplem + x la dreta
             araRENG 3 get dup length Eixamplem add array
             dup 3 -1 roll 0 exch putinterval
             %% ... i afegim el nom desat a comPARA
             dup EnRETIRA CyTm put
             araRENG exch 3 exch put  %% desem
            }
            {
             araRENG 0 get length EnRETIRA ge
             {  %% vol dir que el signe q afegim va entremig
              %% aqui els arrays o s'han d'ampliar pel mig 1+ a la posicio que marca EnRETIRA
              %% tret que ja hi hagi un null a l'index on apunta EnRETIRA!
              araRENG 0 get EnRETIRA get null ne
              {  %% no hi ha cap null, llavors ampliem
               %% l'array de posicions
               araRENG 0 get length dup 1 add array exch araRENG 0 get
               exch EnRETIRA exch EnRETIRA sub getinterval
               1 index exch EnRETIRA 1 add exch putinterval dup
               araRENG 0 get 0 EnRETIRA getinterval 0 exch putinterval
               araRENG exch 0 exch put
               %% l'array de noms de signes
               araRENG 1 get length dup 1 add array exch araRENG 1 get
               exch EnRETIRA exch EnRETIRA sub getinterval
               1 index exch EnRETIRA 1 add exch putinterval dup
               araRENG 1 get 0 EnRETIRA getinterval 0 exch putinterval
               araRENG exch 1 exch put
               %% l'array de tipus
               araRENG 2 get length dup 1 add array exch araRENG 2 get
               exch EnRETIRA exch EnRETIRA sub getinterval
               1 index exch EnRETIRA 1 add exch putinterval dup
               araRENG 2 get 0 EnRETIRA getinterval 0 exch putinterval
               araRENG exch 2 exch put
               %% l'array de cossos
               araRENG 3 get length dup 1 add array exch araRENG 3 get
               exch EnRETIRA exch EnRETIRA sub getinterval
               1 index exch EnRETIRA 1 add exch putinterval dup
               araRENG 3 get 0 EnRETIRA getinterval 0 exch putinterval
               araRENG exch 3 exch put
              }if
             }if
             %% ... o queden intactes de mida, doncs ja han quedat ampliats abans
             %% componem a l'index EnRETIRA el primer array d'araRENG, de posicions X
             araRENG 0 get dup
             iXfX dup length array copy  %% x profilaxi!
             EnRETIRA exch put
             araRENG exch 0 exch put  %% desem
             %% componem a l'index EnRETIRA el segon array d'araRENG, de noms de signes
             araRENG 1 get dup
             3 -1 roll
             EnRETIRA exch put
             araRENG exch 1 exch put  %% desem
             %% componem a l'index EnRETIRA el tercer array d'araRENG, de tipus
             araRENG 2 get dup
             QuinaFONT
             EnRETIRA exch put
             araRENG exch 2 exch put  %% desem
             %% componem a l'index EnRETIRA el quart array d'araRENG, de cossos
             araRENG 3 get dup
             CyTm
             EnRETIRA exch put
             araRENG exch 3 exch put  %% desem
            }ifelse  %% ampliem l'array?
           }
           {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
            %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
            %% componem a l'index iSuara el primer array d'araRENG, de posicions X
            araRENG 0 get dup
            iXfX dup length array copy  %% x profilaxi!
            iSuara exch put
            araRENG exch 0 exch put  %% desem
            %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
            araRENG 1 get dup
            3 -1 roll
            iSuara exch put
            araRENG exch 1 exch put  %% desem
            %% componem a l'index iSuara el tercer array d'araRENG, de tipus
            araRENG 2 get dup
            QuinaFONT
            iSuara exch put
            araRENG exch 2 exch put  %% desem
            %% componem a l'index iSuara el quart array d'araRENG, de cossos
            araRENG 3 get dup
            CyTm
            iSuara exch put
            araRENG exch 3 exch put  %% desem
           }ifelse
           exit  %% sortim doncs ja hem compost el signe te tocava
          }ifelse  %% componem cap a l'esquerra o cap a la dreta
         }ifelse  %% null o no?
        }forall  %% de l'array de posicions
       }
       {  %% el reng NO existeix
        %% ampliem el primer array d'araRENG, de posicions X, 1+ x la dreta ...
        iXfX dup length array copy  %% x profilaxi!
        araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
        0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
        %% ampliem el segon array d'araRENG, de noms de signes, 1+ x la dreta ...
        araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
        0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
        %% ampliem el tercer array d'araRENG, de tipus, 1+ x la dreta ...
        QuinaFONT
        araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
        0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
        %% ampliem el quart array d'araRENG, de cossos, 1+ x la dreta ...
        CyTm
        araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
        0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
       }ifelse
       %% test
       %%isiGne 1 add /isiGne exch def

       iU esUnicode
       {
        2
       }
       {
        1
       }ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
       iU maxLoop ge
       {
        esUnicode
        {
         length 2 idiv /faCadena exch def
        }
        {
         length/faCadena exch def
        }ifelse
        %% pop
        exit
       }if  %% hem llegit tota la cadena?
      }loop  %% x cada un dels caracters del la cadena de dins el Tj

      EStrepitgen
      {  %% si es trepitgen tornem a reiniciar el loop amb els paràmetres adients...
       %% si es trepitgen (cal avaluar aquí si són a la mateixa OC? o ho farem quan generem rengsDtext?)...
       %% primer refem l'array original via /CLONaraRENG
       yRENGS dup araPlana get dup quinRENG CLONaraRENG put  %% desem l'araRENG sense modificar dins el dic de la plana
       araPlana exch put  %% desem la plana i el dic dins yRENGS
       pop  %% ens carreguem el literal que es trepitja

       [  %% array d'elements pel reng, on tots el seus index coincidiran!
        []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
        %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
        %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
        %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
        %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
        %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
        %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
        %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
        []  %% 1: el segon, una array amb els literals dels signes ordenats segons codi (pot no coincidir amb l'ordre de lectura)
        %% correctament on, si hi hagues una separacio (espai o no), contindria un null
        []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
        []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
        Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
        {
         null  %% 4: el cinque, ens indica si la linia es rotada (null=NO angle=SI)
        }
        {
         Aeix  %% valor de l'angle
        }ifelse
        quinOC  %% 5: el sisè, ens diu el nom de la capa (Optional Content), si no és a cap durà /MRCT_capOC
       ]
       /araRENG exch def
       /HiHaY false def  %% el reng NO existeix

       iEStrepitgen 1 add /iEStrepitgen exch def  %% gatell per saber si haurem generat una nova araRENG per un mot trepitjat
       /EStrepitgen false def  %% desactivem el gatell, doncs només hem de passar 1 sol cop pera quí
      }
      {  %% si no es trepitgen, sortim definitivament
       iEStrepitgen 0 ne
       {  %% venim d'un mot trepitjat i haurem generat una nova araRENG
        %% segon avaluem si /trepiTjats existeix
        yRENGS araPlana get /trepiTjats known
        {  %% si existeix extraiem l'array de la línia del reng...
         yRENGS araPlana get /trepiTjats get
         %% ...si existeix, mirem si ja hi ha la clau Y, i si hi és...
         dup quinRENG known
         {  %% la hi deixem
          quinRENG get
         }
         {  %% si no hi és en posem una de buida
          pop []
         }ifelse
         %% ...l'ampliem amb el nou araRENG...
         dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup araVa araRENG put /NOUarareng exch def
         %% i redesem /trepiTjats refet a l'araPlana d'yRENGS
         yRENGS dup araPlana get dup /trepiTjats 1 dict dup quinRENG NOUarareng put put araPlana exch put
         %% (aquí l'array ampliada de la línia del reng que ja existeix a trepiTjats)pstack quit
        }
        {  %% si no existeix, creem l'array de la línia del reng
         %% i desem /trepiTjats a l'araPlana d'yRENGS
         yRENGS dup araPlana get dup /trepiTjats 1 dict dup quinRENG [araRENG] put put araPlana exch put
         %% (aquí l'array de la nova línia del reng per encetar trepiTjats)pstack quit
        }ifelse
       }if
       exit
      }ifelse
     }loop  %% pels mots que es trepitgen

     nullExtra
     {  %% si aquest gatell és aciu voldrà dir que haurem inserit text entremig d'una cadena
      %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
      %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
      %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
      %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

      %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
      araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
      getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
      sub getinterval putinterval araRENG exch 0 exch put

      %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
      araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
      faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
      faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
      baUla exch putinterval araRENG exch 0 exch put

      %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
      araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
      getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
      sub getinterval putinterval araRENG exch 1 exch put

      %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
      araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
      faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
      faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
      baUla exch putinterval araRENG exch 1 exch put

      %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
      araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
      getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
      sub getinterval putinterval araRENG exch 2 exch put

      %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
      araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
      faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
      faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
      baUla exch putinterval araRENG exch 2 exch put

      %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
      araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
      getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
      sub getinterval putinterval araRENG exch 3 exch put

      %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
      araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
      faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
      faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
      baUla exch putinterval araRENG exch 3 exch put
     }if
    }stopped
    {
%QuinaFONT
%%araRENG 
%% iCw EncNETiPLANXAT
%% CalaixDeTipus araPlana get QuinaFONT get
%% Champollion{== ==}forall
%     ( ... peta Tj 0) pstack quit  %% UUUEEE
     ( ... peta Tj 0) pstack stop
    }if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %%sEdAs 40 write sEdAs exch writestring sEdAs 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add
       string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs (Tj\012) writestring
    %%}stopped{( ... peta Tj) == quit}if
   }
   {  %% 2 (correccio L·L)
    %%{  % stopped
    
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %%sEdAs 40 write sEdAs exch writestring sEdAs 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add
       string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs (Tj\012) writestring
    
    %%XsigneF == YsigneF == (>>>>>)pstack quit
    
    %% KTCS  computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm add
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def
    %% KTCS
    {  %% forall de la cadena de text
     %% KTCS  posicio x,y d'inici de caracter
     TxTm
     %%dup ==
     /XsigneO exch def  %% desem la posicio X d'inici de caracter
     TyTm
     %%dup ==
     /YsigneO exch def  %% desem la posicio Y d'inici de caracter
     %% treiem l'ample (Width metrics) de cada caracter ...
     CalaixDeTipus
%% UiX
araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     QuinaFONT get dup 1 get 2 index exch sub exch 2 get exch get
     %% aqui multipliquem l'ample de la metrica pel cos i dividim x 1000 + TxTm x saber la posicio del caracter seguent
     CxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul 1000 div TxTm add
     %% es suma a cada caracter el valor definit per Tc
     ecTc
     SxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul add  %% aquest factor definit per Tc sempre va multiplicat pel multiplicador d'escala X del cos del text
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TxTm exch put
     /TxTm exch def
     EncNETiPLANXAT exch get
     dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
     {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
      epTw
      SxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul  %% ep! que aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
      TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TxTm exch put
      /TxTm exch def
     }if
     %% KTCS  posicio x,y de final de caracter
     TxTm
     %%dup ==
     /XsigneF exch def  %% desem la posicio X de final de caracter
     TyTm
     %%dup ==
     /YsigneF exch def  %% desem la posicio Y de final de caracter
     %% procediment de cerca per un determinat parell d'inici/final
     
     dup
     %% /guillemotleft
     %% /zero
     /d
     eq  %% inici
     {
      pop
      (OBRIR ... ) ==
      /araE true def  %% obrim la generacio d'etiquetes
     }
     {
      dup
      %% /guillemotright
      %% /eight
      /i
      eq  %% final
      {
       pop
       ( ... TANCAR) ==
       /araE false def  %% tanquem la generacio d'etiquetes
       QueTa ==  %% treiem x la pantalleta x test
       /QueTa () def  %% inicialitzem
      }
      {
       araE
       {
        d_WAE exch get QueTa dup length 1 add string dup 3 -1 roll 0 exch putinterval  %% enganxem la cadena fins ara
        dup dup length 1 sub 4 -1 roll put /QueTa exch def  %% enganxem el nou caracter a la cadena
       }
       {
        pop
       }ifelse
      }ifelse
     }ifelse
     %% fi de procediment de cerca per un determinat parell d'inici/final
    }forall  %% de la cadena de text
    
    %%XsigneF YsigneF ()pstack quit
    
    %%}stopped{( ... peta Tj) == quit}if
   }
   {  %% 3 analisi textual x JBC
%% el first character de l'encoding es erroni
%% cal substituir el forall pel loop x manegar B l'unicode
%%0 2 getinterval /cU 4 string def cU /NullEncode filter /ASCIIHexEncode filter dup 3 -1 roll
%%writestring flushfile
%%{==}forall
%%length ==
%% EncNETiPLANXAT ==
%% WinAnsiEncoding2Bytes (0020) get 
%    {  %% stopped
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %%% hem eliminat salvaparent2.ps doncs com q no hem de reescriure l'string ara
    %%% creiem que no es necessari en absolut
    %% computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm add
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup dup EstatGrafic iEG get exch /TyTm exch put /TyTm exch def
    %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia dels valors:
    %% coordenada y i l'angle, d forma que els dos hauran de coincidir x considerar-los dins el mateix reng
    %%eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
    EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
    {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
     %%% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat    
     90NET
     {  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
cvi  %% EP!MASATS treballarem només amb l'enter
      256 string cvs
      EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
      TxTm
cvi  %% EP!MASATS treballarem només amb l'enter
      256 string cvs  %% ara lliguem la X en ves de l'angle
      1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
      6 -1 roll 0 exch putinterval
      UndeR (_) putinterval
      UndeR 1 add 4 -1 roll putinterval
     }
     {
cvi  %% EP!MASATS treballarem només amb l'enter
      256 string cvs
      EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
      1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
      6 -1 roll 0 exch putinterval
      UndeR (_) putinterval
      UndeR 1 add 4 -1 roll putinterval
     }ifelse
     %%%>>%%%
    }
    {
     /Aeix 0 def

     %%Mishima: filtrem la coordenada Y per tal siguin significatius fins a 7 decimals
%     10000 mul truncate 10000 div
cvi  %% EP!MASATS treballarem només amb l'enter
     128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
    }ifelse

    %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
    yRENGS araPlana get dup 2 index dup /clauCM exch def known
    {  %% existeix
     exch get /araRENG exch def  %% capturem l'array amb els elements del reng
     /HiHaY true def  %% el reng ja existeix
    }
    {  %% l'hem de crear
     exch
     [  %% array d'elements pel reng, on tots el seus index coincidiran!
      []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
      %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
      %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
      %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
      []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
      %% correctament on, si hi hagues una separacio (espai o no), contindria un null
      []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
      []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
      Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       null  %% 4: el cinque, ens indica si la linia es rotada (null=NO angle=SI)
      }
      {
       %%%
       Aeix  %% valor de l'angle
       %%%>>%%%
      }ifelse
     ]
     dup /araRENG exch def
     put  %% la desem al dic de la pagina
     /HiHaY false def  %% el reng NO existeix
     %% valors inicials de la translacio Tm de control signe a signe x concat
     /transX TxTm def
     /transY TyTm def
    }ifelse
    %% array de caracter amb les posicions:
    %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
    %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
    %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
    /iXfX 6 array def  %% ara de 6 posicions!

%%    {  % forall de la cadena de text

dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
/iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)
{  %% loop per cada un dels caracters de la cadena de text dins Tj
maxLoop 0 eq {pop exit}if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
dup
iU esUnicode{2 getinterval 1 get}{1 getinterval 0 get}ifelse

     /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
     %% posicio x,y d'inici de caracter
     TxTm
     %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
     Aeix 0 eq
     {
      %% ###################
      dup iXfX exch 0 exch put  %% x JBC
      %% ###################
     }
     {
      %%%
      dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
      {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
       pop
      }
      {
       div
      }ifelse
      iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
      %%%>>%%%
     }ifelse

     Aeix 0 eq  %% si l'eix no es rotat ...
     {  %% no cal q la normalitzem
      iXfX exch 2 exch put  %% coordenada X d'inici del signe
      iXfX 3 TyTm put  %% coordenada Y d'inici del signe
     }
     {  %% normalitzem
      %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
      gsave
      aTm
      %% si es un angle net de 90 graus, hem de treballar a escala 1
      90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
      %% la translacio q ens interessa es la del x,y d'origen del signe
      dup 3 -1 roll 4 exch put  %% posicio X d'inici
      dup 5 TyTm put  %% posicio Y d'inici
      %% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
      0 exch 0 exch
      concat
      matrix currentmatrix  %% valor de la matriu rotada
      grestore
      transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
      itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
      /transY exch def  %% desem pel proper concat?
      /transX exch def  %% desem pel proper concat?
      iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
      iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
     }ifelse

     %%%***
     %%(\n)print flush
     %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
     %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush
     %%%***
     %% treiem l'ample (Width metrics) de cada caracter ...
     CalaixDeTipus
%% UiX
     araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     QuinaFONT get
esUnicode
{
 1 index exch
}
{
 dup 1 get 2 index exch sub exch
}ifelse

     2 get  %% extraiem el paquet de la metrica
     exch
     get
     %% multipliquem l'ample d la metrica pel cos i dividim x1000+TxTm x saber la posicio del caracter seguent
     CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul 1000 div
     %% es suma a cada caracter el valor definit per Tc
     ecTc SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul add  %% aquest factor definit per Tc va multiplicat pel multiplicador d'escala X del cos del text
     dup /aS exch def  %% nomes l'ample del signe
     Aeix 0 eq
     {
      %% ###################
      TxTm add  %% sumem el valor anterior ara
      %% ###################
     }
     {
      %%%
      dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
      /XfLB exch def  %% desem la posicio X final del signe d linia d base x si hem d fer la correccio d'espai
      TxTm add  %% sumem el valor anterior ara
      %%%>>%%%
     }ifelse
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TxTm exch put
     /TxTm exch def
     EncNETiPLANXAT exch get
     dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
     {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
      epTw SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
      %%%
      Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
       dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
      }if
      %%%>>%%%
      TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TxTm exch put
      /TxTm exch def
     }if

     Aeix 0 eq  %% si l'eix no es rotat ...
     {  %% no cal q la normalitzem
      %% posicio x,y de final de caracter
      TxTm
      dup iXfX exch 1 exch put
      iXfX exch 4 exch put  %% coordenada X de final del signe
      TyTm
      iXfX exch 5 exch put  %% coordenada Y de final del signe
     }
     {  %% normalitzem
      %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
      gsave
      %% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
      aS abs  %% hem d'anul·lar el signe de l'amplada xq la coordenada corregida es calculi correctament
0
      aTm
      %% si es un angle net de 90 graus, hem de treballar a escala 1
      90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
      %% la translacio q ens interessa es identica a l'aTm anterior tret q sigui un angle net de 90 graus
      concat
      matrix currentmatrix  %% valor de la matriu rotada
      grestore
      transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
      itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
      dup /transY exch def  %% desem pel proper concat?
      /TyTm exch def  %% nova posisico Y d'inici pel proper signe
      dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
      /transX exch def  %% desem pel proper concat?
      iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
      iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
      %% desem la coordenada X de final de caracter mesurada en horitzontal
      Aeix 0 ne
      {  %% si es rotada
       iXfX 1 XfLB put
      }
      {  %% sense rotar
       iXfX 1 TxTm put
      }ifelse
     }ifelse
     %%%***
     %%iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
     %%iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
     %%(Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush
     %%%***

/nullExtra false def

     HiHaY
     {  %% el reng existeix
      araRENG 0 get
      {  %% forall de l'array de posicions
       dup type /nulltype eq
       {
        %%(AIXO es un NULL!!!)==
        pop
       }
       {
        0 get dup  %% l'inici del primer caracter de la cadena q ja tenim ...
        iXfX 0 get ge  %% ... es + gran o igual q el l'inici del signe q volem situar ...
        {  %% componem cap a l'esquerra
         pop
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
         0 /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index n-1
         %% que el seu origen es igualat o superat per l'origen de iXfX
         dup length 1 sub -1 0
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop
         aSuara 0 get
         iXfX 0 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         EnRETIRA sub

         dup 0 lt
         {  %% filtrem els valors negatius (fan petar l'algorisme!)
          pop 0
         }if
         %% fi del tram on podem afinar la tolerancia 
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
         NOmaseguis
         {  %% un anira darrera l'altre
          %% ampliem el primer array d'araRENG, de posicions X, EnRETIRA + x l'esquerra ...
          /EnRETIRA exch def  %% desem l'index posicionador
          araRENG 0 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          iXfX dup length array copy  %% x profilaxi!
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 0 exch put  %% desem
          %% ampliem el segon array d'araRENG, de noms de signes, EnRETIRA + x l'esquerra ...
          araRENG 1 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup 3 -1 roll
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 1 exch put  %% desem
          %% ampliem el tercer array d'araRENG, de tipus, EnRETIRA + x l'esquerra ...
          araRENG 2 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 QuinaFONT put  %% sempre sera a ZERO ?
          araRENG exch 2 exch put  %% desem
          %% ampliem el quart array d'araRENG, de cossos, EnRETIRA + x l'esquerra ...
          araRENG 3 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 CyTm put  %% sempre sera a ZERO ?
          araRENG exch 3 exch put  %% desem
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }
        {  %% componem cap a la dreta

/nullExtra true def

         pop          
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
         dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index 0
         %% que el seu origen es igualat o superat per l'origen de iXfX
         0 1 EnRETIRA
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'índex posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'índex posicionador definitiu
            %% que és el del darrer mot que és més petit o igual que el que estem situant, o dit
            %% d'una altra manera: el mot que està immediatament a l'esquerra del que situem
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop

%% no apliquem això ara:
%% comptem quants nulls hi ha entremig del mot de més a l'esquerra i el de més a la dreta
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena Tj
%% /hihaNulls 0 def
%% araRENG 0 get dup length 1 sub  %% final
%% EnRETIRA 1 add  %% inici
%% exch
%% 1 exch  %% salt
%% {  %% for
%%  1 index exch get
%%  type /nulltype eq
%%  { 
%%   hihaNulls 1 add /hihaNulls exch def
%%  }
%%  {
%%   exit
%%  }ifelse
%% }for
%% pop  %% ens carreguem l'array
%% }if  %% només un cop i a l'inici de la cadena Tj

%%% aqui es on cal estudiar si en tots els casos cal anar a buscar l'X correcte a ...
%%% l'index 0 d'araRENG treure'n la darrera array i pescar l'index 2: posicio X d'inici del
%%% darrer signe, doncs la linia de sota no tindria cap sentit (interroga el mateix signe!)
%%araRENG 0 get dup length 1 sub get 2 get ... aixo no va com ens pensem

         aSuara 1 get

         iXfX 1 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         %% fi del tram on podem afinar la tolerancia
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre

%% no apliquem això ara:
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena Tj
 %% si hi ha prous nulls entremig per contenir exactament la cadena que situem ara
%% 2 index length 2 add hihaNulls le
%% {  %% llavors, la situem immediatament després del mot de més a l'esquerra separada per un null
%%  pop 2  %% sumaran dues posicions cap a la dreta per que hi quedi un null entremig
%%  }if
%% }if  %% només un cop i a l'inici de la cadena Tj

          EnRETIRA add
          /EnRETIRA exch def  %% fixem finalment l'index real posicionador
          %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
          araRENG 0 get length EnRETIRA le
          {  %% aqui ampliem els arrays segons la diferencia d'index amb EnRETIRA
           EnRETIRA araRENG 0 get length 1 sub sub /Eixamplem exch def  %% de quant ampliem l'array?
           %% ampliem el primer array d'araRENG, de posicions X, Eixamplem + x la dreta
           araRENG 0 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA iXfX dup length array copy put  %% x profilaxi!
           araRENG exch 0 exch put  %% desem
           %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem + x la dreta
           araRENG 1 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA 4 -1 roll put
           araRENG exch 1 exch put  %% desem
           %% ampliem el tercer array d'araRENG, de tipus, Eixamplem + x la dreta
           araRENG 2 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA QuinaFONT put
           araRENG exch 2 exch put  %% desem
           %% ampliem el quart array d'araRENG, de cossos, Eixamplem + x la dreta
           araRENG 3 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA CyTm put
           araRENG exch 3 exch put  %% desem
          }
          {
           araRENG 0 get length EnRETIRA ge
           {  %% vol dir que el signe q afegim va entremig
            %% aqui els arrays o s'han d'ampliar pel mig 1+ a la posicio que marca EnRETIRA
            %% tret que ja hi hagi un null a l'index on apunta EnRETIRA!
            araRENG 0 get EnRETIRA get null ne
            {  %% no hi ha cap null, llavors ampliem
%araRENG 1 get dup EnRETIRA get (:-7)pstack quit
%false{
             %% l'array de posicions
             araRENG 0 get length dup 1 add array exch araRENG 0 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 0 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 0 exch put
             %% l'array de noms de signes
             araRENG 1 get length dup 1 add array exch araRENG 1 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 1 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 1 exch put
             %% l'array de tipus
             araRENG 2 get length dup 1 add array exch araRENG 2 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 2 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 2 exch put
             %% l'array de cossos
             araRENG 3 get length dup 1 add array exch araRENG 3 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 3 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 3 exch put
%}if
            }if
           }if
           %% ... o queden intactes de mida, doncs ja han quedat ampliats abans
           %% componem a l'index EnRETIRA el primer array d'araRENG, de posicions X
           araRENG 0 get dup
           iXfX dup length array copy  %% x profilaxi!
           EnRETIRA exch put
           araRENG exch 0 exch put  %% desem
           %% componem a l'index EnRETIRA el segon array d'araRENG, de noms de signes
           araRENG 1 get dup
           3 -1 roll
           EnRETIRA exch put
           araRENG exch 1 exch put  %% desem
           %% componem a l'index EnRETIRA el tercer array d'araRENG, de tipus
           araRENG 2 get dup
           QuinaFONT
           EnRETIRA exch put
           araRENG exch 2 exch put  %% desem
           %% componem a l'index EnRETIRA el quart array d'araRENG, de cossos
           araRENG 3 get dup
           CyTm
           EnRETIRA exch put
           araRENG exch 3 exch put  %% desem
          }ifelse  %% ampliem l'array?
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }ifelse  %% componem cap a l'esquerra o cap a la dreta
       }ifelse  %% null o no?
      }forall  %% de l'array de posicions
     }
     {  %% el reng NO existeix
      %% ampliem el primer array d'araRENG, de posicions X, 1+ x la dreta ...
      iXfX dup length array copy  %% x profilaxi!
      araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
      %% ampliem el segon array d'araRENG, de noms de signes, 1+ x la dreta ...
      araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
      %% ampliem el tercer array d'araRENG, de tipus, 1+ x la dreta ...
      QuinaFONT
      araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
      %% ampliem el quart array d'araRENG, de cossos, 1+ x la dreta ...
      CyTm
      araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
     }ifelse
     %% test
     %%isiGne 1 add /isiGne exch def

 iU esUnicode{2}{1}ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
 iU maxLoop ge
 {
esUnicode{length 2 idiv /faCadena exch def}{length/faCadena exch def}ifelse
  %%pop
  exit
 } if  %% hem llegit tota la cadena?
} loop  %% x cada un dels caracters del la cadena de dins el Tj

nullExtra
{  %% si aquest gatell és aciu voldrà dir que haurem inserit text entremig d'una cadena
 %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
 %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
 %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
 %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

 %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 0 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 0 exch put

 %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 1 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 1 exch put

 %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 2 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 2 exch put

 %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 3 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 3 exch put
}if

%%    }forall  % de la cadena de text    

%%MASATStext
CursivaMentidera  %% si hi ha falses cursives
{  %% desem dins el diccionari (alerta amb el context!) de l'índex que apunta a la pàgina la clau d'yRENGS
 userdict /yCursivesMentideres get length
 araPlana 6 string cvs cvx exec dup /araVa exch def
 le
 {  %% el dic de la pàgina NO existeix
  araVa 1 add array dup 0 userdict /yCursivesMentideres get putinterval
  dup araVa <<clauCM null>> put  %% donem d'alta el nou dic de pàgina
  /yCursivesMentideres exch userdict 3 1 roll put
 }
 {  %% el dic de la pàgina potser existeix
  userdict /yCursivesMentideres get araVa get null eq
  {  %% encara no
   userdict /yCursivesMentideres get araVa <<clauCM null>> put  %% donem d'alta el nou dic de pàgina
  }
  {  %% ja existeix i ampliem el diccionari
   userdict /yCursivesMentideres get dup araVa get dup clauCM null put araVa exch put
  }ifelse
 }ifelse
}if

%    }stopped
%    {
%% QuinaFONT
%%araRENG 
%% iCw EncNETiPLANXAT
%% CalaixDeTipus araPlana get QuinaFONT get
%% Champollion{== ==}forall
%     ( ... peta Tj) pstack stop  %%quit
%    }if
   }
   {  %% 4 dada variable
    faDADAv  %% gatell per controlar l'activat d'operadors amb funcions de dada variable
    {  %% bastim el diccionari tipusDADAv
     tipusDADAv araPlana known
     {
      tipusDADAv araPlana get
      dup nomDADAclau known
      {  %% si el nom clau de la dada variable és repetit cal estar segurs que comparteixen la mateixa font PDF
       nomDADAclau get QuinaFONT ne
       {  %% si no tenen la mateixa tipografia pleguem per prevenció
        (\n\n ... teniu dues dades variables identiques que comparteixen tipografies diferents!\n) print flush
        ( ... heu d'etiquetar els artefactes amb noms diferents ... pleguem!\n\n)print flush stop
       }if
      }
      {  %% afegim la nova clau de dada variable
       dup nomDADAclau QuinaFONT put
       tipusDADAv exch araPlana exch put  %% redesem
      }ifelse
     }
     {  %% donem d'alta per primer cop la plana i el parell clau de dada variable i font PDF
      tipusDADAv araPlana << nomDADAclau QuinaFONT>> put
     }ifelse
%EncNETiPLANXAT(:-5)pstack quit
    }if
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %%sEdAs 40 write sEdAs exch writestring sEdAs 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add
       string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs (Tj\012) writestring
    %%}stopped{( ... peta Tj) == quit}if
   }
   {  %% 5 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
      %%TiNTeM {  % es la tinta que toca ara ?
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %% posem els caracters ( ... ) com a cadena
      dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
      dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
      %%% fi de salvaparent2.ps
      sEdAs exch writestring
      sEdAs 32 write sEdAs (Tj\012) writestring
      %%}{pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta Tj) == quit}if
   }
  ] i_Tj get /Tj exch bind def

  [  %% /'
   {  %% 0 (arbre jeràrquic) | gatells: 16
    {  % stopped
    dup dup length string copy  %% fem una còpia descontaminada per salvaparent i l'escriptura
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs ('\012) writestring
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% establim les coordenades inicials de la cadena
    %% desant en unes variables particulars per aquest operador

CursivaMentidera
{
0
INTERli neg
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put

%%% sembla com si aqui hi hagues d'anar un valor dinamic en funcio d'X i algun altre factor
dup 4 iTyTm iTxTm div put  %% s'hi aproxima molt pero AIXO NO ES
%%dup 5 1 put

concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

%%(:-b)pstack quit
pop iTxTm add   %% valor X a corregir
/iTxTm exch def  %% nou inici absolut de la linia X
}if

    iTxTm
    dup /TxTm exch def  %% aquets operadors sempre comencen a composar a l'X inicial de la cadena anterior
    /TxTm_ exch def
    iTyTm INTERli sub dup /TyTm_ exch def
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def
    %% KTCS  computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm_ add dup /TyTm_ exch def

%%% darrer retoc
dup /TyTm exch def

    %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia dels valors:
    %% coordenada y i l'angle, d forma que els dos hauran d coincidir xq siguin considerats dins el mateix reng
    %%eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
    EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
    {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
     %%% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat    

90NET
{  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
cvi  %% EP!MASATS treballarem només amb l'enter
256 string cvs
EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
TxTm
cvi  %% EP!MASATS treballarem només amb l'enter
256 string cvs  %% ara lliguem la X en ves de l'angle
1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
6 -1 roll 0 exch putinterval
UndeR (_) putinterval
UndeR 1 add 4 -1 roll putinterval
}
{
cvi  %% EP!MASATS treballarem només amb l'enter
     256 string cvs
     EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
     1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
     6 -1 roll 0 exch putinterval
     UndeR (_) putinterval
     UndeR 1 add 4 -1 roll putinterval
     %%%>>%%%
}ifelse

    }
    {
     /Aeix 0 def
cvi  %% EP!MASATS treballarem només amb l'enter
     128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
    }ifelse
    %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
    yRENGS araPlana get dup 2 index known
    {  %% existeix
     exch get /araRENG exch def  %% capturem l'array amb els elements del reng
     /HiHaY true def  %% el reng ja existeix
    }
    {  %% l'hem de crear
     exch
     [  %% array d'elements pel reng, on tots el seus index coincidiran!
      []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
      %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
      %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
      %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
      []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
       %% correctament on, si hi hagues una separacio (espai o no), contindria un null
      []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
      []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
      Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
      }
      {
       %%%
       Aeix  %% valor de l'angle
       %%%>>%%%
      }ifelse
     ]
     dup /araRENG exch def
     put  %% la desem al dic de la pagina
     /HiHaY false def  %% el reng NO existeix
     %% valors inicials de la translacio Tm de control signe a signe x concat
     /transX TxTm def
     /transY TyTm def
    }ifelse
    %% array de caracter amb les posicions:
    %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
    %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
    %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
    /iXfX 6 array def  %% ara de 6 posicions!
    %%% test
    %% /isiGne 0 def

%%    {  % forall de la cadena de text

dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
/iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)
{  %% loop per cada un dels caracters de la cadena de text dins '
maxLoop 0 eq {pop exit}if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
dup
iU esUnicode{2 getinterval 1 get}{1 getinterval 0 get}ifelse

     /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
     %% posicio x,y d'inici de caracter
     TxTm
     %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
     Aeix 0 eq
     {
      %% ###################
      dup iXfX exch 0 exch put  %% x JBC
      %% ###################
     }
     {
      %%%
      dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
      {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
       pop
      }
      {
       div
      }ifelse iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
      %%%>>%%%
     }ifelse

Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
iXfX exch 2 exch put  %% coordenada X d'inici del signe
iXfX 3 TyTm put  %% coordenada Y d'inici del signe
}
{  %% normalitzem
%% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
gsave
aTm
%% si es un angle net de 90 graus, hem de treballar a escala 1
90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
%% la translacio q ens interessa es la del x,y d'origen del signe
dup 3 -1 roll 4 exch put  %% posicio X d'inici
dup 5 TyTm put  %% posicio Y d'inici
%% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
0 exch 0 exch
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
/transY exch def  %% desem pel proper concat?
/transX exch def  %% desem pel proper concat?
iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
}ifelse

     %%%***
     %%(\n)print flush
     %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
     %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush
     %%%***
     %% treiem l'ample (Width metrics) de cada caracter ...
     CalaixDeTipus
%% UiX
araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     QuinaFONT get

esUnicode
{
1 index exch
}
{

     dup 1 get 2 index exch sub exch

}ifelse

     2 get exch get
     %% multipliquem l'ample d la metrica pel cos i dividim x1000+TxTm x saber la posicio del caracter seguent
     CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul 1000 div  %%TxTm add
     %% es suma a cada caracter el valor definit per Tc
     ecTc
     SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul add  %% aquest factor definit per Tc va multiplicat pel multiplicador d'escala X del cos del text
     dup /aS exch def  %% nomes l'ample del signe
     Aeix 0 eq
     {
      %% ###################
      TxTm add  %% sumem el valor anterior ara
      %% ###################
     }
     {
      %%%
      dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
      %% desem la posicio X final del signe de la linia de base x si hem de fer la correccio d'espai
      /XfLB exch def
      TxTm add  %% sumem el valor anterior ara
      %%%>>%%%
     }ifelse
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TxTm exch put
     /TxTm exch def
     EncNETiPLANXAT exch get
     dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
     {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
      epTw
      SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
      %%%
      Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
       dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
      }if
      %%%>>%%%
      TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TxTm exch put
      /TxTm exch def
     }if
     %%%

Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
%% posicio x,y de final de caracter
TxTm
dup iXfX exch 1 exch put
iXfX exch 4 exch put  %% coordenada X de final del signe
TyTm
iXfX exch 5 exch put  %% coordenada Y de final del signe
}
{  %% normalitzem
%% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
gsave
%% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
aS abs  %% hem d'anul?lar el signe de l'amplada xq la coordenada corregida es calculi correctament
0
aTm
%% si es un angle net de 90 graus, hem de treballar a escala 1
90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
%% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
dup /transY exch def  %% desem pel proper concat?
/TyTm exch def  %% nova posisico Y d'inici pel proper signe
dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
/transX exch def  %% desem pel proper concat?
iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
%% desem la coordenada X de final de caracter mesurada en horitzontal
Aeix 0 ne
{  %% si es rotada
iXfX 1 XfLB put
}
{  %% sense rotar
iXfX 1 TxTm put
}ifelse
}ifelse

     %%%***
     %%iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
     %%iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
     %%(Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush
     %%%***

/nullExtra false def

     HiHaY
     {  %% el reng existeix
      araRENG 0 get
      {  %% forall de l'array de posicions
       dup type /nulltype eq
       {
        %%(AIXO es un NULL!!!)==
        pop
       }
       {
        0 get dup  %% l'inici del primer caracter de la cadena q ja tenim ...
        iXfX 0 get ge  %% ... es + gran o igual q el l'inici del signe q volem situar ...
        {  %% componem cap a l'esquerra
         pop
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
         0 /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index n-1
         %% que el seu origen es igualat o superat per l'origen de iXfX
         dup length 1 sub -1 0
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop
         aSuara 0 get
         iXfX 0 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         EnRETIRA sub

         dup 0 lt
         {  %% filtrem els valors negatius (fan petar l'algorisme!)
          pop 0
         }if
         %% fi del tram on podem afinar la tolerancia 
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre
          %% ampliem el primer array d'araRENG, de posicions X, EnRETIRA + x l'esquerra ...
          /EnRETIRA exch def  %% desem l'index posicionador
          araRENG 0 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          iXfX dup length array copy  %% x profilaxi!
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 0 exch put  %% desem
          %% ampliem el segon array d'araRENG, de noms de signes, EnRETIRA + x l'esquerra ...
          araRENG 1 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup 3 -1 roll
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 1 exch put  %% desem
          %% ampliem el tercer array d'araRENG, de tipus, EnRETIRA + x l'esquerra ...
          araRENG 2 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 QuinaFONT put  %% sempre sera a ZERO ?
          araRENG exch 2 exch put  %% desem
          %% ampliem el quart array d'araRENG, de cossos, EnRETIRA + x l'esquerra ...
          araRENG 3 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 CyTm put  %% sempre sera a ZERO ?
          araRENG exch 3 exch put  %% desem
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }
        {  %% componem cap a la dreta

/nullExtra true def

         pop          
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
         dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index 0
         %% que el seu origen es igualat o superat per l'origen de iXfX
         0 1 EnRETIRA
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop

%% no apliquem això ara:
%% comptem quants nulls hi ha entremig del mot de més a l'esquerra i el de més a la dreta
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena '
%% /hihaNulls 0 def
%% araRENG 0 get dup length 1 sub  %% final
%% EnRETIRA 1 add  %% inici
%% exch
%% 1 exch  %% salt
%% {  %% for
%%  1 index exch get
%%  type /nulltype eq
%%  { 
%%   hihaNulls 1 add /hihaNulls exch def
%%  }
%%  {
%%   exit
%%  }ifelse
%% }for
%% pop  %% ens carreguem l'array
%% }if  %% només un cop i a l'inici de la cadena '

         aSuara 1 get
         iXfX 1 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         %% fi del tram on podem afinar la tolerancia
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre

%% no apliquem això ara:
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena '
 %% si hi ha prous nulls entremig per contenir exactament la cadena que situem ara
%% 2 index length 2 add hihaNulls le
%% {  %% llavors, la situem immediatament després del mot de més a l'esquerra separada per un null
%%  pop 2  %% sumaran dues posicions cap a la dreta per que hi quedi un null entremig
%% }if
%% }if  %% només un cop i a l'inici de la cadena '

          EnRETIRA add
          /EnRETIRA exch def  %% fixem finalment l'index real posicionador
          araRENG 0 get length EnRETIRA le
          {  %% aqui ampliem els arrays segons la diferencia d'index amb EnRETIRA
           EnRETIRA araRENG 0 get length 1 sub sub /Eixamplem exch def  %% de quant ampliem l'array?
           %% ampliem el primer array d'araRENG, de posicions X, Eixamplem + x la dreta
           araRENG 0 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA iXfX dup length array copy put  %% x profilaxi!
           araRENG exch 0 exch put  %% desem
           %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem + x la dreta
           araRENG 1 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA 4 -1 roll put
           araRENG exch 1 exch put  %% desem
           %% ampliem el tercer array d'araRENG, de tipus, Eixamplem + x la dreta
           araRENG 2 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA QuinaFONT put
           araRENG exch 2 exch put  %% desem
           %% ampliem el quart array d'araRENG, de cossos, Eixamplem + x la dreta
           araRENG 3 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA CyTm put
           araRENG exch 3 exch put  %% desem
          }
          {
           araRENG 0 get length EnRETIRA ge
           {  %% vol dir que el signe q afegim va entremig
            %% aqui els arrays o s'han d'ampliar pel mig 1+ a la posicio que marca EnRETIRA
            %% tret que ja hi hagi un null a l'index on apunta EnRETIRA!
            araRENG 0 get EnRETIRA get null ne
            {  %% no hi ha cap null, llavors ampliem
             %% l'array de posicions
             araRENG 0 get length dup 1 add array exch araRENG 0 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 0 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 0 exch put
             %% l'array de noms de signes
             araRENG 1 get length dup 1 add array exch araRENG 1 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 1 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 1 exch put
             %% l'array de tipus
             araRENG 2 get length dup 1 add array exch araRENG 2 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 2 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 2 exch put
             %% l'array de cossos
             araRENG 3 get length dup 1 add array exch araRENG 3 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 3 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 3 exch put
            }if
           }if
           %% ... o queden intactes de mida, doncs ja han quedat ampliats abans
           %% componem a l'index EnRETIRA el primer array d'araRENG, de posicions X
           araRENG 0 get dup
           iXfX dup length array copy  %% x profilaxi!
           EnRETIRA exch put
           araRENG exch 0 exch put  %% desem
           %% componem a l'index EnRETIRA el segon array d'araRENG, de noms de signes
           araRENG 1 get dup
           3 -1 roll
           EnRETIRA exch put
           araRENG exch 1 exch put  %% desem
           %% componem a l'index EnRETIRA el tercer array d'araRENG, de tipus
           araRENG 2 get dup
           QuinaFONT
           EnRETIRA exch put
           araRENG exch 2 exch put  %% desem
           %% componem a l'index EnRETIRA el quart array d'araRENG, de cossos
           araRENG 3 get dup
           CyTm
           EnRETIRA exch put
           araRENG exch 3 exch put  %% desem
          }ifelse  %% ampliem l'array?
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }ifelse  %% componem cap a l'esquerra o cap a la dreta
       }ifelse  %% null o no?
      }forall  %% de l'array de posicions
     }
     {  %% el reng NO existeix
      %% ampliem el primer array d'araRENG, de posicions X, 1+ x la dreta ...
      iXfX dup length array copy  %% x profilaxi!
      araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
      %% ampliem el segon array d'araRENG, de noms de signes, 1+ x la dreta ...
      araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
      %% ampliem el tercer array d'araRENG, de tipus, 1+ x la dreta ...
      QuinaFONT
      araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
      %% ampliem el quart array d'araRENG, de cossos, 1+ x la dreta ...
      CyTm
      araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
     }ifelse
     %% test
     %%isiGne 1 add /isiGne exch def

 iU esUnicode{2}{1}ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
 iU maxLoop ge
 {
esUnicode{length 2 idiv /faCadena exch def}{length/faCadena exch def}ifelse
  %%pop
  exit
 } if  %% hem llegit tota la cadena?
} loop  %% x cada un dels caracters del la cadena de dins '

nullExtra
{  %% si aquest gatell és aciu voldrà dir que haurem inserit text entremig d'una cadena
 %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
 %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
 %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
 %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

 %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 0 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 0 exch put

 %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 1 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 1 exch put

 %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 2 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 2 exch put

 %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 3 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 3 exch put
}if

%%    }forall  % de la cadena de text

    %% cal restablir les coordenades particulars d'execucio de l'operador a les generiques del document
%%    TxTm_
TxTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TxTm exch put
    /TxTm exch def
%%   TyTm_
TyTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def
    }stopped{( ... peta ' 0) pstack stop}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %%sEdAs 40 write sEdAs exch writestring sEdAs 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs ('\012) writestring
    %%}stopped{( ... peta ') == quit}if
   }
   {  %% 2 (correccio L·L)
    {  %% stopped
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %%sEdAs 40 write sEdAs exch writestring sEdAs 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs ('\012) writestring
    
    %% KTCS  establim les coordenades inicials de la cadena
    %% desant en unes variables particulars per aquest operador
    iTxTm /TxTm_ exch def iTyTm INTERli sub dup /TyTm_ exch def
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def
    %% KTCS  computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm_ add /TyTm_ exch def
    %% KTCS
    {  %% forall de la cadena de text
     %% KTCS  posicio x,y d'inici de caracter
     TxTm_
     %%dup ==
     /XsigneO exch def  %% desem la posicio X d'inici de caracter
     TyTm_
     %%dup ==
     /YsigneO exch def  %% desem la posicio Y d'inici de caracter
     %% treiem l'ample (Width metrics) de cada caracter ...
     CalaixDeTipus
%% UiX
araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     QuinaFONT get dup 1 get 2 index exch sub exch 2 get exch get
     %% aqui multipliquem l'ample de la metrica pel cos i dividim x 1000 + TxTm x saber la posicio del caracter seguent
     CxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul 1000 div TxTm_ add
     %% es suma a cada caracter el valor definit per Tc
     ecTc
     SxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul add  %% aquest factor definit per Tc sempre va multiplicat pel multiplicador d'escala X del cos del text
     /TxTm_ exch def
     EncNETiPLANXAT exch get
     dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
     {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
      epTw
      SxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul  %% ep! que aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
      TxTm_ add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
      /TxTm_ exch def
     }if
     %% KTCS  posicio x,y de final de caracter
     TxTm_
     %%dup ==
     /XsigneF exch def  %% desem la posicio X de final de caracter
     TyTm_
     %%dup ==
     /YsigneF exch def  %% desem la posicio Y de final de caracter
     %% procediment de cerca per un determinat parell d'inici/final
     dup /guillemotleft  eq  %% inici
     {
      pop
      %%(OBRIR ...) ==
      /araE true def  %% obrim la generacio d'etiquetes
     }
     {
      dup /guillemotright eq  %% final
      {
       pop
       %%( ... TANCAR) ==
       /araE false def  %% tanquem la generacio d'etiquetes
       %%QueTa ==  % treiem x la pantalleta x test
       /QueTa () def  %% inicialitzem
      }
      {
       araE
       {
        d_WAE exch get QueTa dup length 1 add string dup 3 -1 roll 0 exch putinterval  %% enganxem la cadena fins ara
        dup dup length 1 sub 4 -1 roll put /QueTa exch def  %% enganxem el nou caracter a la cadena
       }
       {
        pop
       }ifelse
      }ifelse
     }ifelse
     %% fi de procediment de cerca per un determinat parell d'inici/final
    }forall  %% de la cadena de text
    %% KTCS  cal restablir les coordenades particular d'execucio de l'operador a les generiques del document
    TxTm_
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TxTm exch put
    /TxTm exch def TyTm_
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def
    }stopped{( .... peta ') == stop}if
   }
   {  %% 3 analisi textual x JBC
    %%{  % stopped
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% establim les coordenades inicials de la cadena
    %% desant en unes variables particulars per aquest operador

CursivaMentidera
{
0
INTERli neg
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put

%%% sembla com si aqui hi hagues d'anar un valor dinamic en funcio d'X i algun altre factor
dup 4 iTyTm iTxTm div put  %% s'hi aproxima molt pero AIXO NO ES
%%dup 5 1 put

concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

%%(:-b)pstack quit
pop iTxTm add   %% valor X a corregir
/iTxTm exch def  %% nou inici absolut de la linia X
}if

    iTxTm
    dup /TxTm exch def  %% aquets operadors sempre comencen a composar a l'X inicial de la cadena anterior
    /TxTm_ exch def
    iTyTm INTERli sub dup /TyTm_ exch def
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def
    %% KTCS  computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm_ add dup /TyTm_ exch def

%%% darrer retoc
dup /TyTm exch def

    %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia dels valors:
    %% coordenada y i l'angle, d forma que els dos hauran d coincidir xq siguin considerats dins el mateix reng
    %%eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
    EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
    {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
     %%% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat    

90NET
{  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
cvi  %% EP!MASATS treballarem només amb l'enter
256 string cvs
EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
TxTm
cvi  %% EP!MASATS treballarem només amb l'enter
256 string cvs  %% ara lliguem la X en ves de l'angle
1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
6 -1 roll 0 exch putinterval
UndeR (_) putinterval
UndeR 1 add 4 -1 roll putinterval
}
{
cvi  %% EP!MASATS treballarem només amb l'enter
     256 string cvs
     EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
     1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
     6 -1 roll 0 exch putinterval
     UndeR (_) putinterval
     UndeR 1 add 4 -1 roll putinterval
     %%%>>%%%
}ifelse

    }
    {
     /Aeix 0 def

     %%Mishima: filtrem la coordenada Y per tal siguin significatius fins a 7 decimals
%     10000 mul truncate 10000 div
cvi  %% EP!MASATS treballarem només amb l'enter
     128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
    }ifelse
    %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
    yRENGS araPlana get dup 2 index known
    {  %% existeix
     exch get /araRENG exch def  %% capturem l'array amb els elements del reng
     /HiHaY true def  %% el reng ja existeix
    }
    {  %% l'hem de crear
     exch
     [  %% array d'elements pel reng, on tots el seus index coincidiran!
      []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
      %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
      %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
      %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
      []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
       %% correctament on, si hi hagues una separacio (espai o no), contindria un null
      []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
      []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
      Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
      }
      {
       %%%
       Aeix  %% valor de l'angle
       %%%>>%%%
      }ifelse
     ]
     dup /araRENG exch def
     put  %% la desem al dic de la pagina
     /HiHaY false def  %% el reng NO existeix
     %% valors inicials de la translacio Tm de control signe a signe x concat
     /transX TxTm def
     /transY TyTm def
    }ifelse
    %% array de caracter amb les posicions:
    %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
    %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
    %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
    /iXfX 6 array def  %% ara de 6 posicions!
    %%% test
    %% /isiGne 0 def

%%    {  % forall de la cadena de text

dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
/iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)
{  %% loop per cada un dels caracters de la cadena de text dins '
maxLoop 0 eq {pop exit}if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
dup
iU esUnicode{2 getinterval 1 get}{1 getinterval 0 get}ifelse

     /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
     %% posicio x,y d'inici de caracter
     TxTm
     %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
     Aeix 0 eq
     {
      %% ###################
      dup iXfX exch 0 exch put  %% x JBC
      %% ###################
     }
     {
      %%%
      dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
      {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
       pop
      }
      {
       div
      }ifelse iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
      %%%>>%%%
     }ifelse

Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
iXfX exch 2 exch put  %% coordenada X d'inici del signe
iXfX 3 TyTm put  %% coordenada Y d'inici del signe
}
{  %% normalitzem
%% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
gsave
aTm
%% si es un angle net de 90 graus, hem de treballar a escala 1
90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
%% la translacio q ens interessa es la del x,y d'origen del signe
dup 3 -1 roll 4 exch put  %% posicio X d'inici
dup 5 TyTm put  %% posicio Y d'inici
%% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
0 exch 0 exch
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
/transY exch def  %% desem pel proper concat?
/transX exch def  %% desem pel proper concat?
iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
}ifelse

     %%%***
     %%(\n)print flush
     %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
     %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush
     %%%***
     %% treiem l'ample (Width metrics) de cada caracter ...
     CalaixDeTipus
%% UiX
araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     QuinaFONT get

esUnicode
{
1 index exch
}
{

     dup 1 get 2 index exch sub exch

}ifelse

     2 get exch get
     %% multipliquem l'ample d la metrica pel cos i dividim x1000+TxTm x saber la posicio del caracter seguent
     CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul 1000 div  %%TxTm add
     %% es suma a cada caracter el valor definit per Tc
     ecTc
     SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul add  %% aquest factor definit per Tc va multiplicat pel multiplicador d'escala X del cos del text
     dup /aS exch def  %% nomes l'ample del signe
     Aeix 0 eq
     {
      %% ###################
      TxTm add  %% sumem el valor anterior ara
      %% ###################
     }
     {
      %%%
      dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
      %% desem la posicio X final del signe de la linia de base x si hem de fer la correccio d'espai
      /XfLB exch def
      TxTm add  %% sumem el valor anterior ara
      %%%>>%%%
     }ifelse
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TxTm exch put
     /TxTm exch def
     EncNETiPLANXAT exch get
     dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
     {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
      epTw
      SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
      %%%
      Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
       dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
      }if
      %%%>>%%%
      TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TxTm exch put
      /TxTm exch def
     }if
     %%%

Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
%% posicio x,y de final de caracter
TxTm
dup iXfX exch 1 exch put
iXfX exch 4 exch put  %% coordenada X de final del signe
TyTm
iXfX exch 5 exch put  %% coordenada Y de final del signe
}
{  %% normalitzem
%% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
gsave
%% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
aS abs  %% hem d'anul?lar el signe de l'amplada xq la coordenada corregida es calculi correctament
0
aTm
%% si es un angle net de 90 graus, hem de treballar a escala 1
90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
%% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
dup /transY exch def  %% desem pel proper concat?
/TyTm exch def  %% nova posisico Y d'inici pel proper signe
dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
/transX exch def  %% desem pel proper concat?
iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
%% desem la coordenada X de final de caracter mesurada en horitzontal
Aeix 0 ne
{  %% si es rotada
iXfX 1 XfLB put
}
{  %% sense rotar
iXfX 1 TxTm put
}ifelse
}ifelse

     %%%***
     %%iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
     %%iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
     %%(Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush
     %%%***

/nullExtra false def

     HiHaY
     {  %% el reng existeix
      araRENG 0 get
      {  %% forall de l'array de posicions
       dup type /nulltype eq
       {
        %%(AIXO es un NULL!!!)==
        pop
       }
       {
        0 get dup  %% l'inici del primer caracter de la cadena q ja tenim ...
        iXfX 0 get ge  %% ... es + gran o igual q el l'inici del signe q volem situar ...
        {  %% componem cap a l'esquerra
         pop
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
         0 /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index n-1
         %% que el seu origen es igualat o superat per l'origen de iXfX
         dup length 1 sub -1 0
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop
         aSuara 0 get
         iXfX 0 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         EnRETIRA sub

         dup 0 lt
         {  %% filtrem els valors negatius (fan petar l'algorisme!)
          pop 0
         }if
         %% fi del tram on podem afinar la tolerancia 
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre
          %% ampliem el primer array d'araRENG, de posicions X, EnRETIRA + x l'esquerra ...
          /EnRETIRA exch def  %% desem l'index posicionador
          araRENG 0 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          iXfX dup length array copy  %% x profilaxi!
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 0 exch put  %% desem
          %% ampliem el segon array d'araRENG, de noms de signes, EnRETIRA + x l'esquerra ...
          araRENG 1 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup 3 -1 roll
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 1 exch put  %% desem
          %% ampliem el tercer array d'araRENG, de tipus, EnRETIRA + x l'esquerra ...
          araRENG 2 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 QuinaFONT put  %% sempre sera a ZERO ?
          araRENG exch 2 exch put  %% desem
          %% ampliem el quart array d'araRENG, de cossos, EnRETIRA + x l'esquerra ...
          araRENG 3 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 CyTm put  %% sempre sera a ZERO ?
          araRENG exch 3 exch put  %% desem
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }
        {  %% componem cap a la dreta

/nullExtra true def

         pop          
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
         dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index 0
         %% que el seu origen es igualat o superat per l'origen de iXfX
         0 1 EnRETIRA
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop

%% no apliquem això ara:
%% comptem quants nulls hi ha entremig del mot de més a l'esquerra i el de més a la dreta
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena '
%% /hihaNulls 0 def
%% araRENG 0 get dup length 1 sub  %% final
%% EnRETIRA 1 add  %% inici
%% exch
%% 1 exch  %% salt
%% {  %% for
%%  1 index exch get
%%  type /nulltype eq
%%  { 
%%   hihaNulls 1 add /hihaNulls exch def
%%  }
%%  {
%%   exit
%%  }ifelse
%% }for
%% pop  %% ens carreguem l'array
%% }if  %% només un cop i a l'inici de la cadena '

         aSuara 1 get
         iXfX 1 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         %% fi del tram on podem afinar la tolerancia
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre

%% no apliquem això ara:
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena '
 %% si hi ha prous nulls entremig per contenir exactament la cadena que situem ara
%% 2 index length 2 add hihaNulls le
%% {  %% llavors, la situem immediatament després del mot de més a l'esquerra separada per un null
%%  pop 2  %% sumaran dues posicions cap a la dreta per que hi quedi un null entremig
%% }if
%% }if  %% només un cop i a l'inici de la cadena '

          EnRETIRA add
          /EnRETIRA exch def  %% fixem finalment l'index real posicionador
          araRENG 0 get length EnRETIRA le
          {  %% aqui ampliem els arrays segons la diferencia d'index amb EnRETIRA
           EnRETIRA araRENG 0 get length 1 sub sub /Eixamplem exch def  %% de quant ampliem l'array?
           %% ampliem el primer array d'araRENG, de posicions X, Eixamplem + x la dreta
           araRENG 0 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA iXfX dup length array copy put  %% x profilaxi!
           araRENG exch 0 exch put  %% desem
           %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem + x la dreta
           araRENG 1 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA 4 -1 roll put
           araRENG exch 1 exch put  %% desem
           %% ampliem el tercer array d'araRENG, de tipus, Eixamplem + x la dreta
           araRENG 2 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA QuinaFONT put
           araRENG exch 2 exch put  %% desem
           %% ampliem el quart array d'araRENG, de cossos, Eixamplem + x la dreta
           araRENG 3 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA CyTm put
           araRENG exch 3 exch put  %% desem
          }
          {
           araRENG 0 get length EnRETIRA ge
           {  %% vol dir que el signe q afegim va entremig
            %% aqui els arrays o s'han d'ampliar pel mig 1+ a la posicio que marca EnRETIRA
            %% tret que ja hi hagi un null a l'index on apunta EnRETIRA!
            araRENG 0 get EnRETIRA get null ne
            {  %% no hi ha cap null, llavors ampliem
             %% l'array de posicions
             araRENG 0 get length dup 1 add array exch araRENG 0 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 0 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 0 exch put
             %% l'array de noms de signes
             araRENG 1 get length dup 1 add array exch araRENG 1 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 1 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 1 exch put
             %% l'array de tipus
             araRENG 2 get length dup 1 add array exch araRENG 2 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 2 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 2 exch put
             %% l'array de cossos
             araRENG 3 get length dup 1 add array exch araRENG 3 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 3 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 3 exch put
            }if
           }if
           %% ... o queden intactes de mida, doncs ja han quedat ampliats abans
           %% componem a l'index EnRETIRA el primer array d'araRENG, de posicions X
           araRENG 0 get dup
           iXfX dup length array copy  %% x profilaxi!
           EnRETIRA exch put
           araRENG exch 0 exch put  %% desem
           %% componem a l'index EnRETIRA el segon array d'araRENG, de noms de signes
           araRENG 1 get dup
           3 -1 roll
           EnRETIRA exch put
           araRENG exch 1 exch put  %% desem
           %% componem a l'index EnRETIRA el tercer array d'araRENG, de tipus
           araRENG 2 get dup
           QuinaFONT
           EnRETIRA exch put
           araRENG exch 2 exch put  %% desem
           %% componem a l'index EnRETIRA el quart array d'araRENG, de cossos
           araRENG 3 get dup
           CyTm
           EnRETIRA exch put
           araRENG exch 3 exch put  %% desem
          }ifelse  %% ampliem l'array?
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }ifelse  %% componem cap a l'esquerra o cap a la dreta
       }ifelse  %% null o no?
      }forall  %% de l'array de posicions
     }
     {  %% el reng NO existeix
      %% ampliem el primer array d'araRENG, de posicions X, 1+ x la dreta ...
      iXfX dup length array copy  %% x profilaxi!
      araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
      %% ampliem el segon array d'araRENG, de noms de signes, 1+ x la dreta ...
      araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
      %% ampliem el tercer array d'araRENG, de tipus, 1+ x la dreta ...
      QuinaFONT
      araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
      %% ampliem el quart array d'araRENG, de cossos, 1+ x la dreta ...
      CyTm
      araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
     }ifelse
     %% test
     %%isiGne 1 add /isiGne exch def

 iU esUnicode{2}{1}ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
 iU maxLoop ge
 {
esUnicode{length 2 idiv /faCadena exch def}{length/faCadena exch def}ifelse
  %%pop
  exit
 } if  %% hem llegit tota la cadena?
} loop  %% x cada un dels caracters del la cadena de dins '

nullExtra
{  %% si aquest gatell és aciu voldrà dir que haurem inserit text entremig d'una cadena
 %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
 %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
 %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
 %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

 %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 0 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 0 exch put

 %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 1 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 1 exch put

 %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 2 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 2 exch put

 %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 3 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 3 exch put
}if

%%    }forall  % de la cadena de text

    %% cal restablir les coordenades particulars d'execucio de l'operador a les generiques del document
%%    TxTm_
TxTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TxTm exch put
    /TxTm exch def
%%   TyTm_
TyTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def
    %%}stopped{( ... peta ') == quit}if
   }
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    {  % stopped
     alFoc
     {
      pop
     }
     {
      /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %%TiNTeM {  % es la tinta que toca ara ?
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs ('\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta ') == quit}if
   }
  ] i_' get /' exch bind def

  [  %% "
   {  %% 0 (arbre jeràrquic) | gatells: 16
    {  % stopped
    3 copy dup length string copy  %% còpia descontaminada de l'string per salvaparent i l'escriure
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    %%    sEdAs 40 write sEdAs exch writestring sEdAs 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs ("\012) writestring
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% establim les coordenades inicials de la cadena
    %% desant en unes variables particulars per aquest operador

CursivaMentidera
{
0
INTERli neg
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put

%%% sembla com si aqui hi hagues d'anar un valor dinamic en funcio d'X i algun altre factor
dup 4 iTyTm iTxTm div put  %% s'hi aproxima molt pero AIXO NO ES
%%dup 5 1 put

concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

%%(:-b)pstack quit
pop iTxTm add   %% valor X a corregir
/iTxTm exch def  %% nou inici absolut de la linia X
}if

    iTxTm
    dup /TxTm exch def  %% aquets operadors sempre comencen a composar a l'X inicial de la cadena anterior
    /TxTm_ exch def iTyTm INTERli sub dup /TyTm_ exch def
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def
    exch
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /ecTc exch put
    /ecTc exch def  %% nou valor de l'espaiat entre caracters (com si fos establert per Tc)
    exch
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /epTw exch put
    /epTw exch def  %% nou valor de l'espaiat entre paraules (com si fos establert per Tw)
    %% computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm_ add dup /TyTm_ exch def

%%% darrer retoc
dup /TyTm exch def

    %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia dels valors:
    %% coordenada y i l'angle, d forma que els dos hauran d coincidir xq siguin considerats dins el mateix reng
    %%eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
    EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
    {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
     %%% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat    

90NET
{  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
cvi  %% EP!MASATS treballarem només amb l'enter
256 string cvs
EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
TxTm
cvi  %% EP!MASATS treballarem només amb l'enter
256 string cvs  %% ara lliguem la X en ves de l'angle
1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
6 -1 roll 0 exch putinterval
UndeR (_) putinterval
UndeR 1 add 4 -1 roll putinterval
}
{
cvi  %% EP!MASATS treballarem només amb l'enter
     256 string cvs
     EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
     1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
     6 -1 roll 0 exch putinterval
     UndeR (_) putinterval
     UndeR 1 add 4 -1 roll putinterval
     %%%>>%%%
}ifelse

    }
    {
     /Aeix 0 def
cvi  %% EP!MASATS treballarem només amb l'enter
     128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
    }ifelse
    %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
    yRENGS araPlana get dup 2 index known
    {  %% existeix
     exch get /araRENG exch def  %% capturem l'array amb els elements del reng
     /HiHaY true def  %% el reng ja existeix
    }
    {  %% l'hem de crear
     exch
     [  %% array d'elements pel reng, on tots el seus index coincidiran!
      []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
      %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
      %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
      %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
      []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
      %% correctament on, si hi hagues una separacio (espai o no), contindria un null
      []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
      []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
      Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
      }
      {
       %%%
       Aeix  %% valor de l'angle
       %%%>>%%%
      }ifelse
     ]
     dup /araRENG exch def
     put  %% la desem al dic de la pagina
     /HiHaY false def  %% el reng NO existeix
     %% valors inicials de la translacio Tm de control signe a signe x concat
     /transX TxTm def
     /transY TyTm def
    }ifelse
    %% array de caracter amb les posicions:
    %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
    %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
    %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
    /iXfX 6 array def  %% ara de 6 posicions!
    %%% test
    %% /isiGne 0 def
    %% gatell x saber si tractem el primer caracter de la cadena per tal d'aplicar-li el ecTc o no
    /iCadena 0 def

%%    {  % forall de la cadena de text     

dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
/iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)
{  %% loop per cada un dels caracters de la cadena de text dins "
maxLoop 0 eq {pop exit}if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
dup
iU esUnicode
{
 2 getinterval 1 get
}
{
 1 getinterval 0 get
}ifelse

     /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
     %%  posicio x,y d'inici de caracter
     TxTm
     %% es suma a cada caracter (aqui a la posicio X d'inici) el valor definit per Tc
     iCadena 0 ne  %% tret q no sigui el primer de la cadena!
     {  %% ... doncs es a partir del segon on s'aplica!
      ecTc
      SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul add  %% aquest factor definit per Tc va multiplicat pel multiplicador d'escala X del cos del text
     }if
     %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
     Aeix 0 eq
     {
      %% ###################
      dup iXfX exch 0 exch put
      %% ###################
     }
     {
      %%%
      dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
      {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
       pop
      }
      {
       div
      }ifelse iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
      %%%>>%%%
     }ifelse

Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
iXfX exch 2 exch put  %% coordenada X d'inici del signe
iXfX 3 TyTm put  %% coordenada Y d'inici del signe
}
{  %% normalitzem
%% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
gsave
aTm
%% si es un angle net de 90 graus, hem de treballar a escala 1
90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
%% la translacio q ens interessa es la del x,y d'origen del signe
dup 3 -1 roll 4 exch put  %% posicio X d'inici
dup 5 TyTm put  %% posicio Y d'inici
%% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
0 exch 0 exch
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
/transY exch def  %% desem pel proper concat?
/transX exch def  %% desem pel proper concat?
iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
}ifelse

     %%%***
     %%(\n)print flush
     %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
     %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush
     %%%***
     %% treiem l'ample (Width metrics) de cada caracter ...
     CalaixDeTipus
%% UiX
araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     QuinaFONT get

esUnicode
{
1 index exch
}
{

     dup 1 get 2 index exch sub exch

}ifelse

     2 get exch get
     %% multipliquem l'ample d la metrica pel cos i dividim x1000+TxTm x saber la posicio del caracter seguent
     CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul 1000 div  %%TxTm add
     %% es suma a cada caracter (aqui a la posicio X de final) el valor definit per Tc
     iCadena 0 ne  %% tret q no sigui el primer de la cadena!
     {  %% ... doncs es a partir del segon on s'aplica!
      ecTc
      SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul add  %% aquest factor definit per Tc va multiplicat pel multiplicador d'escala X del cos del text
     }if
     dup /aS exch def  %% nomes l'ample del signe
     Aeix 0 eq
     {
      %% ###################
      TxTm add  %% sumem el valor anterior ara
      %% ###################
     }
     {
      %%%
      dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
      %% desem la posicio X final del signe de la linia de base x si hem de fer la correccio d'espai
      /XfLB exch def
      TxTm add  %% sumem el valor anterior ara
      %%%>>%%%
     }ifelse
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TxTm exch put
     /TxTm exch def
     EncNETiPLANXAT exch get
     dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
     {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
      epTw
      SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
      %%%
      Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
       dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
      }if
      %%%>>%%%
      TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TxTm exch put
      /TxTm exch def
     }if

Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
%% posicio x,y de final de caracter
TxTm
dup iXfX exch 1 exch put
iXfX exch 4 exch put  %% coordenada X de final del signe
TyTm
iXfX exch 5 exch put  %% coordenada Y de final del signe
}
{  %% normalitzem
%% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
gsave
%% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
aS abs  %% hem d'anul?lar el signe de l'amplada xq la coordenada corregida es calculi correctament
0
aTm
%% si es un angle net de 90 graus, hem de treballar a escala 1
90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
%% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
dup /transY exch def  %% desem pel proper concat?
/TyTm exch def  %% nova posisico Y d'inici pel proper signe
dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
/transX exch def  %% desem pel proper concat?
iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
%% desem la coordenada X de final de caracter mesurada en horitzontal
Aeix 0 ne
{  %% si es rotada
iXfX 1 XfLB put
}
{  %% sense rotar
iXfX 1 TxTm put
}ifelse
}ifelse

     %%%***
     %%iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
     %%iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
     %%(Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush
     %%%***

/nullExtra false def

     HiHaY
     {  %% el reng existeix
      araRENG 0 get
      {  %% forall de l'array de posicions
       dup type /nulltype eq
       {
        %%(AIXO es un NULL!!!)==
        pop
       }
       {
        0 get dup  %% l'inici del primer caracter de la cadena q ja tenim ...
        iXfX 0 get ge  %% ... es + gran o igual q el l'inici del signe q volem situar ...
        {  %% componem cap a l'esquerra
         pop
         araRENG 0 get  %% treiem l'array de posicions
         %% definim l'array inicial identic al que examinem doncs si no es trobat, sera amb el que treballarem
         /aSuara[0 0]def
         /EnRETIRA 0 def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index n-1
         %% que el seu origen es igualat o superat per l'origen de iXfX
         dup length 1 sub -1 0
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop
         aSuara 0 get
         iXfX 0 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         EnRETIRA sub

         dup 0 lt
         {  %% filtrem els valors negatius (fan petar l'algorisme!)
          pop 0
         }if
         %% fi del tram on podem afinar la tolerancia 
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre
          %% ampliem el primer array d'araRENG, de posicions X, EnRETIRA + x l'esquerra ...
          /EnRETIRA exch def  %% desem l'index posicionador
          araRENG 0 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          iXfX dup length array copy  %% x profilaxi!
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 0 exch put  %% desem
          %% ampliem el segon array d'araRENG, de noms de signes, EnRETIRA + x l'esquerra ...
          araRENG 1 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup 3 -1 roll
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 1 exch put  %% desem
          %% ampliem el tercer array d'araRENG, de tipus, EnRETIRA + x l'esquerra ...
          araRENG 2 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 QuinaFONT put  %% sempre sera a ZERO ?
          araRENG exch 2 exch put  %% desem
          %% ampliem el quart array d'araRENG, de cossos, EnRETIRA + x l'esquerra ...
          araRENG 3 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 CyTm put  %% sempre sera a ZERO ?
          araRENG exch 3 exch put  %% desem
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }
        {  %% componem cap a la dreta

/nullExtra true def

         pop          
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array per defecte a zero x quan no el trobem?
         dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index 0
         %% que el seu origen es igualat o superat per l'origen de iXfX
         0 1 EnRETIRA
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop

%% no apliquem això ara:
%% comptem quants nulls hi ha entremig del mot de més a l'esquerra i el de més a la dreta
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena "
%% /hihaNulls 0 def
%% araRENG 0 get dup length 1 sub  %% final
%% EnRETIRA 1 add  %% inici
%% exch
%% 1 exch  %% salt
%% {  %% for
%%  1 index exch get
%%  type /nulltype eq
%%  { 
%%   hihaNulls 1 add /hihaNulls exch def
%%  }
%%  {
%%   exit
%%  }ifelse
%% }for
%% pop  %% ens carreguem l'array
%% }if  %% només un cop i a l'inici de la cadena "

         aSuara 1 get
         iXfX 1 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         %% fi del tram on podem afinar la tolerancia
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre

%% no apliquem això ara
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena "
 %% si hi ha prous nulls entremig per contenir exactament la cadena que situem ara
%% 2 index length 2 add hihaNulls le
%% {  %% llavors, la situem immediatament després del mot de més a l'esquerra separada per un null
%%  pop 2  %% sumaran dues posicions cap a la dreta per que hi quedi un null entremig
%% }if
%% }if  %% només un cop i a l'inici de la cadena "

          EnRETIRA add
          /EnRETIRA exch def  %% fixem finalment l'index real posicionador
          %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
          araRENG 0 get length EnRETIRA le
          {  %% aqui ampliem els arrays segons la diferencia d'index amb EnRETIRA
           EnRETIRA araRENG 0 get length 1 sub sub /Eixamplem exch def  %% de quant ampliem l'array?
           %% ampliem el primer array d'araRENG, de posicions X, Eixamplem + x la dreta
           araRENG 0 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA iXfX dup length array copy put  %% x profilaxi!
           araRENG exch 0 exch put  %% desem
           %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem + x la dreta
           araRENG 1 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA 4 -1 roll put
           araRENG exch 1 exch put  %% desem
           %% ampliem el tercer array d'araRENG, de tipus, Eixamplem + x la dreta
           araRENG 2 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA QuinaFONT put
           araRENG exch 2 exch put  %% desem
           %% ampliem el quart array d'araRENG, de cossos, Eixamplem + x la dreta
           araRENG 3 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA CyTm put
           araRENG exch 3 exch put  %% desem
          }
          {
           araRENG 0 get length EnRETIRA ge
           {  %% vol dir que el signe q afegim va entremig
            %% aqui els arrays o s'han d'ampliar pel mig 1+ a la posicio que marca EnRETIRA
            %% tret que ja hi hagi un null a l'index on apunta EnRETIRA!
            araRENG 0 get EnRETIRA get null ne
            {  %% no hi ha cap null, llavors ampliem
             %% l'array de posicions
             araRENG 0 get length dup 1 add array exch araRENG 0 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 0 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 0 exch put
             %% l'array de noms de signes
             araRENG 1 get length dup 1 add array exch araRENG 1 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 1 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 1 exch put
             %% l'array de tipus
             araRENG 2 get length dup 1 add array exch araRENG 2 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 2 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 2 exch put
             %% l'array de cossos
             araRENG 3 get length dup 1 add array exch araRENG 3 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 3 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 3 exch put
            }if
           }if
           %% ... o queden intactes de mida, doncs ja han quedat ampliats abans
           %% componem a l'index EnRETIRA el primer array d'araRENG, de posicions X
           araRENG 0 get dup
           iXfX dup length array copy  %% x profilaxi!
           EnRETIRA exch put
           araRENG exch 0 exch put  %% desem
           %% componem a l'index EnRETIRA el segon array d'araRENG, de noms de signes
           araRENG 1 get dup
           3 -1 roll
           EnRETIRA exch put
           araRENG exch 1 exch put  %% desem
           %% componem a l'index EnRETIRA el tercer array d'araRENG, de tipus
           araRENG 2 get dup
           QuinaFONT
           EnRETIRA exch put
           araRENG exch 2 exch put  %% desem
           %% componem a l'index EnRETIRA el quart array d'araRENG, de cossos
           araRENG 3 get dup
           CyTm
           EnRETIRA exch put
           araRENG exch 3 exch put  %% desem
          }ifelse  %% ampliem l'array?
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }ifelse  %% componem cap a l'esquerra o cap a la dreta
       }ifelse  %% null o no?
      }forall  %% de l'array de posicions
     }
     {  %% el reng NO existeix
      %% aqui avaluem si som a partir del segon caracter de la cadena, doncs llavors
      %% cal que mirem el valor d'ecTc, que si es diferent de zero haurem de computar quantes
      %% posicions ampliem l'array i cap a quina direccio: ecTc negatiu, cap a l'esquerra
      %% ecTc positiu cap a la dreta
      iCadena 0 ne
      {  %% des del segon caracter de la cadena avaluem ...
       ecTc 0 ne
       {  %% l'espaiat entre caracter es diferent de zero
        ecTc 0 lt
        {  %% cap a l'esquerra
         /capAlaDreta false def
        }
        {  %% cap a la dreta
         /capAlaDreta true def
        }ifelse
        capAlaDreta
        {  %% aqui avaluem quan Eixamplem cap a la dreta
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
         dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index 0
         %% que el seu origen es igualat o superat per l'origen de iXfX
         dup length 1 sub 0 exch 1 exch
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
          }
          {
           dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop
         aSuara 1 get
         iXfX 1 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         %% fi del tram on podem afinar la tolerancia
         dup 0 eq {pop 1}if  %% malgrat cavalquin dos signes, un anira darrera l'altre
         EnRETIRA add
         /Eixamplem exch def  %% posicions que afegirem a l'array cap a la dreta
        }
        {  %% aqui avaluem quan Eixamplem cap a l'esquerra
         araRENG 0 get  %% treiem l'array de posicions
	 /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
	 0 /EnRETIRA exch def  %% index posicionador x defecte?
	 %% extraiem el darrer array NO null començant per l'index n-1
	 %% que el seu origen es igualat o superat per l'origen de iXfX
	 dup length 1 sub -1 0
	 {  %% for
	  dup /iSuara exch def  %% desem l'index
	  1 index exch get dup type /nulltype eq
	  {
	   pop
	  }
	  {
	   dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
	   {
	    iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
	    /aSuara exch def
	   }
	   {
	    pop exit
	   }ifelse
	  }ifelse
	 }for
	 pop
	 aSuara 0 get
	 iXfX 0 get sub
	 %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         EnRETIRA sub

         dup 0 lt
         {  %% filtrem els valors negatius (fan petar l'algorisme!)
          pop 0
         }if
         %% fi del tram on podem afinar la tolerancia 
         dup 0 eq {pop 1}if  %% malgrat cavalquin dos signes, un anira darrera l'altre
         /Eixamplem exch def  %% posicions que afegirem a l'array cap a l'esquerra
        }ifelse
       }
       {  %% es igual a zero
        /Eixamplem 1 def  %% afegim 1 posicio a l'array
        /capAlaDreta true def
       }ifelse
      }
      {  %% som al primer caracter de la cadena
       /Eixamplem 1 def  %% afegim 1 posicio a l'array
       /capAlaDreta true def
      }ifelse
      capAlaDreta
      {
       %% ampliem el primer array d'araRENG, de posicions X, Eixamplem+ x la dreta ...
       iXfX dup length array copy  %% x profilaxi!
       araRENG 0 get dup length dup /baUla exch def Eixamplem add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
       %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem+ x la dreta ...
       araRENG 1 get dup length dup /baUla exch def Eixamplem add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
       %% ampliem el tercer array d'araRENG, de tipus, Eixamplem+ x la dreta ...
       QuinaFONT
       araRENG 2 get dup length dup /baUla exch def Eixamplem add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
       %% ampliem el quart array d'araRENG, de cossos, Eixamplem+ x la dreta ...
       CyTm
       araRENG 3 get dup length dup /baUla exch def Eixamplem add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
      }
      {
       %% ampliem el primer array d'araRENG, de posicions X, Eixamplem+ x l'esquerra ...
       araRENG 0 get dup length Eixamplem add array dup 3 -1 roll
       Eixamplem exch putinterval dup
       iXfX dup length array copy  %% x profilaxi!
       0 exch put  %% sempre sera a ZERO ?
       araRENG exch 0 exch put  %% desem
       %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem+ x l'esquerra ...
       araRENG 1 get dup length Eixamplem add array dup 3 -1 roll
       Eixamplem exch putinterval dup 3 -1 roll
       0 exch put  %% sempre sera a ZERO ?
       araRENG exch 1 exch put  %% desem
       %% ampliem el tercer array d'araRENG, de tipus, Eixamplem+ x l'esquerra ...
       araRENG 2 get dup length Eixamplem add array dup 3 -1 roll
       Eixamplem exch putinterval dup
       0 QuinaFONT put  %% sempre sera a ZERO ?
       araRENG exch 2 exch put  %% desem
       %% ampliem el quart array d'araRENG, de cossos, Eixamplem+ x l'esquerra ...
       araRENG 3 get dup length Eixamplem add array dup 3 -1 roll
       Eixamplem exch putinterval dup
       0 CyTm put  %% sempre sera a ZERO ?
       araRENG exch 3 exch put  %% desem
      }ifelse
     }ifelse
     iCadena 1 add /iCadena exch def  %% sumador de caracters de la cadena detext
     %% test
     %%isiGne 1 add /isiGne exch def

 iU esUnicode{2}{1}ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
 iU maxLoop ge
 {
  esUnicode
  {
   length 2 idiv /faCadena exch def
  }
  {
   length/faCadena exch def
  }ifelse
  %%pop
  exit
 } if  %% hem llegit tota la cadena?
} loop  %% x cada un dels caracters del la cadena de dins "

nullExtra
{  %% si aquest gatell és aciu voldrà dir que haurem inserit text entremig d'una cadena
 %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
 %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
 %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
 %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

 %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 0 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 0 exch put

 %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 1 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 1 exch put

 %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 2 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 2 exch put

 %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 3 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 3 exch put
}if

%%    }forall  % de la cadena de text

    %% cal restablir les coordenades particular d'execucio de l'operador a les generiques del document

%%    TxTm_
TxTm

    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TxTm exch put
    /TxTm exch def

%%    TyTm_
TyTm

    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def
    }stopped{( ... peta " 0) pstack stop}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    {  %% stopped
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    %%    sEdAs 40 write sEdAs exch writestring sEdAs 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs ("\012) writestring
    }stopped{( ... peta ") == quit}if
   }
   {  %% 2 (correccio L·L)
    {  %% stopped
    3 copy
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    %%    sEdAs 40 write sEdAs exch writestring sEdAs 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs ("\012) writestring

    %% KTCS  establim les coordenades inicials de la cadena
    %% desant en unes variables particulars per aquest operador
    iTxTm /TxTm_ exch def iTyTm INTERli sub dup /TyTm_ exch def
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def
    exch
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /ecTc exch put
    /ecTc exch def  %% nou valor de l'espaiat entre caracters (com si fos establert per Tc)
    exch
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /epTw exch put
    /epTw exch def  %% nou valor de l'espaiat entre paraules (com si fos establert per Tw)
    %% KTCS  computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm_ add /TyTm_ exch def
    %% KTCS
    {  %% forall de la cadena de text
     %% KTCS  posicio x,y d'inici de caracter
     TxTm_
     %%dup ==
     /XsigneO exch def  %% desem la posicio X d'inici de caracter
     TyTm_
     %%dup ==
     /YsigneO exch def  %% desem la posicio Y d'inici de caracter
     %% treiem l'ample (Width metrics) de cada caracter ...
     CalaixDeTipus
%% UiX
araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     QuinaFONT get dup 1 get 2 index exch sub exch 2 get exch get
     %% aqui multipliquem l'ample de la metrica pel cos i dividim x 1000 + TxTm x saber la posicio del caracter seguent
     CxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul 1000 div TxTm_ add
     %% es suma a cada caracter el valor definit per Tc
     ecTc
     SxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul add  %% aquest factor definit per Tc sempre va multiplicat pel multiplicador d'escala X del cos del text
     /TxTm_ exch def
     EncNETiPLANXAT exch get
     dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
     {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
      epTw
      SxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul  %% ep! que aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
      TxTm_ add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
      /TxTm_ exch def
     }if
     %% KTCS  posicio x,y de final de caracter
     TxTm_
     %%dup ==
     /XsigneF exch def  %% desem la posicio X de final de caracter
     TyTm_
     %%dup ==
     /YsigneF exch def  %% desem la posicio Y de final de caracter
     %% procediment de cerca per un determinat parell d'inici/final
     dup /guillemotleft  eq  %% inici
     {
      pop
      %%(OBRIR ... ) ==
      /araE true def  %% obrim la generacio d'etiquetes
     }
     {
      dup /guillemotright eq  %% final
      {
       pop
       %%( ... TANCAR) ==
       /araE false def  %% tanquem la generacio d'etiquetes
       %%QueTa ==  % treiem x la pantalleta x test
       /QueTa () def  %% inicialitzem
      }
      {
       araE
       {
        d_WAE exch get QueTa dup length 1 add string dup 3 -1 roll 0 exch putinterval  %% enganxem la cadena fins ara
        dup dup length 1 sub 4 -1 roll put /QueTa exch def  %% enganxem el nou caracter a la cadena
       }
       {
        pop
       }ifelse
      }ifelse
     }ifelse
     %% fi de procediment de cerca per un determinat parell d'inici/final
    }forall  %% de la cadena de text
    %% KTCS  cal restablir les coordenades particular d'execucio de l'operador a les generiques del document
    TxTm_
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TxTm exch put
    /TxTm exch def TyTm_
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def
    }stopped{( ... peta ") == stop}if
   }
   {  %% 3 analisi textual x JBC
    %%{  % stopped
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% establim les coordenades inicials de la cadena
    %% desant en unes variables particulars per aquest operador

CursivaMentidera
{
0
INTERli neg
gsave
[1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
dup dup 1 Amentidera sin neg put 2 Amentidera sin put
dup dup 0 Amentidera cos put 3 Amentidera cos put

%%% sembla com si aqui hi hagues d'anar un valor dinamic en funcio d'X i algun altre factor
dup 4 iTyTm iTxTm div put  %% s'hi aproxima molt pero AIXO NO ES
%%dup 5 1 put

concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

%%(:-b)pstack quit
pop iTxTm add   %% valor X a corregir
/iTxTm exch def  %% nou inici absolut de la linia X
}if

    iTxTm
    dup /TxTm exch def  %% aquets operadors sempre comencen a composar a l'X inicial de la cadena anterior
    /TxTm_ exch def iTyTm INTERli sub dup /TyTm_ exch def
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def
    exch
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /ecTc exch put
    /ecTc exch def  %% nou valor de l'espaiat entre caracters (com si fos establert per Tc)
    exch
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /epTw exch put
    /epTw exch def  %% nou valor de l'espaiat entre paraules (com si fos establert per Tw)
    %% computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm_ add dup /TyTm_ exch def

%%% darrer retoc
dup /TyTm exch def

    %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia dels valors:
    %% coordenada y i l'angle, d forma que els dos hauran d coincidir xq siguin considerats dins el mateix reng
    %%eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
    EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
    {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
     %%% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat    

90NET
{  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
cvi  %% EP!MASATS treballarem només amb l'enter
256 string cvs
EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
TxTm
cvi  %% EP!MASATS treballarem només amb l'enter
256 string cvs  %% ara lliguem la X en ves de l'angle
1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
6 -1 roll 0 exch putinterval
UndeR (_) putinterval
UndeR 1 add 4 -1 roll putinterval
}
{
cvi  %% EP!MASATS treballarem només amb l'enter
     256 string cvs
     EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
     1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
     6 -1 roll 0 exch putinterval
     UndeR (_) putinterval
     UndeR 1 add 4 -1 roll putinterval
     %%%>>%%%
}ifelse

    }
    {
     /Aeix 0 def

     %%Mishima: filtrem la coordenada Y per tal siguin significatius fins a 7 decimals
%     10000 mul truncate 10000 div
cvi  %% EP!MASATS treballarem només amb l'enter
     128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
    }ifelse
    %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
    yRENGS araPlana get dup 2 index known
    {  %% existeix
     exch get /araRENG exch def  %% capturem l'array amb els elements del reng
     /HiHaY true def  %% el reng ja existeix
    }
    {  %% l'hem de crear
     exch
     [  %% array d'elements pel reng, on tots el seus index coincidiran!
      []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
      %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
      %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
      %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
      []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
      %% correctament on, si hi hagues una separacio (espai o no), contindria un null
      []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
      []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
      Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
      }
      {
       %%%
       Aeix  %% valor de l'angle
       %%%>>%%%
      }ifelse
     ]
     dup /araRENG exch def
     put  %% la desem al dic de la pagina
     /HiHaY false def  %% el reng NO existeix
     %% valors inicials de la translacio Tm de control signe a signe x concat
     /transX TxTm def
     /transY TyTm def
    }ifelse
    %% array de caracter amb les posicions:
    %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
    %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
    %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
    /iXfX 6 array def  %% ara de 6 posicions!
    %%% test
    %% /isiGne 0 def
    %% gatell x saber si tractem el primer caracter de la cadena per tal d'aplicar-li el ecTc o no
    /iCadena 0 def

%%    {  % forall de la cadena de text     

dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
/iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)
{  %% loop per cada un dels caracters de la cadena de text dins "
maxLoop 0 eq {pop exit}if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
dup
iU esUnicode
{
 2 getinterval 1 get
}
{
 1 getinterval 0 get
}ifelse

     /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
     %%  posicio x,y d'inici de caracter
     TxTm
     %% es suma a cada caracter (aqui a la posicio X d'inici) el valor definit per Tc
     iCadena 0 ne  %% tret q no sigui el primer de la cadena!
     {  %% ... doncs es a partir del segon on s'aplica!
      ecTc
      SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul add  %% aquest factor definit per Tc va multiplicat pel multiplicador d'escala X del cos del text
     }if
     %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
     Aeix 0 eq
     {
      %% ###################
      dup iXfX exch 0 exch put
      %% ###################
     }
     {
      %%%
      dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
      {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
       pop
      }
      {
       div
      }ifelse iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
      %%%>>%%%
     }ifelse

Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
iXfX exch 2 exch put  %% coordenada X d'inici del signe
iXfX 3 TyTm put  %% coordenada Y d'inici del signe
}
{  %% normalitzem
%% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
gsave
aTm
%% si es un angle net de 90 graus, hem de treballar a escala 1
90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
%% la translacio q ens interessa es la del x,y d'origen del signe
dup 3 -1 roll 4 exch put  %% posicio X d'inici
dup 5 TyTm put  %% posicio Y d'inici
%% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
0 exch 0 exch
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
/transY exch def  %% desem pel proper concat?
/transX exch def  %% desem pel proper concat?
iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
}ifelse

     %%%***
     %%(\n)print flush
     %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
     %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush
     %%%***
     %% treiem l'ample (Width metrics) de cada caracter ...
     CalaixDeTipus
%% UiX
araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     QuinaFONT get

esUnicode
{
1 index exch
}
{

     dup 1 get 2 index exch sub exch

}ifelse

     2 get exch get
     %% multipliquem l'ample d la metrica pel cos i dividim x1000+TxTm x saber la posicio del caracter seguent
     CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
     mul 1000 div  %%TxTm add
     %% es suma a cada caracter (aqui a la posicio X de final) el valor definit per Tc
     iCadena 0 ne  %% tret q no sigui el primer de la cadena!
     {  %% ... doncs es a partir del segon on s'aplica!
      ecTc
      SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul add  %% aquest factor definit per Tc va multiplicat pel multiplicador d'escala X del cos del text
     }if
     dup /aS exch def  %% nomes l'ample del signe
     Aeix 0 eq
     {
      %% ###################
      TxTm add  %% sumem el valor anterior ara
      %% ###################
     }
     {
      %%%
      dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
      %% desem la posicio X final del signe de la linia de base x si hem de fer la correccio d'espai
      /XfLB exch def
      TxTm add  %% sumem el valor anterior ara
      %%%>>%%%
     }ifelse
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TxTm exch put
     /TxTm exch def
     EncNETiPLANXAT exch get
     dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
     {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
      epTw
      SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
      %%%
      Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
       dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
      }if
      %%%>>%%%
      TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TxTm exch put
      /TxTm exch def
     }if

Aeix 0 eq  %% si l'eix no es rotat ...
{  %% no cal q la normalitzem
%% posicio x,y de final de caracter
TxTm
dup iXfX exch 1 exch put
iXfX exch 4 exch put  %% coordenada X de final del signe
TyTm
iXfX exch 5 exch put  %% coordenada Y de final del signe
}
{  %% normalitzem
%% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
gsave
%% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
aS abs  %% hem d'anul?lar el signe de l'amplada xq la coordenada corregida es calculi correctament
0
aTm
%% si es un angle net de 90 graus, hem de treballar a escala 1
90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
%% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
concat
matrix currentmatrix  %% valor de la matriu rotada
grestore
transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
dup /transY exch def  %% desem pel proper concat?
/TyTm exch def  %% nova posisico Y d'inici pel proper signe
dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
/transX exch def  %% desem pel proper concat?
iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
%% desem la coordenada X de final de caracter mesurada en horitzontal
Aeix 0 ne
{  %% si es rotada
iXfX 1 XfLB put
}
{  %% sense rotar
iXfX 1 TxTm put
}ifelse
}ifelse

     %%%***
     %%iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
     %%iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
     %%(Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush
     %%%***

/nullExtra false def

     HiHaY
     {  %% el reng existeix
      araRENG 0 get
      {  %% forall de l'array de posicions
       dup type /nulltype eq
       {
        %%(AIXO es un NULL!!!)==
        pop
       }
       {
        0 get dup  %% l'inici del primer caracter de la cadena q ja tenim ...
        iXfX 0 get ge  %% ... es + gran o igual q el l'inici del signe q volem situar ...
        {  %% componem cap a l'esquerra
         pop
         araRENG 0 get  %% treiem l'array de posicions
         %% definim l'array inicial identic al que examinem doncs si no es trobat, sera amb el que treballarem
         /aSuara[0 0]def
         /EnRETIRA 0 def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index n-1
         %% que el seu origen es igualat o superat per l'origen de iXfX
         dup length 1 sub -1 0
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop
         aSuara 0 get
         iXfX 0 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         EnRETIRA sub

         dup 0 lt
         {  %% filtrem els valors negatius (fan petar l'algorisme!)
          pop 0
         }if
         %% fi del tram on podem afinar la tolerancia 
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre
          %% ampliem el primer array d'araRENG, de posicions X, EnRETIRA + x l'esquerra ...
          /EnRETIRA exch def  %% desem l'index posicionador
          araRENG 0 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          iXfX dup length array copy  %% x profilaxi!
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 0 exch put  %% desem
          %% ampliem el segon array d'araRENG, de noms de signes, EnRETIRA + x l'esquerra ...
          araRENG 1 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup 3 -1 roll
          0 exch put  %% sempre sera a ZERO ?
          araRENG exch 1 exch put  %% desem
          %% ampliem el tercer array d'araRENG, de tipus, EnRETIRA + x l'esquerra ...
          araRENG 2 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 QuinaFONT put  %% sempre sera a ZERO ?
          araRENG exch 2 exch put  %% desem
          %% ampliem el quart array d'araRENG, de cossos, EnRETIRA + x l'esquerra ...
          araRENG 3 get dup length EnRETIRA add array dup 3 -1 roll
          EnRETIRA exch putinterval dup
          0 CyTm put  %% sempre sera a ZERO ?
          araRENG exch 3 exch put  %% desem
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }
        {  %% componem cap a la dreta

/nullExtra true def

         pop          
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array per defecte a zero x quan no el trobem?
         dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index 0
         %% que el seu origen es igualat o superat per l'origen de iXfX
         0 1 EnRETIRA
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
%%iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
          }
          {
           dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop

%% no apliquem això ara:
%% comptem quants nulls hi ha entremig del mot de més a l'esquerra i el de més a la dreta
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena "
%% /hihaNulls 0 def
%% araRENG 0 get dup length 1 sub  %% final
%% EnRETIRA 1 add  %% inici
%% exch
%% 1 exch  %% salt
%% {  %% for
%%  1 index exch get
%%  type /nulltype eq
%%  { 
%%   hihaNulls 1 add /hihaNulls exch def
%%  }
%%  {
%%   exit
%%  }ifelse
%% }for
%% pop  %% ens carreguem l'array
%% }if  %% només un cop i a l'inici de la cadena "

         aSuara 1 get
         iXfX 1 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         %% fi del tram on podem afinar la tolerancia
         %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
         /NOmaseguis true def
         dup 0 eq
         {
          araRENG 1 get iSuara get /space eq
          {
%%           pop /NOmaseguis false def  % l'aixafem!
%%% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
%%% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
%%% consequencies dins la localitzacio de coordenades dels signes
pop 1
          }
          {
           pop 1
          }ifelse
         }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
         NOmaseguis
         {  %% un anira darrera l'altre

%% no apliquem això ara
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena "
 %% si hi ha prous nulls entremig per contenir exactament la cadena que situem ara
%% 2 index length 2 add hihaNulls le
%% {  %% llavors, la situem immediatament després del mot de més a l'esquerra separada per un null
%%  pop 2  %% sumaran dues posicions cap a la dreta per que hi quedi un null entremig
%% }if
%% }if  %% només un cop i a l'inici de la cadena "

          EnRETIRA add
          /EnRETIRA exch def  %% fixem finalment l'index real posicionador
          %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
          araRENG 0 get length EnRETIRA le
          {  %% aqui ampliem els arrays segons la diferencia d'index amb EnRETIRA
           EnRETIRA araRENG 0 get length 1 sub sub /Eixamplem exch def  %% de quant ampliem l'array?
           %% ampliem el primer array d'araRENG, de posicions X, Eixamplem + x la dreta
           araRENG 0 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA iXfX dup length array copy put  %% x profilaxi!
           araRENG exch 0 exch put  %% desem
           %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem + x la dreta
           araRENG 1 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA 4 -1 roll put
           araRENG exch 1 exch put  %% desem
           %% ampliem el tercer array d'araRENG, de tipus, Eixamplem + x la dreta
           araRENG 2 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA QuinaFONT put
           araRENG exch 2 exch put  %% desem
           %% ampliem el quart array d'araRENG, de cossos, Eixamplem + x la dreta
           araRENG 3 get dup length Eixamplem add array
           dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARA
           dup EnRETIRA CyTm put
           araRENG exch 3 exch put  %% desem
          }
          {
           araRENG 0 get length EnRETIRA ge
           {  %% vol dir que el signe q afegim va entremig
            %% aqui els arrays o s'han d'ampliar pel mig 1+ a la posicio que marca EnRETIRA
            %% tret que ja hi hagi un null a l'index on apunta EnRETIRA!
            araRENG 0 get EnRETIRA get null ne
            {  %% no hi ha cap null, llavors ampliem
             %% l'array de posicions
             araRENG 0 get length dup 1 add array exch araRENG 0 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 0 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 0 exch put
             %% l'array de noms de signes
             araRENG 1 get length dup 1 add array exch araRENG 1 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 1 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 1 exch put
             %% l'array de tipus
             araRENG 2 get length dup 1 add array exch araRENG 2 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 2 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 2 exch put
             %% l'array de cossos
             araRENG 3 get length dup 1 add array exch araRENG 3 get
             exch EnRETIRA exch EnRETIRA sub getinterval
             1 index exch EnRETIRA 1 add exch putinterval dup
             araRENG 3 get 0 EnRETIRA getinterval 0 exch putinterval
             araRENG exch 3 exch put
            }if
           }if
           %% ... o queden intactes de mida, doncs ja han quedat ampliats abans
           %% componem a l'index EnRETIRA el primer array d'araRENG, de posicions X
           araRENG 0 get dup
           iXfX dup length array copy  %% x profilaxi!
           EnRETIRA exch put
           araRENG exch 0 exch put  %% desem
           %% componem a l'index EnRETIRA el segon array d'araRENG, de noms de signes
           araRENG 1 get dup
           3 -1 roll
           EnRETIRA exch put
           araRENG exch 1 exch put  %% desem
           %% componem a l'index EnRETIRA el tercer array d'araRENG, de tipus
           araRENG 2 get dup
           QuinaFONT
           EnRETIRA exch put
           araRENG exch 2 exch put  %% desem
           %% componem a l'index EnRETIRA el quart array d'araRENG, de cossos
           araRENG 3 get dup
           CyTm
           EnRETIRA exch put
           araRENG exch 3 exch put  %% desem
          }ifelse  %% ampliem l'array?
         }
         {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
          %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
          %% componem a l'index iSuara el primer array d'araRENG, de posicions X
          araRENG 0 get dup
          iXfX dup length array copy  %% x profilaxi!
          iSuara exch put
          araRENG exch 0 exch put  %% desem
          %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
          araRENG 1 get dup
          3 -1 roll
          iSuara exch put
          araRENG exch 1 exch put  %% desem
          %% componem a l'index iSuara el tercer array d'araRENG, de tipus
          araRENG 2 get dup
          QuinaFONT
          iSuara exch put
          araRENG exch 2 exch put  %% desem
          %% componem a l'index iSuara el quart array d'araRENG, de cossos
          araRENG 3 get dup
          CyTm
          iSuara exch put
          araRENG exch 3 exch put  %% desem
         }ifelse
         exit  %% sortim doncs ja hem compost el signe te tocava
        }ifelse  %% componem cap a l'esquerra o cap a la dreta
       }ifelse  %% null o no?
      }forall  %% de l'array de posicions
     }
     {  %% el reng NO existeix
      %% aqui avaluem si som a partir del segon caracter de la cadena, doncs llavors
      %% cal que mirem el valor d'ecTc, que si es diferent de zero haurem de computar quantes
      %% posicions ampliem l'array i cap a quina direccio: ecTc negatiu, cap a l'esquerra
      %% ecTc positiu cap a la dreta
      iCadena 0 ne
      {  %% des del segon caracter de la cadena avaluem ...
       ecTc 0 ne
       {  %% l'espaiat entre caracter es diferent de zero
        ecTc 0 lt
        {  %% cap a l'esquerra
         /capAlaDreta false def
        }
        {  %% cap a la dreta
         /capAlaDreta true def
        }ifelse
        capAlaDreta
        {  %% aqui avaluem quan Eixamplem cap a la dreta
         araRENG 0 get  %% treiem l'array de posicions
         /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
         dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
         %% extraiem el darrer array NO null començant per l'index 0
         %% que el seu origen es igualat o superat per l'origen de iXfX
         dup length 1 sub 0 exch 1 exch
         {  %% for
          dup /iSuara exch def  %% desem l'index
          1 index exch get dup type /nulltype eq
          {
           pop
          }
          {
           dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
           {
            iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
            /aSuara exch def
           }
           {
            pop exit
           }ifelse
          }ifelse
         }for
         pop
         aSuara 1 get
         iXfX 1 get sub
         %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         %% fi del tram on podem afinar la tolerancia
         dup 0 eq {pop 1}if  %% malgrat cavalquin dos signes, un anira darrera l'altre
         EnRETIRA add
         /Eixamplem exch def  %% posicions que afegirem a l'array cap a la dreta
        }
        {  %% aqui avaluem quan Eixamplem cap a l'esquerra
         araRENG 0 get  %% treiem l'array de posicions
	 /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
	 0 /EnRETIRA exch def  %% index posicionador x defecte?
	 %% extraiem el darrer array NO null començant per l'index n-1
	 %% que el seu origen es igualat o superat per l'origen de iXfX
	 dup length 1 sub -1 0
	 {  %% for
	  dup /iSuara exch def  %% desem l'index
	  1 index exch get dup type /nulltype eq
	  {
	   pop
	  }
	  {
	   dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
	   {
	    iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
	    /aSuara exch def
	   }
	   {
	    pop exit
	   }ifelse
	  }ifelse
	 }for
	 pop
	 aSuara 0 get
	 iXfX 0 get sub
	 %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
         %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
         %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
         iXfX dup 1 get exch 0 get sub
         %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
         dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
         {
          pop pop 0
         }
         {
          div cvi abs
         }ifelse
         EnRETIRA sub

         dup 0 lt
         {  %% filtrem els valors negatius (fan petar l'algorisme!)
          pop 0
         }if
         %% fi del tram on podem afinar la tolerancia 
         dup 0 eq {pop 1}if  %% malgrat cavalquin dos signes, un anira darrera l'altre
         /Eixamplem exch def  %% posicions que afegirem a l'array cap a l'esquerra
        }ifelse
       }
       {  %% es igual a zero
        /Eixamplem 1 def  %% afegim 1 posicio a l'array
        /capAlaDreta true def
       }ifelse
      }
      {  %% som al primer caracter de la cadena
       /Eixamplem 1 def  %% afegim 1 posicio a l'array
       /capAlaDreta true def
      }ifelse
      capAlaDreta
      {
       %% ampliem el primer array d'araRENG, de posicions X, Eixamplem+ x la dreta ...
       iXfX dup length array copy  %% x profilaxi!
       araRENG 0 get dup length dup /baUla exch def Eixamplem add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
       %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem+ x la dreta ...
       araRENG 1 get dup length dup /baUla exch def Eixamplem add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
       %% ampliem el tercer array d'araRENG, de tipus, Eixamplem+ x la dreta ...
       QuinaFONT
       araRENG 2 get dup length dup /baUla exch def Eixamplem add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
       %% ampliem el quart array d'araRENG, de cossos, Eixamplem+ x la dreta ...
       CyTm
       araRENG 3 get dup length dup /baUla exch def Eixamplem add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
      }
      {
       %% ampliem el primer array d'araRENG, de posicions X, Eixamplem+ x l'esquerra ...
       araRENG 0 get dup length Eixamplem add array dup 3 -1 roll
       Eixamplem exch putinterval dup
       iXfX dup length array copy  %% x profilaxi!
       0 exch put  %% sempre sera a ZERO ?
       araRENG exch 0 exch put  %% desem
       %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem+ x l'esquerra ...
       araRENG 1 get dup length Eixamplem add array dup 3 -1 roll
       Eixamplem exch putinterval dup 3 -1 roll
       0 exch put  %% sempre sera a ZERO ?
       araRENG exch 1 exch put  %% desem
       %% ampliem el tercer array d'araRENG, de tipus, Eixamplem+ x l'esquerra ...
       araRENG 2 get dup length Eixamplem add array dup 3 -1 roll
       Eixamplem exch putinterval dup
       0 QuinaFONT put  %% sempre sera a ZERO ?
       araRENG exch 2 exch put  %% desem
       %% ampliem el quart array d'araRENG, de cossos, Eixamplem+ x l'esquerra ...
       araRENG 3 get dup length Eixamplem add array dup 3 -1 roll
       Eixamplem exch putinterval dup
       0 CyTm put  %% sempre sera a ZERO ?
       araRENG exch 3 exch put  %% desem
      }ifelse
     }ifelse
     iCadena 1 add /iCadena exch def  %% sumador de caracters de la cadena detext
     %% test
     %%isiGne 1 add /isiGne exch def

 iU esUnicode{2}{1}ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
 iU maxLoop ge
 {
  esUnicode
  {
   length 2 idiv /faCadena exch def
  }
  {
   length/faCadena exch def
  }ifelse
  %%pop
  exit
 } if  %% hem llegit tota la cadena?
} loop  %% x cada un dels caracters del la cadena de dins "

nullExtra
{  %% si aquest gatell és aciu voldrà dir que haurem inserit text entremig d'una cadena
 %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
 %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
 %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
 %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

 %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 0 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 0 exch put

 %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 1 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 1 exch put

 %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 2 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 2 exch put

 %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 3 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 3 exch put
}if

%%    }forall  % de la cadena de text

    %% cal restablir les coordenades particular d'execucio de l'operador a les generiques del document

%%    TxTm_
TxTm

    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TxTm exch put
    /TxTm exch def

%%    TyTm_
TyTm

    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def
%%    }stopped{( ... peta ") == quit}if
   }
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop pop
    }
    {
     %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %%TiNTeM {  % es la tinta que toca ara ?
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    %%    sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs exch writestring
    sEdAs 32 write sEdAs ("\012) writestring
    %%}{pop pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta ") == quit}if
   }
  ] i_" get /" exch bind def

  [  %% TJ
   {  %% 0 (suma 1+3) | gatells: 16
    {  % stopped
     %% userdict /Bb false put
     %% dup 0 get (\246)eq{userdict /Bb true put}if
     %% userdict /Bb get{(>>>mitel<<<)pstack quit}if

     esUNAlayer
     {
      xSiFosBuida /quinOC exch def  %% desem el nom del possible Optional Content (capa)
     }
     {
      /quinOC /MRCT_capOC def  %% desem el nom del possible Optional Content (capa)
     }ifelse
     %% XRay/Lleixes get/nomIE get{== ==}forall
     /EStrepitgen false def  %% gatell per saber si dues línies de text coincident duen caràcters que es trepitgen

     %% ens cal interrogar explícitament la font aquí per saber si és Unicode!
     CalaixDeTipus araPlana get QuinaFONT get 3 get /esUnicode exch def

     %% interroguem de forma dinàmica el valor de suaraKern en base al valor de la mètrica del caràcter /space
     %% si no existís, hi deixarem el valor ja definit abans
     Champollion araPlana get QuinaFONT get /ncdng exch def  %% anem a pescar l'encoding de la font actual
     /ispace null def
     0 1 ncdng length 1 sub
     {  %% for
      dup ncdng exch get /space eq 
      {
       /ispace exch def exit
      }
      {
       pop
      }ifelse
     }for
     ispace null ne
     {  %% només redefinirem suaraKern si /space existeix
      CalaixDeTipus araPlana get QuinaFONT get dup 1 get ispace exch sub  %% per ajustar l'índex a l'array de mètrica
      %% cal saber xq aquesta resta surt negativa (doncs no s'hauria de donar mai el cas i vol dir q alguna cosa falla abans?)
      dup 0 lt
      {
       pop pop
      }
      {
       exch 2 get  %% anem a pescar l'array de mètrica
       exch get  %% la mètrica de /space
       dup 0 eq
       {  %% si és zero tampoc el redefinim doncs voldrà dir que no existeix
        pop
       }
       {
        userdict exch /suaraKern exch put  %% el redefinim a l'arrel del diccionari de treball!
       }ifelse
      }ifelse
     }if

     dup dup length array copy  %% còpia descontaminada per salvaparent i l'escriptura
     sEdAs ([ ) writestring
     {  %% forall
      dup type /stringtype eq
      { %%sEdAs 40 write sEdAs exch writestring sEdAs 41 write
       %% salvaparent2.ps
       %% de com reescriure una string x solucionar el problema de no deixar-nos
       %% el backslash \ i els parentesi () sense el \ que els marca com a caracters
       %% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
       /fora
       [  %% paquet de caracters a cercar
        (\134)  %% \ backslash
        (\050)  %% ( left parenthesis
        (\051)  %% ) right parenthesis
        (\012)  %% \n line feed (LF)
        (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
        (\011)  %% \t horizontal tab
        (\010)  %% \b backspace
        (\014)  %% \f form feed (FF)
       ] def
       /FAfora fora length def  %% pestell de sortida del loop
       /foraX
       [  %% paquet de substitucio de caracter
        (\\\\)  %% backslash
        (\\\()  %% left parenthesis
        (\\\))  %% right parenthesis
        (\\n)  %% line feed (LF)
        (\\r)  %% carriage return (CR)
        (\\t)  %% horizontal tab
        (\\b)  %% backspace
        (\\f)  %% form feed (FF)
       ] def
       /ifora 0 def  %% index de fora
       %% aqui la cadena a reescriure correctament
       %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
       mark exch
       {  %% loop general
        {  %% loop cerca/subs de caracters
         fora ifora get search
         {
          exch pop
          dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
          dup 3 -1 roll 0 exch putinterval
         }
         {
          exit
         }ifelse
         exch
        }loop
        %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
        counttomark 1 gt
        {
         counttomark /atura't exch def
         /ici 2 def
         {
          ici -1 roll ici 1 add /ici exch def ici atura't gt
          {
           exit
          }if
         } loop
         {  %% loop empalmador de les cadenes trobades en 1 sola
          dup length dup 3 index length add string dup 4 -1 roll
          0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
          counttomark 1 eq
          {
           exit
          } if
         }loop
        }if
        ifora 1 add /ifora exch def
        FAfora ifora eq {exit}if
       }loop
       exch pop  %% ens carreguem mark
       %% posem els caracters ( ... ) com a cadena
       dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
       dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
       %% fi de salvaparent2.ps
       sEdAs exch writestring
       sEdAs 32 write
      }
      {
       10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
      }ifelse
     }forall
     sEdAs (] TJ\012) writestring

     %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     /LleixaBuida false def
     %% computem el valor del Ts (text rise)
     TyTs SyTm mul TyTm add
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TyTm exch put
     dup /TyTm exch def
     %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia la coordenada
     %% y i l'angle, de forma que els dos hauran de coincidir xq siguin considerats dins el mateix reng
     %% eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
     EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
     {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
      %% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat
      90NET
      {  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
       cvi  %% EP!MASATS treballarem només amb l'enter
       256 string cvs
       EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
       TxTm
       cvi  %% EP!MASATS treballarem només amb l'enter
       256 string cvs  %% ara lliguem la X en ves de l'angle
       1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
       6 -1 roll 0 exch putinterval
       UndeR (_) putinterval
       UndeR 1 add 4 -1 roll putinterval
      }
      {
       cvi  %% EP!MASATS treballarem només amb l'enter
       256 string cvs
       EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
       1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
       6 -1 roll 0 exch putinterval
       UndeR (_) putinterval
       UndeR 1 add 4 -1 roll putinterval
      }ifelse
     }
     {
      /Aeix 0 def
      cvi  %% EP!MASATS treballarem només amb l'enter
      128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
     }ifelse
     %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
     yRENGS araPlana get dup 2 index known
     %% pop {== ==}forall(MMMMMM)pstack quit
     {  %% existeix
      exch dup /quinRENG exch def  %% desem la clau del valor Y del reng per control de possibles trepitjats
      get /araRENG exch def  %% capturem l'array amb els elements del reng
      %% es creuen fem una còpia descontaminada per si l'hem de preservar en cas de trepitjat de text
      /CLONaraRENG araRENG dup length array copy def
      %% muntem el rectangle per presentar-lo caràcter a caràcter i saber si es trepitja en algun punt
      CLONaraRENG 0 get  %% l'array de coordenades de cada caràcter
      dup length /maxTrep exch def /Trep exch def
      Trep
      {  %% forall per extraure les coordenades del primer caràcter
       dup null eq
       {
        pop
       }
       {
        dup 2 get /AxTrepLL exch def  %% LowerLeft X del primer caràcter de l'àrea del mot que avaluarem de si trepitja
        3 get /AyTrepLL exch def  %% LowerLeft Y del primer caràcter de l'àrea del mot que avaluarem de si trepitja
        exit  %% i sortim perquè ja tenim la X,Y d'inici del primer caràcter
       }ifelse
      }forall
      maxTrep 1 sub -1 0
      {  %% for per extraure les coordenades del darrer caràcter
       Trep exch get dup null eq
       {
        pop
       }
       {
        dup 4 get /AxTrepLR exch def  %% LowerRight X del darrer caràcter de l'àrea del mot que avaluarem de si trepitja
        5 get /AyTrepLR exch def  %% LowerRight Y del darrer caràcter de l'àrea del mot que avaluarem de si trepitja
        exit  %% i sortim perquè ja tenim la X,Y del final del darrer caràcter
       }ifelse
      }for
      /TrepA  %% userpath d'avaluació de la caixa del mot per presentar-lo caràcter a caràcter i saber si es trepitja en algun punt
      {  %% fem el rectangle començant per LL i en direcció a les agulles
       AxTrepLL AyTrepLL moveto
       AxTrepLL AyTrepLL 2 add lineto  %% l'altura de la caixa del mot és irrellevant per crear el rectangle d'avaluació
       AxTrepLR AyTrepLR 2 add lineto
       AxTrepLR AyTrepLR lineto
       closepath true upath cvlit  %% en fem un userpath
      }def
      /HiHaY true def  %% el reng ja existeix
     }
     {  %% l'hem de crear
      exch
      [  %% array d'elements pel reng, on tots el seus index coincidiran!
       []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
       %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
       %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
       %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
       %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
       []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
       %% correctament on, si hi hagues una separacio (espai o no), contindria un null
       []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
       []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
       Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
       {
        null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
       }
       {
        Aeix  %% valor de l'angle
       }ifelse
       quinOC  %% 5: el sisè, ens diu el nom de la capa (Optional Content), si no és a cap durà /MRCT_capOC
      ]
      dup /araRENG exch def
      put  %% la desem al dic de la pagina
      /HiHaY false def  %% el reng NO existeix
      %% valors inicials de la translacio Tm de control signe a signe x concat
      /transX TxTm def
      /transY TyTm def
     }ifelse
     %% array de caracter amb les posicions:
     %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
     %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
     %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
     %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
     %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
     %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
     /iXfX 6 array def  %% ara de 6 posicions!
     {  %% forall del paquet
      dup type /stringtype eq
      {  %% es la cadena de text (analisi idem Tj)
       %% dup (\000\013\000?) eq {/@--`-,-- true def}{/@--`-,-- false def}ifelse
       %% @--`-,-- {esUnicode(o)pstack quit}if
       dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
       /iEStrepitgen 0 def  %% gatell per saber si haurem generat una nova araRENG per un mot trepitjat
       {  %% loop pels mots que es trepitgen
        /iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)
        {  %% loop per cada un dels caracters de la cadena de text dins TJ
         maxLoop 0 eq
         {
          pop exit
         }if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
         dup
         iU esUnicode
         {
          2 getinterval 1 get
         }
         {
          1 getinterval 0 get
         }ifelse
         /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
         %%  posicio x,y d'inici de caracter
         TxTm
         %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
         Aeix 0 eq
         {
          dup iXfX exch 0 exch put  %% x JBC
         }
         {
          dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
          {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
           pop
          }
          {
           div
          }ifelse
          iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
         }ifelse

         Aeix 0 eq  %% si l'eix no es rotat ...
         {  %% no cal q la normalitzem
          iXfX exch 2 exch put  % coordenada X d'inici del signe
          iXfX 3 TyTm put  %% coordenada Y d'inici del signe
         }
         {  %% normalitzem
          %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
          gsave
          aTm
          %% si es un angle net de 90 graus, hem de treballar a escala 1
          90NET
          {
           dup 1 get 0 lt
           {
            dup dup 1 -1 put 2 1 put
           }
           {
            dup dup 1 1 put 2 -1 put
           }ifelse
          }if
          %% la translacio q ens interessa es la del x,y d'origen del signe
          dup 3 -1 roll 4 exch put  %% posicio X d'inici
          dup 5 TyTm put  %% posicio Y d'inici
          %% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
          0 exch 0 exch
          concat
          matrix currentmatrix  %% valor de la matriu rotada
          grestore
          transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
          itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
          /transY exch def  %% desem pel proper concat?
          /transX exch def  %% desem pel proper concat?
          iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
          iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
         }ifelse

         %% (\n)print flush
         %% iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
         %% iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush

         %% treiem l'ample (Width metrics) de cada caracter ...
         CalaixDeTipus
         araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
         QuinaFONT get

         esUnicode
         {
%%Aquí hi ha un problema: treballant a 1 byte no ajustem l'índex pel valor de FirstChar!
          1 index exch
         }
         {
          dup 1 get 2 index exch sub exch
         }ifelse

         2 get  %% extraiem el paquet de la mètrica
         exch
         %% com pot ser que li arribi un valor d'índex en negatiu?
         abs  %% té lògica?
         %% dup 0 lt{(valor IMAGINARI!)pstack quit}if
         %% l'altra problema és que l'encoding de Widths no té tot el rang a 256 (tot i ser Identity-H) doncs la font està escapçada
         %% si al descendantFont hi ha /DW llavors podriem posar-hi aquest valor?
         %% tirem pel dret: mirem si sortim de rang a l'encoding de Widths i si és així apliquem el valor de l'índex 4 de la font a CalaixDeTipus
         2 copy exch length ge
         {  %% el codi del caràcter és fora de rang de l'encoding de Widths
          pop pop
          CalaixDeTipus
          araPlana get
          QuinaFONT get 4 get  %% ara fem servir el valor mitjà de mètrica calculat
         }
         { 
          get
         }ifelse

         %% multipliquem l'ample de la metrica pel cos i dividim x1000+TxTm x saber la posicio del signe seguent

         CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
         mul 1000 div
         %% es suma a cada caracter el valor definit per Tc
         ecTc
         SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
         %% aquest factor definit per Tc sempre va multiplicat pel multiplicador d'escala X del cos del text
         mul add
         dup /aS exch def  %% nomes l'ample del signe
         Aeix 0 eq
         {
          TxTm add  %% sumem el valor anterior ara
         }
         {
          dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
          %% desem la posicio X final del signe de la linia de base x si hem de fer la correccio d'espai
          /XfLB exch def
          TxTm add  %% sumem el valor anterior ara
         }ifelse
         %% copiem aquest valor al dic de l'estat grafic actiu
         dup EstatGrafic iEG get exch /TxTm exch put
         /TxTm exch def
         EncNETiPLANXAT exch get
         dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
         {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
          epTw
          SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
          mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos de text
          Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
          {
           dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
           dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
          }if
          TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
          %% copiem aquest valor al dic de l'estat grafic actiu
          dup EstatGrafic iEG get exch /TxTm exch put
          /TxTm exch def
         }if

         Aeix 0 eq  %% si l'eix no es rotat ...
         {  %% no cal q la normalitzem
          %% posicio x,y de final de caracter
          TxTm
          dup iXfX exch 1 exch put
          iXfX exch 4 exch put  %% coordenada X de final del signe
          TyTm
          iXfX exch 5 exch put  %% coordenada Y de final del signe
         }
         {  %% normalitzem
          %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
          gsave
          %% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
          aS abs  %% hem d'anul.lar el signe de l'amplada xq la coordenada corregida es calculi correctament
          0
          aTm
          %% si es un angle net de 90 graus, hem de treballar a escala 1
          90NET
          {
           dup 1 get 0 lt
           {
            dup dup 1 -1 put 2 1 put
           }
           {
            dup dup 1 1 put 2 -1 put
           }ifelse
          }if
          %% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
          concat
          matrix currentmatrix  %% valor de la matriu rotada
          grestore
          transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
          itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
          dup /transY exch def  %% desem pel proper concat?
          /TyTm exch def  %% nova posisico Y d'inici pel proper signe
          dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
          /transX exch def  %% desem pel proper concat?
          iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
          iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
          %% desem la coordenada X de final de caracter mesurada en horitzontal
          Aeix 0 ne
          {  %% si es rotada
           iXfX 1 XfLB put
          }
          {  %% sense rotar
           iXfX 1 TxTm put
          }ifelse
         }ifelse

         %% iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
         %% iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
         %% (Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush

         /nullExtra false def

         %% cal fer una primer interrogació de si HiHaY per saber si es creuen amb el rectangle de tast d'araRENG
         HiHaY
         {
          iXfX dup 2 get /CxTrepLL exch def  %% LowerLeft X del primer caràcter de l'àrea del mot que avaluarem de si trepitja
          3 get /CyTrepLL exch def  %% LowerLeft Y del primer caràcter de l'àrea del mot que avaluarem de si trepitja
          iXfX dup 4 get /CxTrepLR exch def  %% LowerRight X del darrer caràcter de l'àrea del mot que avaluarem de si trepitja
          5 get /CyTrepLR exch def  %% LowerRight Y del darrer caràcter de l'àrea del mot que avaluarem de si trepitja

          /TrepC  %% userpath de la caixa del caràcter per comparar-lo amb /TrepA i saber si es trepitja en algun punt
          {  %% fem el rectangle començant per LL i en direcció a les agulles
           CxTrepLL CyTrepLL moveto
           CxTrepLL CyTrepLL 2 add lineto  %% l'altura de la caixa del caràcter és irrellevant per crear el rectangle d'avaluació
           CxTrepLR CyTrepLR 2 add lineto
           CxTrepLR CyTrepLR lineto
           closepath true upath cvlit  %% en fem un userpath
          }def
          %% test de trepitjat
          gsave
          %% generem primer l'àrea de clip amb el mateix upath /TrepA que duplicarem perquè quedi com a valor a l'stack
          newpath TrepA dup uappend clip newpath
          TrepC  %% el segon upath és el que ens dirà si es creua amb el clip del primer i per tant trepitja o no
          inufill  %% interroga l'area de dos userpath, si es creuen dóna true i si no ho fan dóna false
          grestore
          %% si es creuen, sortim del loop i activem l'algorisme de... el reng NO existeix ...via el gatell EStrepitgen
          {
           /EStrepitgen true def
           exit
          }if
         }if

         HiHaY
         {  %% el reng existeix
          araRENG 0 get
          {  %% forall de l'array de posicions
           dup type /nulltype eq
           {
            %% (AIXO es un NULL!!!)==
            pop
           }
           {
            0 get dup  %% l'inici del primer caracter de la cadena q ja tenim ...
            iXfX 0 get ge  %% ... es + gran o igual q el l'inici del signe q volem situar ...
            {  %% componem cap a l'esquerra
             %% tram on calculem l'index on anira el caracter q componem dins la cadena
             pop
             araRENG 0 get  %% treiem l'array de posicions
             /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
             /EnRETIRA 0 def  %% index posicionador x defecte?
             %% extraiem el darrer array NO null començant per l'index n-1
             %% que el seu origen es igualat o superat per l'origen de iXfX
             dup length 1 sub -1 0
             {  %% for
              dup /iSuara exch def  %% desem l'index
              1 index exch get dup type /nulltype eq
              {
               pop
               %% deixaNull
               %% {
               %% iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
               %% }if
              }
              {
               dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
               {
                iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
                /aSuara exch def
               }
               {
                pop exit
               }ifelse
              }ifelse
             }for
             pop
             aSuara 0 get
             iXfX 0 get sub
             %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
             %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
             %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
             iXfX dup 1 get exch 0 get sub
             %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
             dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
             {
              pop pop 0
             }
             {
              div cvi abs
             }ifelse
             EnRETIRA sub

             dup 0 lt
             {  %% filtrem els valors negatius (fan petar l'algorisme!)
              pop 0
              /NOmaseguis false def
             }if
             %% fi del tram on podem afinar la tolerancia 
             %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
             %% test
             %% iSignE 1 eq {araRENG EnRETIRA aSuara (;-\) COMPONEM A L'ESQUERRA!)pstack quit}if
             %% iSignE 1 add /iSignE exch def
             %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
             /NOmaseguis true def
             dup 0 eq
             {
              araRENG 1 get iSuara get /space eq
              {
               %% pop /NOmaseguis false def  % l'aixafem!
               %% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
               %% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
               %% consequencies dins la localitzacio de coordenades dels signes
               pop 1
              }
              {
               pop 1
              }ifelse
             }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
             NOmaseguis
             {  %% un anira darrera l'altre
              %% ampliem el primer array d'araRENG, de posicions X, EnRETIRA + x l'esquerra ...
              /EnRETIRA exch def  %% desem l'index posicionador
              araRENG 0 get dup length EnRETIRA add array dup 3 -1 roll
              EnRETIRA exch putinterval dup
              iXfX dup length array copy  %% x profilaxi!
              0 exch put  %% sempre sera a ZERO ?
              araRENG exch 0 exch put  %% desem
              %% ampliem el segon array d'araRENG, de noms de signes, EnRETIRA + x l'esquerra ...
              araRENG 1 get dup length EnRETIRA add array dup 3 -1 roll
              EnRETIRA exch putinterval dup 3 -1 roll
              0 exch put  %% sempre sera a ZERO ?
              araRENG exch 1 exch put  %% desem
              %% ampliem el tercer array d'araRENG, de tipus, EnRETIRA + x l'esquerra ...
              araRENG 2 get dup length EnRETIRA add array dup 3 -1 roll
              EnRETIRA exch putinterval dup
              0 QuinaFONT put  %% sempre sera a ZERO ?
              araRENG exch 2 exch put  %% desem
              %% ampliem el quart array d'araRENG, de cossos, EnRETIRA + x l'esquerra ...
              araRENG 3 get dup length EnRETIRA add array dup 3 -1 roll
              EnRETIRA exch putinterval dup
              0 CyTm put  %% sempre sera a ZERO ?
              araRENG exch 3 exch put  %% desem
             }
             {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
              %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
              %% componem a l'index iSuara el primer array d'araRENG, de posicions X
              araRENG 0 get dup
              iXfX dup length array copy  %% x profilaxi!
              iSuara exch put
              araRENG exch 0 exch put  %% desem
              %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
              araRENG 1 get dup
              3 -1 roll
              iSuara exch put
              araRENG exch 1 exch put  %% desem
              %% componem a l'index iSuara el tercer array d'araRENG, de tipus
              araRENG 2 get dup
              QuinaFONT
              iSuara exch put
              araRENG exch 2 exch put  %% desem
              %% componem a l'index iSuara el quart array d'araRENG, de cossos
              araRENG 3 get dup
              CyTm
              iSuara exch put
              araRENG exch 3 exch put  %% desem
             }ifelse
             exit  %% sortim doncs ja hem compost el signe te tocava
            }
            {  %% componem cap a la dreta
             %% tram on calculem l'index on anira el caracter q componem dins la cadena
             /nullExtra true def
             pop
             araRENG 0 get  %% treiem l'array de posicions
             /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
             dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
             %% extraiem el darrer array NO null començant per l'index 0
             %% que el seu origen es igualat o superat per l'origen de iXfX
             0 1 EnRETIRA
             {  %% for
              dup /iSuara exch def  %% desem l'index
              1 index exch get dup type /nulltype eq
              {
               pop
               %% deixaNull
               %% {
               %% iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
               %% }if
              }
              {
               dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
               {
                iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
                /aSuara exch def
               }
               {
                pop exit
               }ifelse
              }ifelse
             }for
             pop

             %% no apliquem això ara:
             %% comptem quants nulls hi ha entremig del mot de més a l'esquerra i el de més a la dreta
             %% iU 0 eq
             %% {  %% només un cop i a l'inici de la cadena TJ
             %% /hihaNulls 0 def
             %% araRENG 0 get dup length 1 sub  %% final
             %% EnRETIRA 1 add  %% inici
             %% exch
             %% 1 exch  %% salt
             %% {  %% for
             %%  1 index exch get
             %%  type /nulltype eq
             %%  { 
             %%   hihaNulls 1 add /hihaNulls exch def
             %%  }
             %%  {
             %%   exit
             %%  }ifelse
             %% }for
             %% pop  %% ens carreguem l'array
             %% }if  %% només un cop i a l'inici de la cadena TJ

             aSuara 1 get
             iXfX 1 get sub
             %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
             %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
             %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
             iXfX dup 1 get exch 0 get sub
             %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
             dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
             {
              pop pop 0
             }
             {
              div cvi abs
             }ifelse
             %% fi del tram on podem afinar la tolerancia
             %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
             /NOmaseguis true def
             dup 0 eq
             {
              araRENG 1 get iSuara get /space eq
              {
               %% pop /NOmaseguis false def  % l'aixafem!
               %% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
               %% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
               %% consequencies dins la localitzacio de coordenades dels signes
               pop 1
              }
              {
               pop 1
              }ifelse
             }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
             NOmaseguis
             {  %% un anira darrera l'altre
              %% no apliquem això ara:
              %% iU 0 eq
              %% {  %% només un cop i a l'inici de la cadena TJ
              %% si hi ha prous nulls entremig per contenir exactament la cadena que situem ara
              %% 2 index length 2 add hihaNulls le
              %% {  %% llavors, la situem immediatament després del mot de més a l'esquerra separada per un null
              %%  pop 2  %% sumaran dues posicions cap a la dreta per que hi quedi un null entremig
              %% }if
              %% }if  %% només un cop i a l'inici de la cadena TJ

              EnRETIRA add
              /EnRETIRA exch def  %% fixem finalment l'index real posicionador
              %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
              %% test
              %% iSignD 0 eq {araRENG aSuara iSuara EnRETIRA(!!componem a la dretAAA!!)pstack quit}if
              %% iSignD 1 add /iSignD exch def
              araRENG 0 get length EnRETIRA le
              {  %% aqui ampliem els arrays segons la diferencia d'index amb EnRETIRA
               EnRETIRA araRENG 0 get length 1 sub sub /Eixamplem exch def  %% de quant ampliem l'array?
               %% ampliem el primer array d'araRENG, de posicions X, Eixamplem + x la dreta
               araRENG 0 get dup length Eixamplem add array
               dup 3 -1 roll 0 exch putinterval
               %% ... i afegim el nom desat a comPARA
               dup EnRETIRA iXfX dup length array copy put  %% x profilaxi!
               araRENG exch 0 exch put  %% desem
               %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem + x la dreta
               araRENG 1 get dup length Eixamplem add array
               dup 3 -1 roll 0 exch putinterval
               %% ... i afegim el nom desat a comPARA
               dup EnRETIRA 4 -1 roll put
               araRENG exch 1 exch put  %% desem
               %% ampliem el tercer array d'araRENG, de tipus, Eixamplem + x la dreta
               araRENG 2 get dup length Eixamplem add array
               dup 3 -1 roll 0 exch putinterval
               %% ... i afegim el nom desat a comPARA
               dup EnRETIRA QuinaFONT put
               araRENG exch 2 exch put  %% desem
               %% ampliem el quart array d'araRENG, de cossos, Eixamplem + x la dreta
               araRENG 3 get dup length Eixamplem add array
               dup 3 -1 roll 0 exch putinterval
               %% ... i afegim el nom desat a comPARA
               dup EnRETIRA CyTm put
               araRENG exch 3 exch put  %% desem
              }
              {
               araRENG 0 get length EnRETIRA ge
               {  %% vol dir que el signe q afegim va entremig
                %% aqui els arrays o s'han d'ampliar pel mig 1+ a la posicio que marca EnRETIRA
                %% tret que ja hi hagi un null a l'index on apunta EnRETIRA!
                araRENG 0 get EnRETIRA get null ne
                {  %% no hi ha cap null, llavors ampliem
                 %% l'array de posicions
                 araRENG 0 get length dup 1 add array exch araRENG 0 get
                 exch EnRETIRA exch EnRETIRA sub getinterval
                 1 index exch EnRETIRA 1 add exch putinterval dup
                 araRENG 0 get 0 EnRETIRA getinterval 0 exch putinterval
                 araRENG exch 0 exch put
                 %% l'array de noms de signes
                 araRENG 1 get length dup 1 add array exch araRENG 1 get
                 exch EnRETIRA exch EnRETIRA sub getinterval
                 1 index exch EnRETIRA 1 add exch putinterval dup
                 araRENG 1 get 0 EnRETIRA getinterval 0 exch putinterval
                 araRENG exch 1 exch put
                 %% l'array de tipus
                 araRENG 2 get length dup 1 add array exch araRENG 2 get
                 exch EnRETIRA exch EnRETIRA sub getinterval
                 1 index exch EnRETIRA 1 add exch putinterval dup
                 araRENG 2 get 0 EnRETIRA getinterval 0 exch putinterval
                 araRENG exch 2 exch put
                 %% l'array de cossos
                 araRENG 3 get length dup 1 add array exch araRENG 3 get
                 exch EnRETIRA exch EnRETIRA sub getinterval
                 1 index exch EnRETIRA 1 add exch putinterval dup
                 araRENG 3 get 0 EnRETIRA getinterval 0 exch putinterval
                 araRENG exch 3 exch put
                }if
               }if
               %% ... o queden intactes de mida, doncs ja han quedat ampliats abans
               %% componem a l'index EnRETIRA el primer array d'araRENG, de posicions X
               araRENG 0 get dup
               iXfX dup length array copy  %% x profilaxi!
               EnRETIRA exch put
               araRENG exch 0 exch put  %% desem
               %% componem a l'index EnRETIRA el segon array d'araRENG, de noms de signes
               araRENG 1 get dup
               3 -1 roll
               EnRETIRA exch put
               araRENG exch 1 exch put  %% desem
               %% componem a l'index EnRETIRA el tercer array d'araRENG, de tipus
               araRENG 2 get dup
               QuinaFONT
               EnRETIRA exch put
               araRENG exch 2 exch put  %% desem
               %% componem a l'index EnRETIRA el quart array d'araRENG, de cossos
               araRENG 3 get dup
               CyTm
               EnRETIRA exch put
               araRENG exch 3 exch put  %% desem
              }ifelse  %% ampliem l'array?
             }
             {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
              %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
              %% componem a l'index iSuara el primer array d'araRENG, de posicions X
              araRENG 0 get dup
              iXfX dup length array copy  %% x profilaxi!
              iSuara exch put
              araRENG exch 0 exch put  %% desem
              %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
              araRENG 1 get dup
              3 -1 roll
              iSuara exch put
              araRENG exch 1 exch put  %% desem
              %% componem a l'index iSuara el tercer array d'araRENG, de tipus
              araRENG 2 get dup
              QuinaFONT
              iSuara exch put
              araRENG exch 2 exch put  %% desem
              %% componem a l'index iSuara el quart array d'araRENG, de cossos
              araRENG 3 get dup
              CyTm
              iSuara exch put
              araRENG exch 3 exch put  %% desem
             }ifelse
             exit  %% sortim doncs ja hem compost el signe te tocava
            }ifelse  %% componem cap a l'esquerra o cap a la dreta
           }ifelse  %% null o no?
          }forall  %% de l'array de posicions
         }
         {  %% el reng NO existeix
          %% ampliem el primer array d'araRENG, de posicions X, 1+ x la dreta ...
          iXfX dup length array copy  %% x profilaxi!
          araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
          %% ampliem el segon array d'araRENG, de noms de signes, 1+ x la dreta ...
          araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
          %% ampliem el tercer array d'araRENG, de tipus, 1+ x la dreta ...
          QuinaFONT
          araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
          %% ampliem el quart array d'araRENG, de cossos, 1+ x la dreta ...
          CyTm
          araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
         }ifelse
         %% test
         %% isiGne 1 add /isiGne exch def

         iU esUnicode
         {
          2
         }
         {
          1
         }ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
         iU maxLoop ge
         {
          esUnicode
          {
           length 2 idiv /faCadena exch def
          }
          {
           length/faCadena exch def
          }ifelse
          %% pop
          exit
         }if  %% hem llegit tota la cadena?
        }loop  %% x cada un dels caracters del la cadena de dins TJ

        EStrepitgen
        {  %% si es trepitgen tornem a reiniciar el loop amb els paràmetres adients...
         %% si es trepitgen (cal avaluar aquí si són a la mateixa OC? o ho farem quan generem rengsDtext?)...
         %% primer refem l'array original via /CLONaraRENG
         yRENGS dup araPlana get dup quinRENG CLONaraRENG put  %% desem l'araRENG sense modificar dins el dic de la plana
         araPlana exch put  %% desem la plana i el dic dins yRENGS
         pop  %% ens carreguem el literal que es trepitja

         [  %% array d'elements pel reng, on tots el seus index coincidiran!
          []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
          %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
          %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
          %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
          %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
          %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
          %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
          %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
          []  %% 1: el segon, una array amb els literals dels signes ordenats segons codi (pot no coincidir amb l'ordre de lectura)
          %% correctament on, si hi hagues una separacio (espai o no), contindria un null
          []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
          []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
          Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
          {
           null  %% 4: el cinque, ens indica si la linia es rotada (null=NO angle=SI)
          }
          {
           Aeix  %% valor de l'angle
          }ifelse
          quinOC  %% 5: el sisè, ens diu el nom de la capa (Optional Content), si no és a cap durà /MRCT_capOC
         ]
         /araRENG exch def
         /HiHaY false def  %% el reng NO existeix
         iEStrepitgen 1 add /iEStrepitgen exch def  %% gatell per saber si haurem generat una nova araRENG per un mot trepitjat
         /EStrepitgen false def  %% desactivem el gatell, doncs només hem de passar 1 sol cop per aquí
        }
        {  %% si no es trepitgen, sortim definitivament
         iEStrepitgen 0 ne
         {  %% venim d'un mot trepitjat i haurem generat una nova araRENG
          %% segon avaluem si /trepiTjats existeix
          yRENGS araPlana get /trepiTjats known
          {  %% si existeix extraiem l'array de la línia del reng...
           yRENGS araPlana get /trepiTjats get
           %% ...si existeix, mirem si ja hi ha la clau Y, i si hi és...
           dup quinRENG known
           {  %% la hi deixem
            quinRENG get
           }
           {  %% si no hi és en posem una de buida
            pop []
           }ifelse
           %% ...l'ampliem amb el nou araRENG...
           dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
           dup araVa araRENG put /NOUarareng exch def
           %% i redesem /trepiTjats refet a l'araPlana d'yRENGS
           yRENGS dup araPlana get dup /trepiTjats 1 dict dup quinRENG NOUarareng put put araPlana exch put
           %% (aquí l'array ampliada de la línia del reng que ja existeix a trepiTjats)pstack quit
          }
          {  %% si no existeix, creem l'array de la línia del reng
           %% i desem /trepiTjats a l'araPlana d'yRENGS
           yRENGS dup araPlana get dup /trepiTjats 1 dict dup quinRENG [araRENG] put put araPlana exch put
           %% (aquí l'array de la nova línia del reng per encetar trepiTjats)pstack quit
          }ifelse
         }if
         exit
        }ifelse
       }loop  %% pels mots que es trepitgen

       nullExtra
       {  %% si aquest gatell és actiu voldrà dir que haurem inserit text entremig d'una cadena
        %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
        %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
        %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
        %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

        %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
        araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
        getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
        sub getinterval putinterval araRENG exch 0 exch put

        %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
        araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
        faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
        faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
        baUla exch putinterval araRENG exch 0 exch put

        %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
        araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
        getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
        sub getinterval putinterval araRENG exch 1 exch put

        %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
        araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
        faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
        faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
        baUla exch putinterval araRENG exch 1 exch put

        %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
        araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
        getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
        sub getinterval putinterval araRENG exch 2 exch put

        %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
        araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
        faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
        faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
        baUla exch putinterval araRENG exch 2 exch put

        %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
        araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
        getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
        sub getinterval putinterval araRENG exch 3 exch put

        %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
        araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
        faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
        faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
        baUla exch putinterval araRENG exch 3 exch put
       }if
      }
      {  %% es la prosa (kern)
       Aeix 0 eq  %% si l'eix no es rotat ...
       {
        %% cal veure si aquest cas ha estat contemplat quan es treballa amb els altres operadors de
        %% composició Tj " '

        %% teoria per mesurar si el valor de prosa equival a un espai separador o no, de manera que
        %% l'espai aquí significa que separa paraules diferents doncs si no, només seria una separació
        %% entre caràcters d'una mateixa paraula, tan si són valors inferiors o superiors al quadratí

        %% primera consideració: el valor numèric no és un valor en punts de cícero d'espai de coordenades,
        %% si no que són coordenades de caràcter (caldria dividir per 1000 i multiplicar pel cos real),
        %% això el convertirà en protagonista per les comparacions que farem.

        %% segona consideració: només tindrem en compte els valors negatius per avaluar si és o no és un
        %% espai que separa paraules, doncs els valors negatius enretiren cap a la dreta el signe a
        %% composar en el sentit de lectura actual (d'esquerra a dreta).

        %% tercera consideració: creiem que hem de fonamentar la decisió d'afegir un separador (null)
        %% avaluant el numèric en funció d'un llindar que ara establirem per mitjà de suaraKern
        %% l'experiència ens dirà si hem de ser més subtils a l'hora d'establir aquesta tolerància

        dup 0 lt  %% és un valor negatiu?
        {  %% és superior o igual a suaraKern/1000 de quadratí?
         dup abs suaraKern ge
         {
          /deixaNull true def
          %% /EnRETIRA 0 def  %% index posicionador x defecte?
          %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
          null
          araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
          %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
          null
          araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
          %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
          null
          araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
          %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
          null
          araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
         }
         {
          /deixaNull false def
         }ifelse
        }
        {
         /deixaNull false def
        }ifelse

        %% multipliquem el numeric del kern pel cos i dividim x1000
        %% i restem de TxTm x saber la posicio del caracter seguent
        CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
        mul 1000 div TxTm exch sub
        %% copiem aquest valor al dic de l'estat grafic actiu
        dup EstatGrafic iEG get exch /TxTm exch put
        /TxTm exch def
       }
       {  %% l'eix és rotat
        %% cal veure si aquest cas ha estat contemplat quan es treballa amb els altres operadors de
        %% composició Tj " '

        %% teoria per mesurar si el valor de prosa equival a un espai separador o no, de manera que
        %% l'espai aquí significa que separa paraules diferents doncs si no, només seria una separació
        %% entre caràcters d'una mateixa paraula, tan si són valors inferiors o superiors al quadratí

        %% primera consideració: el valor numèric no és un valor en punts de cícero d'espai de coordenades,
        %% si no que són coordenades de caràcter (caldria dividir per 1000 i multiplicar pel cos real),
        %% això el convertirà en protagonista per les comparacions que farem.

        %% segona consideració: només tindrem en compte els valors negatius per avaluar si és o no és un
        %% espai que separa paraules, doncs els valors negatius enretiren cap a la dreta el signe a
        %% composar en el sentit de lectura actual (d'esquerra a dreta).

        %% tercera consideració: creiem que hem de fonamentar la decisió d'afegir un separador (null)
        %% avaluant el numèric en funció d'un llindar que ara establirem per mitjà de suaraKern
        %% l'experiència ens dirà si hem de ser més subtils a l'hora d'establir aquesta tolerància

        dup 0 lt  %% és un valor negatiu?
        { %% és superior o igual a suaraKern/1000 de quadratí?
         dup abs suaraKern ge
         {
          /deixaNull true def
          %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
          null
          araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
          %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
          null
          araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
          %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
          null
          araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
          %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
          null
          araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
          0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
         }
         {
          /deixaNull false def
         }ifelse
        }
        {
         /deixaNull false def
        }ifelse

        %% multipliquem el numeric del kern pel cos i dividim x1000
        %% i restem de TxTm x saber la posicio del caracter seguent
        CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
        mul 1000 div  %%TxTm exch sub
        /K+ exch def 
        gsave
        %%iXfX TyTm(:-o)pstack quit
        90NET
        {
         0 0
        }
        {
         K+ neg 0
        }ifelse
        aTm dup dup 5 get aS K+ sub add 5 exch put  %%put
        %% si es un angle net de 90 graus, hem de treballar a escala 1
        90NET
        {
         dup 1 get 0 lt
         {
          dup dup 1 -1 put 2 1 put
         }
         {
          dup dup 1 1 put 2 -1 put
         }ifelse
        }
        {
         dup 4 TxTm put  %% posicio X d'inici
         dup 5 TyTm put  %% posicio Y d'inici
        }ifelse
        %% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
        %%sK  %TyTm exch sub
        dup EstatGrafic iEG get exch /TyTm exch put
        /TyTm exch def
        %%sK %TxTm exch sub
        dup EstatGrafic iEG get exch /TxTm exch put
        /TxTm exch def
       }ifelse
      }ifelse
     }forall  %% del paquet
    }stopped
    {
%%     araRENG
%%     CalaixDeTipus araPlana get QuinaFONT get QuinaFONT
%%     Champollion /1 get {== ==}forall
     ( ... peta TJ 0) pstack stop
    }if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    {  %% stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs ([ ) writestring
    {  %% forall
     dup type /stringtype eq
     { %%sEdAs 40 write sEdAs exch writestring sEdAs 41 write
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %% posem els caracters ( ... ) com a cadena
      dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
      dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
      %%% fi de salvaparent2.ps
      sEdAs exch writestring
      sEdAs 32 write
     }
     {
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     } ifelse
    } forall
    sEdAs (] TJ\012) writestring
    %%sEdAs (TJ\015) writestring
    }stopped{( ... peta TJ) == quit}if
   }
   {  %% 2 (correccio L·L)
    {  %% stopped
    dup
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs ([ ) writestring
    {  %% forall
     dup type /stringtype eq
     { %%sEdAs 40 write sEdAs exch writestring sEdAs 41 write
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %% posem els caracters ( ... ) com a cadena
      dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
      dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
      %%% fi de salvaparent2.ps
      sEdAs exch writestring
      sEdAs 32 write
     }
     {
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     } ifelse
    } forall
    sEdAs (] TJ\012) writestring
    %%sEdAs (TJ\015) writestring

    %% KTCS  computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm add
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    /TyTm exch def
    %% KTCS
    {  %% forall del paquet
     dup type /stringtype eq
     {
      %% control de linia
      ReNG begin  %% entrem el dic x jugar amb les variables
      Ylinia TyTm eq  %% encara som al mateix reng?
      {
       /Areng true def
       dup Ulinia
       dup length dup /dNou exch def 1 add array dup 3 -1 roll 0 exch putinterval
       dup 3 -1 roll dNou exch put  %% incrustem la cadena a la darrera posicio de l'array ampliada
       /Ulinia exch def  %% desem la nova array ampliada amb les cadenes pertanyents al mateix reng
      }
      {
       capLpeus length 0 eq  %% ets la primera cadena i reng que llegim del fitxer?
       {
        %% desem la cadena i la posicio d'inici quan es el primer
        dup Ulinia
        dup length dup /dNou exch def 1 add array dup 3 -1 roll 0 exch putinterval
        dup 3 -1 roll dNou exch put  %% incrustem la cadena a la darrera posicio de l'array ampliada
        /Ulinia exch def  %% desem la nova array ampliada amb les cadenes pertanyents al mateix reng
        %% desem la posicio d'inici de reg i en creem l'array de les 4 posicions x desar-lo
        /iniciYreng TyTm def  %% desem l'inici Y del nou reng
        /iniciXreng TxTm def  %% desem l'inici X del nou reng
        capLpeus dup length dup /dNou exch def 1 add array dup 3 -1 roll 0 exch putinterval
        dup dNou [iniciXreng iniciYreng null null] put  %% incrustem el paquet amb les dues primeres posicions d'inci de reng a l'array ampliada
        /capLpeus exch def  %% desem l'array ampliada amb la nova ccordenada d'inici del reng
        /Ylinia TyTm def  %% desem la nova posicio Y del reng
        /Areng false def  %% ens diu tambe que som a la primera cadena de text de la plana
       }
       {
        %% desem el reng que acabem de tancar al paquet Linies
        Ulinia Linies dup length dup /dNou exch def 1 add array dup 3 -1 roll 0 exch putinterval
        dup 3 -1 roll dNou exch put  %% incrustem el paquet amb el nou reng a la darrera posicio de l'array ampliada
        /Linies exch def  %% desem l'array ampliada amb els rengs capturats fins ara
        %% desem la posicio de final de reng al darrer array existent de 4 posicions al paquet capLpeus
        capLpeus dup length 1 sub get dup 2 finalXreng put 3 finalYreng put
        /Ylinia TyTm def  %% desem la nova posicio Y del reng
        dup /Ulinia exch 1 array astore def  %% desem la nova cadena a l'array renovat de linia
        /Areng false def  %% ens diu que ja hem acabat el reng
        /iniciYreng TyTm def  %% desem l'inici Y del nou reng
        /iniciXreng TxTm def  %% desem l'inici X del nou reng
        %% desem la posicio d'inici de reg i en creem l'array de els 4 posicions
        capLpeus dup length dup /dNou exch def 1 add array dup 3 -1 roll 0 exch putinterval
        dup dNou [iniciXreng iniciYreng null null] put  %% incrustem el paquet amb les dues primeres posicions d'inci de reng a l'array ampliada
        /capLpeus exch def  %% desem l'array ampliada amb la nova coordenada d'inici del reng
       }ifelse
      }ifelse
      end  %% sortim del dic
      {  %% forall de la cadena de text
       %% KTCS  posicio x,y d'inici de caracter
       TxTm
       %%     dup ==
       /XsigneO exch def  %% desem la posicio X d'inici de caracter
       TyTm
       %%     dup ==
       /YsigneO exch def  %% desem la posicio Y d'inici de caracter
       ReNG /Areng get  %% gatell que ens diu si comencem o no una linia nova (quan a la Y sigui diferent!)
       {  %% som dins la mateixa Y de la linia, llavors avaluem quin es l'ample de caracter mes gran dins la mateixa linia ...
        XsigneO suaraX sub dup ReNG /Cinyell get gt {ReNG exch /Cinyell exch put}{pop}ifelse
       }if
       %% treiem l'ample (Width metrics) de cada caracter ...
       CalaixDeTipus
%% UiX
araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
       QuinaFONT get dup 1 get 2 index exch sub exch 2 get exch get
       %% aqui multipliquem l'ample de la metrica pel cos i dividim x 1000 + TxTm x saber la posicio del caracter seguent
       CxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       mul 1000 div
       %% aquest es l'ample real de cadascun dels caracters ...
       %%dup ==
       %% es suma a cada caracter el valor definit per Tc
       ecTc
       SxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       mul  %% aquest factor definit per Tc sempre va multiplicat pel multiplicador d'escala X del cos del text
       %% aquest valor d'espaiat entre caracters l'hem de considerar (restant a XsigneF) per calcular correctament Cinyell
       %% i tambe restar-lo 1 vegada al final del calcul del l'ample de linia
       dup /prosaextra exch def
       add
       TxTm add
       %% copiem aquest valor al dic de l'estat grafic actiu
       dup EstatGrafic iEG get exch /TxTm exch put
       /TxTm exch def
       EncNETiPLANXAT exch get
       dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
       {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
        epTw
        SxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
        mul  %% ep! que aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos del text
        TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
        %% copiem aquest valor al dic de l'estat grafic actiu
        dup EstatGrafic iEG get exch /TxTm exch put
        /TxTm exch def
       }if
       %% KTCS  posicio x,y de final de caracter
       TxTm
       %%     dup ==
       /XsigneF exch def  %% desem la posicio X de final de caracter
       TyTm
       %%     dup ==
       /YsigneF exch def  %% desem la posicio Y de final de caracter
       %% cadra posar el gatell Areng?
       %% li restem la prosa extra establerta per Tc xq el calcul de Cinyell sigui el correcte
       XsigneF prosaextra sub /suaraX exch def
       %% procediment de cerca per un determinat parell d'inici/final
       dup /guillemotleft  eq  %% inici
       {
        pop
        %%(OBRIR ... ) ==
        /araE true def  %% obrim la generacio d'etiquetes
       }
       {
        dup /guillemotright eq  %% final
        {
         pop
         %%( ... TANCAR) ==
         /araE false def  %% tanquem la generacio d'etiquetes
         %%QueTa ==  % treiem x la pantalleta x test
         /QueTa () def  %% inicialitzem
        }
        {
         araE
         {
          d_WAE exch get QueTa dup length 1 add string dup 3 -1 roll 0 exch putinterval  %% enganxem la cadena fins ara
          dup dup length 1 sub 4 -1 roll put /QueTa exch def  %% enganxem el nou caracter a la cadena
         }
         {
          pop
         }ifelse
        }ifelse
       }ifelse
       %% fi de procediment de cerca per un determinat parell d'inici/final
      }forall  %% de la cadena de text
      %% control de linia
      ReNG begin  %% entrem el dic x jugar amb les variables
      /finalXreng XsigneF def  %% podria ser el final X del reng
      /finalYreng YsigneF def  %% podria ser el final Y del reng
      end
     }
     {  %% es la prosa (kern)
      %% aqui multipliquem el numeric del kern pel cos i dividim x 1000 i el restem de TxTm x saber la posicio del caracter seguent
      CxTm acTz mul 100 div  %%% KTCS apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
      mul 1000 div TxTm exch sub
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TxTm exch put
      /TxTm exch def
     }ifelse
    }forall  %% del paquet
    }stopped{( ... peta TJ) == stop}if
   }
   {  %% 3 analisi textual (JBC)
%    {  % stopped
    %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /LleixaBuida false def
    %% computem el valor del Ts (text rise)
    TyTs SyTm mul TyTm add
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /TyTm exch put
    dup /TyTm exch def
    %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia la coordenada
    %% y i l'angle, de forma que els dos hauran de coincidir xq siguin considerats dins el mateix reng
    %%eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
    EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
    {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
     %%% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat
     90NET
     {  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
cvi  %% EP!MASATS treballarem només amb l'enter
      256 string cvs
      EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
      TxTm
cvi  %% EP!MASATS treballarem només amb l'enter
      256 string cvs  %% ara lliguem la X en ves de l'angle
      1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
      6 -1 roll 0 exch putinterval
      UndeR (_) putinterval
      UndeR 1 add 4 -1 roll putinterval
     }
     {
cvi  %% EP!MASATS treballarem només amb l'enter
      256 string cvs
      EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
      1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
      6 -1 roll 0 exch putinterval
      UndeR (_) putinterval
      UndeR 1 add 4 -1 roll putinterval
     }ifelse
    }
    {
     /Aeix 0 def

     %%Mishima: filtrem la coordenada Y per tal siguin significatius fins a 7 decimals
%     10000 mul truncate 10000 div
cvi  %% EP!MASATS treballarem només amb l'enter
     256 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
    }ifelse
    %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
    yRENGS araPlana get dup 2 index known
    %%pop {== ==}forall
    {  %% existeix
     exch get /araRENG exch def  %% capturem l'array amb els elements del reng
     /HiHaY true def  %% el reng ja existeix
    }
    {  %% l'hem de crear
     exch
     [  %% array d'elements pel reng, on tots el seus index coincidiran!
      []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
      %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
      %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
      %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
      []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
      %% correctament on, si hi hagues una separacio (espai o no), contindria un null
      []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
      []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
      Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
      {
       null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
      }
      {
       Aeix  %% valor de l'angle
      }ifelse
     ]
     dup /araRENG exch def
     put  %% la desem al dic de la pagina
     /HiHaY false def  %% el reng NO existeix
     %% valors inicials de la translacio Tm de control signe a signe x concat
     /transX TxTm def
     /transY TyTm def
    }ifelse
    %% array de caracter amb les posicions:
    %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
    %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
    %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
    %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
    /iXfX 6 array def  %% ara de 6 posicions!
    %%% test
    %% /isiGne 0 def
    {  %% forall del paquet
     dup type /stringtype eq
     {  %% es la cadena de text (analisi idem Tj)

%%dup (\000\013\000?) eq {/@--`-,-- true def}{/@--`-,-- false def}ifelse
%%@--`-,-- {esUnicode(o)pstack quit}if
      %%      {  % forall de la cadena de text

      dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
      /iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)
      {  %% loop per cada un dels caracters de la cadena de text dins TJ
       maxLoop 0 eq {pop exit}if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
       dup
       iU esUnicode{2 getinterval 1 get}{1 getinterval 0 get}ifelse
       /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
       %%  posicio x,y d'inici de caracter
       TxTm
       %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
       Aeix 0 eq
       {
        dup iXfX exch 0 exch put  %% x JBC
       }
       {
        dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
        {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
         pop
        }
        {
         div
        }ifelse
        iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
       }ifelse

       Aeix 0 eq  %% si l'eix no es rotat ...
       {  %% no cal q la normalitzem
        iXfX exch 2 exch put  % coordenada X d'inici del signe
        iXfX 3 TyTm put  %% coordenada Y d'inici del signe
       }
       {  %% normalitzem
        %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
        gsave
        aTm
        %% si es un angle net de 90 graus, hem de treballar a escala 1
        90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
        %% la translacio q ens interessa es la del x,y d'origen del signe
        dup 3 -1 roll 4 exch put  %% posicio X d'inici
        dup 5 TyTm put  %% posicio Y d'inici
        %% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
        0 exch 0 exch
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
        /transY exch def  %% desem pel proper concat?
        /transX exch def  %% desem pel proper concat?
        iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
        iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
       }ifelse

       %%%***
       %%(\n)print flush
       %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
       %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush
       %%%***
       %% treiem l'ample (Width metrics) de cada caracter ...
       CalaixDeTipus
%% UiX
       araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
       QuinaFONT get

       esUnicode
       {
        1 index exch
       }
       {
        dup 1 get 2 index exch sub exch
       }ifelse

       2 get exch get
       %% multipliquem l'ample de la metrica pel cos i dividim x1000+TxTm x saber la posicio del signe seguent

       CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       mul 1000 div
       %% es suma a cada caracter el valor definit per Tc
       ecTc
       SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       %% aquest factor definit per Tc sempre va multiplicat pel multiplicador d'escala X del cos del text
       mul add
       dup /aS exch def  %% nomes l'ample del signe
       Aeix 0 eq
       {
        TxTm add  %% sumem el valor anterior ara
       }
       {
        dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
        %% desem la posicio X final del signe de la linia de base x si hem de fer la correccio d'espai
        /XfLB exch def
        TxTm add  %% sumem el valor anterior ara
        %%%>>%%%
       }ifelse
       %% copiem aquest valor al dic de l'estat grafic actiu
       dup EstatGrafic iEG get exch /TxTm exch put
       /TxTm exch def
       EncNETiPLANXAT exch get
       dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
       {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
        epTw
        SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
        mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos de text
        Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
        {
         dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
         dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
        }if
        TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
        %% copiem aquest valor al dic de l'estat grafic actiu
        dup EstatGrafic iEG get exch /TxTm exch put
        /TxTm exch def
       }if

       Aeix 0 eq  %% si l'eix no es rotat ...
       {  %% no cal q la normalitzem
        %% posicio x,y de final de caracter
        TxTm
        dup iXfX exch 1 exch put
        iXfX exch 4 exch put  %% coordenada X de final del signe
        TyTm
        iXfX exch 5 exch put  %% coordenada Y de final del signe
       }
       {  %% normalitzem
        %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
        gsave
        %% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
        aS abs  %% hem d'anul.lar el signe de l'amplada xq la coordenada corregida es calculi correctament
        0
        aTm
        %% si es un angle net de 90 graus, hem de treballar a escala 1
        90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
        %% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
        dup /transY exch def  %% desem pel proper concat?
        /TyTm exch def  %% nova posisico Y d'inici pel proper signe
        dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
        /transX exch def  %% desem pel proper concat?
        iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
        iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
        %% desem la coordenada X de final de caracter mesurada en horitzontal
        Aeix 0 ne
        {  %% si es rotada
         iXfX 1 XfLB put
        }
        {  %% sense rotar
         iXfX 1 TxTm put
        }ifelse
       }ifelse

       %%iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
       %%iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
       %%(Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush

 /nullExtra false def

       HiHaY
       {  %% el reng existeix
        araRENG 0 get
        {  %% forall de l'array de posicions
         dup type /nulltype eq
         {
          %%(AIXO es un NULL!!!)==
          pop
         }
         {
          0 get dup  %% l'inici del primer caracter de la cadena q ja tenim ...
          iXfX 0 get ge  %% ... es + gran o igual q el l'inici del signe q volem situar ...
          {  %% componem cap a l'esquerra
           %% tram on calculem l'index on anira el caracter q componem dins la cadena
           pop
           araRENG 0 get  %% treiem l'array de posicions
           /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
           /EnRETIRA 0 def  %% index posicionador x defecte?
           %% extraiem el darrer array NO null començant per l'index n-1
           %% que el seu origen es igualat o superat per l'origen de iXfX
           dup length 1 sub -1 0
           {  %% for
            dup /iSuara exch def  %% desem l'index
            1 index exch get dup type /nulltype eq
            {
             pop
%%deixaNull
%%{
%% iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
%%}if
            }
            {
             dup 0 get iXfX 0 get ge  %% el seu origen es igualat o superat per l'origen de iXfX?
             {
              iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
              /aSuara exch def
             }
             {
              pop exit
             }ifelse
            }ifelse
           }for
           pop
           aSuara 0 get
           iXfX 0 get sub
           %%% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
           %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
           %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
           iXfX dup 1 get exch 0 get sub
           %% dividim x saber quants n'hi caben i passem a enter (eliminant el decimal)
           dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
           {
            pop pop 0
           }
           {
            div cvi abs
           }ifelse
           EnRETIRA sub

         dup 0 lt
         {  %% filtrem els valors negatius (fan petar l'algorisme!)
          pop 0
         }if
           %% fi del tram on podem afinar la tolerancia 
           %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
           %% test
           %%iSignE 1 eq {araRENG EnRETIRA aSuara (;-\) COMPONEM A L'ESQUERRA!)pstack quit}if
           %%iSignE 1 add /iSignE exch def
           %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
           /NOmaseguis true def
           dup 0 eq
           {
            araRENG 1 get iSuara get /space eq
            {
             %% pop /NOmaseguis false def  % l'aixafem!
             %% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
             %% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
             %% consequencies dins la localitzacio de coordenades dels signes
             pop 1
            }
            {
             pop 1
            }ifelse
           }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
           NOmaseguis
           {  %% un anira darrera l'altre
            %% ampliem el primer array d'araRENG, de posicions X, EnRETIRA + x l'esquerra ...
            /EnRETIRA exch def  %% desem l'index posicionador
            araRENG 0 get dup length EnRETIRA add array dup 3 -1 roll
            EnRETIRA exch putinterval dup
            iXfX dup length array copy  %% x profilaxi!
            0 exch put  %% sempre sera a ZERO ?
            araRENG exch 0 exch put  %% desem
            %% ampliem el segon array d'araRENG, de noms de signes, EnRETIRA + x l'esquerra ...
            araRENG 1 get dup length EnRETIRA add array dup 3 -1 roll
            EnRETIRA exch putinterval dup 3 -1 roll
            0 exch put  %% sempre sera a ZERO ?
            araRENG exch 1 exch put  %% desem
            %% ampliem el tercer array d'araRENG, de tipus, EnRETIRA + x l'esquerra ...
            araRENG 2 get dup length EnRETIRA add array dup 3 -1 roll
            EnRETIRA exch putinterval dup
            0 QuinaFONT put  %% sempre sera a ZERO ?
            araRENG exch 2 exch put  %% desem
            %% ampliem el quart array d'araRENG, de cossos, EnRETIRA + x l'esquerra ...
            araRENG 3 get dup length EnRETIRA add array dup 3 -1 roll
            EnRETIRA exch putinterval dup
            0 CyTm put  %% sempre sera a ZERO ?
            araRENG exch 3 exch put  %% desem
           }
           {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
              %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
              %% componem a l'index iSuara el primer array d'araRENG, de posicions X
            araRENG 0 get dup
            iXfX dup length array copy  %% x profilaxi!
            iSuara exch put
            araRENG exch 0 exch put  %% desem
            %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
            araRENG 1 get dup
            3 -1 roll
            iSuara exch put
            araRENG exch 1 exch put  %% desem
            %% componem a l'index iSuara el tercer array d'araRENG, de tipus
            araRENG 2 get dup
            QuinaFONT
            iSuara exch put
            araRENG exch 2 exch put  %% desem
            %% componem a l'index iSuara el quart array d'araRENG, de cossos
            araRENG 3 get dup
            CyTm
            iSuara exch put
            araRENG exch 3 exch put  %% desem
           }ifelse
           exit  %% sortim doncs ja hem compost el signe te tocava
          }
          {  %% componem cap a la dreta
             %% tram on calculem l'index on anira el caracter q componem dins la cadena

/nullExtra true def

           pop          
           araRENG 0 get  %% treiem l'array de posicions
           /aSuara[0 0]def  %% definim l'array inicial a zero si no es trobat
           dup length 1 sub /EnRETIRA exch def  %% index posicionador x defecte?
           %% extraiem el darrer array NO null començant per l'index 0
           %% que el seu origen es igualat o superat per l'origen de iXfX
           0 1 EnRETIRA
           {  %% for
            dup /iSuara exch def  %% desem l'index
            1 index exch get dup type /nulltype eq
            {
             pop
%deixaNull
%{
% iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
%}if
            }
            {
             dup 0 get iXfX 0 get le  %% el seu origen es igualat o superat per l'origen de iXfX?
             {
              iSuara /EnRETIRA exch def  %% desem l'index posicionador definitiu
              /aSuara exch def
             }
             {
              pop exit
             }ifelse
            }ifelse
           }for
           pop

%% no apliquem això ara:
%% comptem quants nulls hi ha entremig del mot de més a l'esquerra i el de més a la dreta
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena TJ
%% /hihaNulls 0 def
%% araRENG 0 get dup length 1 sub  %% final
%% EnRETIRA 1 add  %% inici
%% exch
%% 1 exch  %% salt
%% {  %% for
%%  1 index exch get
%%  type /nulltype eq
%%  { 
%%   hihaNulls 1 add /hihaNulls exch def
%%  }
%%  {
%%   exit
%%  }ifelse
%% }for
%% pop  %% ens carreguem l'array
%% }if  %% només un cop i a l'inici de la cadena TJ

           aSuara 1 get
           iXfX 1 get sub
           %% tram on podem afinar la tolerancia de comportament d'espaiat de signes (null)
           %% en comptes d'avaluar l'ample del mes ample a l'array de CalaixDeTipus, avaluem
           %% el mateix ample del caracter x calcular quants de cops hi cabria x endevinar la posicio
           iXfX dup 1 get exch 0 get sub
           %% dividim x saber quants n'hi caben i passem a enter treient el signe (i eliminant el decimal)
           dup 0 eq  %% evitem la divisio x zero (undefinedresult!)
           {
            pop pop 0
           }
           {
            div cvi abs
           }ifelse
           %% fi del tram on podem afinar la tolerancia
           %% gatell x saber si aixafem el signe existent pel fet de ser un espai en blanc (/space)
           /NOmaseguis true def
           dup 0 eq
           {
            araRENG 1 get iSuara get /space eq
            {
             %% pop /NOmaseguis false def  % l'aixafem!
             %% desactivem l'aixafat de l'espai en blanc doncs nomes afecta a l'extraccio textual i al
             %% recompte del rang de signes a extraure per consultar a la BD, pero no te aparentment
             %% consequencies dins la localitzacio de coordenades dels signes
             pop 1
            }
            {
             pop 1
            }ifelse
           }if  %% malgrat cavalquin dos signes, un anira darrera l'altre tret que el de sota sigui un /space
           NOmaseguis
           {  %% un anira darrera l'altre

%% no apliquem això ara:
%% iU 0 eq
%% {  %% només un cop i a l'inici de la cadena TJ
 %% si hi ha prous nulls entremig per contenir exactament la cadena que situem ara
%% 2 index length 2 add hihaNulls le
%% {  %% llavors, la situem immediatament després del mot de més a l'esquerra separada per un null
%%  pop 2  %% sumaran dues posicions cap a la dreta per que hi quedi un null entremig
%% }if
%% }if  %% només un cop i a l'inici de la cadena TJ

            EnRETIRA add
            /EnRETIRA exch def  %% fixem finalment l'index real posicionador
            %% fi del tram on calculem l'index on anira el caracter q componem dins la cadena
            %% test
            %%iSignD 0 eq {araRENG aSuara iSuara EnRETIRA(!!componem a la dretAAA!!)pstack quit}if
            %%iSignD 1 add /iSignD exch def
            araRENG 0 get length EnRETIRA le
            {  %% aqui ampliem els arrays segons la diferencia d'index amb EnRETIRA
             EnRETIRA araRENG 0 get length 1 sub sub /Eixamplem exch def  %% de quant ampliem l'array?
             %% ampliem el primer array d'araRENG, de posicions X, Eixamplem + x la dreta
             araRENG 0 get dup length Eixamplem add array
             dup 3 -1 roll 0 exch putinterval
             %% ... i afegim el nom desat a comPARA
             dup EnRETIRA iXfX dup length array copy put  %% x profilaxi!
             araRENG exch 0 exch put  %% desem
             %% ampliem el segon array d'araRENG, de noms de signes, Eixamplem + x la dreta
             araRENG 1 get dup length Eixamplem add array
             dup 3 -1 roll 0 exch putinterval
             %% ... i afegim el nom desat a comPARA
             dup EnRETIRA 4 -1 roll put
             araRENG exch 1 exch put  %% desem
             %% ampliem el tercer array d'araRENG, de tipus, Eixamplem + x la dreta
             araRENG 2 get dup length Eixamplem add array
             dup 3 -1 roll 0 exch putinterval
             %% ... i afegim el nom desat a comPARA
             dup EnRETIRA QuinaFONT put
             araRENG exch 2 exch put  %% desem
             %% ampliem el quart array d'araRENG, de cossos, Eixamplem + x la dreta
             araRENG 3 get dup length Eixamplem add array
             dup 3 -1 roll 0 exch putinterval
             %% ... i afegim el nom desat a comPARA
             dup EnRETIRA CyTm put
             araRENG exch 3 exch put  %% desem
            }
            {
             araRENG 0 get length EnRETIRA ge
             {  %% vol dir que el signe q afegim va entremig
                %% aqui els arrays o s'han d'ampliar pel mig 1+ a la posicio que marca EnRETIRA
              %% tret que ja hi hagi un null a l'index on apunta EnRETIRA!
              araRENG 0 get EnRETIRA get null ne
              {  %% no hi ha cap null, llavors ampliem
               %% l'array de posicions
               araRENG 0 get length dup 1 add array exch araRENG 0 get
               exch EnRETIRA exch EnRETIRA sub getinterval
               1 index exch EnRETIRA 1 add exch putinterval dup
               araRENG 0 get 0 EnRETIRA getinterval 0 exch putinterval
               araRENG exch 0 exch put
               %% l'array de noms de signes
               araRENG 1 get length dup 1 add array exch araRENG 1 get
               exch EnRETIRA exch EnRETIRA sub getinterval
               1 index exch EnRETIRA 1 add exch putinterval dup
               araRENG 1 get 0 EnRETIRA getinterval 0 exch putinterval
               araRENG exch 1 exch put
               %% l'array de tipus
               araRENG 2 get length dup 1 add array exch araRENG 2 get
               exch EnRETIRA exch EnRETIRA sub getinterval
               1 index exch EnRETIRA 1 add exch putinterval dup
               araRENG 2 get 0 EnRETIRA getinterval 0 exch putinterval
               araRENG exch 2 exch put
               %% l'array de cossos
               araRENG 3 get length dup 1 add array exch araRENG 3 get
               exch EnRETIRA exch EnRETIRA sub getinterval
               1 index exch EnRETIRA 1 add exch putinterval dup
               araRENG 3 get 0 EnRETIRA getinterval 0 exch putinterval
               araRENG exch 3 exch put
              }if
             }if
             %% ... o queden intactes de mida, doncs ja han quedat ampliats abans
             %% componem a l'index EnRETIRA el primer array d'araRENG, de posicions X
             araRENG 0 get dup
             iXfX dup length array copy  %% x profilaxi!
             EnRETIRA exch put
             araRENG exch 0 exch put  %% desem
             %% componem a l'index EnRETIRA el segon array d'araRENG, de noms de signes
             araRENG 1 get dup
             3 -1 roll
             EnRETIRA exch put
             araRENG exch 1 exch put  %% desem
             %% componem a l'index EnRETIRA el tercer array d'araRENG, de tipus
             araRENG 2 get dup
             QuinaFONT
             EnRETIRA exch put
             araRENG exch 2 exch put  %% desem
             %% componem a l'index EnRETIRA el quart array d'araRENG, de cossos
             araRENG 3 get dup
             CyTm
             EnRETIRA exch put
             araRENG exch 3 exch put  %% desem
            }ifelse  %% ampliem l'array?
           }
           {  %% aixafem el signe existent pel fet de ser un espai en blanc (/space)
            %% queda intacte de mida, doncs maseguem un signe sobre l'altre (iSuara fa la funcio d'EnRETIRA)
            %% componem a l'index iSuara el primer array d'araRENG, de posicions X
            araRENG 0 get dup
            iXfX dup length array copy  %% x profilaxi!
            iSuara exch put
            araRENG exch 0 exch put  %% desem
            %% componem a l'index iSuara el segon array d'araRENG, de noms de signes
            araRENG 1 get dup
            3 -1 roll
            iSuara exch put
            araRENG exch 1 exch put  %% desem
            %% componem a l'index iSuara el tercer array d'araRENG, de tipus
            araRENG 2 get dup
            QuinaFONT
            iSuara exch put
            araRENG exch 2 exch put  %% desem
            %% componem a l'index iSuara el quart array d'araRENG, de cossos
            araRENG 3 get dup
            CyTm
            iSuara exch put
            araRENG exch 3 exch put  %% desem
           }ifelse
           exit  %% sortim doncs ja hem compost el signe te tocava
          }ifelse  %% componem cap a l'esquerra o cap a la dreta
         }ifelse  %% null o no?
        }forall  %% de l'array de posicions
       }
       {  %% el reng NO existeix
        %% ampliem el primer array d'araRENG, de posicions X, 1+ x la dreta ...
        iXfX dup length array copy  %% x profilaxi!
        araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
        0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
        %% ampliem el segon array d'araRENG, de noms de signes, 1+ x la dreta ...
        araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
        0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
        %% ampliem el tercer array d'araRENG, de tipus, 1+ x la dreta ...
        QuinaFONT
        araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
        0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
        %% ampliem el quart array d'araRENG, de cossos, 1+ x la dreta ...
        CyTm
        araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
        0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
       }ifelse
       %% test
       %%isiGne 1 add /isiGne exch def

       iU esUnicode{2}{1}ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
       iU maxLoop ge
       {

esUnicode{length 2 idiv /faCadena exch def}{length/faCadena exch def}ifelse
        %%pop
        exit
       } if  %% hem llegit tota la cadena?
      } loop  %% x cada un dels caracters del la cadena de dins TJ

%deixaNull
%{
nullExtra
%}
%{
% false
%}ifelse
{  %% si aquest gatell és actiu voldrà dir que haurem inserit text entremig d'una cadena
 %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
 %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
 %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
 %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

 %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 0 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 0 exch put

 %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 1 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 1 exch put
%%(:-u) pstack quit

 %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 2 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 2 exch put

 %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
 araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
 getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
 sub getinterval putinterval araRENG exch 3 exch put

%% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
baUla exch putinterval araRENG exch 3 exch put

}if

     %% }forall  % de la cadena de text

     }
     {  %% es la prosa (kern)
      Aeix 0 eq  %% si l'eix no es rotat ...
      {
%% cal veure si aquest cas ha estat contemplat quan es treballa amb els altres operadors de
%% composició Tj " '

%% teoria per mesurar si el valor de prosa equival a un espai separador o no, de manera que
%% l'espai aquí significa que separa paraules diferents doncs si no, només seria una separació
%% entre caràcters d'una mateixa paraula, tan si són valors inferiors o superiors al quadratí

%% primera consideració: el valor numèric no és un valor en punts de cícero d'espai de coordenades,
%% si no que són coordenades de caràcter (caldria dividir per 1000 i multiplicar pel cos real),
%% això el convertirà en protagonista per les comparacions que farem.

%% segona consideració: només tindrem en compte els valors negatius per avaluar si és o no és un
%% espai que separa paraules, doncs els valors negatius enretiren cap a la dreta el signe a
%% composar en el sentit de lectura actual (d'esquerra a dreta).

%% tercera consideració: creiem que hem de fonamentar la decisió d'afegir un separador (null)
%% avaluant el numèric en funció d'un llindar que ara establirem per mitjà de suaraKern
%% l'experiència ens dirà si hem de ser més subtils a l'hora d'establir aquesta tolerància

dup 0 lt  %% és un valor negatiu?
{  %% és superior o igual a suaraKern/1000 de quadratí?
 dup abs suaraKern ge
 {
  /deixaNull true def
%% /EnRETIRA 0 def  %% index posicionador x defecte?
  %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
  null
  araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
  %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
  null
  araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
  %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
  null
  araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
  %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
  null
  araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
%(:-1)araRENG 1 get pstack quit
 }
 {
  /deixaNull false def
 }ifelse
}
{
 /deixaNull false def
}ifelse

       %% multipliquem el numeric del kern pel cos i dividim x1000
       %% i restem de TxTm x saber la posicio del caracter seguent
       CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       mul 1000 div TxTm exch sub
       %% copiem aquest valor al dic de l'estat grafic actiu
       dup EstatGrafic iEG get exch /TxTm exch put
       /TxTm exch def
      }
      {  %% l'eix és rotat
%% cal veure si aquest cas ha estat contemplat quan es treballa amb els altres operadors de
%% composició Tj " '

%% teoria per mesurar si el valor de prosa equival a un espai separador o no, de manera que
%% l'espai aquí significa que separa paraules diferents doncs si no, només seria una separació
%% entre caràcters d'una mateixa paraula, tan si són valors inferiors o superiors al quadratí

%% primera consideració: el valor numèric no és un valor en punts de cícero d'espai de coordenades,
%% si no que són coordenades de caràcter (caldria dividir per 1000 i multiplicar pel cos real),
%% això el convertirà en protagonista per les comparacions que farem.

%% segona consideració: només tindrem en compte els valors negatius per avaluar si és o no és un
%% espai que separa paraules, doncs els valors negatius enretiren cap a la dreta el signe a
%% composar en el sentit de lectura actual (d'esquerra a dreta).

%% tercera consideració: creiem que hem de fonamentar la decisió d'afegir un separador (null)
%% avaluant el numèric en funció d'un llindar que ara establirem per mitjà de suaraKern
%% l'experiència ens dirà si hem de ser més subtils a l'hora d'establir aquesta tolerància

dup 0 lt  %% és un valor negatiu?
{ %% és superior o igual a suaraKern/1000 de quadratí?
 dup abs suaraKern ge
 {
  /deixaNull true def
  %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
  null
  araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
  %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
  null
  araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
  %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
  null
  araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
  %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
  null
  araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
%(:-2)araRENG 1 get pstack quit
 }
 {
  /deixaNull false def
 }ifelse
}
{
 /deixaNull false def
}ifelse

       %% multipliquem el numeric del kern pel cos i dividim x1000
       %% i restem de TxTm x saber la posicio del caracter seguent
       CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       mul 1000 div  %%TxTm exch sub
       /K+ exch def 
       gsave
       %%iXfX TyTm(:-o)pstack quit
       90NET{0 0}{K+ neg 0}ifelse
       aTm dup dup 5 get aS K+ sub add 5 exch put  %%put
       %% si es un angle net de 90 graus, hem de treballar a escala 1
       90NET
       {
        dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse
       }
       {
        dup 4 TxTm put  %% posicio X d'inici
        dup 5 TyTm put  %% posicio Y d'inici
       }ifelse
       %% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
       concat
       matrix currentmatrix  %% valor de la matriu rotada
       grestore
       transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
       itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
       %%sK  %TyTm exch sub
       dup EstatGrafic iEG get exch /TyTm exch put
       /TyTm exch def
       %%sK %TxTm exch sub
       dup EstatGrafic iEG get exch /TxTm exch put
       /TxTm exch def
      }ifelse
     }ifelse
    }forall  %% del paquet

%%yRENGS /1 get {== ==}forall
%%araRENG 0 get ==
%%(:-U)== quit
%%araRENG 1 get
%%(:-4)pstack quit
%    }stopped
%    {
%%     araRENG
%%     CalaixDeTipus araPlana get QuinaFONT get QuinaFONT
%%     Champollion /1 get {== ==}forall
%     ( ... peta TJ)pstack quit
%    }if
   }
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs ([ ) writestring
    {  %% forall
     dup type /stringtype eq
     {  %%sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {  %% loop
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %% posem els caracters ( ... ) com a cadena
      dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
      dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
      %%% fi de salvaparent2.ps
      sEdAs exch writestring
      sEdAs 32 write
     }
     {
      10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     } ifelse
    } forall
    sEdAs (] TJ\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta TJ) == quit}if
   }
  ] i_TJ get /TJ exch bind def

%% Text object
%% (PDF Ref ?) 8.7.2 Text Object operators
  [  %% BT
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (BT\012) writestring
    %%}stopped{( ... peta BT) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual) | gatells: 16
    {  %% stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /CursivaMentidera false def  %% gatell per la falsa italica
    sEdAs (BT\012) writestring
    
    %%% KTCS inicialitzem les variables de text ara i les posem a l'estat grafic actiu
    %% valors inicials de les variables de posicio absoluta del carater definit per Tm
    EstatGrafic iEG get /TxTm 0 cmPx add 2 copy def put
    EstatGrafic iEG get /TyTm 0 cmPy add 2 copy def put
    %%% CAL VEURE SI S'INICIALITZEN LA RESTA DE VALORS I QUE NO PASSI COM INTERLi
    %% valor inicial d'espaiat entre paraules (nomes s'aplica quan troba un /space) definit per Tw
    EstatGrafic iEG get /epTw 0 2 copy def put
    %% valor inicial d'espaiat entre caracters (s'aplica a cada caracter) definit per Tc
    EstatGrafic iEG get /ecTc 0 2 copy def put
    %% valor inicial del % d'escala horitzontal definit per Tz
    EstatGrafic iEG get /acTz 100 2 copy def put
    %% valor inicial del multiplicador d'escala X del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
    EstatGrafic iEG get /SxTm 1 2 copy def put
    %% valor inicial del multiplicador d'escala Y del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
    EstatGrafic iEG get /SyTm 1 2 copy def put
    %% valor per defecte del desplacament vertical del text
    EstatGrafic iEG get /TyTs 0 2 copy def put
    %% NO S'INICIALITZA! valor inicial de l'interliniat (s'aplica amb T* " i ')
    %%EstatGrafic iEG get /INTERli 0 2 copy def put
    %% valors inicials de les coordenades d'inici de cadena, nomes utilitzades pels operadors ' i "
    EstatGrafic iEG get /iTxTm 0 2 copy def put
    EstatGrafic iEG get /iTyTm 0 2 copy def put
    }stopped{( ... peta BT 2) pstack stop}if
   }
   {  %% 3 projecte de verificacio del Col·legi
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %% anellem la llesca sense destriar, de moment, els Forms
    sEdAs dup dup (/OC ) writestring
    llesques 5 get dup 0 true put  %% marquem el text com actiu
    1 get writestring ( BDC\012) writestring
    sEdAs (BT\012) writestring
    %%}stopped{( ... peta BT) == quit}if
   }
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (BT\012) writestring
    }ifelse
   }
  ] i_BT get /BT exch bind def

  [  %% ET
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (ET\012) writestring
    %%}stopped{( ... peta ET) == quit}if
   }
   {  %% 2 (correccio L·L + analisi textual) | gatells: 16
    {  %% stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (ET\012) writestring

    %%% KTCS
    %% inicialitzem els valors de les variables de text a l'estat grafic actiu
    %% valors inicials de les variables de posicio absoluta del carater definit per Tm
    EstatGrafic iEG get /TxTm 0 put
    EstatGrafic iEG get /TyTm 0 put
    %% valor inicial d'espaiat entre paraules (nomes s'aplica quan troba un /space) definit per Tw
    EstatGrafic iEG get /epTw 0 put
    %% valor inicial d'espaiat entre caracters (s'aplica a cada caracter) definit per Tc
    EstatGrafic iEG get /ecTc 0 put
    %% valor inicial del % d'escala horitzontal definit per Tz
    EstatGrafic iEG get /acTz 100 put
    %% valor inicial del multiplicador d'escala X del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
    EstatGrafic iEG get /SxTm 1 put
    %% valor inicial del multiplicador d'escala Y del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
    EstatGrafic iEG get /SyTm 1 put
    %% valor per defecte del desplacament vertical del text
    EstatGrafic iEG get /TyTs 0 put
    %% NO S'INICIALITZA! valor inicial de l'interliniat (s'aplica amb T* " i ')
    %%EstatGrafic iEG get /INTERli 0 put
    %% valors inicials de les coordenades d'inici de cadena, nomes utilitzades pels operadors ' i "
    EstatGrafic iEG get /iTxTm 0 put
    EstatGrafic iEG get /iTyTm 0 put

%% test
%% yRENGS /1 get
%% {pop ==}forall
%% /502.747 get 1 get
%% /483.545
%% /493.146 get 1 get

    }stopped{( ... peta ET 2) pstack stop}if
   }
   {  %% 3 projecte de verificacio de PDF del Col·legi
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (ET\012EMC\012) writestring
    %%}stopped{( ... peta ET) == quit}if
   }
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    alFoc
    {
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (ET\012) writestring
    }ifelse
   }
  ] i_ET get /ET exch bind def

%% Type 3 fonts
%% (PDF Ref ?) 8.10.1 Type 3 font operators
  [  %% d0
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (d0\012) writestring
    %%test
    }stopped{( ... peta d0 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write sEdAs (d0\012) writestring
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta d0) == quit}if
   }
  ] i_d0 get /d0 exch bind def

  [  %% d1
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write}forall
    sEdAs (d1\012) writestring
    %%test
    }stopped{( ... peta d1 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop pop pop pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs exch writestring sEdAs 32 write}forall
     sEdAs (d1\012) writestring
     %%}{6{pop}repeat}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta d1) == quit}if
   }
  ] i_d1 get /d1 exch bind def

%% (PDF Ref 1.7) 10.5 Marked Content
%% (PDF Ref ?) 8.10.3 Marked Content operators

  [  %% MP
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%test
    %%{  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring
    sEdAs 32 write sEdAs (MP\012) writestring
    %%test
    %%}stopped{( ... peta MP) == quit}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring
     sEdAs 32 write sEdAs (MP\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta MP) == quit}if
   }
  ] i_MP get /MP exch bind def

  [  %% DP
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
    dup type /nametype eq
    {
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
    }
    {
     sEdAs (<<) writestring

     sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

%%     {  % forall
%%      exch dup type /nametype eq
%%      {
%%       sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%      }
%%      {
%%       dup type /stringtype eq
%%       {
%%        sEdAs exch writestring sEdAs 32 write
%%       }
%%       {
%%        dup type /arraytype eq
%%        {
%%         sEdAs ([ ) writestring
%%         {
%%          dup type /nametype eq
%%          {
%%           sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%          }
%%          {
%%           64 string cvs sEdAs exch writestring sEdAs 32 write
%%          } ifelse
%%         } forall
%%         sEdAs (] ) writestring
%%        }
%%        {
%%         64 string cvs sEdAs exch writestring sEdAs 32 write
%%        } ifelse
%%       } ifelse
%%      } ifelse
%%      dup type /nametype eq
%%      {
%%       sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%      }
%%      {
%%       dup type /stringtype eq
%%       {
%%        sEdAs exch writestring sEdAs 32 write
%%       }
%%       {
%%        dup type /arraytype eq
%%        {
%%         sEdAs ([ ) writestring
%%         {  % forall
%%          dup type /nametype eq
%%          {
%%           sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%          }
%%          {
%%           64 string cvs sEdAs exch writestring sEdAs 32 write
%%          } ifelse
%%         } forall
%%         sEdAs (] ) writestring
%%        }
%%        {
%%         64 string cvs sEdAs exch writestring sEdAs 32 write
%%        } ifelse
%%       } ifelse
%%      } ifelse
%%     } forall
     sEdAs (>> DP\012) writestring
    } ifelse
    %%test
    }stopped{( ... peta DP 1) pstack stop}if
   }
   {  %% 2 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %%TiNTeM {  % es la tinta que toca ara ?
     exch sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     dup type /nametype eq
     {
      sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     }
     {
      sEdAs (<<) writestring
      sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
      sEdAs (>> DP\012) writestring
     } ifelse
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta DP) == quit}if
   }
  ] i_DP get /DP exch bind def

  [  %% BMC
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /esUNAlayer false def  %% necessari doncs combina amb EMC
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring
    sEdAs 32 write sEdAs (BMC\012) writestring
    %%test
    }stopped{( ... peta BMC 1) pstack stop}if
   }
   {  %% 2 verificacio del Col·legi
    /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    /esUNAlayer false def  %% necessari doncs combina amb EMC
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring
    sEdAs 32 write sEdAs (BMC\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
   }
   {  %% 3 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring
     sEdAs 32 write sEdAs (BMC\012) writestring
    }ifelse
    %%}stopped{( ... peta BMC) == quit}if
   }
  ] i_BMC get /BMC exch bind def

%%MASATS03
  [  %% BDC
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped
    /LleixaBuida true def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)

%%ObjectStreamsProblem
/BDClayer false def  %% gatell per EMC i saber si a de tancar o no una Layer

    exch
    dup /OC eq
    {  %% desem els noms de les layers utilitzades a XRay

%% MASATS
/esUNAlayer true def  %% gatell per EMC i saber si som o no dins una Layer
/BDClayer true def  %% gatell per EMC i saber si a de tancar o no una Layer

     exch dup dup /xSiFosBuida exch def  %% x si fos buida EMC la desaria al dic Buides x llistar-la com a WARNING + tard
     XRay /Lleixes get /Desconegudes get exch /OC put
     exch
    }
    {  %% si el literal no es /OC desem el seu nom igualment

%% MASATS
BDClayer
{  %% per evitar nines russes (capes que tinguin BDCs a dins)
 /esUNAlayer true def  %% gatell per EMC i saber si som o no dins una Layer
 /BDClayer false def
}
{
 /esUNAlayer false def  %% gatell per EMC i saber si som o no dins una Layer
}ifelse

     1 index /xSiFosBuida exch def
    }ifelse
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
    dup type /nametype eq
    {
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     sEdAs (BDC\012) writestring
    }
    {
     sEdAs (<<) writestring

     sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

%%     {  % forall
%%      exch dup type /nametype eq
%%      {
%%       sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%      }
%%      {
%%       dup type /stringtype eq
%%       {
%%        sEdAs (\() writestring
%%        sEdAs exch writestring sEdAs (\) ) writestring
%%       }
%%       {
%%        dup type /arraytype eq
%%        {
%%         sEdAs ([ ) writestring
%%         {  % forall
%%          dup type /nametype eq
%%          {
%%           sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%          }
%%          {
%%           64 string cvs sEdAs exch writestring sEdAs 32 write
%%          } ifelse
%%         } forall
%%         sEdAs (] ) writestring
%%        }
%%        {
%%         64 string cvs sEdAs exch writestring sEdAs 32 write
%%        } ifelse
%%       } ifelse
%%      } ifelse
%%      dup type /nametype eq
%%      {
%%       sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%      }
%%      {
%%       dup type /stringtype eq
%%       {
%%        sEdAs (\() writestring
%%        sEdAs exch writestring sEdAs (\) ) writestring
%%       }
%%       {
%%        dup type /arraytype eq
%%        {
%%         sEdAs ([ ) writestring
%%         {  % forall
%%          dup type /nametype eq
%%          {
%%           sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
%%          }
%%          {
%%           64 string cvs sEdAs exch writestring sEdAs 32 write
%%          } ifelse
%%         } forall
%%         sEdAs (] ) writestring
%%        }
%%        {
%%         64 string cvs sEdAs exch writestring sEdAs 32 write
%%        } ifelse
%%       } ifelse
%%      } ifelse
%%     } forall
     sEdAs (>> BDC\012) writestring
    } ifelse
    %%test
    } stopped{( ... peta BDC 1) pstack stop}if
   }
   {  %% 2 verificacio del Col·legi
    /LleixaBuida true def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch
    dup /OC eq
    {  %% desem els noms de les layers utilitzades a XRay
     exch dup dup /xSiFosBuida exch def  %% x si fos buida EMC la desaria al dic Buides x llistar-la com a WARNING + tard
     XRay /Lleixes get /Desconegudes get exch /OC put
     exch
    }
    {  %% si el literal no es /OC desem el seu nom igualment
     1 index /xSiFosBuida exch def
    }ifelse
    %%exch                          
    %%% eliminem l'estructura de Layers (no pas el seu contingut!)
    dup /OC eq
    {
     /esUNAlayer true def  %% gatell per EMC i saber si cal eliminar-lo si es una Layer
     pop pop
    }
    {
     /esUNAlayer false def
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     dup type /nametype eq
     {
      sEdAs (/) writestring 128 string cvs sEdAs exch writestring
      sEdAs ( BDC\012) writestring
     }
     {
      sEdAs (<<) writestring

      sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

      sEdAs (>> BDC\012) writestring
     } ifelse
     %%}{pop pop}ifelse  % de la tinta que toca ara
    } ifelse  %% x eliminar l'estructura de Layers (no pas el seu contingut!)
   }
   {  %% 3 dada variable
    %% el literal inicial que duu BDC és el que ens dirà si és el nostre artefacte de dada variable
    %% o es tracta d'un altre tipus de container aliè a la nostra llibreria
    1 index /nomDADAclau exch def  %% desem el nom clau de la dada variable
    /esDADAv false def  %% esquer
    aDADAv
    {  %% forall
     nomDADAclau eq
     {
      /esDADAv true def
      exit
     }if
    }forall
    esDADAv {/faDADAv true def}if
%%(:-5)pstack quit

    %%test
    %%{  % stopped
    /LleixaBuida true def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    exch
    dup /OC eq
    {  %% desem els noms de les layers utilitzades a XRay
     exch dup dup /xSiFosBuida exch def  %% x si fos buida EMC la desaria al dic Buides x llistar-la com a WARNING + tard
     XRay /Lleixes get /Desconegudes get exch /OC put
     exch
    }
    {  %% si el literal no es /OC desem el seu nom igualment
     1 index /xSiFosBuida exch def
    }ifelse
    sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
    dup type /nametype eq
    {
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     sEdAs (BDC\012) writestring
    }
    {
     sEdAs (<<) writestring

     sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
     sEdAs (>> BDC\012) writestring
    } ifelse
    %%test
    %%} stopped{( ... peta BDC) == quit}if
   }
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    LleixesAeliminar 1 index known
    {  %% gatell per activar l'eliminat de continguts
     /alFoc true def
     pop pop
    }
    {
     /LleixaBuida true def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     /alFoc false def
     exch
     dup /OC eq
     {  %% desem els noms de les layers utilitzades a XRay
      exch dup dup /xSiFosBuida exch def  %% x si fos buida EMC la desaria al dic Buides x llistar-la com a WARNING + tard
      XRay /Lleixes get /Desconegudes get exch /OC put
      exch
     }
     {  %% si el literal no es /OC desem el seu nom igualment
      1 index /xSiFosBuida exch def
     }ifelse
     sEdAs (/) writestring 128 string cvs sEdAs exch writestring sEdAs 32 write
     dup type /nametype eq
     {
      sEdAs (/) writestring 128 string cvs sEdAs exch writestring
      sEdAs ( BDC\012) writestring
%%MASATSfebrer1
AAiRGB 1 get
{  %% blindem les capes?
%% ens cal reescriure els valors de l'Estat Gràfic que són crítics per la mala gestió de capes feta per Vectorworks
%% llavors, si a l'Estat Gràfic són vius, hi posarem els valors de rg RG i w

%% sEdAs (q 0 0 0 RG\012) writestring
}if
     }
     {
      sEdAs (<<) writestring
      sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
      sEdAs (>> BDC\012) writestring
%%MASATSfebrer1
AAiRGB 1 get
{  %% blindem les capes?
%% ens cal reescriure els valors de l'Estat Gràfic que són crítics per la mala gestió de capes feta per Vectorworks
%% llavors, si a l'Estat Gràfic són vius, hi posarem els valors de rg RG i w

 %%sEdAs (q 0 0 0 RG\012) writestring
}if
     } ifelse
    }ifelse
    %%} stopped{( ... peta BDC) == quit}if
   }
  ] i_BDC get /BDC exch bind def

  [  %% EMC
   {  %% 0
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof | gatells: 16
    %%test
    {  % stopped

%% MASATS
esUNAlayer  %% si som dins la capa...
{
 BDClayer
 {  %% ...i tanquem la capa definitivament
  /esUNAlayer false def  %% gatell per saber si som o no dins una Layer
 }
 {
  esUNAlayer
  {  %% tornem activar el BDC sempre que encara estiguem dins la capa
   /BDClayer true def
  }if
 }ifelse
}if

    LleixaBuida
    {  %% detecta lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     XRay /Lleixes get /Buides get xSiFosBuida /OC put  %% desem el nom intern de la layer amb el valor fix d'OC
     /LleixaBuida false def
    } if
    sEdAs (EMC\012) writestring
    %%test
    }stopped{( ... peta EMC 1) pstack stop}if
   }
   {  %% 2 verificacio del Col·legi
    LleixaBuida
    {  %% detecta lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     XRay /Lleixes get /Buides get xSiFosBuida /OC put  %% desem el nom intern de la layer amb el valor fix d'OC
     /LleixaBuida false def
    } if
    esUNAlayer
    {
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs (EMC\012) writestring
     %%}if  % de la tinta que toca ara
    } ifelse  %% x eliminar l'estructura de Layers (no pas el seu contingut!)
   }
   {  %% 3 dada variable
    faDADAv
    {  %% només si correspon a continguts de dada variable
     /faDADAv false def
     ( ... EMC HO ESTEM FENT! ...)==  %%pstack quit
    }if
    %%test
    %%{  % stopped
    LleixaBuida
    {  %% detecta lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     XRay /Lleixes get /Buides get xSiFosBuida /OC put  %% desem el nom intern de la layer amb el valor fix d'OC
     /LleixaBuida false def
    } if
    sEdAs (EMC\012) writestring
    %%test
    %%}stopped{( ... peta EMC) == quit}if
   }
   {  %% 4 eliminem continguts (x QueLiFemFer 15)
    %%{  % stopped
    LleixaBuida
    {  %% detecta lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     XRay /Lleixes get /Buides get xSiFosBuida /OC put  %% desem el nom intern de la layer amb el valor fix d'OC
     /LleixaBuida false def
    }if
    alFoc
    {  %% gatell per aturar l'eliminat de continguts
     /alFoc false def
    }
    {
     sEdAs (EMC\012) writestring
%%MASATSfebrer1
AAiRGB 1 get
{  %% blindem les capes amb una instrucció genèrica de negre RGB pels perfilats i els omplenats?
 sEdAs (Q\012) writestring
}if
    }ifelse
    %%}stopped{( ... peta EMC) == quit}if
   }
  ] i_EMC get /EMC exch bind def

>> def  %% fi del OpContents_QueLiFemFer1
%%% fi de diccionari

%%% KTCSa3copiseny
%#%21bis2% diccionari on desarem els paquets amb les 4 coordenades de posicio de totes les imatges
(%#%21bis2%)==
/i4cantons <<>> def

%%% KTCS
/EstatGrafic  %% paquet on hi ha en tot moment els estats grafics actius
[  %% mantindrem les claus originals dels operadors PDF q definixen els valors de l'estat grafic
 << %% a l'index zero sempre hi haura l'estat grafic per defecte (aquest no s'elimina mai)

    %% valors de l'estat grafic INdependents del dispositiu
    %% /cm [1 0 0 1 0 0]  % CTM activa ... indentity matrix per l'eix general de coordenades
    %% valors inicials de cm personalitzats un a un
    /cmPy 0  %% Y de l'origen de l'eix de coordenades a cm
    /cmPx 0  %% X de l'origen de l'eix de coordenades a cm
    /cmSy 1  %% escala Y a cm
    /cm_tanBsin 0  %% valor de la tangent o del sinus de l'angle a cm
    /cm_tanAsin 0  %% valor de la tangent o del sinus de l'angle a cm
    /cmSx 1  %% escala X a cm
/girNOcontrolat false  %% gatell provisional per filtrar esbiaixats i miralls de l'eix no implementats encara
/A_cm 0  %% valor de l'angle calculat en funcio dels valors del sin/cos de la cm
/eixcmGirat false  %% valor inicial del gatell detector de girs a l'espai de coordenades

    %% clipping path actiu ... x implementar
    %% color space actiu ... x implementar
    %% color actiu ... x implementar
    %% line width activa ... x implementar
    %% line cap activa ... x implementar
    %% line join actiu ... x implementar
    %% miter limit activa ... x implementar
    %% dash pattern actiu ... x implementar
    %% rendering intent actiu ... x implementar
    %% stroke adjustment actiu ... x implementar
    %% blend mode actiu ... x implementar
    %% soft mask activa ... x implementar
    %% alpha constant activa ... x implementar
    %% alpha source activa ... x implementar

    %% valors de l'estat grafic especifics pel text
    %% /Tm [1 0 0 1 0 0]  % ... Text matrix ... NO es un valor pur de l'estat grafic ... indentity matrix per les coordenades de text
    %% valors inicials de les variables de posicio absoluta del caracter definits per Tm
    /TxTm 0
    /TyTm 0
    %% valor inicial del multiplicador d'escala X del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
    /SxTm 1
    %% valor inicial del multiplicador d'escala Y del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
    /SyTm 1

/A_Tm 0  %% valor de l'angle calculat en funcio dels valors del sin/cos de la Tm
/eixTmGirat false  %% valor inicial del gatell detector de girs a l'espai de coordenades

    %% Tc ecTc (definit tambe a ") ... character space
    %% valor inicial d'espaiat entre caracters (s'aplica a cada caracter) definit per Tc
    /ecTc 0
    
    %% Tw epTw (definit tambe a ") ... Word spacing
    %% valor inicial d'espaiat entre paraules (nomes s'aplica quan troba un /space) definit per Tw
    /epTw 0

    %% Tz ... Horizontal scaling
    %% valor inicial del % d'escala horitzontal definit per Tz
    /acTz 100

    %% TL TD ... Leading
    %% valor inicial del valor pur de l'interliniat (sense multiplicar per SyTm o cmSy)
    /TLoTD 0
    %% valor inicial de l'interliniat (s'aplica amb T* " i ') un cop multiplicat per SyTm i cmSy
    /INTERli 0

    %% Tf ... Text font+Text font size ... l'implementem pel gatell 16 MASATS
    /acTf
    [
     null  %% nom PDF de la font utilitzada  (si és null voldrà dir que encara no s'ha definit)
     null  %% valor del cos aquí, doncs el cos real ve condicionat per l'escala de Tm i cm
    ]

    %% Tr ... Text rendering mode ... x implementar

    %% Ts ... Text rise
    %% valor per defecte del desplacament vertical del text
    /TyTs 0

    %% /TK (definit com a clau del dic gs --graphics state parameter dictionary--) ... Text knockout ... x implementar

    %% valors inicials de les coordenades d'inici de cadena, nomes utilitzades pels operadors ' i "
    /iTxTm 0
    /iTyTm 0

    %% valors de l'estat grafic DEpendents del dispositiu
    %% overprint actiu ... x implementar
    %% overprint mode actiu ... x implementar
    %% black generation activa ... x implementar
    %% undercolor removal activa ... x implementar
    %% transfer function ... x implementar
    %% halftone activa ... x implementar
    %% flatness activa ... x implementar
    %% smoothness actiu ... x implementar
 >> %% els paramentres definits seran nomes els que l'aplicacio necessiti x treballar
] def
%% index de l'estat grafic actiu
0 /iEG exch def
%% reexecutem els valors de l'estat grafic inicial x redefinir-ne les variables
EstatGrafic iEG get  %% recuperem del dic de l'estat grafic actiu
{def}forall  %% redefinim les variables

%% aqui hi havien (%21bis3%) els diccionaris de la metrica de les 14 Core PDF fonts (ara son a %20bis%)

%#%22% procediments de replicat idèntic dels Contents (sense comprimir) dins un fitxer
(%#%22%)==
/BeSSo  %% aquesta darrera funcio executa directament el fitxer de continguts aLLeGiR
{
 OpContents_QueLiFemFer1 begin  %% activem el diccionari amb les redefinicions dels operadors PDF
 aLLeGiR cvx exec end  %% executem el fitxer de l'stream dels /Contents i sortim del diccionari
 sEdAs flushfile
} bind def

/filtRa
{
 dup type /arraytype eq
 {  %% ara contemplen l'us de DecodeParms?
  aload pop
  {
   filter
  } forall
 }  %% ets una array
 {  %% no ets una array
  filter
 }ifelse
} bind def  %% funcio d'execucio dels filtres dins d'una array o no
%% fi de procediments de replicat

0 /iNousStreams exch def  %% index per assignar noms als nous streams repicats
nousStreams length 15 sub /posNum exch def  %% posicio d'inici fixa del numerador d'streams
/ARAcs null def  %% valor inicial del nom de l'espai de color x fill
/araCS null def  %% valor inicial del nom de l'espai de color x stroke

QueLiFemFer 15 eq  %:15 ELIMINA LLEIXES
{  %% valors inicials del gatell que elimina continguts de pàgina
 /alFoc false def
 /LleixaBuida false def
}if  %/15 ELIMINA LLEIXES

QueLiFemFer 2 eq  %:02 MARQUES DE TALL
{
%#%22bis2% dibuix de la creu de tall: aquesta és quadrada amb 4 braços de 30 punts (60x60) de .25 p de gruix a trams de blanc i negre que tapen
 (%#%22bis2%)==
 .25 cvr /GRuiX exch def  %% GRUIX del filet de la Creu de Tall sempre com a real pel repicat dins la mascara de 12 zeros
 /mGRuiX GRuiX 2 div def  %% meitat GRUIX del filet de la Creu de Tall
 141 string /crEU exch def  %% botifarra de dades del codi de la creu de tall
 crEU /NullEncode filter dup  ( cm 0 J 0 j ) writestring  %% iniciem l'escriptura del codi de la creu de tall
 dup (000000000000) dup /NullEncode filter dup GRuiX 12 string cvs writestring flushfile writestring  %% entrem el gruix del filet
 dup ( w q 1 G 0 30 m 0 -30 l S Q q[4]0 d 0 G 0 30 m 0 -30 l S Q q 1 G 30 0 m -30 0 l S Q q[4]0 d 0 G 30 0 m -30 0 l S Q Q ) writestring
 flushfile  %% desem la resta de codi a crEU
}if  %/02 MARQUES DE TALL

QueLiFemFer 6 eq  %:06 COSIT D'IMATGES
{
%#%22bis3% diccionari on desarem les ref ind de les imatges considerades frontisa (o isolades normals o claus d'un mosaic)
(%#%22bis3%)==
 /FRoNTiSeS <<>> def
 /ARAgs null def  %% (ep! no confondre amb gsARA !) variable senzilla per emmagatzemar el darrer estat grafic llegit per gs per repicar-lo en la reescriptura d'imatges clau als Contents de pagina
}if  %/06 COSIT D'IMATGES

QueLiFemFer 10 eq  %:10 PREFLIGHT AMB CAPES
QueLiFemFer 13 eq  %:13 eliminem continguts de pàgina
QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
or or
{
 /TRNCCLSQS false def  %% necessitem aquesta variable doncs aprofitem funcions del gatell 6
%#%22bis4% definim el flag VectorViu i l'array de materials digitals amb els noms interns/externs de les llesques (layers) i si han estat detectats
(%#%22bis4%)==
 /VectorViu false def  %% gatell d'anellat en llesques de vectorials
 /llesques
 [
  [  %% 0 estrat d'imatges [XObjects]
   false  %% gatell de si aquest material digital ha estat detectat
   (/MRCT_llXObject)  %% nom a l'stream de dades i a l'array Properties
   (imatges [XObjects])  %% CAT noms visibles al lateral
   (images [XObjects])  %% ENG
  ]
  [  %% 1 estrat de farcells grafics [Form XObjects]
   false
   (/MRCT_llFXObject)
   (farcells gràfics [Form XObjects])
   (graphic container [Form XObjects])
  ]
  [  %% 2 estrat d'imatges farcides [inLines]
   false
   (/MRCT_llinLine)
   (imatges farcides [inLines])
   (stream images [inLines])
  ]
  [  %% 3 estrat de grafics vectorials [Paths]
   false
   (/MRCT_llPath)
   (gràfics vectorials [Paths])
   (graphic vectors [Paths])
  ]
  [  %% 4 estrat d'esfumats dinamics [Shading Patterns] (deixarem els Tiling Patterns per + endavant)
   false
   (/MRCT_llShading)
   (esfumats dinàmics [Shading Patterns])
   (dynamic gradients [Shading Patterns])
  ]
  [  %% 5 estrat de text [Text]
   false
   (/MRCT_llText)
   (text [Text])
   (text [Text])
  ]
  %% altres estrats que es podrien implementar son: de trames, de transfers, d'espais de colors, d'Intents, de transparencies, d'objectes externs o de temes interactius i multimedia
 ]

%%MASATS##
%pop
%[  %% l'ordre en realitat s'adiu a la matèria prima digital
% [false (/ocg0) null null]
% [false (/ocg1) null null]
% [false (/ocg2) null null]
% [false (/ocg3) null null]
% [false (/ocg4) null null]
% [false (/ocg5) null null]
%]
%[
%  [  %% 5 estrat de text [Text]
%   false
%   (/MRCT_llText)
%   (text [Text])
%   (text [Text])
%  ]
%]

 def

 %% bastim el diccionari de fer les comparatives de quines capes de contingut de pàgina eliminarem
 /dEliminar <<>> def  %% hi haurà com a clau el nom de les capes a eliminar-ne el contingut
 aEliminar length dup llesques length
 ne
 {
  %% l'array /aEliminar de continguts de pàgina a eliminar ha de quadrar amb l'array /llesques
  (\n\n/aEliminar NO s'adiu amb /llesques ... pleguem!\n\n)print flush quit
 }if
 0 exch 1 exch 1 sub
 {
  dup aEliminar exch get
  {  %% desem la clau de la capa a eliminar-ne els continguts
   llesques exch get 1 get cvx exec
   dEliminar exch null put
  }
  {
   pop
  }ifelse
 }for

%%MASATS##
%dEliminar
%/ocg5 undef
%{== ==}forall (****)== quit

}if  %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13 
     %/13 eliminem continguts de pàgina
     %/10 PREFLIGHT AMB CAPES

QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
{
 %#%22bis5%  definim l'array de noms interns/externs la llesca de vincles transparents 
 (%#%22bis5%)==
 /llesques
 [
  [  %% 0 estrat dels vincles transparents
   lleixaNOi  %% gatell d'activacio de la layer
   (/MRCT_llQuetes_JBC)  %% nom a l'stream de dades i a l'array Properties
   (vincles transparents)  %% CAT noms visibles al lateral
   (transparent links)  %% ENG
  ]
 ] def

 torsimany  %% només si treballem pel traductor
 {
  %% llegim el fitxer torsimanysortida.txt, provinent del PHP, per tal de tornar al seu lloc
  %% cadascuna de les cadenes dins el fitxer rengsDtext.txt
  %% inclourengsdetext.ps

  0 /liniestraduides exch def  %% nombre de línies traduïdes per controlar p.e. el color
  0 /iPlana exch def  %% índex per reinserir els arrays de pàgines a la còpia aDoc

  %% aquest fitxer ja vindrà escrit del PHP via traducció de Google Translate
  %% els canvis de plana venen senyalitzats per la traducció amb [] i el de línia per () que blindem
  %% pel traductor amb <span class=notranslate></span> i <span class=notranslate>\(</span>
  {  %% stopped
   [
    %% l'afegirem al mateix directori
    rengsDtext
    {  %% loop
     bUsca search
     {
      pop pop
     }
     {
      exit
     }ifelse
    }loop
    rengsDtext exch search pop exch pop exch pop
    %% extret el directori hi inserim el nou txt
    dup length (torsimanysortida.txt) dup length 3 -1 roll add
    string dup 4 -1 roll dup length /VAa exch def 0 exch putinterval
    dup 3 -1 roll VAa exch putinterval
    (r) file cvx exec
    %% el metode de la | tampoc és estable!
    %% 65535 string readstring pop  %% llegim segur tot el fitxer (si fem traduccions curtes!)
    %% dup length string dup /DbAp exch def /NullEncode filter /deBaP exch def  %% buffer on repiquem de Barres a Parèntesi
    %% /iBarra true def  %% control de barres parells/senars per obrir o tancar parèntesi
    %% {
    %%  dup 124 eq
    %%  {
    %%   pop iBarra
    %%   {
    %%    deBaP 40 write  %% obrim parèntesi
    %%    iBarra not /iBarra exch def
    %%   }
    %%   {
    %%    deBaP 41 write  %% tanquem parèntesi
    %%    iBarra not /iBarra exch def
    %%   }ifelse
    %%  }
    %%  {  %% reescrivim el caràcter idem
    %%   deBaP exch write
    %%  }ifelse
    %% }forall
    %% deBaP dup flushfile closefile
    %% DbAp cvx exec
   ] /torsiMany exch def
   torsiMany length 1 sub /maXPlana exch def  %% per sortir de l'explorador d'arrays de pàgina
  }stopped
  {  %% blindem la possibilitat que no s'hagi escrit torsimanysortida.txt per un error al gatell
     %% /torsimany de capçalera o de l'execució del PHP en el procés de traducció
   (\n\nNO s'ha creat el fitxer de traduccio ... pleguem!\n\n)print flush quit
  }if
  %% hem de llegir el fitxer línia a línia per poder destriar les pàgines

  maXPlana 0 ge
  {  %% només regenerem rengsDtext.txt en cas que NO fem una traducció idem del document
     %% i això voldrà dir que a torsimanysortida.txt (provinent del PHP ) no hi haurà res escrit
     %% i per tant maXPlana valdrà -1
   rengsDtext (r) file
   cvx exec dup dup length array copy /aDoc exch def  %% còpia descontaminada de l'array de tot el document
   {  %% forall on explorem l'array de cada plana i tot el text extret del document
    dup length array copy /aPlana exch def
    %% extraiem la traducció per pàgina, segons l'ìndex, reinserint-la dins una array
    torsiMany iPlana get
%% ATENCIÓ: es repeteixen a partir de la segona plana els botons amb tool tip de l'anterior!!!!
    %% i detectem si som al final
    maXPlana iPlana eq {/pleguem true def}{/pleguem false def}ifelse
    dup length liniestraduides add /liniestraduides exch def  %% sumador de línies
    /iLT 0 def  %% índex de línies traduïdes
    {  %% forall per reincloure la traducció a l'array original provinent de rengsDtext
     aPlana
     %% aquí és on afegim el gatell true al darrer element (índex 9) de l'array numèric de
     %% la línia que ens indicarà que ha estat traduïda per Google Translate i aquest després
     %% a LINIESTRADUiDES n'activarà el color transparent que ens ho indicarà
     dup dup iLT 1 add get dup 9 true put iLT 1 add exch put
     exch iLT exch put
     iLT 2 add /iLT exch def
    }forall

    %% reinserim l'array de pàgina traduït al seu lloc
    aDoc iPlana aPlana put
    iPlana 1 add /iPlana exch def  %% sumador de l'índex de plana
    pleguem {exit}if  %% hem reinclòs totes les cadenes a aPlana

   }forall

   %% aquí haurem de reescriure aDoc cap a rengsDtext.txt amb la funció espiapaq_fura3
   %% i controlar la variable liniestraduides per tintar amb color diferent les línies traduïdes i no
   /Objected'Ara rengsDtext (w) file def
   aDoc /salva'l save def espiapaq_fura3 salva'l restore
   Objected'Ara closefile
  }if

 }if  %% treballem pel traductor?

}if  %/08 ETIQUETA TEXT

QueLiFemFer 5 eq  %:05 dada variable
{
 %#%22bis6% definim el diccionari on hi haura la clau del núm de pàgina i de valor un diccionari on la clau serà nomDADAclau i el valor el nom PDF de la tipografia, per muntar el diccionari tipusDADAv haurem de fer una redefinició dels operadors Tf BDC EMC i Tj TJ ' "
 %# gatell per controlar l'activat d'operadors amb funcions de dada variable
 (%#%22bis6%)==
 /tipusDADAv 2 dict def
 /faDADAv false def
}if  %/05 dada variable

%%test
%% /indexONpeta 0 def
%%{  % stopped

%% % com a %49% busquem el num del darrer objecte actiu (QuiEsAra)
%% (%22.49%)==
%% /QuiEsAra 0 def
%% /iDimoni 0 def
%% {  % loop
%%  currentdict iDimoni 4 string cvs get
%%  {  % forall
%%   pop
%%   16 string cvs (_) search pop cvi dup QuiEsAra gt
%%   {
%%    /QuiEsAra exch def
%%   }
%%   {
%%    pop
%%   }ifelse pop pop
%%  }forall
%%  iDimoni 1 add /iDimoni exch def
%%  iDimoni MaxDimoni eq {exit} if
%% } loop
%% QuiEsAra (;-O)pstack quit

BaBeL 23 get print flush  %% missatge de reinterpretacio dels Contents

%% torsimany
/LINIESTRADUiDES 0 def  %% comptador per la variable liniestraduides

%#%23% repiquem els Contents a partir del diccionari decodificador OpContents_QueLiFemFer1
(%#%23%)==
quinaPlana
{  %% forall que extrau els Contents i els repica
 /actGina exch def  %% desem el literal del num d'obj /Page

 %% /1 eq {/miraARA true def}{/miraARA false def}ifelse
 %%(pagina ... ) ==
 dup ==  %% llistem l'ordinal del num de pagina

 QueLiFemFer 4 eq  %:04 ANÀLISI TEXTUAL
 QueLiFemFer 12 eq  %:12 arbre jeràrquic
 QueLiFemFer 16 eq  %:16 cerca i substitució de text
 or or
 {

%%MASATStext
/yCursivesMentideres  %% inicialitzem l'array de diccionaris que localitzarà les falses cursives
[ %% les claus desades (valor a null) als diccionaris ens diran quines línies de yRENGS duen falses cursives
  %% i llavors en sabrem la tipografia associada i si pot reutilitzar-se o no (l'índex del diccionari ens dirà la pàgina)
 null
] def
/esUNAlayer false def  %% gatell per saber si som o no dins una Layer
/BDClayer false def  %% complementa l'anterior per filtrar parells BDC EMC sense /OC dins de layers

  %% aquest paràmetre és important inicialitzar-lo ara, doncs Tm el necessita i a voltes ho fa
  %% abans no s'hagi cridat Tf, que és qui realment el fixa
  /cos_ 1 def  % valor per defecte del multiplicador del cos
  %%% KTCS x JBC
  dup yRENGS exch known not  %% si no hi és ...
  {  %% ... obrim un nou diccionari de pàgina
   dup yRENGS exch << >> put
   %%( ... AQUI INICIEM L'ANALISI TEXTUAL ... ) == quit
   /iSignE 0 def  %% el farem servir x comptar signes q es componen cap a l'esquerra
   /iSignD 0 def  %% el farem servir x comptar signes q es componen cap a la dreta
  }if
 }if  %/16 cerca i substitució de text
      %/12 arbre jeràrquic
      %/04 ANÀLISI TEXTUAL

 %%!%! literal del num de pagina per extraure les dades del TrimBox
 /araPlana exch def
 %%!%! aqui dibuixavem abans la Creu de Tall

 %% pesquem la branca ...
 /iDimoni 0 def
 {  %% loop d'interrogacio dels dicts de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  %% el diccionari de l'objecte
  dup actGina known {actGina get exit}{pop}ifelse 
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq {exit} if
 } loop  %% d'interrogacio dels dicts de COMdimoni
%% miraARA {actGina{== ==}forall(!!!!!!!)== quit }if

%%MASATSfebrer1
QueLiFemFer 15 eq  %:15 ELIMINA LLEIXES
{
 AAiRGB 0 get
 {
  dup /AA undef  %% esborrem a sac les Additional Actions de cadascuna de les /Page
 }if
}if  %/15 ELIMINA LLEIXES

 dup /Contents known  %% hi ha continguts a la pagina ?
 {
  /Contents get dup type /nametype eq
  {

%%Llistem la refind de l'objecte Contents
dup ==

   %%COMdimoni exch get
   /laBranca exch def
   %% pesquem la branca ...
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup laBranca known {laBranca get exit}{pop}ifelse 
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
   dup
   dup type /arraytype eq
   {  %% es una array indirecte d'objectes indirectes
    %%( ... es una array indirecte d'objectes indirectes 0) ==
    %%    %%test
    %%    391 get == () == quit
    %%% x posar tots els Contents en 1 sol objecte
    dup dup length dup 0 eq
    {  %% no hi ha Contents!
     BaBeL 22 get print flush
     %% informem dels fitxers del tmp
     BaBeL 50 get print flush
     clear stop  %%quit
%%UBpliegOMaker
    } if                        
    1 sub /aFora exch def
    dup 0 get /ToTen1 exch def  %% triem a l'atzar el primer objecte de l'array x desar l'stream dels Contents unificats en 1 sol objecte
    1 aFora getinterval /xUnDef exch def  %% tota la resta d'objectes els donarem de baixa
    laBranca /quinOmodifiquem exch def  %% ref ind de l'objecte que apunta els Contents
    /QueLiFem {quinOmodifiquem [ToTen1] put} def  %% procediment x modificar l'objecte
    %%% x posar tots els Contents en 1 sol objecte
    /DeNouContents exch def  %% desem l'array de Contents
    
    QueLiFemFer 2 eq  %:02 MARQUES DE TALL
    {  %#%23bis% extraiem les dades del TrimBox per traslladar l'orígen de l'eix de coordenades i pintar les creus
(%#%23bis%)==
     XRay /PeDeEfa get araPlana get /TrimBox get dup dup dup 0 get /trimX exch def 1 get /trimY exch def 2 get /Xtrim exch def 3 get /Ytrim exch def

%%REpublica aquí podríem controlar l'escala/trasllat/rotacio de la pàgina per generar d'1 PDF d'n pàgines 1 PDF de 2 pàgines
%     sEdAs dup dup dup dup (q .5 0 0 .5 ) writestring llUm 24 string cvs writestring 32 write llUm 24 string cvs writestring ( cm ) writestring
     %% per tal d'enretirar tot el contingut de pagina i posar les creus de tall, traslladem l'origen de l'eix a trasllX i trasllY
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring llUm 24 string cvs writestring 32 write llUm 24 string cvs writestring ( cm ) writestring

    }if  %/02 MARQUES DE TALL

    QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
    QueLiFemFer 12 eq  %:12 arbre jeràrquic
    or
    {  %% anellem l'stream original entre q i Q
     sEdAs (q ) writestring
    }if  %/08 ETIQUETA TEXT

    {  %% forall on extreiem el fitxer de continguts per cada un dels elements de l 'array
     /laBranca exch def
     %% pesquem la branca ...
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup laBranca known {laBranca get exit}{pop}ifelse 
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
     dup /Filter known
     {  %% fitxer stream amb algun tipus de filtre
      dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres

      dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
      dup /DecodeParms known exch /DP known 2 copy or
      {
       {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
       {
        [ exch [ exch filtresstream ] ] /filtresstream exch def
       }
       {  %% es una array
        %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
        dup length filtresstream length ne
        {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
         (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
        }if
        /iDPF 0 def
        [ exch
         {  %% forall
          dup null eq
          {
           pop [filtresstream iDPF get]
           iDPF 1 add/iDPF exch def
          }
          {
           [exch filtresstream iDPF get]
           iDPF 1 add/iDPF exch def
          }ifelse
         }forall
        ]
        /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
       }ifelse
      }
      {
       pop pop  %% ens carreguem els logics
       pop  %% ens carreguem el dic
       %% avaluem filtresstream per redefinir-lo com cal per /filtRa
       filtresstream type /arraytype eq
       {
        [filtresstream] /filtresstream exch def
       }
       {
        [[filtresstream]] /filtresstream exch def
       }ifelse
      }ifelse

      dadesstream
      %% comprovem si l'stream es un path dins una array o una string de dades directe
      type /arraytype eq
      {
       dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
      }
      {  %% convertim a fitxer de la cadena sense decodificar
       dadesstream 0 () /SubFileDecode filter
      } ifelse
      filtresstream
%(F1) ==
      filtRa  %% decodifiquem el fitxer stream
      %%% preparem el fitxer de lectura que a l'estar filtrat el repiquem al disc
      repiCa (w) file /REPIcA exch def
      {  %% loop
       dup
       65535 string readstring
       {REPIcA exch writestring}		%% estrategia per no acabar mai amb un ET
       {REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit}ifelse
      }loop
      repiCa dup
      status  %%pop
      {
       pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
       (r) file /aLLeGiR exch def
      }
      {
       %%(zzzzzzzzzzzzzzzz ... x aqui petava!!! ... cal saber xq no troba aquest fitxer ¿?) ==
       pop
      }ifelse
     }
     {  %% fitxer stream sense filtres
      /XIU get
      /dadesstream exch def  %% definim l'adreca de l'stream per despres
      dadesstream  %% tibem el fitxer stream sense decodificar
      %% comprovem si l'stream es un path dins una array o una string de dades directe
      type /arraytype eq
      {
       dadesstream 0 get
       dup
       status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
       (r) file /aLLeGiR exch def
      }
      {  %% convertim a fitxer de la cadena sense decodificar
       dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
       0 () /SubFileDecode filter /aLLeGiR exch def
      } ifelse
     }ifelse
     %% repicat idem en ascii dels Contents
     %%(.1.)
     null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream de Patterns&Shadings
%(BESSONADA 1)==
     BeSSo
     %%     %%test
     %%     indexONpeta 1 add /indexONpeta exch def     
    } forall

    QueLiFemFer 2 eq  %:02 MARQUES DE TALL
    {  %%!%! aqui ens traslladarem a l'origen de la CREU BAIX ESQUERRA i la pintem
%SIcreus{  %% i si volem ampliar el format de pàgina sense posar les creus?
     sEdAs dup dup dup dup ( Q q 1 0 0 1 ) writestring trimX mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write trimY mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU DALT ESQUERRA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring trimX mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write Ytrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU DALT DRETA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring Xtrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write Ytrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU BAIX DRETA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring Xtrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write trimY mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
%}if
    }if  %/02 MARQUES DE TALL

    QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
    {
     %% caldria veure si aquesta tecnica d'escriure totes les dades en una string es + eficient q fer-ho a disc
     lleixaNOi  %% fem la lleixa no imprimible?
     {
      (\012Q\012/OC /MRCT_llQuetes_JBC BDC\012q /MRCT_t1 gs )
     }
     {  %% marquem el contingut igualment per si mai l'haguessim d'eliminar
      (\012Q\012/MRCT_llQuetes_JBC BMC\012q /MRCT_t1 gs )
     }ifelse
sEdAs exch writestring
%%     /enganXines exch def  %% tanquem l'anellat de l'stream i anem pel codi de les enganxines transparents
     rengsDtext (r) file cvx exec araPlana 16 string cvs cvi 1 sub get  %% treiem l'array de la plana q toca 
     dup /motsXplana exch def length 1 sub 1 exch 2 exch
     {  %% for ... on ventem a sac els array de dades
      motsXplana exch get aload pop
      dup /TRADUiT exch def  %% gatell que ens indica si ha estat traduït
      %% aquí avaluem si hi ha link o hi haurà un missatge, doncs variarem el color de l'etiqueta
      null eq {/mCEC true def}{/mCEC false def}ifelse
%% hauriem d'escriure els valors actuals de cm aqui?
%%[
%% EstatGrafic iEG get /cmSx get  % escala X a cm
%% EstatGrafic iEG get /cm_tanAsin get  % valor de la tangent o del sinus de l'angle a cm
%% EstatGrafic iEG get /cm_tanBsin get  % valor de la tangent o del sinus de l'angle a cm
%% EstatGrafic iEG get /cmSy get  % escala Y a cm
%% EstatGrafic iEG get /cmPx get  % X de l'origen de l'eix de coordenades a cm
%% EstatGrafic iEG get /cmPy get  % Y de l'origen de l'eix de coordenades a cm
%%]  ==
%% ara donem x bo que sempre hi haura els valors inicials x defecte xq anellem l'stream original entre q i Q
       %% escrivim el codi de generacio del rectangle
%%% aqui definim el valor i l'espai de color de la transparencia
       mCEC  %% hi ha link o hi haurà un missatge?
       {  %% trist gris, tret que fem el torsimany
        torsimany
        {
         LINIESTRADUiDES liniestraduides ge
         mCEC and  %% els dos han d'estar a false per tenyir de groc i marcar la traducció
         {
          (q .3 .3 .3 rg )  %% tenyim de gris per marcar la traducció inactiva
         }
         {
          TRADUiT
          {
           (q 1 1 0 rg )  %% tenyim de groc per marcar la traducció feta i sumar una línia
           LINIESTRADUiDES 1 add /LINIESTRADUiDES exch def
          }
          {
           (q .3 .3 .3 rg )  %% tenyim de gris per marcar la traducció inactiva
          }ifelse
         }ifelse
        }
        {
         (q .3 .3 .3 rg )
        }ifelse
       }
       {  %% d'un roig encès
        (q 1 0 0 rg )
       }ifelse
sEdAs exch writestring
%%       dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
       %% escrivim el punt xUL
       8 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% esrivim el punt yUL
       7 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% el codi de posicionament
       (m )
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring
       %% escrivim el punt xLL
       6 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% esrivim el punt yLL
       5 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% el codi del primer costat
       (l )
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring
       %% escrivim el punt xLR
       4 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% esrivim el punt yLR
       3 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% el codi del segon costat
       (l )
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring
       %% escrivim el punt xUR
       exch 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% esrivim el punt yUR
       256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% el codi del tercer costat
%%       (l) dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def

       %% escrivim el codi de tancat+omplert del rectangle i tancament
%%       (h f Q) dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
(l h f Q ) sEdAs exch writestring
      }for
      %% dada final de tancament dels rectangles transparents
%%      (Q) dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
%%      sEdAs enganXines writestring
      %% lleixaNOi {
      sEdAs(Q\012EMC\012)writestring
      %% }if  %% fem la lleixa no imprimible?
     }if  %/08 ETIQUETA TEXT

    QueLiFemFer 12 eq  %:12 arbre jeràrquic
    {  %% anellem l'stream original entre q i Q
     sEdAs(Q\012)writestring
    }if
    %% bufem els fitxers
    aLLeGiR dup flushfile closefile
   }
   {  %% es un sol objecte indirecte
    %%( ... es un sol objecte indirecte 1) ==
    dup /DeNouContents exch def  %% desem el diccionari dels Contents
    /Filter known
    {  %% fitxer stream amb algun tipus de filtre
     dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres

     dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
     dup /DecodeParms known exch /DP known 2 copy or
     {
      {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
      {
       [ exch [ exch filtresstream ] ] /filtresstream exch def
      }
      {  %% es una array
       %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
       dup length filtresstream length ne
       {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
        (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
       }if
       /iDPF 0 def
       [ exch
        {  %% forall
         dup null eq
         {
          pop [filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }
         {
	  [exch filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }ifelse
        }forall
       ]
       /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
      }ifelse
     }
     {
      pop pop  %% ens carreguem els logics
      pop  %% ens carreguem el dic
      %% avaluem filtresstream per redefinir-lo com cal per /filtRa
      filtresstream type /arraytype eq
      {
       [filtresstream] /filtresstream exch def
      }
      {
       [[filtresstream]] /filtresstream exch def
      }ifelse
     }ifelse

     dadesstream
     %% comprovem si l'stream es un path dins una array o una string de dades directe
      type /arraytype eq
     {
      dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
     }
     {  %% convertim a fitxer de la cadena sense decodificar
      dadesstream 0 () /SubFileDecode filter
     } ifelse
     filtresstream
%(F2) ==
     filtRa  %% decodifiquem el fitxer stream
     %% a l'estar filtrat el repiquem al disc
     repiCa (w) file /REPIcA exch def
     {  %% loop
      dup
      65535 string readstring
      {
       REPIcA exch writestring
      }		%% estrategia per no acabar mai amb un ET
      {
       REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit
      }ifelse
     }loop
     repiCa dup status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
     (r) file /aLLeGiR exch def
    }
    {  %% fitxer stream sense filtres
     /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
     dadesstream  %% tibem el fitxer stream sense decodificar
     %% comprovem si l'stream es un path dins una array o una string de dades directe
      type /arraytype eq
     {
      dadesstream 0 get
      dup
      status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
      (r) file /aLLeGiR exch def
     }
     {  %% convertim a fitxer de la cadena sense decodificar
      dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
      0 () /SubFileDecode filter /aLLeGiR exch def
     } ifelse
    }ifelse
    %% repicat idem en ascii dels Contents
    %% (.2.)
    null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream de Patterns&Shadings

    QueLiFemFer 2 eq  %:02 MARQUES DE TALL
    {  %#%23bis% extraiem les dades del TrimBox per traslladar l'orígen de l'eix de coordenades i pintar les creus
 (%#%23bis%)==
     XRay /PeDeEfa get araPlana get /TrimBox get dup dup dup 0 get /trimX exch def 1 get /trimY exch def 2 get /Xtrim exch def 3 get /Ytrim exch def

%%REpublica aquí podríem controlar l'escala/trasllat/rotacio de la pàgina per generar d'1 PDF d'n pàgines 1 PDF de 2 pàgines
%     sEdAs dup dup dup dup (q .5 0 0 .5 ) writestring llUm 24 string cvs writestring 32 write llUm 24 string cvs writestring ( cm ) writestring
     %% per tal d'enretirar tot el contingut de pagina i posar les creus de tall, traslladem l'origen de l'eix a trasllX i trasllY
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring llUm 24 string cvs writestring 32 write llUm 24 string cvs writestring ( cm ) writestring

    }if  %/02 MARQUES DE TALL

    QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
    QueLiFemFer 12 eq  %:12 arbre jeràrquic
    or
    {  %% anellem l'stream original entre q i Q
     sEdAs (q ) writestring
    }if  %/08 ETIQUETA TEXT

%(BESSONADA 2)==
    BeSSo

%(LLLLLLLLLLL)pstack quit

    QueLiFemFer 2 eq  %:02 MARQUES DE TALL
    {  %%!%! aqui ens traslladarem a l'origen de la CREU BAIX ESQUERRA i la pintem
%SIcreus{  %% i si volem ampliar el format de pàgina sense posar les creus?
     sEdAs dup dup dup dup ( Q q 1 0 0 1 ) writestring trimX mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write trimY mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU DALT ESQUERRA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring trimX mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write Ytrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU DALT DRETA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring Xtrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write Ytrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU BAIX DRETA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring Xtrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write trimY mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
%}if
    }if  %/02 MARQUES DE TALL

    QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
    {
     %% caldria veure si aquesta tecnica d'escriure totes les dades en una string es + eficient q fer-ho a disc
     lleixaNOi  %% fem la lleixa no imprimible?
     {
      (\012Q\012/OC /MRCT_llQuetes_JBC BDC\012q /MRCT_t1 gs )
     }
     {  %% marquem el contingut igualment per si mai l'haguessim d'eliminar
      (\012Q\012/MRCT_llQuetes_JBC BMC\012q /MRCT_t1 gs )
     }ifelse
sEdAs exch writestring
%%     /enganXines exch def  %% tanquem l'anellat de l'stream i anem pel codi de les enganxines transparents
     rengsDtext (r) file cvx exec araPlana 16 string cvs cvi 1 sub get  %% treiem l'array de la plana q toca 
     dup /motsXplana exch def length 1 sub 1 exch 2 exch
     {  %% for ... on ventem a sac els array de dades
       motsXplana exch get aload pop
       dup /TRADUiT exch def  %% gatell que ens indica si ha estat traduït
       %% aquí avaluem si hi ha link o hi haurà un missatge, doncs variarem el color de l'etiqueta
       null eq {/mCEC true def}{/mCEC false def}ifelse
%% hauriem d'escriure els valors actuals de cm aqui?
%%[
%% EstatGrafic iEG get /cmSx get  % escala X a cm
%% EstatGrafic iEG get /cm_tanAsin get  % valor de la tangent o del sinus de l'angle a cm
%% EstatGrafic iEG get /cm_tanBsin get  % valor de la tangent o del sinus de l'angle a cm
%% EstatGrafic iEG get /cmSy get  % escala Y a cm
%% EstatGrafic iEG get /cmPx get  % X de l'origen de l'eix de coordenades a cm
%% EstatGrafic iEG get /cmPy get  % Y de l'origen de l'eix de coordenades a cm
%%] ==
%% ara donem x bo que sempre hi haura els valors inicials x defecte xq anellem l'stream original entre q i Q
       %% escrivim el codi de generacio del rectangle
       mCEC  %% hi ha link o hi haurà un missatge?
       {  %% trist gris, tret que fem el torsimany
        torsimany
        {
         LINIESTRADUiDES liniestraduides ge
         mCEC and  %% els dos han d'estar a false per tenyir de groc i marcar la traducció
         {
          (q .3 .3 .3 rg )  %% tenyim de gris per marcar la traducció inactiva
         }
         {
          TRADUiT
          {
           (q 1 1 0 rg )  %% tenyim de groc per marcar la traducció feta i sumar una línia
           LINIESTRADUiDES 1 add /LINIESTRADUiDES exch def
          }
          {
           (q .3 .3 .3 rg )  %% tenyim de gris per marcar la traducció inactiva
          }ifelse
         }ifelse
        }
        {
         (q .3 .3 .3 rg )
        }ifelse
       }
       {  %% d'un roig encès
        (q 1 0 0 rg )
       }ifelse
%%       dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring
       %% escrivim el punt xUL
       8 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% esrivim el punt yUL
       7 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% el codi de posicionament
       (m )
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring
       %% escrivim el punt xLL
       6 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% esrivim el punt yLL
       5 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% el codi del primer costat
       (l )
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring
       %% escrivim el punt xLR
       4 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% esrivim el punt yLR
       3 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% el codi del segon costat
       (l )
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring
       %% escrivim el punt xUR
       exch 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% esrivim el punt yUR
       256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
       %% el codi del tercer costat
%%       (l) dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
       %% escrivim el codi de tancat+omplert del rectangle i tancament
%%       (h f Q) dup length enganXines length add 1 add string /bUffer exch def
%%       bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%       bUffer /enganXines exch def
(l h f Q ) sEdAs exch writestring
      }for
      %% dada final de tancament dels rectangles transparents
%%      (Q) dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
%%      sEdAs enganXines writestring
      %% lleixaNOi {
      sEdAs(Q\012EMC\012)writestring
      %% }if  %% fem la lleixa no imprimible?
     }if  %/08 ETIQUETA TEXT

    QueLiFemFer 12 eq  %:12 arbre jeràrquic
    {  %% anellem l'stream original entre q i Q
     sEdAs(Q\012)writestring
    }if
    %% bufem els fitxers
    %%    REPIcA dup flushfile closefile
    aLLeGiR dup flushfile closefile
   }ifelse
  }
  {  %% es una array directe d'objectes indirectes

%%Llistem les refind dels objectes Contents
dup ==

   %%( ... es una array directe d'objectes indirectes) ==  
   repiCa (w) file /REPIcA exch def
   %%% x posar tots els Contents en 1 sol objecte
   dup dup length dup 0 eq
   {  %% no hi ha Contents!
    BaBeL 22 get print flush
    %% informem dels fitxers del tmp
    BaBeL 50 get print flush
    clear stop  %%quit
%%UBpliegOMaker
   } if
   1 sub /aFora exch def
   dup 0 get /ToTen1 exch def  %% triem a l'atzar el primer objecte de l'array x desar l'stream dels Contents unificats en 1 sol objecte
   1 aFora getinterval /xUnDef exch def  %% tota la resta d'objectes els donarem de baixa
   actGina /quinOmodifiquem exch def  %% ref ind del dic on hi ha els Contents
   /QueLiFem {quinOmodifiquem get /Contents [ToTen1] put} def  %% procediment x modificar l'objecte
   %%% x posar tots els Contents en 1 sol objecte
   dup /DeNouContents exch def  %% desem l'array de Contents
   {  %% forall on extreiem el fitxer de continguts per cada un dels elements de l'array
    /laBranca exch def
    %% cada branca es un objecte amb part dels continguts ...
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup laBranca known {laBranca get exit}{pop}ifelse 
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
    dup /Filter known
    {  %% fitxer stream amb algun tipus de filtre
     dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres

     dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
     dup /DecodeParms known exch /DP known 2 copy or
     {
      {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
      {
       [ exch [ exch filtresstream ] ] /filtresstream exch def
      }
      {  %% es una array
       %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
       dup length filtresstream length ne
       {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
        (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
       }if
       /iDPF 0 def
       [ exch
        {  %% forall
         dup null eq
         {
          pop [filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }
         {
	  [exch filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }ifelse
        }forall
       ]
       /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
      }ifelse
     }
     {
      pop pop  %% ens carreguem els logics
      pop  %% ens carreguem el dic
      %% avaluem filtresstream per redefinir-lo com cal per /filtRa
      filtresstream type /arraytype eq
      {
       [filtresstream] /filtresstream exch def
      }
      {
       [[filtresstream]] /filtresstream exch def
      }ifelse
     }ifelse

     dadesstream
     %% comprovem si l'stream es un path dins una array o una string de dades directe
     type /arraytype eq
     {
      dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
     }
     {  %% convertim a fitxer de la cadena sense decodificar
      dadesstream 0 () /SubFileDecode filter
     } ifelse
     filtresstream
%(F3) ==
     filtRa  %% decodifiquem el fitxer stream
    }
    {  %% fitxer stream sense filtres
     /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
     dadesstream
     %% comprovem si l'stream es un path dins una array o una string de dades directe
     type /arraytype eq
     {
      dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
     }
     {  %% convertim a fitxer de la cadena sense decodificar
      dadesstream 0 () /SubFileDecode filter
     } ifelse
    }ifelse
    {  %% loop
     dup
     %% afegim el contingut de l'array a REPIcA per si es trencat ...
     65535 string readstring
     {
      REPIcA exch writestring
     }		%% estrategia per no acabar mai amb un ET
     {
      REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit
     }ifelse
    }loop
   } forall
   %% tanquem el fitxer
   %%   REPIcA closefile
   repiCa  %% interpretem tot l'array enganxat per si era trencat ...
   dup
   status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
   (r) file /aLLeGiR exch def
   %% repicat idem en ascii dels Contents
   %% (.3.)
   null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream de Patterns&Shadings

   QueLiFemFer 2 eq  %:02 MARQUES DE TALL
    {  %#%23bis% extraiem les dades del TrimBox per traslladar l'orígen de l'eix de coordenades i pintar les creus
 (%#%23bis%)==
     XRay /PeDeEfa get araPlana get /TrimBox get dup dup dup 0 get /trimX exch def 1 get /trimY exch def 2 get /Xtrim exch def 3 get /Ytrim exch def
     %% per tal d'enretirar tot el contingut de pagina i posar les creus de tall, traslladem l'origen de l'eix a trasllX i trasllY

%%REpublica aquí podríem controlar l'escala/trasllat/rotacio de la pàgina per generar d'1 PDF d'n pàgines 1 PDF de 2 pàgines
%     sEdAs dup dup dup dup (q .5 0 0 .5 ) writestring llUm 24 string cvs writestring 32 write llUm 24 string cvs writestring ( cm ) writestring
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring llUm 24 string cvs writestring 32 write llUm 24 string cvs writestring ( cm ) writestring

    }if  %/02 MARQUES DE TALL

    QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
    QueLiFemFer 12 eq  %:12 arbre jeràrquic
    or
    {  %% anellem l'stream original entre q i Q
     sEdAs (q ) writestring
    }if  %/08 ETIQUETA TEXT

%(BESSONADA 3)==

%/esAQUI 0 def  %% UUUEEE

   BeSSo

   QueLiFemFer 2 eq  %:02 MARQUES DE TALL
    {  %%!%! aqui ens traslladarem a l'origen de la CREU BAIX ESQUERRA i la pintem
%SIcreus{  %% i si volem ampliar el format de pàgina sense posar les creus?
     sEdAs dup dup dup dup ( Q q 1 0 0 1 ) writestring trimX mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write trimY mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU DALT ESQUERRA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring trimX mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write Ytrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU DALT DRETA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring Xtrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write Ytrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
     %%!%! aqui ens traslladarem a l'origen de la CREU BAIX DRETA i la pintem
     sEdAs dup dup dup dup (q 1 0 0 1 ) writestring Xtrim mGRuiX add  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring 32 write trimY mGRuiX sub  %% ajustem xq la creu vagi x fora el TrimBox
     24 string cvs writestring crEU writestring
%}if
    }if  %/02 MARQUES DE TALL

    QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
    {
     %% caldria veure si aquesta tecnica d'escriure totes les dades en una string es + eficient q fer-ho a disc
     lleixaNOi  %% fem la lleixa no imprimible?
     {
      (\012Q\012/OC /MRCT_llQuetes_JBC BDC\012q /MRCT_t1 gs )
     }
     {  %% marquem el contingut igualment per si mai l'haguessim d'eliminar
      (\012Q\012/MRCT_llQuetes_JBC BMC\012q /MRCT_t1 gs )
     }ifelse
sEdAs exch writestring
%%     /enganXines exch def  %% tanquem l'anellat de l'stream i anem pel codi de les enganxines transparents
     rengsDtext (r) file cvx exec araPlana 16 string cvs cvi 1 sub get  %% treiem l'array de la plana q toca 
     dup /motsXplana exch def length 1 sub 1 exch 2 exch
     {  %% for ... on ventem a sac els array de dades
      motsXplana exch get aload pop
      dup /TRADUiT exch def  %% gatell que ens indica si ha estat traduït
      %% aquí avaluem si hi ha link o hi haurà un missatge, doncs variarem el color de l'etiqueta
      null eq {/mCEC true def}{/mCEC false def}ifelse
%% hauriem d'escriure els valors de cm aqui?
%%[
%% EstatGrafic iEG get /cmSx get  % escala X a cm
%% EstatGrafic iEG get /cm_tanAsin get  % valor de la tangent o del sinus de l'angle a cm
%% EstatGrafic iEG get /cm_tanBsin get  % valor de la tangent o del sinus de l'angle a cm
%% EstatGrafic iEG get /cmSy get  % escala Y a cm
%% EstatGrafic iEG get /cmPx get  % X de l'origen de l'eix de coordenades a cm
%% EstatGrafic iEG get /cmPy get  % Y de l'origen de l'eix de coordenades a cm
%%] ==
%% ara donem x bo que sempre hi haura els valors inicials x defecte xq anellem l'stream original entre q i Q
      %% escrivim el codi de generacio del rectangle
%%% aqui definim el valor i l'espai de color de la transparencia 
       mCEC  %% hi ha link o hi haurà un missatge?
       {  %% trist gris, tret que fem el torsimany
        torsimany
        {
         LINIESTRADUiDES liniestraduides ge
         mCEC and  %% els dos han d'estar a false per tenyir de groc i marcar la traducció
         {
          (q .3 .3 .3 rg )  %% tenyim de gris per marcar la traducció inactiva
         }
         {
          TRADUiT
          {
           (q 1 1 0 rg )  %% tenyim de groc per marcar la traducció feta i sumar una línia
           LINIESTRADUiDES 1 add /LINIESTRADUiDES exch def
          }
          {
           (q .3 .3 .3 rg )  %% tenyim de gris per marcar la traducció inactiva
          }ifelse
         }ifelse
        }
        {
         (q .3 .3 .3 rg )
        }ifelse
       }
       {  %% d'un roig encès
        (q 1 0 0 rg )
       }ifelse
%%      dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring
      %% escrivim el punt xUL
      8 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
      %% esrivim el punt yUL
      7 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
      %% el codi de posicionament
      (m )
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring
      %% escrivim el punt xLL
      6 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
      %% esrivim el punt yLL
      5 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
      %% el codi del primer costat
      (l )
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring
      %% escrivim el punt xLR
      4 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
      %% esrivim el punt yLR
      3 -1 roll 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
      %% el codi del segon costat
      (l )
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring
      %% escrivim el punt xUR
      exch 256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
      %% esrivim el punt yUR
      256 string cvs
%% dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
sEdAs exch writestring sEdAs 10 write
      %% el codi del tercer costat
%%      (l) dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
      %% escrivim el codi de tancat+omplert del rectangle i tancament
%%      (h f Q) dup length enganXines length add 1 add string /bUffer exch def
%%      bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%      bUffer /enganXines exch def
(l h f Q ) sEdAs exch writestring
     }for
     %% dada final de tancament dels rectangles transparents
%%     (Q) dup length enganXines length add 1 add string /bUffer exch def
%%     bUffer /NullEncode filter dup dup dup enganXines writestring 4 -1 roll writestring 13 write flushfile
%%     bUffer /enganXines exch def
%%     sEdAs enganXines writestring
     %% lleixaNOi {
     sEdAs(Q\012EMC\012)writestring
     %% }if  %% fem la lleixa no imprimible?
    }if  %/08 ETIQUETA TEXT

    QueLiFemFer 12 eq  %:12 arbre jeràrquic
    {  %% anellem l'stream original entre q i Q
     sEdAs(Q\012)writestring
    }if
  }ifelse
  %% bufem i tanquem el fitxer
  aLLeGiR dup flushfile closefile
 }
 {  %% no te continguts ...
  BaBeL 22 get print flush
  QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
  {
   %#%23bis2% si fem la separació de colors, sortim per que no té continguts
   (%#%23bis2%)==
   %% informem dels fitxers del tmp
   BaBeL 50 get print flush
   clear stop  %%quit
  }  %/01 SEPARACIÓ DE TINTES
  {  %% p.e. amb el multipagina no tallem la feina
   pop  %% eliminem el dic de la pagina
   /DeNouContents <</XIU ()>> def  %% amb aquest dic de Contents salpassem els PDF que no duen aquesta entrada
   null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream
   /aLLeGiR () 0 ()/SubFileDecode filter def  %% fitxer buit que necessitem tenir donat d'alta malgrat no hi hagi res
  }ifelse
 }ifelse

 sEdAs closefile

 %%currentdict /0 get /8______________0 get {== ==}forall ($) == quit
 %%% test de l'array de gamma de colors
 %%XRay /EspaisDeColor get /Desconeguts get {== ==} forall
 %%DeNouContents {== ==}forall

%%Aquí és on ens cal implementar la compressió d'streams amb Flate (ara s'escriuren descomprimits)
%%% HEM D'ESTAR SEGURS QUE FUNCIONA AL 100% %%%
%% implementem aquí l'algorisme %53% que feiem servir per la separació de colors per
%% tal d'unificar tots els streams trencats dels Contents de cada pàgina en 1 de sol
QueLiFemFer 0 eq  %:00 REESCRIPTURA IDEM
QueLiFemFer 15 eq  %:15 ELIMINEM LLESQUES
QueLiFemFer 17 eq  %:17 ENCAVALCA CONTINGUTS
or or
xQuinaArea 0 eq  %% volem explicitament reunificar els streams en 1 de sol
and
%% QueLiFemFer 6 eq  % ... o que fem el trencaclosques
%%or
{
 %#%23bis53% aquí és on unificarem els Contents en 1 sol stream
% (%#%23bis53%)==
 %% reincrustem els streams reinterpretats, als seus corresponents objectes
 DeNouContents  %% diccionari o array de Contents de la plana
 type /dicttype eq
 {  %% es un diccionari directe (segur 1 sol stream)
  %% aqui mirem i redefinim el Length
  l'objectenet

  status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer sense comprimir
  DeNouContents /Length FiFtxr put
%%MASATS09
Aflate
{
 DeNouContents /Filter /FlateDecode put  %% compressor flate/zip
}
{
  %% treiem el filtrat si en duu
  DeNouContents /Filter undef  %% encara que no en dugui, cap publema!
}ifelse

  %% esbrinem on hem de desar l'stream
  DeNouContents /XIU get /dadesstream exch def  %% la mena d'stream per despres
  dadesstream type /arraytype eq
  {  %% comprovem si l'stream es un path dins una array
   dadesstream 0 get /aRePiCaR exch def
   %%EP! genererem el nom dels Contents sencers ...
   iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
   nousStreams dup posNum iNousStreams 10 string cvs putinterval
   %% el repiquem
   (w) file /trAsllAt exch def 
   aRePiCaR (r) file
   {  %% loop
    dup 65535 string readstring
    {
     trAsllAt exch writestring
    }
    {
     trAsllAt exch writestring
     closefile exit
    } ifelse
   } loop
   trAsllAt closefile
   %% regenerem nousStreams al nom que duu l'stream original intacte
   (2__________.nou)  %% aquest sempre duu l'stream original intacte
   dup length faPath add string dup /pAthXiU exch def
   0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
   pAthXiU /nousStreams exch def  %% utilitzat per l'applet per desar els nous streams redefinits al disc
   nousStreams /l'objectenet99 exch def  %% redefinim el renombrat a la seva variable original!
   %% fitxer a traslladar
   l'objectenet
   (r) file

%%MASATS09
Aflate
{  %% reescrivim en Flate
 /touDlectura exch def
 aRePiCaR (w) file /FlateEncode filter /touDescriptura exch def
 {  %% loop
  touDlectura
  65535 string readstring not
  {
   touDescriptura exch writestring exit
  }if
  touDescriptura exch writestring
 }loop
 touDescriptura closefile flush
 aRePiCaR status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer comprimit
 DeNouContents /Length FiFtxr put
}
{  %% reescrivim sense comprimir
   %% el repiquem
   aRePiCaR (w) file /trAsllAt exch def
   {
    dup 65535 string readstring
    {
     trAsllAt exch writestring
    }
    {
     trAsllAt exch writestring
     closefile exit
    } ifelse
   } loop
   trAsllAt closefile
}ifelse
   %%( DiC DIRECTE AMB PATH DINS UNA ARRAY) ==
  }
  {  %% si es una cadena de dades directe ...
   %% llavors redefinim /XIU com una array renobrant l'objectenet a un *.nou
   iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream

%%MASATS09
Aflate
{
 l'objectenet (r) file /touDlectura exch def
 nousStreams (w) file /FlateEncode filter /touDescriptura exch def
 {  %% loop
  touDlectura
  65535 string readstring not
  {
   touDescriptura exch writestring exit
  }if
  touDescriptura exch writestring
 }loop
 touDescriptura closefile flush
 nousStreams status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer comprimit
 DeNouContents /Length FiFtxr put
}
{
   l'objectenet nousStreams dup posNum iNousStreams 10 string cvs putinterval renamefile
}ifelse

   %% !!!!
   nousStreams /l'objectenet99 exch def  %% redefinim el renombrat a la seva variable original!
   DeNouContents /XIU [null] dup nousStreams dup length string copy 0 exch put put  %% incrustem el *.nou a l'array XIU i aquesta al dic
   %%( DIC DIRECTE AMB CADENA DE DADES) ==
  } ifelse
 }
 {  %% es una array (1 o + streams)
  %% aqui implementem l'algorisme per deixar 1 sol stream eliminant la resta
  /iDimoni 0 def
  {  %% loop, primer anem a buscar el dic ToTen1
   currentdict iDimoni 4 string cvs cvn get
   dup ToTen1 known {ToTen1 get exit}{pop}ifelse
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% de descarrega
  %% desem el dic on posarem l'stream de Contents unificat
  /DeNouContents2 exch def
  %% incrustem l'stream de Contents sencer al mateix dic
  %% aqui mirem i redefinim el Length
  l'objectenet status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
  DeNouContents2 /Length FiFtxr put

%%MASATS09
Aflate
{
 DeNouContents2 /Filter /FlateDecode put  %% compressor flate/zip
}
{
  %% treiem el filtrat si en duu
  DeNouContents2 /Filter undef  %% encara que no en dugui, cap publema!
}ifelse

  %% esbrinem on hem de desar l'stream
  DeNouContents2 /XIU get /dadesstream exch def  %% la mena d'stream per despres
  dadesstream type /arraytype eq
  {  %% comprovem si l'stream es un path dins una array
%%MASATS09
Aflate
{  %% reescrivim en Flate
 l'objectenet (r) file
 /touDlectura exch def
 dadesstream 0 get (w) file /FlateEncode filter /touDescriptura exch def
 {  %% loop
  touDlectura
  65535 string readstring not
  {
   touDescriptura exch writestring exit
  }if
  touDescriptura exch writestring
 }loop
 touDescriptura closefile flush
 dadesstream 0 get status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer comprimit
 DeNouContents2 /Length FiFtxr put
}
{  %% reescrivim sense comprimir
   dadesstream 0 get
   %% el repiquem
   (w) file /trAsllAt exch def
   %% fitxer a traslladar
   l'objectenet (r) file
   {  %% loop
    dup 65535 string readstring
    {
     trAsllAt exch writestring
    }
    {
     trAsllAt exch writestring
     closefile exit
    } ifelse
   } loop
   trAsllAt closefile
}ifelse
   %%( DIC DIRECTE AMB PATH DINS UNA ARRAY) ==
  }
  {  %% si es una cadena de dades directe ...
   %% llavors redefinim /XIU com una array renombrant l'objectenet a un *.nou
   iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream

%%MASATS09
Aflate
{
 l'objectenet (r) file /touDlectura exch def
 nousStreams (w) file /FlateEncode filter /touDescriptura exch def
 {  %% loop
  touDlectura
  65535 string readstring not
  {
   touDescriptura exch writestring exit
  }if
  touDescriptura exch writestring
 }loop
 touDescriptura closefile flush
 nousStreams status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer comprimit
 DeNouContents2 /Length FiFtxr put
}
{
   l'objectenet nousStreams dup posNum iNousStreams 10 string cvs putinterval renamefile
}ifelse

   %% !!!
   nousStreams /l'objectenet99 exch def  %% redefinim el renombrat a la seva variable original!
   DeNouContents2 /XIU [null] dup nousStreams dup length string copy 0 exch put put  %% incrustem el *.nou a l'array XIU i aquesta al dic
   %%( DIC DIRECTE AMB CADENA DE DADES) ==
  } ifelse
  %%% fi de l'incrustacio de l'stream de Contents
  %% donem de baixa tots els elements d'aquesta array ...
  /iDimoni 0 def
  {  %% loop
   currentdict iDimoni 4 string cvs cvn get
   /aSac exch def xUnDef {aSac exch undef}forall  %% podem fer-ho a sac sense mirar
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% de descarrega
  %% rectifiquem l'objecte portador de la ref ind dels Contents
  /iDimoni 0 def
  {  %% loop
   currentdict iDimoni 4 string cvs cvn get
   dup quinOmodifiquem known {QueLiFem}{pop}ifelse
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% de descarrega
  %%( es una array de Contents trencats) ==
 }ifelse

 %%sEdAs2 closefile
 %%flush

 %%Salva'm restore

 %%%CALi2COPi%%% fi del repicat de Contents
 %%% ALERTA

}  %/00 REESCRIPTURA IDEM
   %/15 ELIMINEM LLESQUES
   %/17 ENCAVALCA CONTINGUTS
%%%
%%% HEM D'ESTAR SEGURS QUE FUNCIONA AL 100% %%%
{

QueLiFemFer 6 ne
%:00 REESCRIPTURA IDEM
%:01 SEPARACIÓ DE TINTES
%:02 MARQUES DE TALL
%:03 CORRECTOR TIPOGRÀFIC
%:04 ANÀLISI TEXTUAL
%:05 dada variable
%:07 REINSEREIX IMATGES JPEG
%:08 ETIQUETA TEXT
%:09 EXTRAU IMATGES JPEG
%:10 PREFLIGHT AMB CAPES
%:12 arbre jeràrquic
%:17 ENCAVALCA CONTINGUTS
%% salpassem el reincrustat d'streams si fem el trencaclosques!
%% doncs d'aquesta manera la primera interpretacio dels operadors de Contents nomes
%% ens ha de servir per analitzar XRay i la resta de dades d'imatge que necessitem
%% doncs es al segon repicat quan hem de modificar l'stream dels Contents per tal
%% d'unificar el mosaic i eliminar les imatges sobreres
%% QueLiFemFer 10 ne  % salpassem el reincrustat d'streams si fem l'analisi de PDF?
{

 %#%23bis3% reincrustem els streams reinterpretats, als seus corresponents objectes
 (%#%23bis3%)==
 DeNouContents  %% diccionari o array de Contents de la plana
 type /dicttype eq
 {  %% es un diccionari directe (segur 1 sol stream)
  %% aqui mirem i redefinim el Length
  l'objectenet status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
  DeNouContents /Length FiFtxr put
  %% treiem el filtrat si en duu
  DeNouContents /Filter undef  %% encara que no en dugui, cap publema!
  %% esbrinem on hem de desar l'stream
  DeNouContents /XIU get /dadesstream exch def  %% la mena d'stream per despres
  dadesstream
  type /arraytype eq
  {  %% comprovem si l'stream es un path dins una array
   ( <<<< DIC DIRECTE AMB PATH DINS UNA ARRAY) ==
   dadesstream 0 get
   %% on el traslladem ?
   (w) file /trAsllAt exch def
   %% fitxer a traslladar
   l'objectenet (r) file
   {
    dup 65535 string readstring
    {
     trAsllAt exch writestring
    }
    {
     trAsllAt exch writestring
     closefile exit
    } ifelse
   } loop
   trAsllAt closefile
  }
  {  %% si es una cadena de dades directe ...
   ( <<<< DIC DIRECTE AMB CADENA DE DADES) ==
   %% llavors redefinim /XIU com una array renombrant l'objectenet a un *.nou

   %%                     iNousStreams 1 add /iNousStreams exch def  % comptador de nous fitxers d'stream
   %%                     l'objectenet nousStreams dup posNum iNousStreams 10 string cvs putinterval renamefile
   %%                     nousStreams /l'objectenet exch def  % redefinim el renombrat a la seva variable original!
   %%                     DeNouContents /XIU [null] dup nousStreams dup length string copy 0 exch put put  % incrustem el *.nou a l'array XIU i aquesta al dic

   DeNouContents /XIU
   [
    iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
    nousStreams dup posNum iNousStreams 10 string cvs putinterval  %% nou fitxer+path
    dup length string copy dup /nousStreams exch def
    %% on el traslladem ?
    (w) file /trAsllAt exch def
    %% fitxer a traslladar
    l'objectenet (r) file
    {
     dup 65535 string readstring
     {
      trAsllAt exch writestring
     }
     {
      trAsllAt exch writestring
      closefile exit
     } ifelse
    } loop
    trAsllAt closefile
    nousStreams dup length string copy  %% imprescindible x no contaminar posteriors cadenes
   ] put
  } ifelse
 }
 {  %% es una array (1 o + streams)
  ( <<< es una array de Contents trencats) ==
  DeNouContents length
  /Atrossos exch def  %% quants trossos te l'array de Contents?
  %% esbrinem quan fara cada tros (MaXtros) dels streams repicats
  l'objectenet dup status pop pop pop Atrossos idiv /MaXtros exch def pop
  (r) file /totStream exch def  %% lectura de tot l'stream a trencar
  DeNouContents  %% per a cada un dels objectes de Contents trencats
%%(:-n)pstack quit
  {  %% forall
   %% cerquem el dic que correspon al literal de Contents
   /litCo exch def /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% deixem a la pila el diccionari de l'objecte que cerquem
    dup litCo known {litCo get exit}{pop}ifelse 
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
   %% tractarem els streams trencats sempre com a fitxers a disc
   iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
   nousStreams dup posNum iNousStreams 10 string cvs putinterval  %% nou fitxer+path
   dup length string copy dup /nousStreams exch def
   (w) file /bociStream exch def  %% desem el fitxer d'escriptura
   %% aquest loop evita problemes amb bocins d'stream superiors a 65535
   MaXtros /trosMaXtros exch def
   {  %% loop
    trosMaXtros 65535 sub dup 0 lt
    {
     pop /tMt true def trosMaXtros /StringStream exch def
    }
    {
     /trosMaXtros exch def 65535 /StringStream exch def /tMt false def
    }ifelse
    totStream StringStream string readstring pop
    bociStream exch writestring  %% escrivim el boci que toca
    tMt {exit}if
   } loop
   totStream 4096 string readline pop  %% i l'arrodonim fins al final de linia xq no trenquem cap sentencia (amb un buffer de 4K)
   bociStream exch writestring bociStream closefile
   %% esbrinem el nou Length del boci de l'stream que toca
   nousStreams status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
   dup /Length FiFtxr put  %% l'incrustem al dic
   dup /Filter undef  %% eliminem el possible codificador/compressor (ara tenim ascii pur!)
   /XIU [null] dup nousStreams dup length string copy 0 exch put put  %% incrustem el *.nou a l'array XIU i aquesta al dic
  } forall
  totStream closefile
 }ifelse

}if  %% salpassem el reincrustat d'streams si fem el trencaclosques!
%/17 ENCAVALCA CONTINGUTS
%/12 arbre jeràrquic
%/10 PREFLIGHT AMB CAPES
%/09 EXTRAU IMATGES JPEG
%/08 ETIQUETA TEXT
%/07 REINSEREIX IMATGES JPEG
%/05 dada variable
%/04 ANÀLISI TEXTUAL
%/03 CORRECTOR TIPOGRÀFIC
%/02 MARQUES DE TALL
%/01 SEPARACIÓ DE TINTES
%/00 REESCRIPTURA IDEM

} ifelse
%%% HEM D'ESTAR SEGURS QUE FUNCIONA AL 100% %%%
%%%

 %%!% la inicialitzacio per multiples pagines hauria de contemplar un numerador xq els
 %%% fitxers dels Contents repicats fossin diferents a cada pagina pel seu tractament posterior?
 %% (la inicialitzacio d'aquest fitxer on reescriurem els Contents no es necessaria treballant amb PDF d'1 sola pagina)
 l'objectenet (w) file
 /sEdAs exch def

 QueLiFemFer 6 eq  %:06 COSIT D'IMATGES
 {  %% nomes si activem el trencaclosques
  %#%23bis4% algorisme muntador del trencaclosques
(%#%23bis4%)==
  %%% filtrem si el dic i4cantons es buit (no es criden imatges al contingut de plana)
  i4cantons length 0 eq
  {
   (>>> ... encara sense imatges)==
  }
  {
   %%% a3copiseny ... casos especials a considerar:
   %%% Imatges cavalcades: si hi ha imatges amb les mateixes coordenades pero amb nom diferent, aquest algorisme
   %%% nomes n'agafa 1 per la filera correlativa i la resta les ailla una a una ... veure 14imatgesxtrossos_cavalcadesAmbNomDiferent_apel.pdf
   %%% si a mes a mes de les mateixes coordenades, tambe tenen el mateix nom, doncs llavors nomes en conservem una
   %%% per tant els duplicats cavalcats identics desapareixen! ... veure 14imatgesxtrossos_cavalcadesidentiques_apel.pdf
   %%% Imatges identiques de nom repetides dins un mosaic pero en lloc diferent: no les agrupa i nomes en considera una
   %%% ... veure 14imatgesxtrossos_identiquesDnomRepetidesEnLlocsDiferents_apel.pdf

   %%% primer, el caçador de files ...
   %% fem una copia del diccionari l'original de totes les imatges d'una plana, doncs haurem d'anar donant de baixa
   %% els elements que s'hagin empalmat per tal de regenerar l'array trencadis
   i4cantons
   
   dup araPlana known  %% existeix la plana? (si no existeix es q no hi ha imatges)
   {
    araPlana get dup length dict copy /closques exch def
    %% aixo cal fer-ho per totes les imatges d'una mateixa plana
    0  %% index
    %% clau (nom d'imatge) valor (numeric a ordenar)
    closques
    dup length array /trencadis exch def
    {  %% desem el nom de totes les imatges per comparar a trencadis
     pop 1 index exch trencadis 3 1 roll put 1 add
    }forall

    %% reordenem trencadis x test ...
    %% /trencadis [/Im12 /Im3 /Im6 /Im14 /Im13 /Im7 /Im8 /Im10 /Im1 /Im9 /Im2 /Im11 /Im4 /Im5] def

    /totalDcostat [] def
    %% aquest valor caldra estudiar-lo B doncs es presenten casos d'imatges cavalcades q podria interessar empalmar (p.e. Fotos_segmentades_irotades_A7.pdf podem localitzar les dues imatges rotades amb un factor de tlrnc de 25)
    5 /tlrnc exch def  %% factor màxim de tolerància permesa (1 punt?) en el posicionament de les imatges per detectar si coincideixen
    1 sub /MAXi exch def  %% index de la darrera imatge de trencadis
    false /hemTriomfat exch def
    {  %% loop que esbrina quins elements pertanyen a una mateixa filera
     trencadis 0 get dup /COMpara exch def
     closques exch get
     /nUm exch def
     /iDcostat [COMpara] def  %% agrupa els NOMS de les imatges que es toquin de costat (que pertanyin a una mateixa filera de forma ordenada)
     /iDcostatN [nUm] def  %% agrupa l'array de VALORS de les imatges que es toquin de costat (que pertanyin a una mateixa filera de forma ordenada)
     {  %% loop de si hemTriomfat
      1 1 MAXi  %% el for el comencem per 1 doncs l'element zero es el que comparem i no ho farem amb ell mateix!
      {  %% for
       trencadis exch get dup /comPARA exch def closques exch get /nUm exch def  %% extraiem l'array de valors de l'index q toca
       %% establim el valor de l'index + gran (el q haura de cercar imatges x la dreta), doncs el + petit sempre valdra zero (el q haura de buscar imatges per l'esquerra)
       iDcostatN length 1 sub/isobira exch def
       %% mirem el primer xamfra ...
       %% primer comparem l'element + petit (corresponent a les coordenades de la possible imatge per l'esquerra) de l'array iDcostatN
       %% en realitat aqui nomes volem saber si hi ha imatges per l'esquerra que empalmin
       iDcostatN 0 get nUm 2 copy
       1 get exch 0 get  %% comparem dues arrays (com q tenen sempre 2 elements, aqui no mirem el length)
       %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
       /aComp exch def
       /iDeNTiQueS true def  %% gatell x saber si son identiques
       /iaComp 0 def
       {  %% forall
        aComp iaComp get  %%eq no podem jugar amb la igualtat exacte doncs hem vist que hi ha un factor de tolerancia
        sub abs tlrnc le {true}{false}ifelse  %% avaluem la coincidencia jugant amb el valor de tolerancia
        {
         iaComp 1 add /iaComp exch def
        }
        {
         /iDeNTiQueS false def exit
        }ifelse
       }forall
       iDeNTiQueS  %% les coordenades 0 (de la imatge de + a l'esquerra trobada) i 1 (de la imatge que comparem) son iguals?
       {  %% si es que SI, podria ser una imatge que empalmi per l'esquerra i ara nomes ens cal mirar el segon xamfra ...
        %%(1Xesquerra) ==
        3 get exch 2 get  %% comparem dues arrays (com q tenen sempre 2 elements, aqui no mirem el length)
        %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
        /aComp exch def
        /iDeNTiQueS true def  %% gatell x saber si son identiques
        /iaComp 0 def
        {  %% forall
         aComp iaComp get  %%eq no podem jugar amb la igualtat exacte doncs hem vist que hi ha un factor de tolerancia
         sub abs tlrnc le {true}{false}ifelse  %% avaluem la coincidencia jugant amb el valor de tolerancia
         {
          iaComp 1 add /iaComp exch def
         }
         {
          /iDeNTiQueS false def exit
         }ifelse
        }forall
        iDeNTiQueS  %% les coordenades 2 (de la imatge de + a l'esquerra trobada) i 3 (de la imatge que comparem) son iguals?
        %%(2Xesquerra) ==
        {
         %% ampliem l'array iDcostat 1 + x l'esquerra ...
         iDcostat dup length 1 add array dup 3 -1 roll 1 exch putinterval
         %% ... i afegim el nom desat a comPARA
         dup 0 comPARA put /iDcostat exch def
         %% ampliem l'array iDcostatN 1 + x l'esquerra ...
         iDcostatN dup length 1 add array dup 3 -1 roll 1 exch putinterval
         %% ... i afegim el valor
         dup 0 nUm put /iDcostatN exch def
         /hemTriomfat true def  %% si!
        }if  %% si el primer xamfra per l'esquerra coincideix i el segon no ho fa, doncs segur que tampoc ho pot fer per al 100% la banda dreta!
       }
       {  %% si es que NO, podria ser una imatge que empalmi per la dreta ...
        %% despres comparem l'element + gran (corresponent a les coordenades de la possible imatge de la dreta) de l'array iDcostatN
        %% en realitat aqui nomes volem saber si hi ha imatges per la dreta que empalmin
        exch pop  %% eliminem les coordenades de la imatge que avaluem x l'esquerra
        iDcostatN isobira get 2 copy
        %% mirem el primer xamfra ...
        1 get exch 0 get  %% comparem dues arrays (com q tenen sempre 2 elements, aqui no mirem el length)
        %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
        /aComp exch def
        /iDeNTiQueS true def  %% gatell x saber si son identiques
        /iaComp 0 def
        {  %% forall
         aComp iaComp get  %%eq no podem jugar amb la igualtat exacte doncs hem vist que hi ha un factor de tolerancia
         sub abs tlrnc le {true}{false}ifelse  %% avaluem la coincidencia jugant amb el valor de tolerancia
         {
          iaComp 1 add /iaComp exch def
         }
         {
          /iDeNTiQueS false def exit
         }ifelse
        }forall
        iDeNTiQueS  %% les coordenades 1 (de la imatge de + a la dreta trobada) i 0 (de la imatge que comparem) son iguals?
        {
         %%(1Xdreta) ==
         %% mirem el segon xamfra ...
         %% primer comparem l'element + gran (corresponent a les coordenades de la possible imatge de la dreta) de l'array iDcostatN
         %% en realitat aqui nomes volem saber si hi ha imatges per la dreta que empalmin
         3 get exch 2 get  %% comparem dues arrays (com q tenen sempre 2 elements, aqui no mirem el length)
         %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
         /aComp exch def
         /iDeNTiQueS true def  %% gatell x saber si son identiques
         /iaComp 0 def
         {  %% forall
          aComp iaComp get  %%eq no podem jugar amb la igualtat exacte doncs hem vist que hi ha un factor de tolerancia
          sub abs tlrnc le {true}{false}ifelse  %% avaluem la coincidencia jugant amb el valor de tolerancia
          {
           iaComp 1 add /iaComp exch def
          }
          {
           /iDeNTiQueS false def exit
          }ifelse
         }forall
         iDeNTiQueS  %% les coordenades 3 (de la imatge de + a la dreta trobada) i 2 (de la imatge que comparem) son iguals?
         %%(2Xdreta) ==
         {  %% si es que SI, sera una imatge que empalma per la dreta ...
          %% ampliem l'array iDcostat 1 + x la dreta ...
          iDcostat dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 exch putinterval
          %% ... i afegim el nom desat a comPARA
          dup baUla comPARA put
          /iDcostat exch def
          %% ampliem l'array iDcostatN 1 + x la dreta ...
          iDcostatN dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 exch putinterval
          %% ... i afegim el valor
          dup baUla nUm put /iDcostatN exch def
          /hemTriomfat true def  %% si!
         }if
        }
        {  %% si no, els eliminem
         pop pop
        }ifelse
       }ifelse
      }for
      hemTriomfat
      {  %% si hem empalmat algun element, doncs tornem a posar el gatell a false
       /hemTriomfat false def
      }
      {  %% sortim del loop xq ja no hem trobat + elements que pertanyin a la mateixa filera de forma continua
       %% per tant tambe ja podem desar l'array dels elements acoplats a iDcostat amb exit ...   
       totalDcostat dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 exch putinterval
       %% ... i afegim iDcostat amb profilaxi
       dup baUla iDcostat dup length array copy put /totalDcostat exch def
       %% ... i regenerar l'array trencadis per mitja del dict closques
       iDcostat {closques exch undef}forall  %% donem de baixa primer els elements acoplats
       0 closques
       dup length array /trencadis exch def
       {  %% desem el nom de totes les imatges per comparar a trencadis
        pop 1 index exch trencadis 3 1 roll put 1 add
       }forall  %% regenerem!
       1 sub /MAXi exch def  %% index de la darrera imatge de trencadis
       exit
      }ifelse
     } loop  %% de si hemTriomfat
     closques length 0 eq {exit}if  %% si ja ho tenim tot comparat, doncs pleguem!
    }loop  %% que esbrina quins elements pertanyen a una mateixa filera
    %%% fi del caçador de files

    %%% segon, el caçador de mosaics ...
    %%% agafa totes les imatges que pertanyen a una mateixa filera (array) i en compara els extrems per saber si pertanyen a un
    %%% mateix mosaic, i si es aixi, agrupa les arrays per fileres endreçades de dalt a baix en un mateix paquet a totalMosaics

    totalDcostat dup length array copy  %%% comentar x test si cal

    %%% controlem x test l'ordre del paquet ...
    %%[ [/Im3 /Im4 /Im11] [/Im12 /Im13 /Im14] [/Im7] [/Im8] [/Im9 /Im5 /Im6] [/Im1 /Im2 /Im10] ]
    %%[ [/Im12 /Im13 /Im14] [/Im3 /Im4 /Im11] [/Im7] [/Im8] [/Im9 /Im5 /Im6] [/Im1 /Im2 /Im10] ]
    %%[ [/Im1 /Im2 /Im10] [/Im12 /Im13 /Im14] [/Im3 /Im4 /Im11] [/Im7] [/Im8] [/Im9 /Im5 /Im6] ]
    %%[ [/Im7] [/Im1 /Im2 /Im10] [/Im12 /Im13 /Im14] [/Im3 /Im4 /Im11] [/Im8] [/Im9 /Im5 /Im6] ]
    %%[ [/Im8] [/Im1 /Im2 /Im10] [/Im12 /Im13 /Im14] [/Im3 /Im4 /Im11] [/Im9 /Im5 /Im6] [/Im7] ]
    %%[ [/Im9 /Im5 /Im6] [/Im8] [/Im1 /Im2 /Im10] [/Im12 /Im13 /Im14] [/Im3 /Im4 /Im11] [/Im7] ]
    %%[ [/Im9 /Im5 /Im6] ]  % aquest seria el trencadis minim: 1 linia SOLA que no encaixa amb cap mes
    %%[ [/Im9 /Im5 /Im6] [/Im8] ]  % aqui hi ha dues linies d'imatge que no encaixen entre elles x length d'entrada
    %%[ [/Im9 /Im5 /Im6] [/Im8] [/Im1 /Im2 /Im10] ]  % aqui hi ha tres linies d'imatge que, dues no encaixen x coordenades i una x length d'entrada
    %%[ [/Im9 /Im5 /Im6] [/Im8] [/Im1 /Im2 /Im10] [/Im7] ]  % aqui hi ha dues fileres que encaixen
    %%[ [/Im3 /Im4 /Im11] [/Im12 /Im13 /Im14] [/Im1 /Im2 /Im10] ]  % NOMES si hi ha Im3+Im4+Im11 al davant amb la filera que li segueix dessota al darrere atrapem les tres fileres!
    %%[ [/Im3 /Im4 /Im11] [/Im1 /Im2 /Im10] [/Im12 /Im13 /Im14] ]  % RESOLLLLLT!!!!!
    %%%

    /trencadis exch def  %% ara trencadis es una copia de totalDcostat

    %% a mida que analitzem els elements que pertanyen a un mateix mosaic, els anirem marcant amb un null dins el paquet
    %% de trencadis per tal de saltar-nos el seu analisi mentre progressem pel caos d'imatges, tammateix acotarem la cerca
    %% esbrinant des d'on comença la primera filera d'imatges util (no null) amb iNOnull i on s'acaba la darrera filera
    %% d'imatges util (no null) amb MAXi dins el paquet trencadis.

    /totalMosaics [] def  %% aqui desarem en paquets els mosaics perfectament formats pel nom de la imatge (sera regenerat plana a plana)
    %%1 /tlrnc exch def  % ja l'hem definit + amunt
    false /hemTriomfat exch def  %% gatell per saber si ja hem esgotat les possibilitats de formar un mosaic

    {  %% loop1 que esbrina quins elements pertanyen a un mateix mosaic
     %% gira cada vegada que ha trobat un mosaic
     %% cerquem l'index del darrer paquet d'imatges NO null de trencadis
     null/MAXi exch def  %% valor inicial del gatell que en servira x saber que ja hem acabat totes les comparacions possibles
     trencadis length 1 sub -1 0
     {dup trencadis exch get null eq {pop}{/MAXi exch def exit}ifelse}for
     MAXi null eq
     {
      %%(***PLEGUEM***)pstack quit
      exit
     }if  %% si no ha trobat cap array de linies d'imatge, doncs es que ja les hem avaluat totes i pleguem!
     %% cerquem el primer index NO null de trencadis
     /iNOnull 0 def
     trencadis {null eq{iNOnull 1 add /iNOnull exch def}{exit}ifelse}forall
     trencadis iNOnull get /COMpara exch def  %% primer paquet NO null d'una mateixa filera d'imatges
     /iApilades [COMpara] def  %% agrupa el mosaic que es forma a cada volta de loop1: l'array de NOMS dels conjunts d'imatges (un paquet x filera) que es toquin apilades (els dos extrems coincideixin de forma ordenada)

     {  %% loop2 de si hemTriomfat, o sigui de si un cop a cabat el for per trencadis ja no hem trobat + coincidencies ...
      %% ... doncs gira cada vegada que acabat el for trobem linies que encaixen
      %% intentarem de fer una politica de no deixar res a la pila!
      iNOnull 1 add 1 MAXi  %% el comencem per iNOnull+1 doncs l'element iNOnull es el que comparem (COMpara) i no ho farem pas amb ell mateix!
      {  %% for de trencadis
       %% la primera de les linies apilades la comparem per sobre
       trencadis exch dup /ARAi exch def  %% index del paquet de filera d'imatges per on corre el for i que comparem amb COMpara
       get dup null eq  %% l'hem mort amb null?
       {  %% fem correr for
        pop  %% ens carreguem el null
       }
       {  %% l'analitzem
        dup /comPARAdelfor exch def  %% desem el paquet q compararem amb COMpara
        length iApilades 0 get length eq  %% si les dues fileres no tenen les mateixes imatges, no cal ni que en comparem les coordenades
        {
         comPARAdelfor 0 get i4cantons araPlana get exch get  %% extraiem el valor de les coordenades de la imatge de mes a l'esquerra de for
         iApilades 0 get 0 get i4cantons araPlana get exch get  %% extraiem el valor de les coordenades de la imatge de mes a l'esquerra de la primera de les linies apilades (COMpara)
         %% mirem el xamfra de sobre a l'esquerra ...
         %% en realitat aqui nomes volem saber si hi ha fileres d'imatge que empalmin per sobre
         0 get  %% x,y del xamfra superior esquerra del COMpara
         exch 2 get  %% x,y del xamfra inferior esquerra del comPARAdelfor
         %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
         /aComp exch def
         /iDeNTiQueS true def  %% gatell x saber si son identiques
         /iaComp 0 def
         {  %% forall
          aComp iaComp get  %%eq no podem jugar amb la igualtat exacte doncs hem vist que hi ha un factor de tolerancia
          sub abs tlrnc le {true}{false}ifelse  %% avaluem la coincidencia jugant amb el valor de tolerancia
          {
           iaComp 1 add /iaComp exch def
          }
          {
           /iDeNTiQueS false def exit
          }ifelse
         }forall
         iDeNTiQueS  %% les coordenades 2 (de la imatge de + a l'esquerra de la filera trobada) i 0 (de la imatge de la filera que comparem) son iguals?
         {  %% si es que SI ara nomes ens cal mirar el xamfra de sobre a la dreta ...
          (lligatXesquerraSobre) ==
          comPARAdelfor dup length 1 sub get i4cantons araPlana get exch get  %% extraiem el valor de les coordenades de la imatge de mes a la dreta de for
          iApilades 0 get dup length 1 sub get i4cantons araPlana get exch get  %% extraiem el valor de les coordenades de la imatge de mes a la dreta de la primera de les linies apilades (COMpara)
          1 get  %% x,y del xamfra superior dreta del COMpara
          exch 3 get  %% x,y del xamfra inferior dreta del comPARAdelfor
          %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
          /aComp exch def
          /iDeNTiQueS true def  %% gatell x saber si son identiques
          /iaComp 0 def
          {  %% forall
           aComp iaComp get  %%eq no podem jugar amb la igualtat exacte doncs hem vist que hi ha un factor de tolerancia
           sub abs tlrnc le {true}{false}ifelse  %% avaluem la coincidencia jugant amb el valor de tolerancia
           {
            iaComp 1 add /iaComp exch def
           }
           {
            /iDeNTiQueS false def exit
           }ifelse
          }forall
          iDeNTiQueS  %% les coordenades 3 (de la imatge de + a la dreta de la filera trobada) i 1 (de la imatge que comparem) son iguals?
          {
           (lligatXdretaSobre) ==
           %% ampliem l'array iApilades 1 + x sobre ...
           iApilades dup length 1 add array dup 3 -1 roll 1 exch putinterval
           %% ... i afegim el nom desat a comPARAdelfor
           dup 0 comPARAdelfor put /iApilades exch def

           %% hem de matar amb un NULL a trencadis l'element caçat a iApilades
           trencadis ARAi null put

           /hemTriomfat true def  %% si!
          }if
         }if

         %% la darrera de les linies apilades la comparem per sota
         %% volem saber si hi ha fileres d'imatge per sota que empalmin
         %% mirem el xamfra de l'esquerra ...
         comPARAdelfor 0 get i4cantons araPlana get exch get  %% extraiem el valor de les coordenades de la imatge de mes a l'esquerra de for
         iApilades dup length 1 sub get 0 get i4cantons araPlana get exch get  %% extraiem el valor de les coordenades de la imatge de mes a l'esquerra de la darrera de les linies apilades (COMpara)
         2 get  %% x,y del xamfra inferior esquerra de la imatge COMpara
         exch 0 get  %% x,y del xamfra superior esquerra de la imatge comPARAdelfor
         /aComp exch def  %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
         /iDeNTiQueS true def  %% gatell x saber si son identiques
         /iaComp 0 def
         {  %% forall
          aComp iaComp get  %%eq no podem jugar amb la igualtat exacte doncs hem vist que hi ha un factor de tolerancia
          sub abs tlrnc le {true}{false}ifelse  %% avaluem la coincidencia jugant amb el valor de tolerancia
          {
           iaComp 1 add /iaComp exch def
          }
          {
           /iDeNTiQueS false def exit
          }ifelse
         }forall
         iDeNTiQueS  %% les coordenades 0 (de la imatge de + a l'esquerra de la filera trobada) i 2 (de la imatge que comparem) son iguals?
         {
          (lligatXesquerraSota) ==
          %% mirem el segon xamfra ...
          comPARAdelfor dup length 1 sub get i4cantons araPlana get exch get  %% extraiem el valor de les coordenades de la imatge de mes a la dreta de for
          iApilades dup length 1 sub get dup length 1 sub get i4cantons araPlana get exch get  %% extraiem el valor de les coordenades de la imatge de mes a la dreta de la darrera de les linies apilades (COMpara)
          3 get  %% x,y del xamfra inferior dreta de la imatge COMpara
          exch 1 get  %% x,y del xamfra superior dreta de la imatge comPARAdelfor
          %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
          /aComp exch def
          /iDeNTiQueS true def  %% gatell x saber si son identiques
          /iaComp 0 def
          {  %% forall
           aComp iaComp get  %%eq no podem jugar amb la igualtat exacte doncs hem vist que hi ha un factor de tolerancia
           sub abs tlrnc le {true}{false}ifelse  %% avaluem la coincidencia jugant amb el valor de tolerancia
           {
            iaComp 1 add /iaComp exch def
           }
           {
            /iDeNTiQueS false def exit
           }ifelse
          }forall
          iDeNTiQueS  %% les coordenades 3 (de la imatge de + a la dreta de la filera trobada) i 1 (de la imatge que comparem) son iguals?
          {
           (lligatXdretaSota) ==
           %% ampliem l'array iApilades 1 + x sota ...
           iApilades dup length 1 add array dup 3 -1 roll 0 exch putinterval
           %% ... i afegim el nom desat a comPARAdelfor
           dup dup length 1 sub comPARAdelfor put /iApilades exch def

           %% hem de matar amb un NULL a trencadis l'element caçat a iApilades
           trencadis ARAi null put

           /hemTriomfat true def  %% si!
          }if
         }if  %% de si encaixa per l'esquerra
        }if  %% les dues fileres d'imatges a comparar tenen els mateixos elements?
       }ifelse  %% de si l'hem mort amb null
      }for  %% de trencadis

      hemTriomfat
      {  %% si hem empalmat algun element, doncs tornem a posar el gatell a false
       /hemTriomfat false def
      }
      {  %% sortim del loop xq ja no hem trobat + elements que pertanyin al mateix mosaic de forma continua
       %% per tant tambe ja podem desar l'array dels elements acoplats a iApilades amb exit cap a totalMosaics ...
       totalMosaics dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 exch putinterval
       %% ... i afegim iApilades amb profilaxi
       dup baUla iApilades dup length array copy put /totalMosaics exch def
       0 /aEscapsar exch def  %% valor inicial del comptador d'elements regenerables

       %% anul·lem el paquet que hem avaluat a trencadis per mitja del seu index iNOnull
       trencadis iNOnull null put
       %% regenerem l'array trencadis en cas que tingui nullS per la cua ...
       trencadis length 1 sub -1 0
       {
        trencadis 1 index get null eq
        {pop}{1 add /aEscapsar exch def exit}ifelse
       }for
       %% ... de forma que escapcem el paquet pel darrer element no null de trencadis
       trencadis 0 aEscapsar getinterval /trencadis exch def
       exit  %% sortim del loop de si hemTriomfat
      }ifelse
     }loop  %% 2
    }loop  %% 1
    %%%
    %%% desem el mapa de totes les imatges que pertanyin a un mateix mosaic dins trEncAclOsqUEs, lligat al num de pagina
    XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
    /trEncAclOsqUEs get araPlana totalMosaics put
    %%% fi de l'algorisme muntador del trencaclosques
   }
   {  %% no hi ha imatges en aquesta plana
    pop
   }ifelse
  }ifelse  %% filtrem si el dic i4cantons es buit (no es criden imatges al contingut de plana)
 }if  %/06 COSIT D'IMATGES
} forall  %% que extrau els Contents i els repica


sEdAs closefile
flush
%%% fi del repicat de Contents

%% aquí explorem el diccionari que controla les claus (Artifact) de dada variable i les tipografies
%%tipusDADAv/1 get{== ==}forall(:-5)pstack quit

QueLiFemFer 6 eq  %:06 COSIT D'IMATGES
{  %% nomes si activem el trencaclosques
 %% gatell per saber si el PDF té trencaclosques (si li hem cosit cap imatge)
 /TRNCCLSQS false def
 %#%24% anàlisi de si hi ha trencaclosques d'imatges ...
(%#%24%)==
 %% ... per muntar pagina a pagina les dades clau per la regeneracio en un diccionari extern anomenat iFenix ...
 /iFenix <<>>def  %% ... que utilitzarà l'algorisme culcusit.ps x refer tots els mosaics
 XRay /ObjectesX get
 {  %% forall plana x plana
  exch pop  %% ens carreguem el literal de la pagina (num de pagina d'ObjectesX) on explorem si hi ha mosaics
  /trEncAclOsqUEs get
  dup length 0 eq
  {  %% PDF sense imatges XObject (manquen encara controlar les inLine!)
   pop  %% ens carreguem el dic de trEncAclOsqUEs
   %%( ... SENSE trencaclosques!) ==
  }
  {
   {  %% forall del dic trEncAclOsqUEs
    exch /PiFenix exch def  %% pagina on explorem si hi ha mosaics
    {  %% forall de l'array de paquets de mosaics
     dup length 1 gt
     {  %% es un mosaic de diverses linies d'imatges
      /TRNCCLSQS true def   %% pop exit
      dup dup length 1 sub get 0 get  %% en aquest cas es la primera del darrer paquet
      dup /iClau exch def %% nom de la imatge clau que regenerara el mosaic
      <<
        %% paquet original de com s'organitza el mosaic fila a fila xq culcosit pugui actuar
	/capCapsa 3 index
        %% paquet amb els paquets de noms de les imatges q eliminarem (matades a Do, a XObject de Resources i objectes associats)
        /eliminem 5 index mark exch {dup length array copy}forall  %% copiem x profilaxi tots els paquets
        dup length 1 sub 1 exch getinterval  %% afaitem la imatge clau el darrer paquet (es la unica q no cal eliminar!)
        counttomark array astore exch pop  %% desem
        %% paquet amb la matriu de coordenades que la imatge clau invocara amb cm abans de ser cridada per Do
        /matriu
        %% anem a pescar la matriu identica de la imatge clau
        i4cantons PiFenix get iClau get 4 get
        %% i en modifiquem l'escala X,Y per la la nova escala del mosaic
        dup 10 -1 roll 0 get dup length 1 sub get  %% primer anem a pescar la imatge de l'extrem superior dret (la darrera del primer paquet) ...
        %% ... n'esbrinem el xamfra UR
        i4cantons PiFenix get exch get 1 get
        %% calculem l'escala X del mosaic
        dup 0 get 3 -1 roll 4 get sub
        %% calculem l'escala Y del mosaic
        exch 1 get 2 index 5 get sub
        %% incrustem l'escala Y a la matriu del mosaic
        2 index exch 3 exch put
        %% incrustem l'escala X a la matriu del mosaic
        1 index exch 0 exch put
      >>
      %% cal comprovar abans si ja hi ha mosaics desats en aquesta pagina
      iFenix PiFenix known
      {  %% si ja n'hi ha en desem un +
       iFenix PiFenix get 3 1 roll put
       %%( ... ja hi ha mosaics en aquesta pagina! ... ) pstack quit
      }
      {  %% si no n'hi ha, generem el dic de pagina corresponent desant-hi el mosaic
       2 dict dup 4 -1 roll 4 -1 roll put  %% incrustem el parell: imatge clau/dic del mosaic ...
       iFenix exch PiFenix exch put  %% ... al diccionari de la pagina que anira desat al dic iFenix x regenerar els mosaics
       %%( ... NO hi ha mosaics en aquesta pagina ...) pstack quit
      }ifelse
     }
     {  %% paquet d'1 sola linia d'imatges
      0 get dup length 1 gt
      {  %% es un mosaic de nomes 1 linia d'imatges
       /TRNCCLSQS true def  %% exit
       dup 0 get dup /iClau exch def %% nom de la imatge clau que regenerara el mosaic (en aquest cas es la primera del paquet)
       <<
         %% paquet original de com s'organitza el mosaic fila a fila xq culcosit pugui actuar
	 /capCapsa 3 index
         %% paquet amb paquet de noms de les imatges q eliminarem (matades a Do, a XObject de Resources i objectes associats)
         /eliminem 5 index dup length 1 sub 1 exch getinterval 1 array astore  %% afaitem la imatge clau del paquet (es la unica q no cal eliminar!)
         %% paquet amb la matriu de coordenades que la imatge clau invocara amb cm abans de ser cridada per Do
         /matriu
         %% anem a pescar la matriu identica de la imatge clau
         i4cantons PiFenix get iClau get 4 get
         %% i en modifiquem l'escala X,Y per la la nova escala del mosaic
         dup 10 -1 roll dup length 1 sub get  %% primer anem a pescar la imatge de l'extrem superior dret (la darrera del paquet) ...
         %% ... n'esbrinem el xamfra UR
         i4cantons PiFenix get exch get 1 get
         %% calculem l'escala X del mosaic
         dup 0 get 3 -1 roll 4 get sub
         %% calculem l'escala Y del mosaic
         exch 1 get 2 index 5 get sub
         %% incrustem l'escala Y a la matriu del mosaic
         2 index exch 3 exch put
         %% incrustem l'escala X a la matriu del mosaic
         1 index exch 0 exch put
       >>
       %% cal comprovar abans si ja hi ha mosaics desats en aquesta pagina
       iFenix PiFenix known
       {  %% si ja n'hi ha en desem un +
        iFenix PiFenix get 3 1 roll put
        %%( ... ja hi ha mosaics en aquesta pagina! ... ) pstack quit
       }
       {  %% si no n'hi ha, generem el dic de pagina corresponent desant-hi el mosaic
        2 dict dup 4 -1 roll 4 -1 roll put  %% incrustem el parell: imatge clau/dic del mosaic ...
        iFenix exch PiFenix exch put  %% ... al diccionari de la pagina que anira desat al dic iFenix x regenerar els mosaics
        %%( ... NO hi ha mosaics en aquesta pagina ... ) pstack quit
       }ifelse
      }
      {  %% no es cap mosaic
       pop
       %% /TRNCCLSQS false def
      }ifelse
     }ifelse
    }forall  %% de l'array de paquets de mosaics
    %%TRNCCLSQS
    %%{
    %% ==
    %% ( ... HI HA TRENCACLOSQUES!)==
    %% /TRNCCLSQS false def
    %%}
    %%{
    %% ==
    %% ( ... SENSE trencaclosques!) ==
    %%}ifelse
   }forall  %% del dic trEncAclOsqUEs
  }ifelse
 }forall  %% plana x plana
 %% treiem un missatge pel prompt i escrivim el fitxer que servirà de gatell per que la interfície
 %% ens digui de forma més clara que el PDF processat no duu imatges trencades o que es puguin cosir
 TRNCCLSQS not
 {  %% i també parem l'execució (doncs no val la pena repicar el PDF)
  (totbe.txt)  %% si NO HI HA aquest arxiu, la interfície donarà un error d'execució de CaLi2CoPi
  dup length tEmp length dup /faPath exch def add string dup /pAthXiU exch def
  0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
  pAthXiU (w) file dup 32 write closefile

  (trencaclosques.txt)  %% si HI HA aquest arxiu, la interfície donarà un avís
  dup length tEmp length dup /faPath exch def add string dup /pAthXiU exch def
  0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
  pAthXiU (w) file dup 32 write closefile 
  BaBeL 45 get print flush stop
 }if
}if  %/06 COSIT D'IMATGES


%%}stopped
%%{
%%% a l'objecte 1022 de l'stream de continguts trencats peta el sistema r/w
%%% q cal fer ?
%% indexONpeta pstack quit
%%}if

%#%25% exploració de les Layers del document
(%#%25%)==
%% pesquem el dic del Catalog ...
/iDimoni 0 def
{  %% loop d'interrogacio dels dicts de COMdimoni
 currentdict iDimoni 4 string cvs cvn get
 %% el diccionari de l'objecte
 dup CtLg known {CtLg get exit}{pop}ifelse  %% variable amb el Catalog+Nou
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% d'interrogacio dels dicts de COMdimoni

dup /CtLgViu exch def  %% x implementar-hi despres OCProperties + PieceInfo i el que vingui

QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
{  %% corregim temporalment l'error de Ghostscript q al repicar de nou el PDF al principi x eliminar
 %% d'arrel la supercompressio o les inLine conflictives, es carrega el PageMode del Catalog
 dup /Outlines known  %% si duu bookmarks
 {
 %%dup/PageMode/UseOutlines put
 dup/PageMode undef  %% ens carreguem explicitament qualsevol solapa oberta
 }if
 %% JBC: posem a pinyo fix una adreça Base URL de proves?
 %%dup /URI<</Base (http://femfum.com/)>> put
}if  %/08 ETIQUETA TEXT

QueLiFemFer 10 eq  %:10 PREFLIGHT AMB CAPES
QueLiFemFer 13 eq  %:13 eliminem continguts de pàgina
QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%%MASATS07 p.e. x corregir l'error de desat a 1.4 de Vectorworks a DM0977600E0v4_v2014-8.pdf
QueLiFemFer 15 eq  %:15 ELIMINA LLESQUES
or or or
{  %#%25bis% desem el diccionari del Catalog més nou, actualitzem a 1.5 si s'escau, i activem l'obertura de PDF amb solapa de Layers
 (%#%25bis%)==
 %%dup /CtLgViu exch def  %% x implementar-hi despres OCProperties si fem 10
 %% comprovem la versio de PDF x saber si es 1.5 (versio minima x poder tenir Layers)
 vPDF cvx exec 1.5 lt {/vPDF (1.5) def}if  %% si es + petita q 1.5 l'anivellem
 %% activem al Catalog la solapa de llesques visible
 dup /PageMode /UseOC put
} if  %/15 ELIMINA LLESQUES
      %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
      %/13 eliminem continguts de pàgina
      %/10 PREFLIGHT AMB CAPES 

QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
{  %#%25bis2% desem el diccionari del Catalog més nou, actualitzem a 1.5 si s'escau
 (%#%25bis2%)==
 %%dup /CtLgViu exch def  %% x implementar-hi despres OCProperties
 %% comprovem la versio de PDF x saber si es 1.5 (versio minima x poder tenir Layers)
 vPDF cvx exec 1.5 lt {/vPDF (1.5) def}if  %% si es + petita q 1.5 l'anivellem
} if  %/08 ETIQUETA TEXT 

dup /OCProperties known
{
%%(       This PDF has Layers?) ==
 /OCProperties get dup type /nametype eq
 {  %% no es un dic directe
  /aCercar exch def  %% nom del dic de les OCProperties a cercar
  /iDimoni 0 def
  {  %% loop d'interrogacio dels dicts de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   %% el diccionari de l'objecte
   dup aCercar known {aCercar get exit}{pop}ifelse
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% d'interrogacio dels dicts de COMdimoni
 }if  %% deixem el dic generic de les propietats de les Layers a la pila
 dup /OCGs known  %% segona possibilitat de que NO hi hagin Layers (hem trobat dics OCProperties buits)
 {  %% SI que n'hi ha!
  dup /OCPROP exch def  %% desem el dic OCProperties x + endavant
  /OCGs get  %% n'extraiem l'entrada obligatoria
  dup type /nametype eq  %% es una array directe o indirecte?
  {
   /aCercar exch def  %% nom amb la ref ind del l'array OCGs a cercar
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup aCercar known
    {
     dup /dCOMdimoniOCGs exch def  %% necessari per redesar l'objecte indirecte d'OCGs a 15
     aCercar get exit
    }
    {
     pop
    }ifelse
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
  } if
  %% deixem l'array OCGs a la pila ...
  dup /OCeGeEsa exch def  %% desem l'array OCGs x + endavant

  %% aqui teniem definits els 3 encodings que podrem utilitzar ...
  %% WinAnsiEncoding2Bytes WinAnsiEncoding PDFDocEncoding ... (ara son definits a %20%)

%%MASATS01 comptador d'índex de l'array OCGs, necessari pel codi JS pel browser de Masats
  /iOCGs 0 def

  {  %% forall per l'array OCGs x cercar al dic de cada layer el nom obligatori extern del Viewer
   %% descartem possibles null
   dup type /nulltype eq
   {
    pop
   }
   { 
    /aCercarL exch def  %% nom diferenciat per la incrustacio a /nomIE de /Lleixes, amb la ref ind del dic de cada layer
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercarL known {aCercarL get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
    {
     dup /Usage known
     {  %% existeix el diccionari Usage ?
      dup /Usage get
      dup type /nametype eq
      {  %% es un objecte indirecte
       /aCercar exch def  %% nom amb la ref ind del dic de cada layer
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
       dup /Print known
       {  %% existeix el diccionari Print ?
        /Print get
        dup type /nametype eq
        {  %% es un objecte indirecte
         /aCercar exch def  %% nom amb la ref ind del dic de cada layer
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
         dup /PrintState known
         {  %% interroguem si el PrintState es a ON o OFF ...
          /PrintState get /ON eq
          {/PrntStt true def}{/PrntStt false def}ifelse
         }
         {  %% si no existeix posem el gatell del Print State a true
          pop /PrntStt true def
         }ifelse
        }
        {  %% es un dic directe
         dup /PrintState known
         {  %% interroguem si el PrintState es a ON o OFF ...
          /PrintState get /ON eq {/PrntStt true def}{/PrntStt false def}ifelse
         }
         {  %% si no existeix posem el gatell del Print State a true
          pop /PrntStt true def
         }ifelse
        }ifelse
       }
       {  %% si no existeix posem el gatell del Print State a true
        pop /PrntStt true def
       }ifelse
      }
      {  %% es un dic directe
       dup /Print known
       {  %% existeix el diccionari Print ?
        /Print get
        dup type /nametype eq
        {  %% es un objecte indirecte
         /aCercar exch def  %% nom amb la ref ind del dic de cada layer
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
         dup /PrintState known
         {  %% interroguem si el PrintState es a ON o OFF ...
          /PrintState get /ON eq {/PrntStt true def}{/PrntStt false def}ifelse
         }
         {  %% si no existeix posem el gatell del Print State a true
          pop /PrntStt true def
         }ifelse
        }
        {  %% es un dic directe
         dup /PrintState known
         {  %% interroguem si el PrintState es a ON o OFF ...
          /PrintState get /ON eq {/PrntStt true def}{/PrntStt false def}ifelse
         }
         {  %% si no existeix posem el gatell del Print State a true
          pop /PrntStt true def
         }ifelse
        }ifelse
       }
       {  %% si no existeix posem el gatell del Print State a true
        pop /PrntStt true def
       }ifelse
      }ifelse
     }
     {  %% si no existeix posem el gatell del Print State a true
      /PrntStt true def
     }ifelse
     /Name get
    } stopped
    {  %% si no s'ha trobat el dic de la layer es produira un error
     XRay /Lleixes get /Errades get aCercar (The Object Layer Dictionary is Missing) put  %% que haurem de registrar a XRay al dic errades amb  /NumObj (text de l'error)
    }if
    %% nom de extern de la Layer que cal mirar si es en Unicode!
    /esUnicode false def  %% gatell x deteccio
    dup length 2 ge
    {  %% si com a minim te 2 caracters ja podem fer la comprovacio d'unicode
     dup 0 2 getinterval <feff> eq
     {  %% el text es en Unicode
      /esUnicode true def
      dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
      maxLoop 2 sub 2 idiv string /T1B exch def  %% la cadena de text a 1 byte
      T1B /NullEncode filter /fT1B exch def  %% el fitxer d'escriptura de la cadena de text
      /iU 2 def  %% inici del text unicode
      4 string /BuFF exch def  %% buffer per l'escriptura del codi hexa
      {  %% loop x tota la cadena
       dup iU 2 getinterval
       BuFF /NullEncode filter dup 3 -1 roll writehexstring closefile  %% escrivim l'hexa i es IMPRESCINDIBLE per Ghost tancar el fitxer!!!
       %% primer mirem si existeix a dic d'Unicode
       WinAnsiEncoding2Bytes
       BuFF
       %%  cvn  %% test x Ghost
       known
       %% test x Ghost q sospitem q no tracta igual les strings que els literals dins un dic
       %%  BuFF (Ghost?) pstack stop
       {  %% es a la taula Unicode
        WinAnsiEncoding2Bytes BuFF get /BuscaTrusca exch def
        /HiEs false def  %% gatell x detectar si es a la taula WinAnsiEncoding
        /iWAE 0 def  %% comptador x saber com l'hem d'escriure
        WinAnsiEncoding
        {
         BuscaTrusca eq{/HiEs true def exit}if iWAE 1 add /iWAE exch def
        }forall
        BuscaTrusca /.notdef eq {/HiEs false def}if  %% mirem que no fos un /.notdef
        HiEs
        {  %% es a la taula WinAnsiEncoding
         fT1B iWAE write  %% escrivim el codi del caracter que toca a l'string 1 byte
        }
        {  %% si no existeix o es un /.notdef a la taula WinAnsiEncoding ho desem a XRay
         %% ( ... XRay ... NO es a WinAnsi) ==
         XRay /Lleixes get /NoHeEscrit get BuscaTrusca << BuFF dup length string copy (This Character is Not Defined Inside the WinAnsi Encoding) >> put
         fT1B 63 write  %% l'escrivim ? a l'string 1 byte
        }ifelse
       }
       {  %% si no existeix a la taula 2Bytes hauriem de donar una alerta
        %%( ... XRay ... NO es a PDFDocEnc) ==
        XRay /Lleixes get /NoHeEscrit get /UnknowName << BuFF dup length string copy (This Character is Not defined inside the PDFDoc Encoding) >> put
        fT1B 63 write  %% l'escrivim ? a l'string 1 byte
       }ifelse
       iU 2 add /iU exch def  %% saltem de dos en dos
       iU maxLoop ge {pop fT1B closefile exit} if  %% hem llegit tota la cadena?
      } loop
     } if
    } if
    esUnicode
    {  %% canviem el flag /Unicode a l'XRay
     %%   ( ... XRay ... es 2Byte) ==
     XRay /Lleixes get /Unicode true put
    }
    {  %% es 1byte + comprovarem els encodings
     %%   ( ... XRay ... es 1Byte) ==
     dup length string /T1B exch def  %% la cadena de text a 1 byte
     T1B /NullEncode filter /fT1B exch def  %% el fitxer d'escriptura de la cadena de text
     {  %% x tota la cadena
      PDFDocEncoding exch get /BuscaTrusca exch def
      /iWAE 0 def  %% comptador x saber com l'hem d'escriure
      /HiEs false def  %% gatell x detectar si es a la taula PDFDocEncoding
      WinAnsiEncoding
      {
       BuscaTrusca eq{/HiEs true def exit}if iWAE 1 add /iWAE exch def
      }forall
      BuscaTrusca /.notdef eq {/HiEs false def}if  %% mirem que no fos un /.notdef
      HiEs
      {  %% es a la taula WinAnsiEncoding
       fT1B iWAE write  %% escrivim el codi del caracter que toca a l'string 1 byte
      }
      {  %% si no existeix o es un /.notdef a la taula WinAnsiEncoding hauriem de donar una alerta
       XRay /Lleixes get /NoHeEscrit get BuscaTrusca << iWAE 3 string cvs (This Character is Not defined in WinAnsi Encoding) >> put
       %% (. .. XRay ... NO es a WinAnsi) ==
       fT1B 63 write  %% l'escrivim ? a l'string 1 byte
      }ifelse
     }forall
     fT1B closefile
    }ifelse

    %% ara desem a XRay els noms dels dic de cada layer, l'array amb el nom extern i de moment un false que voldra dir que NO l'utilitzem
%%MASATS01 afegim a l'índex 4 el valor de iOCGs i una array  a l'índex 5 per saber l'ordinal de pàgines on la capa és activa
    XRay /Lleixes get /nomIE get aCercarL [ null T1B false PrntStt iOCGs [] ] put  %% posem tambe PrntStt al nou index 3 que ens dira el seu PrintState
   } ifelse  %% hi ha nulls ?

%%MASATS01 fem córrer l'índex
/iOCGs iOCGs 1 add def

  } forall  %% x l'array OCGs

  %% ara anem a pescar els Resources de cada plana per llegir el dic /Properties
  %% amb l'emparellat del nom intern nom del dic de cada layer
  quinaPlana
  {  %% forall
   /actGina exch def /NumPag exch def  %% desem el literal del num d'obj /Page i l'ordinal
   %% pesquem la branca ...
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup actGina known {actGina get exit}{pop}ifelse 
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni

%%  % ens assegurem que la pagina te /Resources, si no produim un error MRCT
%%  dup /Resources known not
%%  {
%%   BaBeL 33 get print flush
%%   % informem dels fitxers del tmp
%%   BaBeL 50 get print flush
%%   clear stop
%%  }if

   %% 05.03.09 aquesta solucio de la cerca recursiva del dic Resources considerant el null i el diccionari buit cal implementar-la arreu on calgui!
   %% anem cercant cap enrera els Parent en cas de no trobar Resources dins la mateixa pagina
   {  %% loop
    dup /Resources known  %% hi ha Resources?
    {  %% Resources es a /Page o /Pages ?
     %% descartem la possibilitat de que la ref indirecte sigui un null o un dict buit
     %% pel que llavors tindria els Resources heretats i continuariem el loop enrera ...
     /Resources get dup type /nametype eq
     {
      /aCercar exch def  %% nom amb la ref ind del dic Resources
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dics de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
      dup length 0 eq
      {  %% pagina amb Resources heretats i continuem el loop enrera
       pop
      }
      {
       exit  %% sortim del loop amb el dic Resources a l'stack
      }ifelse
     }
     {
      dup null eq
      {  %% pagina amb Resources heretats i continuem el loop enrera
       pop
      }
      {  %% no pot ser altra cosa que un dic directe
       dup length 0 eq
       {  %% pagina amb Resources heretats i continuem el loop enrera
        %% pop
       }
       {
        exit  %% sortim del loop amb el dic Resources a l'stack
       }ifelse
      }ifelse
     }ifelse
    }
    {  %% Resources podria estar a /Pages!
     dup /Parent known
     {
      dup /Parent get
      /aCercar exch def
      %% pesquem la branca ...
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse 
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
     }
     {  %% aquesta pagina no te Resources!
      BaBeL 33 get print flush
actGina == (2)==
      %% informem dels fitxers del tmp
      BaBeL 50 get print flush
      clear stop  %%quit
%%UBpliegOMaker
     }ifelse
    }ifelse
   }loop

   %% aqui tenim el dic Resources
   dup /RSRCS exch def  %% desem una copia del dic Resources x + endavant
   dup /Properties known  %% si al dic Resources no hi ha aquesta entrada ...
   {  %% donem un error a XRay?
    /Properties get dup type /nametype eq
    {
     /aCercar exch def  %% nom amb la ref ind del dic Resources
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }if
    dup length dict copy  %% en fem una copia x mantenir inalterat l'original!
    dup /PRPRTS exch def  %% desem el dic Properties x fer la comprovacio d'us + endavant
    {  %% forall on explorem tot el dic per posar els noms interns a XRay
     dup XRay /Lleixes get /nomIE get exch known
     {
      dup XRay /Lleixes get /nomIE get dup 3 -1 roll get dup 5 -1 roll 0 exch put  %% incrustem el nom intern de la layer a la posicio 0 de l'array
      3 -1 roll exch put  %% reincrustem el parell /NomObj [nomintern nomextern utilitzada? PrintState?] al dic nomIE
     }
     {  %% aqui cal escriure un Error a XRay de Layer no definida a Properties (cal realment?)
      dup type /nametype eq  %% pot ser un dic directe?
      {
       /aCercar exch def  %% nom amb la ref ind del dic Resources
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
      }if
      dup /Type get /OCMD eq
      {  %% es un diccionari 'membership' de conducta de la capa
       dup /OCGs known
       {
        /OCGs get
        dup type /nametype eq
        {
         /aCercar exch def  %% nom amb la ref ind
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
        }if
        %% pot ser un diccionari o una array
        dup type /arraytype eq
        {
         {  %% forall
          2 copy PRPRTS 3 1 roll put  %% repiquem el num d'objecte que apunta directament al dic de la Layer i no al seu Membership!
          dup XRay /Lleixes get /nomIE get dup 3 -1 roll get
          dup 5 -1 roll 0 exch put  %% incrustem el nom intern de la layer a la posicio 0 de l'array
          3 -1 roll exch put  %% reincrustem el parell /NomObj [nomintern nomextern utilitzada? PrintState] al dic nomIE
         }forall
        }
        {  %% es un dic
         pop  %% ens el carreguem
         PRPRTS 1 index get
         /aCercar exch def  %% nom amb la ref ind
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
         /OCGs get dup
         XRay /Lleixes get /nomIE get dup 3 -1 roll get dup
         5 -1 roll 0 exch put  %% incrustem el nom intern de la layer a la posicio 0 de l'array
         3 -1 roll exch put  %% reincrustem el parell /NomObj [nomintern nomextern utilitzada? PrintState] al dic nomIE
        }ifelse
       }
       {  %% ara ignorem que pot ser i sortim...
        (\n\nMRCT27 LAYER sense /OCGs ...comportament desconegut ... pleguem!\n\n) print flush stop  %%quit
       }ifelse
      }
      {  %% ara ignorem que pot ser, però llistem la refind que ho provoca...
       (\n\nMRCT27 LAYER sense /Type /OCMD ...comportament desconegut ... oju!\n\n) print flush %stop  %%quit
       aCercar ==
      }ifelse
     }ifelse
    }forall
   }
   {
    pop XRay /Lleixes get /Errades get actGina (The Properties Layers Dictionary is Missing in this Page) put  %% que haurem de registrar a XRay al dic errades amb /NumObj (text de l'error)
    null /PRPRTS exch def  %% desem un null en comptes del dic Properties x NO fer les comprovacions de + endavant
   }ifelse
   
   %% aquesta comprovacio de les Properties com que penja de Resources cal fer-la a cada plana
   PRPRTS type /dicttype eq
   {
    %% comprovem comparant amb Properties si totes les layers cridades a l'stream de dades estan definides o no
    XRay /Lleixes get /Desconegudes get /uStream exch def  %% dic de les layers utilitzades a l'stream dels Contents
    %% ara les marquem a nomIE com a utilitzades amb un true
    XRay /Lleixes get /nomIE get /FaigServir exch def
    uStream
    {  %% forall
     pop dup PRPRTS exch known
     {
      PRPRTS exch get  %% extraiem la refind de la layer
      FaigServir 1 index known
      {
       FaigServir exch get 2 true put  %% i la marquem com a utilitzada
      }
      {  %% podria no ser-hi degut a que entremig hi ha quelcom que no controlem encara? ...
       XRay /Lleixes get /Errades get exch (Object Layer not defined in the Properties dictionary) put
       %%(\n\nMRCT27 LAYER amb comportament desconegut ... pleguem!\n\n) print flush quit
      }ifelse
     }{pop}ifelse
    } forall
    PRPRTS {pop uStream exch undef} forall  %% donem de baixa al dic de /Desconegudes totes les layers existents a Properties
   } if  %% nomes executem aquestes comprovacions si Properties existeix
   
  } forall

  %% fi del pescat de Properties
 }
 {  %% NO n'hi han!
  pop
 }ifelse  %% segona possibilitat de que NO hi hagin Layers
}
{
 pop  %%XRay /Lleixes get /NhiHa false put  % posem a false l'entrada que indica si hi ha layers
} ifelse  %% si no la duu es que no te Layers

%%% FI d'exploracio de les Layers del document

%% test d'XRay
%% XRay /Lleixes get /Errades <</1 (l'hem cagada 1)/2 (l'hem cagada 2)/3 (l'hem cagada 3)>> put
%% XRay /Lleixes get /Desconegudes get /XYZ /OC put
%% XRay /Lleixes get /NoHeEscrit <</Ablanatanalba <<(1234) (es quan trempo que hi veig clar!)>> >> put
%% XRay /Lleixes get /nomIE get {2 false put pop}forall

%#%26% ara anem a pescar els Resources de cada plana per localitzar /XObject
(%#%26%)==
/RSRCS <<>> def  %% ara desem en un diccionari el dic Resources dins del literal de cada pagina
/JectesX <<>> def  %% dic on desarem els XObjects de totes les pagines (clau el nom de l'XObject i valor la ref ind)

quinaPlana
{  %% forall
 /actGina exch def /araPlana exch def  %% desem el literal del num d'obj /Page i l'ordinal de la plana a la que correspon
 %% pesquem la branca ...
 /iDimoni 0 def
 {  %% loop d'interrogacio dels dicts de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  %% el diccionari de l'objecte
  dup actGina known {actGina get exit}{pop}ifelse 
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq {exit} if
 } loop  %% d'interrogacio dels dicts de COMdimoni

 %% 05.03.09 aquesta solucio de la cerca recursiva del dic Resources considerant el null i el diccionari buit cal implementar-la arreu on calgui!
 %% anem cercant cap enrera els Parent en cas de no trobar Resources dins la mateixa pagina
 {  %% loop
  dup /Resources known  %% hi ha Resources?
  {  %% Resources es a /Page o /Pages ?
   %% descartem la possibilitat de que la ref indirecte sigui un null o un dict buit
   %% pel que llavors tindria els Resources heretats i continuariem el loop enrera ...
   /Resources get dup

%dup ==(LOOP1)== actGina == araPlana ==
 type /nametype eq
   {
    /aCercar exch def  %% nom amb la ref ind del dic Resources
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dics de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
    dup length 0 eq
    {  %% pagina amb Resources heretats i continuem el loop enrera
%% no matem el diccionari per si de cas detectar si /Resources és heretat!
%     pop
    }
    {
     exit  %% sortim del loop amb el dic Resources a l'stack
    }ifelse
   }
   {
    dup null eq
    {  %% pagina amb Resources heretats i continuem el loop enrera
     pop
    }
    {  %% no pot ser altra cosa que un dic directe
     dup length 0 eq
%(:-])pstack quit
     {  %% pagina amb Resources heretats i continuem el loop enrera
      %% pop
     }
     {

%%PEDAÇ temporal per incrustar 2 Patterns al dic Resources
%dup /Shading known not
%{
% dup /Pattern <</P2 /2______________0 /P3 /3______________0 >> put
%}if

      exit  %% sortim del loop amb el dic Resources a l'stack
     }ifelse
    }ifelse
   }ifelse
  }
  {  %% Resources podria estar a /Pages!
   dup /Parent known
   {
    dup /Parent get
    /aCercar exch def
    %% pesquem la branca ...
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse 
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
   }
   {  %% aquesta pagina no te Resources!
    BaBeL 33 get print flush
actGina == (3)==
    %% informem dels fitxers del tmp
%% 27.09.2023 NO aturem l'execució malgrat aquest possible forat de dades al /Resource de /Page i sortim
    exit
%%    BaBeL 50 get print flush
%%    clear stop  %%quit
%%UBpliegOMaker
   }ifelse
  }ifelse
 }loop

 %% aqui tenim el dic Resources
 dup RSRCS exch araPlana exch put  %% desem una copia del dic Resources (ara paginada!) x + endavant
 dup /XObject known  %% si al dic Resources no hi ha aquesta entrada ...
 {  %% donem un error a XRay?
  /XObject get dup type /nametype eq
  {
   /aCercar exch def  %% nom amb la ref ind del dic Resources
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup aCercar known {aCercar get exit}{pop}ifelse
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
  }if
  dup dup length dict copy  %% descontaminem pel forall de la pagina actual

  %% Quedelemi
  JectesX exch araPlana exch put  %% desem a la plana q toca el dic XObject dels Resources corresponents
  JectesX dup length dict copy /JectesX exch def  %% descontaminem x profilaxi

%% Quedelemi
%% JectesX {{== ==}forall ==}forall

  %%0 /iAdirecte exch def  % numerador per les arrays de color directes
  {  %% forall, explorem tot el dic per classificar a XRay els XObjects en Utilitzats, NoUtilitzats, Desconeguts i Errades
   /JECTEx exch def XRay /ObjectesX get
   dup araPlana known  %% en aquesta plana hi ha imatges?
   {  %% si
    araPlana get  %% pesquem el dic de la plana on som
    /Desconeguts get exch 2 copy known
    {  %% si hi es, primer busquem el dic de la imatge x desar-ne les dades q ens interessen a l'XRay
     JECTEx dup type /nametype eq
     {
      /aCercar exch def  %% nom amb la ref ind del dic Resources
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     %% comprovem que sigui Subtype Image
     dup /Subtype get /Image eq
     {  %% desem en un array de 3 posicions els pixels x,y i l'espai de color
      /3ai 3 array def dup
      /Width get 3ai exch 0 exch put dup
      /Height get 3ai exch 1 exch put dup
      /ColorSpace known
      {
       /ColorSpace get
       %%dup type /arraytype eq
       %%{  % x detectar les arrays de color directes
       %%}if
       3ai exch 2 exch put
      }
      {  %% pot ser una imatge ploma feta amb imagemask?
       %% /ImageMask known
       %%{}{}ifelse
       QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
       {  %#%26bis% sortim, doncs ara no tractem els plomes a les separacions de color
        (%#%26bis%)==
        (\n\n>>>>> ... es una imatge sense ColorSpace (deu ser un ploma) i de moment x la Separacio de Colors pleguem ... <<<<<\n\n) print flush stop  %%quit
       }  %/01 SEPARACIÓ DE TINTES
       {
        (\n\n ... deu ser una imatge ploma ...\n) print flush
        pop   %% ens carreguem el dict i posem provisionalment /Unknow_ColorSpace al lloc de l'espai de color que li correspondria dins l'array
        3ai 2 /Unknow_ColorSpace put  %% cal q tingui una llargaria diferent a 16 doncs coincidiria amb una ref ind!
       }ifelse
      }ifelse
      %% ... i despres el donem d'alta a Utilitzats amb l'array de dades arreplegades i el donem de baixa a Desconeguts
      dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
      /Utilitzats get exch 3ai put undef
     }
     {  %% pot ser un Form XObject o un PostScript XObject ...
      dup /Subtype get /Form eq
      {  %% es un Form XObject
       %% descartem que no sigui ni un 'Reference XObject' ni un OPI XObject que voldria dir que es vincula externament a d'altres continguts
       dup /Ref known
       {  %% Reference XObject
%%/Ref get {== ==}forall(::::::)pstack quit  %% hauríem de poder preservar el doble hexadecimal de la ID del pdf referenciat
%%EP cal afinar aquest detectorID pels PDF amb Reference XObjects, doncs és via ID que s'identifiquen els Proxy
        pop dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on somt
        /Errades get exch ( Reference XObject Form Not Supported) put undef
       }
       {
        dup /OPI known
        {  %% OPI XObject
         pop dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Errades get exch ( OPI XObject Form Not Supported) put undef
        }
        {
         /3ai 3 array def dup
         %% atencio! ara posarem al primer lloc d'3ai l'array del BoundingBox del Form
         /BBox get 3ai exch 0 exch put dup
         %% atencio! ara posarem al segon lloc d'3ai l'objecte (array o literal) dels recursos associats
         /Resources known  %% no es 100% obligatori
         {
          dup /Resources get 3ai exch 1 exch put
         }if  %% si no te Resources creiem q no passa res
         %% el tercer lloc d'3ai li posem el dic sencer o la seva ref ind del Form
         pop
         3ai 2 JECTEx put
         %% ... i despres el donem d'alta a Utilitzats amb l'array de dades arreplegades i el donem de baixa a Desconeguts
         dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Utilitzats get exch 3ai put undef
        }ifelse
       }ifelse
      }
      {  %% haura de ser un PS XObject i llavors el passarem a Errades + el donem de baixa a Desconeguts
       pop dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
       /Errades get exch ( PostScript XObject Type Not Supported) put undef
      }ifelse
     } ifelse
    }
    {  %% si no hi es, es que l'XObject no ha estat utilitzat en aquest document
     XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
     /NoUtilitzats get exch null put pop
    }ifelse
   }
   {  %% en aquesta plana no hi ha imatges
    pop pop
   }ifelse
  }forall
 }
 {
  pop
  %%null
  JectesX /JectesX exch def  %% ara NO desem un null doncs som al multipagina
 }ifelse

} forall %% fi del forall x pagines
%% fi de 26

%%MASATSencvlct
%% hi posem el gatell 17
%:17 ENCAVALCA CONTINGUTS
QueLiFemFer 17 eq
{
 %17a% control dels Bbox
 /BBtlrnc .5 def  %% valor de tolerància màxima extablerta en comparar MediaBox/CropBox entre les pàgines
 %% de l'anàlisi d'XRay recuperem els valors de /MediaBox i /CropBox de cadascuna de les pàgines /dPagns
 XRay /PeDeEfa get dup /dPagns exch def /1 get
 /MediaBox get aload pop 3 -1 roll sub /suaraY exch def  %% valor inicial d'alt a comparar
 exch sub /suaraX exch def  %% valor inicial d'ample a comparar
 1 1 maxPlana
 {  %% for de control dels Bbox
  12 string cvs dup /araPgn exch def dPagns exch get
  %% alt del MediaBox
  /MediaBox get aload pop 3 -1 roll sub suaraY sub abs BBtlrnc ge
  {  %% error alt Media
   BaBeL 67 get print flush araPgn == stop
  }
  { %% ample del MediaBox
   exch sub suaraX sub abs BBtlrnc ge
   {  %% error ample Media
    BaBeL 66 get print flush araPgn == stop
   }
   {
    dPagns araPgn get dup /CropBox known
    {
     %% alt del CropBox
     /CropBox get aload pop 3 -1 roll sub suaraY sub abs BBtlrnc ge
     {  %% error alt Crop
      BaBeL 69 get print flush araPgn == stop
     }
     {  %% ample del CropBox
      exch sub suaraX sub abs BBtlrnc ge
      {  %% error ample Crop
       BaBeL 68 get print flush araPgn == stop
      }if
     }ifelse
    }
    {
     pop
    }ifelse
   }ifelse
  }ifelse 
 }for  %% de control dels Bbox
 BaBeL 70 get print flush

 %17b% recollim els /Resources de totes les pàgines, a encavalcar
 %% com que les n pàgines estan prèviament normalitzades pel gs, podem ser molt resolutius repicant tots els diccionaris a sac
 %% resurs a recurs, i posant a la llista dels objectes a donar de baixa totes les ref ind intermitges que pengin de cadascun
 %% dels recursos de cadascuna de les pàgines, i de moment tot els /Resources existents repicats els desarem aquí...
 /recursosRepicats <<>> def  %% la clau tindrà el nom original del recurs i el valor serà un diccionari (inclòs /ProcSet)
 %% fins la v1.7 del PDF Reference (TABLE 3.30) hi ha: ExtGState ColorSpace Pattern Shading XObject Font ProcSet Properties
 1 1 maxPlana
 {  %% for pels dics dels /Resources de totes les pàgines
  12 string cvs RSRCS exch get
  {  %% forall per cadascun dels recursos d'1 pàgina
   %% els seus valors poden ser:
   dup type /nametype eq
   {  %% es tracta d'un objecte indirecte
    dup OdeBaixa exch null put  %% a posar a la llista d'eliminar a /OdeBaixa
    /esProcSet false def  %% gatell per l'excepció
    1 index /ProcSet eq  %% tret que sigui una ref ind de ProcSet
    {
     /esProcSet true def
    }if
    %% anem a cercar-ne l'objecte diccionari o array (/ProcSet) per repicar-lo a /recursosRepicats
    /aCercar exch def  %% nom amb la ref ind del dic Resources
    /iDimoni 0 def
    {  %% loop d'interrogació dels dics de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     dup aCercar known  %% som al diccionari segmentat de pdf on hi ha l'objecte?
     {
      aCercar get exit
     }
     {
      pop
     }ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq
     {
      exit
     }if
    }loop  %% d'interrogació dels dicts de COMdimoni
    esProcSet
    {  %% transformem l'array en claus de diccionari (amb valor null) per facilitar el seu repicat
     1 dict exch
     {
      1 index exch null put
     }forall
    }if
    recursosRepicats 2 index known  %% el recurs ja existeix?
    {  %% copiem els diciconaris un dins l'altre
     recursosRepicats 2 index get copy
     recursosRepicats 3 1 roll put  %% i tornem a desar-lo
    }
    {  %% el desem de nou
     recursosRepicats 3 1 roll put
    }ifelse
   }
   {
    dup type /dicttype eq
    {  %% dicttype 
     recursosRepicats 2 index known  %% el recurs ja existeix?
     {  %% copiem els diciconaris un dins l'altre
      recursosRepicats 2 index get copy
      recursosRepicats 3 1 roll put  %% i tornem a desar-lo
     }
     {  %% el desem de nou
      recursosRepicats 3 1 roll put
     }ifelse
    }
    {
     dup type /arraytype eq
     {  %% cal només comprovar que sigui només /ProcSet sinó donarem error
      1 index /ProcSet eq
      {  %% transformem l'array en claus de diccionari (amb valor null) per facilitar el seu repicat
       1 dict exch
       {
        1 index exch null put
       }forall
       recursosRepicats 2 index known  %% el recurs ja existeix?
       {  %% copiem els diciconaris un dins l'altre
        recursosRepicats 2 index get copy
        recursosRepicats 3 1 roll put  %% i tornem a desar-lo
       }
       {  %% el desem de nou
        recursosRepicats 3 1 roll put
       }ifelse
      }
      {  %% seria una altra cosa sense control i donaríem error
       == == BaBeL 8 get print flush BaBeL 71 get print flush stop
%%UBpliegOMaker
     }ifelse
     }
     {  %% seria una altra cosa sense control i donaríem error
      == == BaBeL 8 get print flush BaBeL 71 get print flush stop
%%UBpliegOMaker
    }ifelse
    }ifelse
   }ifelse
  }forall
 }for  %% pels dics dels /Resources de totes les pàgines

 %17c% copiem xafant tots els recursos sumats a dic /Resources de la pàgina 1
 %% refent primer el diccionari /ProcSet com array
 recursosRepicats dup [ exch /ProcSet get {pop}forall ] /ProcSet exch put 
 RSRCS (1) recursosRepicats put  %% per si fessim servir RSRCS més endavant
 quinaPlana (1) get  %% xafem /Resources al diccionari de l'objecte /Page de la 1
 /aCercar exch def  %% nom amb la ref ind de l'objecte /Page
 /iDimoni 0 def
 {  %% loop d'interrogació dels dics de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  dup aCercar known  %% som al diccionari segmentat de pdf on hi ha l'objecte?
  {
   aCercar get exit
  }
  {
   pop
  }ifelse
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq
  {
   exit
  }if
 }loop  %% d'interrogació dels dicts de COMdimoni
 dup /Resources recursosRepicats put  %% ho desem a l'objecte de la pàgina 1

 %17d% cal posar tots els Continguts de la resta de pàgines dins l'array de /Contents de la pàgina 1
 dup /Contents get  %% els continguts de la pàgina 1
 dup type /arraytype ne
 {  %% si no és una array li posem a dins
  1 array astore
 }if
 /contentsDnou exch def  %% anirem alimentant l'array
 %% hi afegim els /Contents de la resta de pàgines (de la 2 a la n) concatenant arrays si convé
 2 1 maxPlana
 {  %% for pels /Contents de la 2 a la n
  12 string cvs quinaPlana exch get
  /aCercar exch def  %% nom amb la ref ind de l'objecte /Page
  /iDimoni 0 def
  {  %% loop d'interrogació dels dics de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   dup aCercar known  %% som al diccionari segmentat de pdf on hi ha l'objecte?
   {
    aCercar get exit
   }
   {
    pop
   }ifelse
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq
   {
    exit
   }if
  }loop  %% d'interrogació dels dicts de COMdimoni
  /Contents get  %% els continguts de la pàgina
  dup type /arraytype ne
  {  %% si no és una array li posem a dins
   1 array astore
  }if
  %% i concatenem
  contentsDnou dup length dup /araVa exch def 2 index length add array dup 3 -1 roll 0 exch putinterval
  dup 3 -1 roll araVa exch putinterval /contentsDnou exch def
 }for  %% pels /Contents de la 2 a la n
 %% desem l'array de tots els /Contents a la pàgina 1
 /Contents contentsDnou put

 %17e% matem tots els objectes /Pages, si n'hi ha més d'un, o sigui, el primer no (l'arrel)
 %% deixant a la primera /Pages l'array /Kids amb només la primera ref ind apuntant a /Page de la 1
 %% i rectificar el comptador /Count a 1
 elPagesNOESFA dup l'arrel undef  %% eliminem l'entrada de l'arrel /Pages
 %% perquè tota la resta (si hi són) els posarem a diccionari d'esborrar objectes
 {
  OdeBaixa 3 1 roll put
 }forall
 l'arrel /aCercar exch def  %% nom amb la ref ind de l'arrel /Pages
 /iDimoni 0 def
 {  %% loop d'interrogació dels dics de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  dup aCercar known  %% som al diccionari segmentat de pdf on hi ha l'objecte?
  {
   aCercar get exit
  }
  {
   pop
  }ifelse
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq
  {
   exit
  }if
 }loop  %% d'interrogació dels dicts de COMdimoni
 dup /Count 1 put  %% modifiquem el diccionari
 dup /Kids get 0 1 getinterval /Kids exch put

 %% cal contemplar la possibilitat d'escriure l'ordre d'encavalcat dels fitxers enllaçats al PDF de n pàgines
 %% via /PieceInfo al /Catalog i dins el diccionari /MRCT_CaLi2CoPi on a la clau /Private podríem desar els noms originals
 % (arasom%%MASATSencvlct)pstack quit
}if
%/17 ENCAVALCA CONTINGUTS

QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
{
 %#%26bis1% ja hem tractat abans aquest PDF amb el gatell #8?
 (%#%26bis1%) ==
 RSRCS
 {
  dup /Properties known
  {
   /Properties get /MRCT_llQuetes_JBC known
   {  %% ja hem tractat aquest PDF amb el gatell #8 (JBC), i de moment sortim
    (\n\n >>>> no podem tractar dues vegades un PDF amb el gatell 8 de CaLi2CoPi <<<<\n\n\n)
    print flush stop
   }
   {  %% eliminem la clau de pàgina
    pop
   }ifelse
  }
  {  %% eliminem dic i clau de pàgina
   pop pop
  }ifelse
 }forall
}if  %/08 ETIQUETA TEXT

%%% aqui s'ha desat correctament la ref ind de l'objecte Form
%% JectesX/5 get{== ==}forall(:-/)== quit
%%% aqui comprovem q a Utilitzats hi ha el Form correcte
%%% i a l'index 2 hi ha el nom de l'objecte del Form que ens permetria distingir-nos
%%% de l'idem del de la imatge
%% XRay /ObjectesX get /5 get/Utilitzats get{== ==}forall(:-v)== quit

%%% creem un nou dic on podem estar segurs q hi haura nomes els Form XObjects (farcellsGrafics)
%%% aixo ens servira, de moment, per filtrar incongruencies com les documentades a :-v
/farcellsGrafics 2 dict def
XRay begin
ObjectesX   %% /1 get {== ==}forall (:-11)== quit
{  %% forall per totes les pagines
 /Utilitzats get
 {  %% forall sobre tots els XObjects del diccionari de la pagina
  dup type /dicttype eq
  {  %% és una imatge inLine
   pop pop
  }
  {
   dup 0 get type /arraytype eq
   {
    farcellsGrafics 3 index known
    {
     farcellsGrafics 3 index get dup 4 -1 roll 4 -1 roll put
     1 index exch farcellsGrafics 3 1 roll put
    }
    {
     2 index farcellsGrafics  exch 2 dict dup 6 -1 roll 6 -1 roll put put
    }ifelse
   }
   {
    pop pop
   }ifelse
  }ifelse
 }forall
 pop  %% ens carreguem la clau del num de pagina
}forall
end
%%farcellsGrafics{{== ==}forall ==}forall (:-v)== quit
%% XRay /ObjectesX get {/Utilitzats get{== ==}forall ==}forall(:-v)== quit

JectesX length 0 eq
{  %#%26bis2% sortim si no hi ha XObjects ?
(%#%26bis2%)==
 %% EP! aquesta comprovacio la repetirem + endavant a %27bis3% doncs ...
 %% ... si no hi ha XObjects pero si que hi ha FormXObjects, el diccionari JectesX no estara pas buit!
 QueLiFemFer 7 eq  %:07 REINSEREIX IMATGES JPEG
 {
  ( <<< aquest PDF NO TE imatges per tractar ... PLEGUEM!)== stop  %%quit
 }  %/07 REINSEREIX IMATGES JPEG
 {
  null /JectesX exch def  %% desem un null en comptes del dic XObjects x NO fer les comprovacions de + endavant si cal
 }ifelse
}if

%% Quedelemi
%% XRay /ObjectesX get {/Utilitzats get {== ==}forall pop}forall
%%(QUEDELEMI) == quit

%#%27% filtrat d'arrays directes d'espai de color als XObjects
(%#%27%)==
%%% aqui es on comprovem si els XObjects normals duen una array directe d'espai de color
%%% doncs es la unica manera de que aquests espais de color puguin ser analitzats a temps a la seccio %30%
0 /iAdirecte exch def  %% numerador per les arrays de color directes
XRay /ObjectesX get
dup araPlana known  %% per que no hi ha totes les planes?
{
 araPlana get  %% pesquem el dic de la plana on som
 /Utilitzats get
 {  %% forall
  dup type /arraytype eq
  {
   0 get
   %%  (TamDaLa) pstack quit
   type /integertype eq  %% si el primer valor es un enter llavors segur q es una XObject d'imatge
   {
    dup /NomXobject exch def
    JectesX araPlana get exch get
    dup type /nametype eq
    {
     /aCercar exch def  %% nom amb la ref ind del dic Resources
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop  %% d'interrogacio dels dicts de COMdimoni
    }if
    dup /ColorSpace known  %% amb aquest dubte filtrem les imatges ploma (1 bit x pix)
    {
     /ColorSpace get dup type /arraytype eq
     {  %% si es una array directe l'emmagatzemem al dic Utilitzats d'EspaisDeColor d'XRay ...
      dup 0 get /DeviceN eq
      {  %% numerem l'array DeviceN directe
       /araRay exch def
       iAdirecte 6 string cvs dup length 13 add string dup dup
       0 (directDeviceN) putinterval 3 -1 roll 13 exch putinterval cvn
       %% deixem el nom numerat de directDeviceN a la pila i l'incrustem com a un nou espai de color a Utilitzats
       XRay /EspaisDeColor get /Utilitzats get exch dup /nomECad exch def
       <<
         /Tipus /directDeviceN /NomExtern araRay 1 get /FTipus null
         /Paleta << NomXobject /Imatge >>
         /TanX100 []
       >> put
       XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
       /Utilitzats get NomXobject get 2 nomECad put  %% incrustem el nom de l'espai de color directe a l'array de descripcio de l'XObject
      }
      {  %% hauria de ser una Separation ...
       %%pstack (S1) == quit
       /araRay exch def
       iAdirecte 6 string cvs dup length 16 add string dup dup
       0 (directSeparation) putinterval 3 -1 roll 16 exch putinterval cvn
       %% deixem el nom numerat de directSeparation a la pila i l'incrustem com a un nou espai de color a Utilitzats
       XRay /EspaisDeColor get /Utilitzats get exch dup /nomECad exch def
       <<
         /Tipus /directSeparation /NomExtern araRay 1 get /FTipus null
         /Paleta << NomXobject /Imatge >>
         /TanX100 []
       >> put
       XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
       /Utilitzats get NomXobject get 2 nomECad put  %% incrustem el nom de l'espai de color directe a l'array de descripcio de l'XObject
       %% donem d'alta la separacio ...
       XRay /Separacions get nomECad araRay 1 get put
      }ifelse
     }
     {  %% si no es una array directe voldra dir que es un espai de color indirecte (pengi o no de ColorSpace a Resources)
      %% o un literal d'espai de color ... i llavors si es valid l'haurem de desar a Paleta el parell corresponent NomXobject /Imatge
      %% es a ColorSpace de Resources ?
      /refIN exch def RSRCS araPlana get /ColorSpace known {/HiHaCS true def}{/HiHaCS false def}ifelse
      HiHaCS
      {
       /EsaCS false def  %% x defecte
       RSRCS araPlana get /ColorSpace get
       dup type /nametype eq
       {
        /aCercar exch def  %% nom amb la ref ind del dic Resources
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        } loop  %% d'interrogacio dels dicts de COMdimoni
       }if
       {  %% forall
        refIN eq {/EsaCS true def /CSnomIN exch def exit}{pop}ifelse
       }forall
      }
      {
       /EsaCS false def
      }ifelse
      EsaCS
      {  %% si es a ColorSpace de Resources ja tindra nom i haurem de comprovar si ja existeix a XRay /EspaisDeColor /Utilitzats? ...
       refIN /aCercar exch def  %% nom amb la ref ind del dic Resources
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
       %% atencio, doncs podria ser un espai de color directe dins una array!
       dup type /arraytype eq {dup length 1 eq {0 get}if}if  %% si es una array ens assegurem que nomes tingui 1 sol element (2 seria una Separacio!)
       dup /DeviceCMYK eq 1 index /DeviceGray eq 2 index /DeviceRGB eq or or
       {  %% tret que sigui un /DeviceCMYK, /DeviceGray o /DeviceRGB directes doncs llavors no fem res ¿? ...
        pop
       }
       {
        dup 0 get /DeviceN eq
        {
         /araRay exch def
         XRay /EspaisDeColor get /Desconeguts get dup CSnomIN known
         {  %% ... com que ja existeix o el regenerem com un dic o nomes afegim el parell NomXobject /Imatge a Paleta i ampliem l'array /TanX100 
          %%% QUE PASSA SI AQUEST ESPAI ES COMPARTIT AMB UN OBJECTE VECTORIAL ??
          CSnomIN get dup
          type /arraytype eq
          {  %% el regenerem com un dic doncs es un espai de color creat inicialment per operadors a Contents
           /TanX100 exch def  %%pstack (¿?) == quit
           XRay /EspaisDeColor get /Desconeguts get
           CSnomIN
           <<
             /Tipus /DeviceN /NomExtern araRay 1 get /FTipus null
             /Paleta << NomXobject /Imatge >>
             /TanX100 TanX100  %% l'array ja no es buida doncs l'espai ja no es exclusiu d'una imatge
           >> put
          }
          {  %% es un espai de color creat x un XObject
           dup
           /Paleta get NomXobject /Imatge put
           dup /TanX100 get
           dup length 1 add dup 1 sub /Dmes exch def
           array dup dup 4 -1 roll 0 exch putinterval Dmes
           %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
           %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
           araRay 1 get length /ComFaciFalta exch def
           NomXobject /LiTeRaLS exch def
           LiTeRaLS dup length 2 add dup /aDeS exch def string dup
           3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
           /iaRa exch def
           aDeS  %%4
           ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
           mul string /aDesiaRa exch def
           aDesiaRa /NullEncode filter
           ComFaciFalta {dup iaRa writestring} repeat
           closefile aDesiaRa put /TanX100 exch put  %% incrustem el nou array ampliat de TanX100 al dic de l'espai de color
          }ifelse
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Utilitzats get NomXobject get 2 CSnomIN put  %% incrustem el nom de l' espai de color a l'array de descripcio de l'XObject
         }
         {  %% ... si no el donarem dalta
          %%(????) ==
          CSnomIN
          <<
            /Tipus /DeviceN /NomExtern araRay 1 get /FTipus null
            /Paleta << NomXobject /Imatge >>
            /TanX100 []  %% cal que l'array sigui buida x ser detectat com a espai exclusiu d'una imatge
          >> put
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Utilitzats get NomXobject get 2 CSnomIN put  %% incrustem el nom de l'espai de color a l'array de descripcio de l'XObject
         }ifelse
        }
        {  %% hauria de ser una Separation ...
         /araRay exch def
         XRay /EspaisDeColor get /Desconeguts get dup CSnomIN known
         {  %% ... com que ja existeix o el regenerem com un dic o nomes afegim el parell NomXobject /Imatge a Paleta i ampliem l'array /TanX100 
          %%% QUE PASSA SI AQUEST ESPAI ES COMPARTIT AMB UN OBJECTE VECTORIAL ??
          CSnomIN get dup
          type /arraytype eq
          {  %% el regenerem com un dic doncs es un espai de color creat inicialment per operadors a Contents
           /TanX100 exch def  %%pstack (¿?) == quit
           XRay /EspaisDeColor get /Desconeguts get
           CSnomIN

           []  %% NO el donem d'alta com un dict si no com una array!
           %% ... doncs si no entra en conflicte amb (:-T)

%%           <<
%%             /Tipus /Separation /NomExtern araRay 1 get /FTipus null
%%             /Paleta << NomXobject /Imatge >>
%%             /TanX100 TanX100  % l'array ja no es buida doncs l'espai ja no es exclusiu d'una imatge
%%           >>

           put
           %% donem d'alta la separacio (si es que no ho esta?) ...
           %%XRay /Separacions get CSnomIN araRay 1 get put
          }
          {  %% es un espai de color creat x un XObject
           dup
           /Paleta get NomXobject /Imatge put
           dup /TanX100 get
           dup length 1 add dup 1 sub /Dmes exch def
           array dup dup 4 -1 roll 0 exch putinterval Dmes
           %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
           %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
           %%araRay 1 get length
           1 /ComFaciFalta exch def
           NomXobject /LiTeRaLS exch def
           LiTeRaLS dup length 2 add dup /aDeS exch def string dup
           3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
           /iaRa exch def
           aDeS  %%4
           ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
           mul string /aDesiaRa exch def
           aDesiaRa /NullEncode filter
           ComFaciFalta {dup iaRa writestring} repeat
           closefile aDesiaRa put /TanX100 exch put  %% incrustem el nou array ampliat de TanX100 al dic de l'espai de color
          }ifelse
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Utilitzats get NomXobject get 2 CSnomIN put  %% incrustem el nom de l'espai de color a l'array de descripcio de l'XObject
          %% donem d'alta la separacio (si es que no ho esta?) ...
          %%XRay /Separacions get CSnomIN araRay 1 get put
         }
         {  %% ... si no el donarem dalta
          CSnomIN

          []  %% NO el donem d'alta com un dict si no com una array!
          %% ... doncs si no entra en conflicte amb (:-T)

%%          <<
%%            /Tipus /Separation /NomExtern araRay 1 get /FTipus null
%%            /Paleta << NomXobject /Imatge >>
%%            /TanX100 []  % cal que l'array sigui buida x ser detectat com a espai exclusiu d'una imatge
%%          >>

          put
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Utilitzats get NomXobject get 2 CSnomIN put  %% incrustem el nom de l'espai de color a l'array de descripcio de l'XObject
          %% donem d'alta la separacio ...
          XRay /Separacions get CSnomIN araRay 1 get put
         }ifelse
        }ifelse
       }ifelse
      }
      {  %% si NO es a ColorSpace de Resources i es DeviceN o Separation l'haurem de numerar sota /directDeviceN# o /directSeparation# i donar d'alta a XRay /EspaisDeColor /Utilitzats ...
       %% si es un Device ara de moment no fem res ...
       refIN dup /DeviceCMYK eq 1 index /DeviceGray eq 2 index /DeviceRGB eq or or
       {  %% tret que sigui un /DeviceCMYK, /DeviceGray o /DeviceRGB directes doncs llavors no fem res ¿? ...
        pop
       }
       {
        /aCercar exch def  %% nom amb la ref ind del dic Resources
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        } loop  %% d'interrogacio dels dicts de COMdimoni
        dup type /arraytype eq  %% descartem que no sigui un nom d'un /DeviceCMYK directe
        {  %% sempre que sigui un array de color, doncs si no no fem res
         dup 0 get /DeviceN eq
         {  %% numerem l'array DeviceN directe     
          /araRay exch def
          iAdirecte 6 string cvs dup length 13 add string dup dup
          0 (directDeviceN) putinterval 3 -1 roll 13 exch putinterval cvn
          %% deixem el nom numerat de directDeviceN a la pila i l'incrustem com a un nou espai de color a Utilitzats
          XRay /EspaisDeColor get /Utilitzats get exch dup /nomECad exch def
          <<
            /Tipus /directDeviceN /NomExtern araRay 1 get /FTipus null
            /Paleta << NomXobject /Imatge >>
            /TanX100 []
          >> put
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Utilitzats get NomXobject get 2 nomECad put  %% incrustem el nom de l'espai de color directe a l'array de descripcio de l'XObject
         }
         {  %% hauria de ser una Separation ...
          %%pstack (S3) == quit
          /araRay exch def
          iAdirecte 6 string cvs dup length 16 add string dup dup
          0 (directSeparation) putinterval 3 -1 roll 16 exch putinterval cvn
          %% deixem el nom numerat de directSeparation a la pila i l'incrustem com a un nou espai de color a Utilitzats
          XRay /EspaisDeColor get /Utilitzats get exch dup /nomECad exch def
          <<
            /Tipus /directSeparation /NomExtern araRay 1 get /FTipus null
            /Paleta << NomXobject /Imatge >>
            /TanX100 []
          >> put
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Utilitzats get NomXobject get 2 nomECad put  %% incrustem el nom de l'espai de color directe a l'array de descripcio de l'XObject
          %% donem d'alta la separacio ...
          XRay /Separacions get nomECad araRay 1 get put
         }ifelse
        }
        {  %% si no es una array de color no fem res ...
         pop
        } ifelse
       } ifelse  %%  es un /DeviceCMYK directe ?
      } ifelse
      %%pstack (*!*) == quit
     }ifelse
    }
    {
     %% solucio provisional per les imatges ploma
     pop  %% ens carreguem el dic de la imatge
     aCercar /NomXobject exch def  %% desem el nom intern de la imatge
     XRay /EspaisDeColor get /Utilitzats get
     %% tots els elements definits sota l'espai DeviceGray passaran a formar part de la tinta /Black
     dup /DeviceGray known
     {
      /DeviceGray get /Paleta get NomXobject /Imatge put
     }
     {  %% si no hi es el creem de nou
      /DeviceGray
      <<
        /Tipus /PureCMYK /NomExtern /Black /FTipus null
        /Paleta << NomXobject /Imatge >>
        /TanX100 []
      >> put
     }ifelse
    }ifelse  %% te o no te /ColorSpace
   }
   {  %% com q el primer valor de l'array no es un enter (es una altra array) llavors es tracta d'un Form XObject q no hem de tractar aqui l'espai de color
    pop
   }ifelse
  }
  {pop pop}ifelse
  iAdirecte 1 add /iAdirecte exch def  %% numerador per les arrays de color directes
 } forall  %% x tots els XObject capturats per Do
}
{
 pop
}ifelse  %% si existeix la plana
%%% fi de filtrat d'arrays directes d'espai de color a XObjects

%#%27bis% Exploració dels Form XObject donats d'alta
(%#%27bis%)==
%%% CAL FER ... ATENCIO: L'EXPLORACIO DELS FORMS S'HA DE REVISAR DES QUE HEM REDEFINIT Do PEL COMPORTAMENT MULTIPAGINA
%%3 · veure com gestionem el 2n repicat de Contents x la separacio 46/52
%% tal com podem veure a 18_UK17_1form_pla.pdf, necessitem afegir els Resources particulars (si en duu) al magatzem general de resources
%% (per tan no sembla greu que no en dugui!), podriem fer servir l'array totalRSRCS q despres ja ampliem tambe amb els Resources particulars dels Patterns
%% pero cladra estar alerta doncs si el Form duu XObjects particulars CALDRA TENIRLOS CONTROLATS! ... i executar l'stream del form per reinterpretar les dades
/HiHaXObjects false def  %% gatell per saber-ho (sobretot per les opcions 7 i 10)
/HiHaForms false def  %% gatell x saber-ho
/FormsQhiHa [] def  %% array on desarem els noms dels Forms q hi ha
/totalRSRCS [] def  %% aqui desarem tots els Resources del document (generals+privats)
/FormsiColorSpaces 2 dict def  %% aqui hi desarem els continguts dels dic /ColorSpace dels Resources de cada Form x tal de poder atorgar + endavant els valors de Tinta a la separacio corresponent
/FormsiXObjects 2 dict def  %% aqui desarem els parells nom del Form (clau) i un paquet (valor) amb els noms dels XObjects que contingui
/totalNomXO [] def  %% array on desarem els noms dels XObject (imatges) utilitzats al Form
/Forms1cop 1 dict def  %% diccionari que farem servir a l'opcio 10 on desarem els noms dels forms on ja hem processat el seu stream (per evitar treball en va i ioerrors)
/FormsRecursius [] def  %% array dels dics directes dels Forms que contenen Forms x reinterpretar-los a part
XRay /ObjectesX get

%{  % stopped

{  %% forall per totes les planes
 exch /araPlana exch def
 /Utilitzats get
 dup length dict copy  %% en fem una copia blindada doncs ens cal fer el forall sense possibles ampliacions posteriors
 {  %% forall on esbrinem si hi ha Forms ...
  %% x no cal tractar el mateix form +d'1 cop!
  Forms1cop 2 index known  %% ja l'hem tractat aquest Form ?
  {  %% si, i no cal q ho tornem a fer
   pop pop
  }
  {  %% no l'hem  tractat encara!
   Forms1cop 2 index null put
   %% primer descartem les inLine images (duran un dic com a valor)
   dup type /dicttype eq
   {  %% es una inLine
    pop pop
   }
   {  %% pot ser un FormXObject o un simple XObject ...
    dup 0 get type /arraytype eq
    {
     %%% aqui es on posem un loop x poder tractar els Forms recursius i anar cap endins fins la darrera nina russa
     %%(HHVcap)pstack quit  % a la pila hi ha el nom del Form i el seu array
     /NOninesRusses true def  %% gatell x saber si hi ha FormXObjects recursius true=NO false=SI
     {  %% loop x detectar FormsXObjects recursius
      /HiHaForms true def
      %% aqui explorem l'array
      %%1% · recollim els Resources de cada Form x posar-los a l'array totalRSRCS
      dup 1 get null ne
      {  %% if de mentre en dugui ...
       dup 1 get dup type /nametype eq
       {
        /aCercar exch def  %% nom amb la ref ind del dic Resources
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        } loop  %% d'interrogacio dels dicts de COMdimoni
       }if    
       %% duu /ColorSpace?
       dup /ColorSpace known
       {  %% si hi ha ColorSpace desem el seu dic com a valor del nom del Form
        dup /ColorSpace get dup type /nametype eq
        {
         /aCercar exch def  %% nom amb la ref ind del dic Resources
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def                                                                  
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
        }if
        dup length dict copy  %% en fem una clon desvinculat doncs si arrivem a modificar-lo ens podria afegir espais de color originalment no definits a ColorSpace (p.e. /NoName9)
        FormsiColorSpaces exch 4 index exch
        put  %% desem el parell nom del Form / dic del ColorSpace
       }
       {  %% si no hi ha ColorSpace desem un dic buit com a valor del nom del Form
        FormsiColorSpaces 3 index << >> put
       }ifelse
       %% analitzem si hi ha XObjects a Resources del Form
       dup /XObject known
       {
        dup /XObject get dup type /nametype eq
        {
         /aCercar exch def  %% nom amb la ref ind del dic Resources
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
        }if
        %%dup /JectesX exch def  % hem desactivat aquest desat preventiu doncs trinxava literalment el diccionari de les imatges p.e. a 18_SW22.PDF i 18_UK13.PDF
        JectesX
        null ne
        {  %% tret q no sigui un null !
         dup {JectesX araPlana get 3 1 roll put}forall  %% el q cal fer es nomes acualitzar el contigut del dic JectesX
        }if
        {  %% forall on explorem tot el dic de l'XObject (q esbrinarem de quina mena es) per classificar-lo a XRay els XObjects en Utilitzats, NoUtilitzats, Desconeguts i Errades
         /JECTEx exch def
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Desconeguts get exch
         JECTEx dup type /nametype eq
         {
          /aCercar exch def  %% nom amb la ref ind del dic Resources
          /iDimoni 0 def
          {  %% loop d'interrogacio dels dicts de COMdimoni
           currentdict iDimoni 4 string cvs cvn get
           %% el diccionari de l'objecte
           dup aCercar known {aCercar get exit}{pop}ifelse
           iDimoni 1 add /iDimoni exch def
           iDimoni MaxDimoni eq {exit} if
          } loop  %% d'interrogacio dels dicts de COMdimoni
         }if
         %% comprovem que sigui Subtype Image
         dup /Subtype get /Image eq
         {  %% desem en un array de 3 posicions els pixels x,y i l'espai de color
          /NOninesRusses true def  %% gatell q indica q NO tenim un form recursiu
          /3ai 3 array def dup /Width get 3ai exch 0 exch put dup /Height get 3ai exch 1 exch put
          dup /ColorSpace known
          {
           /ColorSpace get
           %%dup type /arraytype eq
           %%{  % x detectar les arrays de color directes
           %%}if
           3ai exch 2 exch put
          }
          {  %% si no hi ha espai de color posem el literal d'espai de color deconegut a l'array 3ai com a %26%
           pop 3ai 2 /Unknow_ColorSpace put
          }ifelse
          %% ... i despres el donem d'alta a Utilitzats amb l'array de dades arreplegades i el donem de baixa a Desconeguts
          dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Utilitzats get exch 3ai put
          dup /aVeure exch def
          totalNomXO  %% desem el nom de l'XObject en aquest array 
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
          /totalNomXO exch def  %% redesem el paquet ampliat dels XObject d'imatge usats al Form
          undef  %% el donem de baixa a Desconeguts
userdict /HiHaXObjects true put  %% encenem el gatell q els detecta (ara x 7 i x 10!)
         }
         {  %% pot ser un Form XObject o un PostScript XObject ... 
          %% Forms recursius, en nines russes, sense fi, son perfectament viables
          %% i fins hi tot poden fer sevir noms identics per a recursos diferents (vegeu fa1vectorial1textDins1FormXObject_recursiuD2NivellsDnoMidem.pdf)
          dup /Subtype get /Form eq
          {  %% es un Form XObject recursiu!
(1 FORM dins un ALTRE!!!)==
           %% capturem dins una array els dics directes dels Forms que son continguts x altres Forms x reinterpretar-los a part
           dup FormsRecursius length dup /Vaaqui exch def 1 add array dup 0 FormsRecursius putinterval
           /FormsRecursius exch def FormsRecursius Vaaqui 3 -1 roll put  %% desem als nous FormsRecursius el dic del Form que es contingut x un Form
           %% desem una copia del dic Resources a totalRSRCS per assegurar-nos que inclourem Properties a %53bis%
           dup /Resources get dup type /nametype eq
           {
            /laBranca exch def
            %% pesquem la branca ...
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup laBranca known {laBranca get exit}{pop}ifelse 
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            } loop  %% d'interrogacio dels dicts de COMdimoni
           }if
           totalRSRCS length dup /Vaaqui exch def 1 add array dup 0 totalRSRCS putinterval /totalRSRCS exch def
           totalRSRCS Vaaqui 3 -1 roll put  %% desem a totalRSRCS el dic Resources del Form

           %% descartem que no sigui ni un 'Reference XObject' ni un OPI XObject que voldria dir que es vincula externament a d'altres continguts
           dup /Ref known
           {  %% Reference XObject
%%EP cal afinar aquest detectorID pels PDF amb Reference XObjects, doncs és via ID que s'identifiquen els Proxy
            pop dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
            /Errades get exch ( Reference XObject Form Not Supported) put undef
            /NOninesRusses true def  %% gatell q indica q NO tenim un form recursiu q ens interessi
           }
           {
            dup /OPI known
            {  %% OPI XObject
             pop dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
             /Errades get exch ( OPI XObject Form Not Supported) put undef
             /NOninesRusses true def  %% gatell q indica q NO tenim un form recursiu q ens interessi
            }
            {  %% es un FormXObject normal ...
             /NOninesRusses false def  %% gatell q indica q TENIM un form recursiu
             /3ai 3 array def dup  %% dupliquem el diccionari del FormXObject recursiu
             %% atencio! ara posarem al primer lloc d'3ai l'array del BoundingBox del Form
             /BBox get 3ai exch 0 exch put dup
             %% atencio! ara posarem al segon lloc d'3ai l'objecte (array o literal) dels recursos associats
             /Resources known  %% no es 100% obligatori
             {
              dup /Resources get 3ai exch 1 exch put
             }if  %% si no te Resources creiem q no passa res
             %% el tercer lloc d'3ai li posem el dic sencer o la seva ref ind del Form
             pop
             3ai 2 JECTEx put
             %% aqui desem el nom/array del FormXObject recursiu per posar-lo a la pila a la nova volta del loop
             dup 3ai 2 array astore /ninaFXO exch def %%(HoHaveuVist?)pstack quit
             %% ... i despres el donem d'alta a Utilitzats amb l'array de dades arreplegades i el donem de baixa a Desconeguts
             dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
             /Utilitzats get
             %% aqui es on filtrarem la possibilitat que el nom sigui repetit x canviar-li a un d'unic
             dup 2 index known
             {  %% pero com q segur apuntara a objectes diferents ...
              exch
              %% ... llavors afegirem al nom del form el del literal de l'objecte form per fer-ne un nom unic
              128 string cvs dup length 16 add string dup 0 JECTEx 16 string cvs putinterval
              dup 16 4 -1 roll putinterval 3ai put undef
             }
             {
              exch 3ai put undef
             }ifelse
            }ifelse
           }ifelse
          }
          {  %% haura de ser un PS XObject i llavors el passarem a Errades + el donem de baixa a Desconeguts
           /NOninesRusses true def  %% gatell q indica q NO tenim un form recursiu
           pop dup XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
           /Errades get exch ( PostScript XObject Type Not Supported) put undef
          }ifelse
         } ifelse            
        }forall  %% forall on explorem tot el dic de l'XObject (q esbrinarem de quina mena es)
       }
       {
        /NOninesRusses true def  %% gatell q indica q ja NO tenim un form recursiu
        null /JectesX exch def  %% desem un null en comptes del dic XObjects x NO fer les comprovacions de + endavant si cal
       }ifelse

       %% fiquem aVeure (els Resources del Form) dins totalRSRCS ampliant cada vegada aquest array
       /aVeure exch def
       totalRSRCS
       dup length 1 add dup 1 sub /Dmes exch def
       array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
       /totalRSRCS exch def  %% redesem el paquet ampliat dels Resources particulars dels Form
      }
      {  %% si no te Resources tampoc tindra cap ColorSpace relacionat en aquest punt
       FormsiColorSpaces 1 index << >> put  %% ... desem un dic buit com a valor del nom del Form
       /NOninesRusses true def  %% tornem el gatell al valor inicial de q NO tenim un form recursiu
      }ifelse
      %%2% · repiquem l'stream dels Contents de cada Form per primer cop (semblant a %23)
      dup 2 get dup type /nametype eq
      {
       /laBranca exch def
       %% pesquem la branca ...
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup laBranca known {laBranca get exit}{pop}ifelse 
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
      }if
      NOninesRusses not
      {  %% sempre que sigui recursiu ...
       %% capturem dins una array els dics directes dels Forms que contenen Forms x reinterpretar-los a part
       dup FormsRecursius length dup /Vaaqui exch def 1 add array dup 0 FormsRecursius putinterval /FormsRecursius exch def
       FormsRecursius Vaaqui 3 -1 roll put  %% desem als nous FormsRecursius el dic del Form que conte Forms
      }if

      dup /dicX10 exch def  %% el necessitem x l'opcio 10 de verificacio de PDF
      dup /Filter known
      {  %% fitxer stream amb algun tipus de filtre
       dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
       dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
       dup /DecodeParms known exch /DP known 2 copy or
       {
        {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
        {
         [ exch [ exch filtresstream ] ] /filtresstream exch def
        }
        {  %% es una array
         %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
         dup length filtresstream length ne
         {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
          (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
         }if
         /iDPF 0 def
         [ exch
          {  %% forall
           dup null eq
           {
            pop [filtresstream iDPF get]
            iDPF 1 add/iDPF exch def
           }
           {
            [exch filtresstream iDPF get]
            iDPF 1 add/iDPF exch def
           }ifelse
          }forall
         ]
         /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
        }ifelse
       }
       {
        pop pop  %% ens carreguem els logics
        pop  %% ens carreguem el dic
        %% avaluem filtresstream per redefinir-lo com cal per /filtRa
        filtresstream type /arraytype eq
        {
         [filtresstream] /filtresstream exch def
        }
        {
         [[filtresstream]] /filtresstream exch def
        }ifelse
       }ifelse
       dadesstream
       %% comprovem si l'stream es un path dins una array o una string de dades directe
       type /arraytype eq
       {
        dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
       }
       {  %% convertim a fitxer de la cadena sense decodificar
        dadesstream 0 () /SubFileDecode filter
       } ifelse
       filtresstream
(F4) ==
       filtRa  %% decodifiquem el fitxer stream
       %% preparem el fitxer de lectura que a l'estar filtrat el repiquem al disc
       repiCa (w) file /REPIcA exch def
       {  %% loop
        dup
        65535 string readstring
        {REPIcA exch writestring}  %% estrategia per no acabar mai amb un ET
        {REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit}ifelse
       }loop
       repiCa dup
       status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
       (r) file /aLLeGiR exch def
      }
      {  %% fitxer stream sense filtres
       /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
       dadesstream  %% tibem el fitxer stream sense decodificar
       %% comprovem si l'stream es un path dins una array o una string de dades directe
       type /arraytype eq
       {
        dadesstream 0 get
        dup
        status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
        (r) file /aLLeGiR exch def
       }
       {  %% convertim a fitxer de la cadena sense decodificar
        dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
        0 () /SubFileDecode filter /aLLeGiR exch def
       } ifelse
      }ifelse
      %% repicat idem en ascii de l'stream de Contents particular del Form
      null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream de Patterns&Shadings
      %% redefinim el fitxer on reescriurem l'stream de Contents del Form x 1er cop
      l'objectenet5 (w) file  %%  repicats a traves de les redefinicions d'OpContents_QueLiFemFer1
      /sEdAs exch def
      %% ventilem de la pila l'array del Form i el seu nom
      /araXForm exch def  %% desem l'array
      /araNomXForm exch def  %% desem el nom del Form XObject
      %% hem afegit a les redefinicions de k/K i cs/CS (doncs llavors ja condicionen l'us de sc/SC) (nomes primera execucio) que apunten a CMYK
      %% la inclusio al Form q toca (araNomXForm) al dic FormsiColorSpaces el tractament del CMYK que ens estavem deixant
      BeSSo
      %% bufem els fitxers
      aLLeGiR dup flushfile closefile
      sEdAs dup flushfile closefile
      %% desem en una array els noms de les Forms que hi ha
      FormsQhiHa
      dup length 1 add dup 1 sub /Dmes exch def
      array dup dup 4 -1 roll 0 exch putinterval Dmes araNomXForm put
      /FormsQhiHa exch def  %% redesem el paquet ampliat dels noms de les Forms existents
      (\n ... Form XObject ... ) print flush araNomXForm 128 string cvs print flush (\n) print flush
      %% desem el nom del Form amb el seu array de noms d'XObject usats
      FormsiXObjects araNomXForm totalNomXO dup length array copy put
      /totalNomXO [] def  %% redefinim l'array on desarem els noms dels XObject (imatges) utilitzats al Form
      QueLiFemFer 10 eq  %:10 PREFLIGHT AMB CAPES
      QueLiFemFer 13 eq  %:13 eliminem continguts de pàgina
      QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
      or or
      {
       %#%27bis2% reescriurem o redefinirem l'stream del FormXObject reinterpretat, a string o a fitxer, amb les llesques (Layers) posades
(%#%27bis2%)==
       dicX10 dup /Filter undef  %% treiem a sac aquesta possible entrada doncs l'stream ara sera pla
       dup /XIU get dup type /stringtype eq
       {  %% es una cadena
        pop
        l'objectenet5
        (r) file dup 65535 string readstring
        pop
        exch dup flushfile closefile  %% tanquem el fitxer de lectura!
        /XIU exch put
       }
       {  %% es un fitxer a disc
        0 get (w) file /trAsllAt exch def  %% pesquem el path on reescriure l'stream del form
        pop  %% ens carreguem el dic
        l'objectenet5 (r) file  %% llegim l'stream repicat
        {  %% loop
         dup 65535 string readstring
         {
          trAsllAt exch writestring
         }
         {
          trAsllAt exch writestring
          closefile exit
         } ifelse
        } loop
        trAsllAt closefile
       }ifelse
      }if  %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
           %/13 eliminem continguts de pàgina
           %/10 PREFLIGHT AMB CAPES
      NOninesRusses
      {  %% si no hi ha recursius o s'han acabat
       exit
      }
      {
       ninaFXO aload pop  %% desempaquetem el nom i l'array del Form x la nova volta de loop
       /NOninesRusses true def
      }ifelse
     } loop  %% loop x detectar FormsXObjects recursius
%%(sortim del loop!)==
    }
    {  %% es un XObject d'imatge
     /HiHaXObjects true def  %% encenem el gatell q els detecta (ara x 7 i x 10!)
     pop pop
    }ifelse
   }ifelse
  }ifelse %% x no cal tractar el mateix Form +d'1 cop!
%%( ... forall dels FORMS) ==
 }forall  %% x tots els Forms esbrinats
%%( ... forall de les PLANES) ==
} forall  %% x totes les planes

%% aqui ja podem detectar la inconruencia que hi ha un imatge XObject dins un Form que es diu igual
%% FormsiXObjects {== ==}forall (:-v)pstack quit
%% ara a Utilitzats ja hi ha com a valor l'array de la imatge XObject
%% i a Desconeguts hi ha un null com a valor
%% XRay /ObjectesX get /5 get/Utilitzats get{== ==}forall(:-v)== quit

%}stopped{(:-///)pstack quit}if

HiHaForms
{  %% si n'hi ha en clonarem els dics
 /clONformsX << >> def  %% on clonarem el diccionari

%% cal saber en quin moment a ObjectesX Utilitzats de la pag5 hi ha hagut el Form desat
%% (doncs en aquest punt hi ha quedat desada la imatge)
%% nhess-9-1599-2009.pdf hi ha dos Im4 corresponents a un Form i a un XObject, on curiosament el
%% Form anomenat Im4 te com a recurs l'XObject tambe anomenat Im4
 FormsQhiHa

 {  %% forall

%%% pedaç per controlar el cas :-v
%%  XRay /ObjectesX get %araPlana get  % pesquem el dic de la plana on som
farcellsGrafics
  {  %% forall x totes les planes
   exch pop  %% esborrem el literal de la plana
%%% pedaç x controlar el cas :-v
%%   /Utilitzats get
   dup 2 index known  %% existeix el form en aquesta plana?
   {  %% si
    exch get
    2 get dup type /nametype eq
    {
     dup  %% sempre q el Form sigui un objecte indirecte desarem al dic clONformsX la ref ind com a clau (en comptes del nom intern del Form)
     /laBranca exch def
     %% pesquem la branca ...
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup laBranca known {laBranca get exit}{pop}ifelse 
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }if
    dup length dict copy  %% clonem el dic del Form x no tenir problemes amb el repicat dels streams    
    clONformsX 3 1 roll put  %% desem l'original
    exit  %% i sortim del forall de planes
   }
   {
    pop  %% ens carreguem el dic d'utilitzats
   }ifelse
  }forall  %% x totes les planes
 }forall  %% per tot l'array dels forms que hi ha
}
{
 BaBeL 46 get print flush
}ifelse

%% comprovarem que cada Form donat d'alta a FormsiXObjects estigui a ObjectesX Utilitzats
%% x donar de baixa els noms dels XObject de l'array a ObjectesX Desconeguts
%% i activar-los per a la separacio de Tintes
FormsiXObjects
{  %% forall
 exch XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
 /Utilitzats get exch known
 {  %% donem de baixa tots els noms d'XObject d'imatge usats al dic Desconeguts
  {XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
  /Desconeguts get exch undef}forall
 }
 {
  pop
 }ifelse
}forall

%% FormsiXObjects {== ==}forall
%% NO hauriem d'incrustar a Utilitzats d'XObject les dades provinents dels Recursos del Form!
%% si no que hauria de ser el repicat de contents el que poses les XObject que s'utilitzen x plana
%%	XRay /ObjectesX get
%%	/1 get /Utilitzats get {== ==}forall
%% XRay /PeDeEfa get /imatgesXordre get
%%{== ==}forall
%% FormsQhiHa == (HoHaveuVist?)== quit

HiHaXObjects not
{
 QueLiFemFer 7 eq  %:07 REINSEREIX IMATGES JPEG
 {
  %#%27bis3% aquí és on comprovem l'absència definitiva d'imatges XObject
  (%#%27bis3%)==
  ( <<< aquest PDF NO TE imatges per tractar ... PLEGUEM!)== stop  %%quit
 }if  %/07 REINSEREIX IMATGES JPEG
}if

/elsAltresShadings 2 dict def  %% aqui hi desarem els Shadings definits a %S1# i %S2#
/totalST2 [] def  %% aqui desarem els dics directes dels Shadings Type 2 cara a modificar-los de forma permanent abans de separar les tintes

%#%28% Exploració dels Patterns i els Shadings del document
(%#%28%)==
/psRSRCSrai [] def  %% array on desarem les ref ind de tots els Resources particulars dels Patterns&Shadings

%%% ep! aixo no deu paginar ara com deu mana x fer l'analisi
RSRCS araPlana get  %% copia del dic Resources general

%% Quedelemi
%%{== ==}forall (&&&&&&)== quit

%% el fiquem dins totalRSRCS ampliant cada vegada aquest array
/aVeure exch def
totalRSRCS  %% he d'ampliar aquesta exploracio no nomes als recursos generals si no tambe a la resta de resursos que puguin provenir dels Form XObject
dup length 1 add dup 1 sub /Dmes exch def
array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
/totalRSRCS exch def  %% redesem el paquet ampliat

/HiHaPa false def  %% gatell x saber si hi ha dic Pattern o no
/totalRSRCS_logic [] def  %% definim buit un paquet on desarem els true/false q indiquin si el dic duu l'entrada q cerquem
/i_totalRSRCS 0 def  %% index x explorar tots els recursos

totalRSRCS  %% aqui hi ha tan els recursos generals com els dels Form Xobjects (si n'hi ha)
{  %% forall
 dup /Pattern known  %% al dic Resources hi ha aquesta entrada?
 {
  /Pattern get length 0 eq  %% filtrem els dics buits
  {
   false /aVeure exch def
   totalRSRCS_logic
   dup length 1 add dup 1 sub /Dmes exch def
   array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
   /totalRSRCS_logic exch def  %% redesem el paquet ampliat
  }
  {
   true /aVeure exch def
   totalRSRCS_logic
   dup length 1 add dup 1 sub /Dmes exch def
   array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
   /totalRSRCS_logic exch def  %% redesem el paquet ampliat
   /HiHaPa true def
  }ifelse
 }
 {
  pop
  false /aVeure exch def
  totalRSRCS_logic
  dup length 1 add dup 1 sub /Dmes exch def
  array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
  /totalRSRCS_logic exch def  %% redesem el paquet ampliat
 }ifelse
}forall

totalRSRCS_logic
{  %% forall x tots els recursos
 {  %% if de si hi ha Pattern a Resources ?
  totalRSRCS i_totalRSRCS get
  /RSRCSara exch def  %% diccionari actual del recurs q explorem
  RSRCSara /Pattern get dup type /nametype eq
  {
   /aCercar exch def  %% nom amb la ref ind del dic Resources
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup aCercar known {aCercar get exit}{pop}ifelse
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
  }if
  dup dup length dict copy  %% amb profilaxi!
  /JectesPS exch def  %% desem el dic dels Pattern x us + endavant si cal
  {  %% forall on explorem tot el dic per classificar a XRay els Patterns en Utilitzats, NoUtilitzats, Desconeguts i Errades
   /JECTEps exch def XRay /Patterns&Shadings get
   /Desconeguts get exch 2 copy known
   {  %% si hi es, primer busquem el dic del Pattern x desar-ne les dades q ens interessen a l'XRay
    2 copy get /3paq exch def  %% desem l'array existent creat a scn/SCN
    JECTEps dup type /nametype eq
    {
     /aCercar exch def  %% nom amb la ref ind del dic Resources
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }if
    %% mirem quina mena de Pattern es
    dup /PatternType get  %% no sabem encara ben be quines i com desarem les dades
    1 eq
    {  %% es un Tiling Pattern
     %% a la posicio 2 de l'array 3paq hi ha el nom de l'espai de color del Pattern xutat x scn/SCN
     3paq dup 0 1 put  %% a la posicio 0 posem 1 x indicar que es tracta d'un Tiling Pattern
     exch dup /PaintType get exch
     /Resources get  %% aqui la ref ind dels Resources del Pattern
     %% mirem si un valor (aVeure) existeix dins una array (psRSRCSrai) i si no hi es, li fiquem
     /aVeure exch def
     /jaHIes false def
     psRSRCSrai {aVeure eq {/jaHIes true def exit} if}forall
     jaHIes not
     {
      psRSRCSrai
      dup length 1 add dup 1 sub /Dmes exch def
      array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
      /psRSRCSrai exch def  %% redesem el paquet ampliat dels Resources particulars dels Pattern
     } if
     1 exch put  %% ... i a la posicio 1 hi posem el PaintType
     2 copy undef  %% donem de baixa a Desconeguts ...
     XRay /Patterns&Shadings get /Utilitzats get exch
     3paq dup length array copy put  %% ... i d'alta a Utilitzats 
     pop
    }
    {  %% es un Shading Pattern que penja d'una referencia del dic Pattern a Resources
     /Shading get
     dup type /nametype eq
     {
      /aCercar exch def  %% nom amb la ref ind del dic Resources
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
     } if
     dup /aVeure exch def
     totalST2
     dup length 1 add dup 1 sub /Dmes exch def
     array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
     /totalST2 exch def  %% redesem el paquet ampliat dels Shading Type 2
     /elSha exch def  %% desem el dic on es defineix el Shading
     %% mirem quina mena de Shading es
     elSha /ShadingType get dup /eST exch def  %% desem el ShadingType
     dup  %% aqui nomes deixem passar els /ShadingType 2 i 3 ...
     2 eq 1 index 3 eq or
     {
      pop  %% ara ens carreguem el ShadingType
      3paq dup 0 2 put  %% a la posicio 0 posem 2 x indicar que es tracta d'un Shading Pattern
      1 eST put  %% ... i a la posicio 1 hi posem el ShadingType
      %% a la posicio 2 de l'array 3paq hi va el nom Extern de l'espai de color del Shading
      elSha /ColorSpace get  %% al dic Shading n'xtraiem l'espai de color underlying
      %% que haurem de donar d'alta a EspaisDeColor Utilitzats
      dup type /nametype eq
      {
       dup length 16 eq
       {
        dup 16 string cvs 10 get 95 eq{true}{false}ifelse
       }
       {
        false
       }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
       {  %% primer descartem que no sigui una ref ind
        /aCercar exch def
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        } loop  %% d'interrogacio dels dicts de COMdimoni
       } if
       dup type /arraytype eq
       {  %%  o una array INdirecte de color (/DeviceN o /Separation)
        aCercar /refIN exch def  %% desem la ref ind de l'espai de color
        %% com que es valid incrustem el nom extern de l'espai de color a la posicio 2 de l'array 3paq
        3paq exch 1 get  %% anem a pescar el nom extern a l'array de color
        2 exch put
        %% ... i despres el donem d'alta a Utilitzats amb l'array 3paq de descripcio com a valor
        XRay /Patterns&Shadings get /Utilitzats get 1 index 3paq dup length array copy put
        %%dup == (ARA5) ==
        dup /PnomIntern exch def undef  %% i el donem de baixa a Desconeguts desant abans el nom intern del Pattern
        %% analitzem la /Function x deduir-ne els valors de color x l'entrada Paleta i TanX100 del dic de l'espai de color
        elSha /Function get dup type /nametype eq
        {  %% primer descartem que no sigui una ref ind
         /aCercar exch def
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
        } if
        /FunctionType get
        [
         {  %% 0 NO implementada encara
          XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
          XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
          %%(Shading FunctionType 0) ==
         }
         {  %% 1 inexistents
          XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
          XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
          %%(Shading FunctionType 1) ==
         }
         {  %% 2
          %%(Shading FunctionType 2) ==
         }
         {  %% 3
          %%(Shading FunctionType 3) ==
         }
         {  %% 4 NO implementada encara
          XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
          XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
          %%(Shading FunctionType 4) ==
         }
        ]
        exch get cvx exec
        %% mirarem si existeix a ColorSpace de Resources
        RSRCSara /ColorSpace known {/HiHaCS true def}{/HiHaCS false def}ifelse
        HiHaCS
        {
         RSRCSara /ColorSpace get
         {  %% forall
          refIN eq
          {
           /EsaCS true def /CSnomIN exch def exit
          }
          {
           pop /EsaCS false def
          }ifelse
         }forall
        }
        {
         /EsaCS false def
        }ifelse
        EsaCS
        {  %% si es a ColorSpace de Resources ja tindra nom i haurem de comprovar si ja existeix a XRay /EspaisDeColor /Utilitzats? ...
         refIN /aCercar exch def  %% nom amb la ref ind del dic Resources
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
         dup 0 get /DeviceN eq
         {  %% es un DeviceN
          dup length 5 eq
          {  %% comprovem si no fos del nou tipus de DeviceN ...
           XRay /EspaisDeColor get /Errades get aCercar ( DeviceN Color Space with NChannel Not Supported) put
          } if
          /araRay exch def
          XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
          {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
           CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
           /Paleta get PnomIntern known not
           {  %% del Shading/Pattern n'esbrinem el nombre de components
            %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
            %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
            dicEC /NomExtern get dup type /arraytype eq
            {length}{pop 1}ifelse /ComFaciFalta exch def
            PnomIntern /LiTeRaLS exch def
            LiTeRaLS dup length 2 add dup /aDeS exch def string dup
            3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
            /iaRa exch def
            aDeS
            ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
            mul string /aDesiaRa exch def
            aDesiaRa /NullEncode filter
            ComFaciFalta {dup iaRa writestring} repeat
            closefile 
            dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
            dup length 1 add dup 1 sub /Dmes exch def
            array dup dup
            4 -1 roll 0 exch putinterval Dmes aDesiaRa put
            /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
            %% i ara afegim a Paleta el nou Shading/Pattern
            dicEC /Paleta get PnomIntern /Shading put
           }if  %% si PnomIntern ja es desat no fem res
           %%mug@
           %%(\n\n---1959 9.a\n\n) print flush %stop
          }
          {  %% ... si no el donarem dalta
           %% farcim l'array TanX100 del nou espai de color
           [] dup length 1 add dup 1 sub /Dmes exch def
           array dup dup 4 -1 roll 0 exch putinterval Dmes
           %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
           %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
           araRay 1 get length /ComFaciFalta exch def
           PnomIntern /LiTeRaLS exch def
           LiTeRaLS dup length 2 add dup /aDeS exch def string dup
           3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
           /iaRa exch def
           aDeS  %%4
           ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
           mul string /aDesiaRa exch def
           aDesiaRa /NullEncode filter
           ComFaciFalta {dup iaRa writestring} repeat
           closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
           CSnomIN
           <<
             /Tipus /DeviceN /NomExtern araRay 1 get /FTipus null
             /Paleta << PnomIntern /Shading >>
             /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
           >> put
          }ifelse
         }
         {  %% hauria de ser una Separation ...
          /araRay exch def
          XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
          {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
           CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
           /Paleta get PnomIntern known not
           {  %% del Shading/Pattern n'esbrinem el nombre de components
            %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
            %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
            dicEC /NomExtern get dup type /arraytype eq
            {length}{pop 1}ifelse /ComFaciFalta exch def
            PnomIntern /LiTeRaLS exch def
            LiTeRaLS dup length 2 add dup /aDeS exch def string dup
            3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
            /iaRa exch def
            aDeS
            ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
            mul string /aDesiaRa exch def
            aDesiaRa /NullEncode filter
            ComFaciFalta {dup iaRa writestring} repeat
            closefile 
            dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
            dup length 1 add dup 1 sub /Dmes exch def
            array dup dup
            4 -1 roll 0 exch putinterval Dmes aDesiaRa put
            /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
            %% i ara afegim a Paleta el nou Shading/Pattern
            dicEC /Paleta get PnomIntern /Shading put
           }if  %% si PnomIntern ja es desat no fem res
           %%mug@
           %%(\n\n---1959 9.b\n\n) print flush %stop
           %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
           XRay /Separacions get PnomIntern null put
          }
          {  %% ... si no el donarem dalta
           %% farcim l'array TanX100 del nou espai de color
           [] dup length 1 add dup 1 sub /Dmes exch def
           array dup dup 4 -1 roll 0 exch putinterval Dmes
           %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
           %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
           1 /ComFaciFalta exch def  %% com que es tracta s'una Separation nomes en duu 1 (i sense array)
           PnomIntern /LiTeRaLS exch def
           LiTeRaLS dup length 2 add dup /aDeS exch def string dup
           3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
           /iaRa exch def
           aDeS  %%4
           ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
           mul string /aDesiaRa exch def
           aDesiaRa /NullEncode filter
           ComFaciFalta {dup iaRa writestring} repeat
           closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
           CSnomIN
           <<
             /Tipus /Separation /NomExtern araRay 1 get /FTipus null
             /Paleta << PnomIntern /Shading >>
             /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
           >> put
           %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
           XRay /Separacions get PnomIntern null put
           %%(fem) ==
          }ifelse
         }ifelse
        }
        {  %% si NO es a ColorSpace de Resources l'haurem de numerar sota /directDeviceN# o /directSeparation# i donar d'alta a XRay /EspaisDeColor /Utilitzats ...
         iAdirecte 6 string cvs dup length 13 add string dup dup
         0 (directDeviceN) putinterval 3 -1 roll 13 exch putinterval cvn
         %% deixem el nom numerat de directDeviceN a la pila
         /CSnomIN exch def  %% el desem
         refIN /aCercar exch def  %% nom amb la ref ind de l'objecte d'espai de color q no es a Resources/ColorSpace
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
         dup 0 get /DeviceN eq
         {  %% es un DeviceN
          dup length 5 eq
          {  %% comprovem si no fos del nou tipus de DeviceN ...
           XRay /EspaisDeColor get /Errades get aCercar ( DeviceN Color Space with NChannel Not Supported) put
          } if
          /araRay exch def
          XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
          {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
           CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
           /Paleta get PnomIntern known not
           {  %% del Shading/Pattern n'esbrinem el nombre de components
            %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
            %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
            dicEC /NomExtern get dup type /arraytype eq
            {length}{pop 1}ifelse /ComFaciFalta exch def
            PnomIntern /LiTeRaLS exch def
            LiTeRaLS dup length 2 add dup /aDeS exch def string dup
            3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
            /iaRa exch def
            aDeS
            ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
            mul string /aDesiaRa exch def
            aDesiaRa /NullEncode filter
            ComFaciFalta {dup iaRa writestring} repeat
            closefile 
            dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
            dup length 1 add dup 1 sub /Dmes exch def
            array dup dup
            4 -1 roll 0 exch putinterval Dmes aDesiaRa put
            /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
            %% i ara afegim a Paleta el nou Shading/Pattern
            dicEC /Paleta get PnomIntern /Shading put
           }if  %% si PnomIntern ja es desat no fem res
           %%mug@
           %%(\n\n---1959 9.c\n\n) print flush %stop
          }
          {  %% ... si no el donarem dalta
           %% farcim l'array TanX100 del nou espai de color
           [] dup length 1 add dup 1 sub /Dmes exch def
           array dup dup 4 -1 roll 0 exch putinterval Dmes
           %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
           %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
           araRay 1 get length /ComFaciFalta exch def
           PnomIntern /LiTeRaLS exch def
           LiTeRaLS dup length 2 add dup /aDeS exch def string dup
           3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
           /iaRa exch def
           aDeS  %%4
           ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
           mul string /aDesiaRa exch def
           aDesiaRa /NullEncode filter
           ComFaciFalta {dup iaRa writestring} repeat
           closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
           CSnomIN
           <<
             /Tipus /DeviceN /NomExtern araRay 1 get /FTipus null
             /Paleta << PnomIntern /Shading >>
             /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
           >> put
          }ifelse
         }
         {  %% hauria de ser una Separation ...
          /araRay exch def
          XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
          {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
           CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
           /Paleta get PnomIntern known not
           {  %% del Shading/Pattern n'esbrinem el nombre de components
            %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
            %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
            dicEC /NomExtern get dup type /arraytype eq
            {length}{pop 1}ifelse /ComFaciFalta exch def
            PnomIntern /LiTeRaLS exch def
            LiTeRaLS dup length 2 add dup /aDeS exch def string dup
            3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
            /iaRa exch def
            aDeS
            ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
            mul string /aDesiaRa exch def
            aDesiaRa /NullEncode filter
            ComFaciFalta {dup iaRa writestring} repeat
            closefile 
            dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
            dup length 1 add dup 1 sub /Dmes exch def
            array dup dup
            4 -1 roll 0 exch putinterval Dmes aDesiaRa put
            /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
            %% i ara afegim a Paleta el nou Shading/Pattern
            dicEC /Paleta get PnomIntern /Shading put
           }if  %% si PnomIntern ja es desat no fem res
           %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
           XRay /Separacions get PnomIntern null put
           %%mug@
           %%(\n\n---1959 9.d\n\n) print flush %stop
          }
          {  %% ... si no el donarem dalta
           %% farcim l'array TanX100 del nou espai de color
           [] dup length 1 add dup 1 sub /Dmes exch def
           array dup dup 4 -1 roll 0 exch putinterval Dmes
           %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
           %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
           1 /ComFaciFalta exch def  %% com que es tracta s'una Separation nomes en duu 1 (i sense array)
           PnomIntern /LiTeRaLS exch def
           LiTeRaLS dup length 2 add dup /aDeS exch def string dup
           3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
           /iaRa exch def
           aDeS  %%4
           ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
           mul string /aDesiaRa exch def
           aDesiaRa /NullEncode filter
           ComFaciFalta {dup iaRa writestring} repeat
           closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
           CSnomIN
           <<
             /Tipus /Separation /NomExtern araRay 1 get /FTipus null
             /Paleta << PnomIntern /Shading >>
             /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
           >> put
           %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
           XRay /Separacions get PnomIntern null put
           %%(fem) ==
          }ifelse
         }ifelse
         iAdirecte 1 add /iAdirecte exch def  %% numerador per les arrays de color directes
         %%mug@
         %%(\n\n---1959 2000\n\n) print flush %stop  % error Temporal
        }ifelse
        %% donem d'alta el Shading a EspaisDeColor i li posem un null com a valor que indica q es un Pattern ...
        XRay /EspaisDeColor get /Utilitzats get PnomIntern null put
       }
       {  %% o un Device ...
        dup /DeviceCMYK eq
        {
         %% com que es valid incrustem el nom extern de l'espai de color a la posicio 2 de l'array 3paq
         3paq exch 2 exch put
         %% ... i despres el donem d'alta a Utilitzats amb l'array 3paq de descripcio com a valor
         XRay /Patterns&Shadings get /Utilitzats get 1 index 3paq dup length array copy put
         %%dup == (ARA4) ==
         dup /PnomIntern exch def undef  %% i el donem de baixa a Desconeguts desant abans el nom intern del Pattern
         %% analitzem la /Function x deduir-ne els valors de color x l'entrada Paleta i TanX100 del dic de l'espai de color
         elSha /Function get dup type /nametype eq
         {  %% primer descartem que no sigui una ref ind
          /aCercar exch def
          /iDimoni 0 def
          {  %% loop d'interrogacio dels dicts de COMdimoni
           currentdict iDimoni 4 string cvs cvn get
           %% el diccionari de l'objecte
           dup aCercar known {aCercar get exit}{pop}ifelse
           iDimoni 1 add /iDimoni exch def
           iDimoni MaxDimoni eq {exit} if
          } loop  %% d'interrogacio dels dicts de COMdimoni
         } if
         /FunctionType get
         [
          {  %% 0 NO implementada encara
           XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
           XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
           %%(Shading FunctionType 0) ==
          }
          {  %% 1 inexistents
           XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
           XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
           %%(Shading FunctionType 1) ==
          }
          {  %% 2
           %%(Shading FunctionType 2) ==
          }
          {  %% 3
           %%(Shading FunctionType 3) ==
          }
          {  %% 4 NO implementada encara
           XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
           XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
           %%(Shading FunctionType 4) ==
          }
         ]
         exch get cvx exec
         %% donem d'alta a EspaisDeColor Utilitzats
         XRay /EspaisDeColor get /Utilitzats get dup
         /NoName9 known
         {
          /NoName9 get /Paleta get
          PnomIntern /Shading put
         }
         {
          /NoName9
          <<
            /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
            /Paleta << PnomIntern /Shading >>
            /TanX100 []
          >> put
         } ifelse
         %%pstack (/*/) == quit
         %% donem d'alta el Shading a EspaisDeColor i li posem un null com a valor que indica q es un Pattern ...
         XRay /EspaisDeColor get /Utilitzats get PnomIntern null put
        }
        {
	 QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
         {  %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
          (%#%28bis%)==
          (\n\nMRCT1959 2001\n\n) print flush stop  %%quit  % error Temporal
         }  %/01 SEPARACIÓ DE TINTES
         {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
          (\n\nMRCT1959 2001\n\n) print flush clear
         }ifelse
         %%% X OMPLIR
        }ifelse
       } ifelse
      }
      {  %%  o una array directe de color (/DeviceN o /Separation)
       QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
       {  %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
        (%#%28bis%)==
        (\n\nMRCT1959 2002\n\n) print flush stop  %%quit  % error Temporal
       }  %/01 SEPARACIÓ DE TINTES
       {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
        (\n\nMRCT1959 2002\n\n) print flush clear
       }ifelse
       %%% X OMPLIR
      }ifelse
     }
     {  %% ara donarem error per la resta de /ShadingType ... 1 4 5 6 7
      QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
      {  %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
       (%#%28bis%)==
       (\n\nMRCT1959 2003\n\n) print flush stop  %%quit  % error Temporal
      }  %/01 SEPARACIÓ DE TINTES
      {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
       (\n\nMRCT1959 2003\n\n) print flush clear
      }ifelse
      %%% X OMPLIR
     }ifelse
    }ifelse  %% es un Tiling o Shading Pattern?
   }
   {  %% si no hi es es que el Pattern no ha estat utilitzat en aquest document
    XRay /Patterns&Shadings get /NoUtilitzats get exch null put pop
   }ifelse
  }forall
 } if  %% hi ha Pattern a Resources ?
 i_totalRSRCS 1 add /i_totalRSRCS exch def
}forall  %% x tots els recursos

%#%28bis0% aquí explorem els Shadings ...
(%#%28bis0%)==

/3paq 3 array def  %% creem l'array que definira el Shading encara buida
/i_totalRSRCS 0 def  %% index x explorar tots els recursos
/totalRSRCS_logic [] def  %% definim buit un paquet on desarem els true/false q indiquin si el dic duu l'entrada q cerquem
/HiHaSha false def  %% gatell x saber si hi ha dic Shading o no

totalRSRCS  %% aqui hi ha tan els recursos generals com els dels Form Xobjects (si n'hi ha)
{  %% forall
 dup /Shading known  %% al dic Resources hi ha aquesta entrada?
 {
  /Shading get length 0 eq  %% filtrem els dics buits
  {
   false /aVeure exch def
   totalRSRCS_logic
   dup length 1 add dup 1 sub /Dmes exch def
   array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
   /totalRSRCS_logic exch def  %% redesem el paquet ampliat
  }
  {
   true /aVeure exch def
   totalRSRCS_logic
   dup length 1 add dup 1 sub /Dmes exch def
   array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
   /totalRSRCS_logic exch def  %% redesem el paquet ampliat
   /HiHaSha true def
  }ifelse
 }
 {
  pop
  false /aVeure exch def
  totalRSRCS_logic
  dup length 1 add dup 1 sub /Dmes exch def
  array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
  /totalRSRCS_logic exch def  %% redesem el paquet ampliat
 }ifelse
}forall

totalRSRCS_logic
{  %% forall x tots els recursos
 {  %% if de si hi ha Shading Pattern que NO penjen d'una referencia del dic Pattern si no q ho fan del dic Shading dels recursos
  totalRSRCS i_totalRSRCS get
  /RSRCSara exch def  %% diccionari actual del recurs q explorem
  i_totalRSRCS 0 eq
  {  %% creiem nomes cal fer-ho en els recursos generals
   HiHaPa
   {  %% incrustem a JectesPS (contingut del dic Pattern) tot el contingut del dic Shading pero amb una entrada a part amb el nom /Shading
    RSRCSara /Shading get JectesPS exch /Shading exch put
   }
   {  %% incrustem a JectesPS tot el contingut del dic Shading pero amb una entrada a part amb el nom /Shading
    RSRCSara /Shading get /JectesPS 2 dict dup /Shading 5 -1 roll put def
   }ifelse
  }if  %% nomes cal fer-ho en els recursos generals
  RSRCSara /Shading get
  dup type /nametype eq
  {  %% primer descartem que no sigui una ref ind
   /aCercar exch def
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup aCercar known {aCercar get exit}{pop}ifelse
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
  } if
  {  %% forall x tot el dic de Shading
   elsAltresShadings 2 index 2 index put  %% incrustem el parell del nom del Shading i la seva ref ind en aquest dic especial
   dup type /nametype eq
   {
    /aCercar exch def  %% nom amb la ref ind
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
   } if
   dup /aVeure exch def
   totalST2
   dup length 1 add dup 1 sub /Dmes exch def
   array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
   /totalST2 exch def  %% redesem el paquet ampliat dels Shading Type 2
   /elSha exch def  %% desem el dic on es defineix el Shading
   %% mirem quina mena de Shading es
   elSha /ShadingType get dup /eST exch def  %% desem el ShadingType
   dup  %% aqui nomes deixem passar els /ShadingType 2 i 3 ...
   2 eq 1 index 3 eq or
   {
    pop  %% ara ens carreguem el ShadingType
    3paq dup 0 2 put  %% a la posicio 0 posem 2 x indicar que es tracta d'un Shading Pattern
    1 eST put  %% ... i a la posicio 1 hi posem el ShadingType
    %% a la posicio 2 de l'array 3paq hi va el nom Extern de l'espai de color del Shading
    elSha /ColorSpace get  %% al dic Shading n'xtraiem l'espai de color underlying
    %% que haurem de donar d'alta a EspaisDeColor Utilitzats
    dup type /nametype eq
    {
     dup length 16 eq
     {
      dup 16 string cvs 10 get 95 eq{true}{false}ifelse
     }
     {
      false
     }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
     {  %% primer descartem que no sigui una ref ind
      /aCercar exch def
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
     } if
     dup type /arraytype eq
     {  %%  o una array INdirecte de color (/DeviceN o /Separation)
      aCercar /refIN exch def  %% desem la ref ind de l'espai de color
      %% com que es valid incrustem el nom extern de l'espai de color a la posicio 2 de l'array 3paq
      3paq exch 1 get  %% anem a pescar el nom extern a l'array de color
      2 exch put
      %% ... i despres el donem d'alta a Utilitzats amb l'array 3paq de descripcio com a valor
      XRay /Patterns&Shadings get /Utilitzats get 1 index 3paq dup length array copy put
      %%dup == (ARA3) == dup /Sh3 eq {3paq == (ARA!!!) == quit} if
      dup /PnomIntern exch def
      XRay /Patterns&Shadings get /Desconeguts get exch undef  %% i el donem de baixa a Desconeguts desant abans el nom intern del Pattern
      %% analitzem la /Function x deduir-ne els valors de color x l'entrada Paleta i TanX100 del dic de l'espai de color
      elSha /Function get dup type /nametype eq
      {  %% primer descartem que no sigui una ref ind
       /aCercar exch def
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
      } if
      /FunctionType get
      [
       { %% 0 NO implementada encara
        XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
        XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
        %%(Shading FunctionType 0) ==
       }
       { %% 1 inexistents
        XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
        XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
        %%(Shading FunctionType 1) ==
       }
       { %% 2
        %%(Shading FunctionType 2) ==
       }
       { %% 3
        %%(Shading FunctionType 3) ==
       }
       { %% 4 NO implementada encara
        XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
        XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
        %%(Shading FunctionType 4) ==
       }
      ]
      exch get cvx exec
      %% mirarem si existeix a ColorSpace de Resources
      RSRCSara /ColorSpace known {/HiHaCS true def}{/HiHaCS false def}ifelse
      HiHaCS
      {
       RSRCSara /ColorSpace get dup type /nametype eq
       {  %% primer descartem que no sigui una ref ind
        /aCercar exch def
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        } loop  %% d'interrogacio dels dicts de COMdimoni
       } if
       {  %% forall
        refIN eq
        {
         /EsaCS true def /CSnomIN exch def exit
        }
        {
         pop /EsaCS false def
        }ifelse
       }forall
      }
      {
       /EsaCS false def
      }ifelse
      EsaCS
      {  %% si es a ColorSpace de Resources ja tindra nom i haurem de comprovar si ja existeix a XRay /EspaisDeColor /Utilitzats? ...
       refIN /aCercar exch def  %% nom amb la ref ind del dic Resources
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
       dup 0 get /DeviceN eq
       {  %% es un DeviceN
        dup length 5 eq
        {  %% comprovem si no fos del nou tipus de DeviceN ...
         XRay /EspaisDeColor get /Errades get aCercar ( DeviceN Color Space with NChannel Not Supported) put
        } if
        /araRay exch def
        XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
        {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
         CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
         /Paleta get PnomIntern known not
         {  %% del Shading/Pattern n'esbrinem el nombre de components
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          dicEC /NomExtern get dup type /arraytype eq
          {length}{pop 1}ifelse /ComFaciFalta exch def
          PnomIntern /LiTeRaLS exch def
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile 
          dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup
          4 -1 roll 0 exch putinterval Dmes aDesiaRa put
          /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
          %% i ara afegim a Paleta el nou Shading/Pattern
          dicEC /Paleta get PnomIntern /Shading put
         }if  %% si PnomIntern ja es desat no fem res
         %%mug@
         %%(\n\n---1959 9.0\n\n) print flush %stop
        }
        {  %% ... si no el donarem dalta
         %% farcim l'array TanX100 del nou espai de color
         [] dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         araRay 1 get length /ComFaciFalta exch def
         PnomIntern /LiTeRaLS exch def
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS  %%4
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
         CSnomIN
         <<
           /Tipus /DeviceN /NomExtern araRay 1 get /FTipus null
           /Paleta << PnomIntern /Shading >>
           /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
         >> put
         %% i donem de baixa a Desconeguts!
         XRay /EspaisDeColor get /Desconeguts get CSnomIN undef
        }ifelse
       }
       {  %% hauria de ser una Separation ...
        /araRay exch def
        XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
        {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
         CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
         /Paleta get PnomIntern known not
         {  %% del Shading/Pattern n'esbrinem el nombre de components
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          dicEC /NomExtern get dup type /arraytype eq
          {length}{pop 1}ifelse /ComFaciFalta exch def
          PnomIntern /LiTeRaLS exch def
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile 
          dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup
          4 -1 roll 0 exch putinterval Dmes aDesiaRa put
          /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
          %% i ara afegim a Paleta el nou Shading/Pattern
          dicEC /Paleta get PnomIntern /Shading put
         }if  %% si PnomIntern ja es desat no fem res
         %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
         XRay /Separacions get PnomIntern null put
         %%mug@
         %%(\n\n---1959 9.1\n\n) print flush %stop
        }
        {  %% ... si no el donarem dalta
         %% farcim l'array TanX100 del nou espai de color
         [] dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         1 /ComFaciFalta exch def  %% com que es tracta s'una Separation nomes en duu 1 (i sense array)
         PnomIntern /LiTeRaLS exch def
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS  %%4
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
         CSnomIN
         <<
           /Tipus /Separation /NomExtern araRay 1 get /FTipus null
           /Paleta << PnomIntern /Shading >>
           /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
         >> put
         %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
         XRay /Separacions get PnomIntern null put
         %% i donem de baixa a Desconeguts!
         XRay /EspaisDeColor get /Desconeguts get CSnomIN undef
        }ifelse
       }ifelse
      }
      {  %% si NO es a ColorSpace de Resources l'haurem de numerar sota /directDeviceN# o /directSeparation# i donar d'alta a XRay /EspaisDeColor /Utilitzats ...
       iAdirecte 6 string cvs dup length 13 add string dup dup
       0 (directDeviceN) putinterval 3 -1 roll 13 exch putinterval cvn
       %% deixem el nom numerat de directDeviceN a la pila
       /CSnomIN exch def  %% el desem
       refIN /aCercar exch def  %% nom amb la ref ind de l'objecte d'espai de color q no es a Resources/ColorSpace
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
       dup 0 get /DeviceN eq
       {  %% es un DeviceN
        dup length 5 eq
        {  %% comprovem si no fos del nou tipus de DeviceN ...
         XRay /EspaisDeColor get /Errades get aCercar ( DeviceN Color Space with NChannel Not Supported) put
        } if
        /araRay exch def
        XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
        {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
         CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
         /Paleta get PnomIntern known not
         {  %% del Shading/Pattern n'esbrinem el nombre de components
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          dicEC /NomExtern get dup type /arraytype eq
          {length}{pop 1}ifelse /ComFaciFalta exch def
          PnomIntern /LiTeRaLS exch def
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile 
          dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup
          4 -1 roll 0 exch putinterval Dmes aDesiaRa put
          /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
          %% i ara afegim a Paleta el nou Shading/Pattern
          dicEC /Paleta get PnomIntern /Shading put
         }if  %% si PnomIntern ja es desat no fem res
         %%mug@
         %%(\n\n---1959 9.2\n\n) print flush %stop
        }
        {  %% ... si no el donarem dalta
         %% farcim l'array TanX100 del nou espai de color
         [] dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         araRay 1 get length /ComFaciFalta exch def
         PnomIntern /LiTeRaLS exch def
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS  %%4
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
         CSnomIN
         <<
           /Tipus /DeviceN /NomExtern araRay 1 get /FTipus null
           /Paleta << PnomIntern /Shading >>
           /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
         >> put
         %% i donem de baixa a Desconeguts!
         XRay /EspaisDeColor get /Desconeguts get CSnomIN undef
        }ifelse
       }
       {  %% hauria de ser una Separation ...
        /araRay exch def
        XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
        {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
         CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
         /Paleta get PnomIntern known not
         {  %% del Shading/Pattern n'esbrinem el nombre de components
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          dicEC /NomExtern get dup type /arraytype eq
          {length}{pop 1}ifelse /ComFaciFalta exch def
          PnomIntern /LiTeRaLS exch def
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile 
          dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup
          4 -1 roll 0 exch putinterval Dmes aDesiaRa put
          /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
          %% i ara afegim a Paleta el nou Shading/Pattern
          dicEC /Paleta get PnomIntern /Shading put
         }if  %% si PnomIntern ja es desat no fem res
         %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
         XRay /Separacions get PnomIntern null put
         %%mug@
         %%(\n\n---1959 9.3\n\n) print flush %stop
        }
        {  %% ... si no el donarem dalta
         %% farcim l'array TanX100 del nou espai de color
         [] dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         1 /ComFaciFalta exch def  %% com que es tracta s'una Separation nomes en duu 1 (i sense array)
         PnomIntern /LiTeRaLS exch def
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS  %%4
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
         CSnomIN
         <<
           /Tipus /Separation /NomExtern araRay 1 get /FTipus null
           /Paleta << PnomIntern /Shading >>
           /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
         >> put
         %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
         XRay /Separacions get PnomIntern null put
         %% i donem de baixa a Desconeguts!
         XRay /EspaisDeColor get /Desconeguts get CSnomIN undef
        }ifelse
       }ifelse
       iAdirecte 1 add /iAdirecte exch def  %% numerador per les arrays de color directes
       %%mug@
       %%(\n\n---1959 2000\n\n) print flush %stop  % error Temporal
      }ifelse
      %% donem d'alta el Shading a EspaisDeColor i li posem un null com a valor que indica q es un Pattern ...
      XRay /EspaisDeColor get /Utilitzats get PnomIntern null put
     }
     {  %% o un Device ...
      dup /DeviceCMYK eq
      {
       %% com que es valid incrustem el nom extern de l'espai de color a la posicio 2 de l'array 3paq
       3paq exch 2 exch put
       %% ... i despres el donem d'alta a Utilitzats amb l'array 3paq de descripcio com a valor
       XRay /Patterns&Shadings get /Utilitzats get 1 index 3paq dup length array copy put
       %%dup == (ARA2) ==
       dup /PnomIntern exch def
       XRay /Patterns&Shadings get /Desconeguts get exch undef  %% i el donem de baixa a Desconeguts desant abans el nom intern del Pattern
       %% analitzem la /Function x deduir-ne els valors de color x l'entrada Paleta i TanX100 del dic de l'espai de color
       elSha /Function get
       dup type /arraytype eq
       {
        {  %% forall
         dup type /nametype eq
         {  %% primer descartem que no sigui una ref ind
          /aCercar exch def
          /iDimoni 0 def
          {  %% loop d'interrogacio dels dicts de COMdimoni
           currentdict iDimoni 4 string cvs cvn get
           %% el diccionari de l'objecte
           dup aCercar known {aCercar get exit}{pop}ifelse
           iDimoni 1 add /iDimoni exch def
           iDimoni MaxDimoni eq {exit} if
          } loop  %% d'interrogacio dels dicts de COMdimoni
         } if
         /FunctionType get
         [
          {  %% 0 NO implementada encara
           XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
           XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
           %%(Shading FunctionType 0) ==
          }
          {  %% 1 inexistents
           XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
           XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
           %%(Shading FunctionType 1) ==
          }
          {  %% 2
           %%(Shading FunctionType 2) ==
          }
          {  %% 3
           %%(Shading FunctionType 3) ==
          }
          {  %% 4 NO implementada encara
           XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
           XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
           %%(Shading FunctionType 4) ==
          }
         ]
         exch get cvx exec
        }forall
       }
       {
        dup type /nametype eq
        {  %% primer descartem que no sigui una ref ind
         /aCercar exch def
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
        } if
        /FunctionType get
        [
         {  %% 0 NO implementada encara
          XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
          XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
          %%(Shading FunctionType 0) ==
         }
         {  %% 1 inexistents
          XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
          XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
          %%(Shading FunctionType 1) ==
         }
         {  %% 2
          %%(Shading FunctionType 2) ==
         }
         {  %% 3
          %%(Shading FunctionType 3) ==
         }
         {  %% 4 NO implementada encara
          XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
          XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
          %%(Shading FunctionType 4) ==
         }
        ]
        exch get cvx exec
       }ifelse
%%(:-P)pstack quit
       %% donem d'alta a EspaisDeColor Utilitzats
       XRay /EspaisDeColor get /Utilitzats get dup
       /NoName9 known
       {
        /NoName9 get /Paleta get
        PnomIntern /Shading put
       }
       {
        /NoName9
        <<
          /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
          /Paleta << PnomIntern /Shading >>
          /TanX100 []
        >> put
       } ifelse
       %% donem d'alta el Shading a EspaisDeColor i li posem un null com a valor que indica q es un Pattern ...
       XRay /EspaisDeColor get /Utilitzats get PnomIntern null put
      }
      {
       QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
       {  %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
        (%#%28bis%)==
        (\n\nMRCT1959 2001\n\n) print flush stop  %%quit  % error Temporal
       }  %/01 SEPARACIÓ DE TINTES
       {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
        (\n\nMRCT1959 2001\n\n) print flush clear
       }ifelse
       %%% X OMPLIR
      }ifelse
     } ifelse
    }
    {  %%  o una array directe de color (/DeviceN o /Separation)
     QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
     {  %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
      (%#%28bis%)==
      (\n\nMRCT1959 2002\n\n) print flush stop  %%quit  % error Temporal
     }  %/01 SEPARACIÓ DE TINTES
     {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
      (\n\nMRCT1959 2002\n\n) print flush clear
     }ifelse
     %%% X OMPLIR
    }ifelse
   }
   {  %% ara donarem error per la resta de /ShadingType ... 1 4 5 6 7
    QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
    {  %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
     (%#%28bis%)==
     (\n\nMRCT1959 2003\n\n) print flush stop  %%quit  % error Temporal
    }  %/01 SEPARACIÓ DE TINTES
    {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
     (\n\nMRCT1959 2003\n\n) print flush clear
    }ifelse
    %%% X OMPLIR
   }ifelse
  } forall
 } if  %% hi ha Shading als recursos?
 i_totalRSRCS 1 add /i_totalRSRCS exch def
}forall  %% x tots els recursos

%% totalRSRCS 0 get
%% /Pattern get {== ==}forall quit

HiHaPa HiHaSha or not  %% nomes si els dos son false ...
{  %% no hi ha ni Patterns ni Shadings ...
 null /JectesPS exch def  %% desem un null en comptes del dic Pattern i/o Shading x NO fer les separacions de + endavant
} if

%% en aquest dic desarem els Colored Patterns descrits amb Shading
/ColPatSha 2 dict def
%%(aviamla) pstack quit
%#%28bis2% dins els nous Resources particulars dels Patterns esbrinem si hi ha /Shading
(%#%28bis2%)==
psRSRCSrai
{  %% forall
 dup /BaulaP exch def  %% la baula que ens permet trobar el Pattern on un determinat Shading treballa
 dup type /dicttype ne
 {
  /aCercar exch def  %% nom amb la ref ind del dic Resources
  /iDimoni 0 def
  {  %% loop d'interrogacio dels dicts de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   %% el diccionari de l'objecte
   dup aCercar known {aCercar get exit}{pop}ifelse
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% d'interrogacio dels dicts de COMdimoni
 }if
 dup /Shading known
 {  %% hi ha aquesta entrada?
  /Shading get
  {  %% forall x tot el dic de Shading
   elsAltresShadings 2 index 2 index put  %% incrustem el parell del nom del Shading i la seva ref ind en aquest dic especial
   dup type /nametype eq
   {
    /aCercar exch def  %% nom amb la ref ind
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
   } if
   dup /aVeure exch def
   totalST2
   dup length 1 add dup 1 sub /Dmes exch def
   array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
   /totalST2 exch def  %% redesem el paquet ampliat dels Shading Type 2
   /elSha exch def  %% desem el dic on es defineix el Shading
   %% mirem quina mena de Shading es
   elSha /ShadingType get dup /eST exch def  %% desem el ShadingType
   dup  %% aqui nomes deixem passar els /ShadingType 2 i 3 ...
   2 eq 1 index 3 eq or
   {
    pop  %% ara ens carreguem el ShadingType
    3paq dup 0 2 put  %% a la posicio 0 posem 2 x indicar que es tracta d'un Shading Pattern
    1 eST put  %% ... i a la posicio 1 hi posem el ShadingType
    %% a la posicio 2 de l'array 3paq hi va el nom Extern de l'espai de color del Shading
    elSha /ColorSpace get  %% al dic Shading n'xtraiem l'espai de color underlying
    %% que haurem de donar d'alta a EspaisDeColor Utilitzats
    dup type /nametype eq
    {
     dup length 16 eq
     {
      dup 16 string cvs 10 get 95 eq{true}{false}ifelse
     }
     {
      false
     }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
     {  %% primer descartem que no sigui una ref ind
      /aCercar exch def
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
     } if
     dup type /arraytype eq
     {  %%  o una array INdirecte de color (/DeviceN o /Separation)
      aCercar /refIN exch def  %% desem la ref ind de l'espai de color
      %% com que es valid incrustem el nom extern de l'espai de color a la posicio 2 de l'array 3paq
      3paq exch 1 get  %% anem a pescar el nom extern a l'array de color
      2 exch put
      %% ... i despres el donem d'alta a Utilitzats amb l'array 3paq de descripcio com a valor
      XRay /Patterns&Shadings get /Utilitzats get 1 index 3paq dup length array copy put
      %%dup == (ARA1) ==
      dup /PnomIntern exch def
      XRay /Patterns&Shadings get /Desconeguts get exch undef  %% i el donem de baixa a Desconeguts desant abans el nom intern del Pattern
      %% analitzem la /Function x deduir-ne els valors de color x l'entrada Paleta i TanX100 del dic de l'espai de color
      elSha /Function get dup type /nametype eq
      {  %% primer descartem que no sigui una ref ind
       /aCercar exch def
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
      } if
      /FunctionType get
      [
       {	%% 0 NO implementada encara
        XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
        XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
        %%(Shading FunctionType 0) ==
       }
       {	%% 1 inexistents
        XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
        XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
        %%(Shading FunctionType 1) ==
       }
       {	%% 2
        %%(Shading FunctionType 2) ==
       }
       {	%% 3
        %%(Shading FunctionType 3) ==
       }
       {	%% 4 NO implementada encara
        XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
        XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
        %%(Shading FunctionType 4) ==
       }
      ]
      exch get cvx exec
      %% mirarem si existeix a ColorSpace de Resources
      RSRCS araPlana get /ColorSpace known {/HiHaCS true def}{/HiHaCS false def}ifelse
      HiHaCS
      {
       RSRCS araPlana get /ColorSpace get
       {
        refIN eq {/EsaCS true def /CSnomIN exch def exit}{pop /EsaCS false def}ifelse
       }forall
      }
      {
       /EsaCS false def
      }ifelse
      EsaCS
      {  %% si es a ColorSpace de Resources ja tindra nom i haurem de comprovar si ja existeix a XRay /EspaisDeColor /Utilitzats? ...
       refIN /aCercar exch def  %% nom amb la ref ind del dic Resources
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
       dup 0 get /DeviceN eq
       {  %% es un DeviceN
        dup length 5 eq
        {  %% comprovem si no fos del nou tipus de DeviceN ...
         XRay /EspaisDeColor get /Errades get aCercar ( DeviceN Color Space with NChannel Not Supported) put
        } if
        /araRay exch def
        XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
        {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
         CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
         /Paleta get PnomIntern known not
         {  %% del Shading/Pattern n'esbrinem el nombre de components
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          dicEC /NomExtern get dup type /arraytype eq
          {length}{pop 1}ifelse /ComFaciFalta exch def
          PnomIntern /LiTeRaLS exch def
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile 
          dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup
          4 -1 roll 0 exch putinterval Dmes aDesiaRa put
          /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
          %% i ara afegim a Paleta el nou Shading/Pattern
          dicEC /Paleta get PnomIntern /Shading put
         }if  %% si PnomIntern ja es desat no fem res
         %%mug@
         %%(\n\n---1959 9.e\n\n) print flush %stop
        }
        {  %% ... si no el donarem dalta
         %% farcim l'array TanX100 del nou espai de color
         [] dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         araRay 1 get length /ComFaciFalta exch def
         PnomIntern /LiTeRaLS exch def
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS  %%4
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
         CSnomIN
         <<
           /Tipus /DeviceN /NomExtern araRay 1 get /FTipus null
           /Paleta << PnomIntern /Shading >>
           /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
         >> put
        }ifelse
       }
       {  %% hauria de ser una Separation ...
        /araRay exch def
        XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
        {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
         CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
         /Paleta get PnomIntern known not
         {  %% del Shading/Pattern n'esbrinem el nombre de components
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          dicEC /NomExtern get dup type /arraytype eq
          {length}{pop 1}ifelse /ComFaciFalta exch def
          PnomIntern /LiTeRaLS exch def
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile 
          dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup
          4 -1 roll 0 exch putinterval Dmes aDesiaRa put
          /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
          %% i ara afegim a Paleta el nou Shading/Pattern
          dicEC /Paleta get PnomIntern /Shading put
         }if  %% si PnomIntern ja es desat no fem res
         %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
         XRay /Separacions get PnomIntern null put
         %%mug@
         %%(\n\n---1959 9.f\n\n) print flush %stop
        }
        {  %% ... si no el donarem dalta
         %% farcim l'array TanX100 del nou espai de color
         [] dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         1 /ComFaciFalta exch def  %% com que es tracta s'una Separation nomes en duu 1 (i sense array)
         PnomIntern /LiTeRaLS exch def
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS  %%4
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
         CSnomIN
         <<
           /Tipus /Separation /NomExtern araRay 1 get /FTipus null
           /Paleta << PnomIntern /Shading >>
           /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
         >> put
         %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
         XRay /Separacions get PnomIntern null put
        }ifelse
       }ifelse
      }
      {  %% si NO es a ColorSpace de Resources l'haurem de numerar sota /directDeviceN# o /directSeparation# i donar d'alta a XRay /EspaisDeColor /Utilitzats ...
       iAdirecte 6 string cvs dup length 13 add string dup dup
       0 (directDeviceN) putinterval 3 -1 roll 13 exch putinterval cvn
       %% deixem el nom numerat de directDeviceN a la pila
       /CSnomIN exch def  %% el desem
       refIN /aCercar exch def  %% nom amb la ref ind de l'objecte d'espai de color q no es a Resources/ColorSpace
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       } loop  %% d'interrogacio dels dicts de COMdimoni
       dup 0 get /DeviceN eq
       {  %% es un DeviceN
        dup length 5 eq
        {  %% comprovem si no fos del nou tipus de DeviceN ...
         XRay /EspaisDeColor get /Errades get aCercar ( DeviceN Color Space with NChannel Not Supported) put
        } if
        /araRay exch def
        XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
        {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
         CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
         /Paleta get PnomIntern known not
         {  %% del Shading/Pattern n'esbrinem el nombre de components
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          dicEC /NomExtern get dup type /arraytype eq
          {length}{pop 1}ifelse /ComFaciFalta exch def
          PnomIntern /LiTeRaLS exch def
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile 
          dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup
          4 -1 roll 0 exch putinterval Dmes aDesiaRa put
          /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
          %% i ara afegim a Paleta el nou Shading/Pattern
          dicEC /Paleta get PnomIntern /Shading put
         }if  %% si PnomIntern ja es desat no fem res
         %%mug@
         %%(\n\n---1959 9.g\n\n) print flush %stop
        }
        {  %% ... si no el donarem dalta
         %% farcim l'array TanX100 del nou espai de color
         [] dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         araRay 1 get length /ComFaciFalta exch def
         PnomIntern /LiTeRaLS exch def
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS  %%4
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
         CSnomIN
         <<
           /Tipus /DeviceN /NomExtern araRay 1 get /FTipus null
           /Paleta << PnomIntern /Shading >>
           /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
         >> put
        }ifelse
       }
       {  %% hauria de ser una Separation ...
        /araRay exch def
        XRay /EspaisDeColor get /Utilitzats get dup CSnomIN known
        {  %% ... si ja existeix comprovem si el Shading/Pattern q hi esta relacionat hi es donat d'alta
         CSnomIN get dup /dicEC exch def  %% desem el dic de l'espai de color del Shading/Pattern
         /Paleta get PnomIntern known not
         {  %% del Shading/Pattern n'esbrinem el nombre de components
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading/Pattern ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          dicEC /NomExtern get dup type /arraytype eq
          {length}{pop 1}ifelse /ComFaciFalta exch def
          PnomIntern /LiTeRaLS exch def
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile 
          dicEC dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup
          4 -1 roll 0 exch putinterval Dmes aDesiaRa put
          /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
          %% i ara afegim a Paleta el nou Shading/Pattern
          dicEC /Paleta get PnomIntern /Shading put
         }if  %% si PnomIntern ja es desat no fem res
         %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
         XRay /Separacions get PnomIntern null put
         %%mug@
         %%(\n\n---1959 9.h\n\n) print flush %stop
        }
        {  %% ... si no el donarem dalta
         %% farcim l'array TanX100 del nou espai de color
         [] dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         1 /ComFaciFalta exch def  %% com que es tracta s'una Separation nomes en duu 1 (i sense array)
         PnomIntern /LiTeRaLS exch def
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS  %%4
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa put /TanX100 exch def  %% desem el nou array de TanX100 x incrusta-lo al dic de l'espai de color
         CSnomIN
         <<
           /Tipus /Separation /NomExtern araRay 1 get /FTipus null
           /Paleta << PnomIntern /Shading >>
           /TanX100 TanX100  %% array farcida amb una string de amb tants literals (nom intern del Shading) com components de color del DeviceN
         >> put
         %% donem d'alta el Shading a Separacions i li posem un null com a valor que indica q es un Pattern ...
         XRay /Separacions get PnomIntern null put
        }ifelse
       }ifelse
       iAdirecte 1 add /iAdirecte exch def  %% numerador per les arrays de color directes
       %%mug@
       %%(\n\n---1959 2000\n\n) print flush %stop  % error Temporal
      }ifelse
      %% donem d'alta el Shading a EspaisDeColor i li posem un null com a valor que indica q es un Pattern ...
      XRay /EspaisDeColor get /Utilitzats get PnomIntern null put
     }
     {  %% o un Device ...
      dup /DeviceCMYK eq
      {
       %% com que es valid incrustem el nom extern de l'espai de color a la posicio 2 de l'array 3paq
       3paq exch 2 exch put
       %% ... i despres el donem d'alta a Utilitzats amb l'array 3paq de descripcio com a valor
       XRay /Patterns&Shadings get /Utilitzats get 1 index 3paq dup length array copy put
       %%dup == (ARA0) ==
       dup /PnomIntern exch def
       XRay /Patterns&Shadings get /Desconeguts get exch undef  %% i el donem de baixa a Desconeguts desant abans el nom intern del Pattern
       %% analitzem la /Function x deduir-ne els valors de color x l'entrada Paleta i TanX100 del dic de l'espai de color
       elSha /Function get dup type /nametype eq
       {  %% primer descartem que no sigui una ref ind
        /aCercar exch def
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        } loop  %% d'interrogacio dels dicts de COMdimoni
       } if
       /FunctionType get
       [
        {  %% 0 NO implementada encara
         XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
         XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 0 Not Ready) put
         %%(Shading FunctionType 0) ==
        }
        {  %% 1 inexistents
         XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
         XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 1 Not Supported) put
         %%(Shading FunctionType 1) ==
        }
        {  %% 2
         %%(Shading FunctionType 2) ==
        }
        {  %% 3
         %%(Shading FunctionType 3) ==
        }
        {  %% 4 NO implementada encara
         XRay /EspaisDeColor get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
         XRay /Patterns&Shadings get /Errades get PnomIntern ( Shading Color Space Function Type 4 Not Ready) put
         %%(Shading FunctionType 4) ==
        }
       ]
       exch get cvx exec
       %% donem d'alta a EspaisDeColor Utilitzats
       XRay /EspaisDeColor get /Utilitzats get dup
       /NoName9 known
       {
        /NoName9 get /Paleta get
        PnomIntern /Shading put
       }
       {
        /NoName9
        <<
          /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
          /Paleta << PnomIntern /Shading >>
          /TanX100 []
        >> put
       } ifelse
       %% donem d'alta el Shading a EspaisDeColor i li posem un null com a valor que indica q es un Pattern ...
       XRay /EspaisDeColor get /Utilitzats get PnomIntern null put
      }
      {
       QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
       {  %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
        (%#%28bis%)==
        (\n\nMRCT1959 2001\n\n) print flush stop  %%quit  % error Temporal
       }  %/01 SEPARACIÓ DE TINTES
       {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
        (\n\nMRCT1959 2001\n\n) print flush clear
       }ifelse
       %%% X OMPLIR
      }ifelse
     } ifelse
    }
    {  %%  o una array directe de color (/DeviceN o /Separation)
     QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
     {  %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
      (%#%28bis%)==
      (\n\nMRCT1959 2002\n\n) print flush stop  %%quit  % error Temporal
     }  %/01 SEPARACIÓ DE TINTES
     {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
      (\n\nMRCT1959 2002\n\n) print flush clear
     }ifelse
     %%% X OMPLIR
    }ifelse
   }
   {  %% ara donarem error per la resta de /ShadingType ... 1 4 5 6 7
    QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
    { %#%28bis% error no controlat en la separació de colors dels Patterns i Shadings
     (%#%28bis%)==
     (\n\nMRCT1959 2003\n\n) print flush stop  %%quit  % error Temporal
    }  %/01 SEPARACIÓ DE TINTES
    {  %% llistem l'MRCT i netegem la pila x continuar (caldra controlar-ho quan millorem l'XRay)
     (\n\nMRCT1959 2003\n\n) print flush clear
    }ifelse
    %%% X OMPLIR
   }ifelse
  } forall  %% x cadascuna de les entrades del dic Shading de Resources
 }
 {  %% si no hi ha /Shading no fem res ...
  pop
 } ifelse
 %%JectesPS {== ==}forall (mmLA) pstack quit
 JectesPS  %% explorem tots els Patterns x saber per mitja dels seus Resources si utilitzen un Shading ...
 {  %% forall
  exch /elNomDelP exch def
  /aCercar exch def
  /iDimoni 0 def
  {  %% loop d'interrogacio dels dicts de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   %% el diccionari de l'objecte
   dup aCercar known {aCercar get exit}{pop}ifelse
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% d'interrogacio dels dicts de COMdimoni
  dup /Resources known  %% hi ha Resources?
  {
   /Resources get BaulaP eq  %% els Resources utilitzats pel Pattern son els mateixos que el Shading explorat ara?
   {
    XRay /Patterns&Shadings get /Utilitzats get dup
    %%PnomIntern
    elNomDelP get 2 get  %% extraiem l'espai de color del Shading usat
    exch elNomDelP get exch 2 exch put  %% incrustem al Pattern l'espai de color del seu Shading
    ColPatSha elNomDelP null put  %% incrustem el nom del Pattern descrit amb Shading al dic x fara de detector a #0#
   } if
  }
  {
   pop
  } ifelse
 } forall
}forall  %% x cadascuna de les entrades de l'array de Resources particulars dels Patterns&Shadings

%#%28bis3% definim el fitxer on reescriurem l'stream del Pattern
(%#%28bis3%)==
l'objectenet3 (w) file  %%  repicats a traves de les redefinicions d'OpContents_QueLiFemFer1
/sEdAs exch def
%%%CALi2COPi%%%
%% algun dels Patterns desats a /Patterns&Shadings es un Colored Pattern?
XRay /Patterns&Shadings get /Utilitzats get
{  %% forall on filtrem els Tiling Patterns (/PatternType 1) Colored (/PaintType 1)
 dup 0 get 1 eq
 {  %% si es un Tiling Pattern ...
  1 get 1 eq
  {  %% si es un Colored Pattern ens obliga a reinterpretar el seu stream de dades x deduir-ne l'espai de color i les Tintes
   /nomDtp exch def  %% ens desem el nom del Tiling Pattern
   %% anem a Resources a cercar el dic Pattern
   %%% COM SABEM ON ES EL PATTERN Q BUSQUEM?
   %%% (ARA) CAL MUNTAR UN EXEMPLE DE COLORED TILING PATTERN DINS UN FORM
   %%% CAL PODER SABER A QUIN DIC ES TROBARIA EL COLORED TILING PATTERN SI EN TINGUESSIM UN EN UN FORMXOBJECT
   RSRCS araPlana get /Pattern get
   dup type /nametype eq
   {
    /aCercar exch def
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% d'interrogacio dels dicts de COMdimoni     
   }if
   %% x l'error de 12.pdf d'A3copiseny
   %% podria ser que encara no fos el diccionari del Pattern!
   %% si fos aixi duria novament la clau del nom intern del Pattern nomDtp lligada a una ref ind
   dup nomDtp known
   {  %% si li trobem, es que duu aquest diccionari intermig que en teoria hauria d'apuntar al definitiu
    nomDtp get
    /aCercar exch def
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
   }if

   %% aqui executem l'stream i n'esbrinem l'espai de color i les Tintes
   dup /Filter known
   {  %% fitxer stream amb algun tipus de filtre
    dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
    
     dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
     dup /DecodeParms known exch /DP known 2 copy or
     {
      {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
      {
       [ exch [ exch filtresstream ] ] /filtresstream exch def
      }
      {  %% es una array
       %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
       dup length filtresstream length ne
       {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
        (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
       }if
       /iDPF 0 def
       [ exch
        {  %% forall
         dup null eq
         {
          pop [filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }
         {
	  [exch filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }ifelse
        }forall
       ]
       /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
      }ifelse
     }
     {
      pop pop  %% ens carreguem els logics
      pop  %% ens carreguem el dic
      %% avaluem filtresstream per redefinir-lo com cal per /filtRa
      filtresstream type /arraytype eq
      {
       [filtresstream] /filtresstream exch def
      }
      {
       [[filtresstream]] /filtresstream exch def
      }ifelse
     }ifelse
    
    dadesstream
    %% comprovem si l'stream es un path dins una array o una string de dades directe
    type /arraytype eq
    {
     dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
    }
    {  %% convertim a fitxer de la cadena sense decodificar
     dadesstream 0 () /SubFileDecode filter
    } ifelse
    filtresstream
(F5) ==
    filtRa  %% decodifiquem el fitxer stream
    %% preparem el fitxer de lectura que a l'estar filtrat el repiquem al disc
    repiCa (w) file /REPIcA exch def
    {  %% loop
     dup
     65535 string readstring
     {
      REPIcA exch writestring
     }
     {
      REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit
     }ifelse
    }loop
    repiCa dup
    status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
    (r) file /aLLeGiR exch def
   }
   {  %% fitxer stream sense filtres
    /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
    dadesstream  %% tibem el fitxer stream sense decodificar
    %% comprovem si l'stream es un path dins una array o una string de dades directe
    type /arraytype eq
    {
     dadesstream 0 get
     dup
     status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
     (r) file /aLLeGiR exch def
    }
    {  %% convertim a fitxer de la cadena sense decodificar
     dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
     0 () /SubFileDecode filter /aLLeGiR exch def
    } ifelse
   }ifelse
   %% repicat idem en ascii de l'stream del Colored Pattern
   BeSSo
  }
  {  %% si es un Uncolored Pattern no fem res
   pop
  }ifelse
 }
 {  %% aqui hi anira l'analisi dels Shading Patterns
  pop pop
 }ifelse
}forall
%% Fi d'Exploracio dels Patterns i Shadings del document

%% XRay /Patterns&Shadings get /Utilitzats get /Sh3 get ==

%#%28bis4% farcim l'array totalRSRCS amb els diccionaris directes dels Resources dels Patterns&Shadings
(%#%28bis4%)==
%% /totalRSRCS [] def  % ara definida + amunt
psRSRCSrai  %% array de les ref ind dels Resources particulars dels Patterns&Shadings
{  %% forall x farcir una nova array (totalRSRCS) amb el total de Resources (Pagina+Patterns&Shadings)
 dup type /dicttype ne
 {
  /aCercar exch def  %% nom amb la ref ind del dic Resources
  /iDimoni 0 def
  {  %% loop d'interrogacio dels dicts de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   %% el diccionari de l'objecte
   dup aCercar known {aCercar get exit}{pop}ifelse
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% d'interrogacio dels dicts de COMdimoni
 }if
 %% fiquem aVeure dins totalRSRCS ampliant cada vegada aquest array
 /aVeure exch def
 totalRSRCS
 dup length 1 add dup 1 sub /Dmes exch def
 array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
 /totalRSRCS exch def  %% redesem el paquet ampliat dels Resources particulars dels Pattern
}forall

%% l'error MUT de ... INO02260-02-OR-Nou_senseFonts.pdf
%% es en aquest sector d'explorar els Estats Grafics i Espais de Color

%#%29% Exploració dels Estats Gràfics del document
(%#%29%)==
%% ara anem a pescar els Resources de cada plana per llegir ExtGState i ColorSpace
%% quinaPlana
%% {  % forall
%%  /actGina exch def pop  % desem el literal del num d'obj /Page i ens carreguem l'ordinal
%%  % pesquem la branca ...
%%  /iDimoni 0 def
%%  {  % loop d'interrogacio dels dicts de COMdimoni
%%   currentdict iDimoni 4 string cvs cvn get
%%   % el diccionari de l'objecte
%%   dup actGina known {actGina get exit}{pop}ifelse 
%%   iDimoni 1 add /iDimoni exch def
%%   iDimoni MaxDimoni eq {exit} if
%%  } loop  % d'interrogacio dels dicts de COMdimoni
%%  /Resources get dup type /nametype eq
%%  {
%%   /aCercar exch def  % nom amb la ref ind del dic Resources
%%   /iDimoni 0 def
%%   {  % loop d'interrogacio dels dicts de COMdimoni
%%    currentdict iDimoni 4 string cvs cvn get
%%    % el diccionari de l'objecte
%%    dup aCercar known {aCercar get exit}{pop}ifelse
%%    iDimoni 1 add /iDimoni exch def
%%    iDimoni MaxDimoni eq {exit} if
%%   } loop  % d'interrogacio dels dicts de COMdimoni
%%  }if

%% ara no cal, doncs ja ho hem fet abans
%% farcim l'array totalRSRCS, ara si, amb el total de Resources (Pagina+Patterns&Shadings)
%% RSRCS
%% /aVeure exch def
%%dup length 1 add dup 1 sub /Dmes exch def
%%array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
%% /totalRSRCS exch def  % redesem el paquet ampliat amb el total de Resources (Pagina+Patterns&Shadings)

/totalEstatsG << >> def  %% diccionari ampliat amb el total d'Estats Grafics (Pagina+Patterns&Shadings)
/totalEspaisDeC << >> def  %% diccionari ampliat amb el total d'Espais de Color (Pagina+Patterns&Shadings)
%%% ATENCIO! AQUESTA ARRAY DE DICS NO ES PAGINADA!!!!
totalRSRCS
{  %% forall x explorar els Estats Grafics i Espais de Color de tots els Resources utilitzats (Pagina+Patterns&Shadings)
 dup dup /ExtGState known  %% si al dic Resources no hi ha aquesta entrada ...
 {  %% donem un error a XRay?
  /ExtGState get dup type /nametype eq
  {
   /aCercar exch def  %% nom amb la ref ind del dic Resources
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup aCercar known {aCercar get exit}{pop}ifelse
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
  }if
  dup /EstatsG exch def  %% desem el dic dels Estats Grafics x us + endavant
  {  %% forall on explorem tot el dic per classificar a XRay els Estats Grafics en Utilitzats, NoUtilitzats i Desconeguts
   pop XRay /EstatsGrafics get /Desconeguts get exch 2 copy known
   {  %% si hi es el donem d'alta a Utilitzats i el donem de baixa a Desconeguts
    dup XRay /EstatsGrafics get /Utilitzats get exch null put undef
   }
   {  %% si no hi es es que l'Estat Grafic no ha estat utilitzat en aquest document ...
    dup XRay /EstatsGrafics get /Utilitzats get exch known
    {  %% ... tret que (pel fet q ara som dins un forall) ja estigui a Utilitzats
     pop pop
    }
    {
     XRay /EstatsGrafics get /NoUtilitzats get exch null put pop
    } ifelse
   }ifelse
  }forall
  %% incrustem a sac totes les claus/valor del dic d'estats grafics concret al dic ampliat (Pagina+Patterns&Shadings)
  EstatsG
  {  %% ens refiem que no hi hauran noms repetits ...
   totalEstatsG 3 1 roll put
  }forall
 }
 {
  pop  %% ens carreguem un dels dics de Resources
  null /EstatsG exch def  %% desem un null x fer les comprovacions + endavant (ara sembla que no serveix per a res)
 }ifelse

 %#%30% explorem els Espais de Color del document
 (%#%30%)==
 dup /ColorSpace known  %% si al dic Resources no hi ha aquesta entrada, no donarem cap error doncs podria tenir colors CMYK definits de forma directe ...
 {
  dup /Pattern known
  {
   dup /Pattern get length 0 eq {/pAtrO false def}{/pAtrO true def}ifelse
  }
  {
   /pAtrO false def
  }ifelse  %% l'entrada Pattern a Resources es tractada com un Espai de Color per cs/CS
  /ColorSpace get dup type /nametype eq
  {
   /aCercar exch def  %% nom amb la ref ind del dic Resources
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup aCercar known {aCercar get exit}{pop}ifelse
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
  }if
  dup /EspaisDeC exch def  %% desem el dic dels Espais de Color x us + endavant
  {  %% forall on explorem tot el dic per classificar a XRay els Espais de Color en Utilitzats, NoUtilitzats i Desconeguts
   /esBo true def  %% gatell x saber si l'espai de color explorat s'adiu als permesos
   exch /NomIntern exch def  %% desem el nom intern de l'espai de color
   dup type /nametype eq
   {
    %% ens assegurem que no sigui un nom directe d'un Device Color Space
    dup <</DeviceGray null /DeviceRGB null /DeviceCMYK null /Pattern null>> exch known
    {
     dup /TEcolor exch def  %% desem el tipus d'espai de color
     /NoName0 /NomExtern exch def  %% desem aquest nom de color anonim
    }
    {  %% en cas que l'array de l'espai de color no sigui directe l'anem a pescar
     /aCercar exch def
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }ifelse
    %% ens tornem a assegurar que no sigui un nom de Device Color Space ... imagina't # # obj /DeviceRGB endobj ...
    %% o ... # # obj [/DeviceRGB] endobj
    %% si es una array ens assegurem que nomes tingui 1 sol element (2 seria una array de color tipica!)
    dup type /arraytype eq {dup length 1 eq {0 get}if}if
    %% ens assegurem que no sigui un nom directe d'un Device Color Space
    dup <</DeviceGray null /DeviceRGB null /DeviceCMYK null /Pattern null>> exch known
    {
     dup /TEcolor exch def  %% desem el tipus d'espai de color
     /NoName1 /NomExtern exch def  %% desem aquest nom de color anonim
     /araRay null def  %% si no hi ha array de color li posem un null x saber que duu un nom Device Color Space
    }
    {
     %% es l'array de color
     dup 1 get /NomExtern exch def
     dup /araRay exch def  %% l'array del color
     0 get dup /TEcolor exch def  %% n'extraiem el tipus d'espai de color
    }ifelse
   }
   {  %% si no es un nom es una array segur
    dup 1 get /NomExtern exch def
    dup /araRay exch def  %% l'array del color
    0 get dup /TEcolor exch def  %% n'extraiem el tipus d'espai de color
   }ifelse    
   NomExtern exch
   NomIntern  %% deixem el nom intern (els que es cridat per cs/CS x fer les comprovacions)
   XRay /EspaisDeColor get /Desconeguts get exch 2 copy known
   {  %% si hi es el donem d'alta a Utilitzats i el donem de baixa a Desconeguts
    2 copy get
    %% atencio xq aqui els espais de color tenen aspecte divers si han estat desats inicialment a partir dels operadors de contents o per XObject
    dup type /arraytype eq
    {
     /TanX100 exch def  %% arrepleguem l'array amb els strings dels % de colors diferents usats x aquest espai
     << >> /Paleta exch def  %% dic nou de trinca
    }
    {
     dup /Paleta get /Paleta exch def
     /TanX100 get /TanX100 exch def  %% arrepleguem l'array amb els strings dels % de colors diferents usats x aquest espai
    } ifelse
    dup XRay /EspaisDeColor get /Utilitzats get exch 5 -1 roll
    %% creem el dic sota el nom intern i ara hi desem el tipus d'espai de color, el seu nom extern, l'array de valors de % usats i el dic buit de la paleta que muntarem + endavant un cop interroguem les TypeFunction
    <<>> dup 3 -1 roll /Tipus exch put  %% desem el tipus d'espai de color
    dup /NomExtern NomExtern put  %% desem el seu nom extern (el que es visualitza a l'Output Preview)
    dup /Paleta Paleta put  %% arrosseguem el dic on desem la gamma de color de cada Pantone
    dup /TanX100 TanX100 put  %% desem al dic l'array amb els strings dels % de colors diferents
    put  %% desem a Utilitzats el dic sota el NomIntern del color amb totes les dades
    undef  %% donem de baixa a Desconeguts
    TEcolor /Separation eq
    {  %% si es una separacio la desem amb parell nom extern/nom intern
     XRay /Separacions get exch NomIntern put
    }
    {
     pop
    }ifelse
   }
   {  %% si no hi es, es que l'Espai de Color no ha estat utilitzat en aquest document ...
    dup XRay /EspaisDeColor get /Utilitzats get exch known
    {  %% ... tret que (pel fet q ara som dins un forall) ja estigui a Utilitzats
     pop pop pop pop
    }
    {
     XRay /EspaisDeColor get /NoUtilitzats get exch 4 -1 roll put pop
     TEcolor /Separation eq
     {  %% si es una separacio la desem amb parell nom extern/nom intern
      XRay /Separacions get exch NomIntern put
     }
     {
      pop
     }ifelse
    }ifelse
   }ifelse
   %% nomes si existeix a Utilitzats o a Separacions ...
   XRay /EspaisDeColor get /Utilitzats get NomIntern known
   dup /cUt exch def  %% gatell que ens dira si es a utilitzats x anar-hi a pescar la Paleta de colors + endavant o no
   /HiEs false def XRay /Separacions get
   {
    NomIntern eq {pop /HiEs true def exit}{pop}ifelse
   }forall
   HiEs or  %% avaluem els logics (un dels dos o els dos han de ser certs)
   {  %% detectem els espais de color directes que no siguin o Separation/DeviceN/Pattern i els desem a Errades
    <<  %% diccionari dels espais de color directes no suportats amb el text del seu error associat
      /CalGray ( CIE CalGray Color Space Not Supported)
      /CalRGB ( CIE CalRGB Color Space Not Supported)
      /Lab ( CIE Lab Color Space Not Supported)
      /ICCBased ( CIE ICCBased Color Space Not Supported)
      /Indexed ( Indexed Color Space Not Supported)
      %% /Pattern ( Pattern Color Space Not Supported)
    >> dup
    TEcolor known
    {  %% desem l'error a Errades sota el nom intern (segons l'espai de color el nom extern no existeix)
     TEcolor get XRay /EspaisDeColor get /Errades get exch NomIntern exch put
     %% i el donem de baixa a Utilizats i Separacions (no cal comprovar l'undef)
     XRay /EspaisDeColor get /Utilitzats get NomIntern undef
     XRay /Separacions get NomIntern undef
     /esBo false def  %% invalidem el gatell
    }
    {  %% filtrem la resta Separation/DeviceN i ens assegurem que l'espai de color alternatiu es /DeviceCMYK
     pop
     araRay type /nulltype eq
     {
      <<
%%        /DeviceGray ( DeviceGray Color Space Not Supported)
        /DeviceRGB ( DeviceRGB Color Space Not Supported)
      >> dup TEcolor known
      {
       %% sobreixidor x saber on es crida l'espai de color q encara no tractem
       %%(-- AQUI es crida:EspaiDcolor: DeviceRGB) ==
       TEcolor get
       XRay /EspaisDeColor get /Errades get
       exch NomIntern exch put
       %% i el donem de baixa a Utilizats i Separacions (no cal comprovar l'undef)
       XRay /EspaisDeColor get /Utilitzats get NomIntern undef
       XRay /Separacions get NomIntern undef
       /esBo false def  %% invalidem el gatell
      }
      {
       pop
      }ifelse
     }
     {  %% l'espai de color alternatiu es CMYK ?
      araRay 0 get /Pattern eq
      {  %% si es un Pattern ...
       araRay 1 get type /nametype eq
       {
        araRay 1 get
        dup length 16 eq
        {
         dup 16 string cvs 10 get 95 eq{true}{false}ifelse
        }
        {
         false
        }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
        {  %% primer descartem que no sigui una ref ind
         /aCercar exch def
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
        } if
        dup type /arraytype eq
        {  %%  o una array INdirecte de color (/DeviceN o /Separation)
         %% nomes comprovarem es a /ColorSpace i si l'espai de color altrernatiu es CMYK
         /NoHiEs true def
         EspaisDeC
         {
          aCercar eq {/NoHiEs false def /cNomIntern exch def exit}{pop}ifelse
         }forall
         NoHiEs
         {  %% si no es a /ColorSpace de Resources l'afegim al dic /Utilitzats d'EspaisDeColor
          /araRay exch def
          <</DeviceN null /Separation null>>
          araRay 0 get known
          {  %% primer comprovem si te un alternateSpace tipus /DeviceCMYK
           araRay 2 get /DeviceCMYK eq
           {  %% si es CMYK el donem d'alta als Utilitzats
            araRay 0 get /Separation eq
            {
             XRay /Separacions get aCercar araRay 1 get put  %% afegim el parell nom intern/nom extern
             XRay /EspaisDeColor get /Utilitzats get
             aCercar %% de nom intern
             <<
               /Tipus araRay 0 get /NomExtern araRay 1 get /FTipus null
    	       /Paleta << >>
 	       /TanX100 []
             >> put
            }
            {
             araRay length 5 eq
             {  %% comprovem si no fos del nou tipus de DeviceN ...
              XRay /EspaisDeColor get /Errades get aCercar ( DeviceN Color Space with NChannel Not Supported) put
             }
             {
              XRay /EspaisDeColor get /Utilitzats get
              aCercar  %% de nom intern
              <<
                /Tipus araRay 0 get /NomExtern araRay 1 get /FTipus null
                /Paleta << >>
                /TanX100 []
              >> put
             }ifelse
            }ifelse
           }
           {  %% si no es CMYK el passem a Errades a EspaisDeColor
            XRay /EspaisDeColor get /Errades get aCercar ( Color Space Not Supported) put
           }ifelse
          }
          {  %% si no es cap dels dos el passem a Errades a EspaisDeColor
           XRay /EspaisDeColor get /Errades get aCercar ( Color Space Not Supported) put
          }ifelse
         }
         {  %% aqui nomes comprovarem la validesa de l'espai de color i el seu alternatiu ...
          /araRay exch def
          <</DeviceN null /Separation null>>
          araRay 0 get known
          {  %% comprovem si te un alternateSpace tipus /DeviceCMYK
           araRay 2 get /DeviceCMYK eq
           {  %% comprovem que no estigui a Utilitzats x donar-lo d'alta
            XRay /EspaisDeColor get /Utilitzats get cNomIntern known not
            {
             XRay /EspaisDeColor get /Utilitzats get NomIntern get /TanX100 get  %% capturem l'array de % de l'espai de color corresponent al Pattern x pasar-lo al seu underlying
             dup /Ax100 exch def
             {  %% forall x tots els strings de valors de l'array
              cvx exec
              faPaletaCMYK2Hexa
              4 array astore {100 mul} forall  %% desem en una array els valors CMYK passats a %
              4 array astore
             } forall  %% com que nomes hi ha d'haver una sola string a l'array TanX100 aquest forall es inofensiu ¿?
             /elVALDels8vals exch def
             XRay /EspaisDeColor get /Utilitzats get
             cNomIntern  %% de nom intern
             <<
               /Tipus araRay 0 get /NomExtern araRay 1 get /FTipus null
 	       /Paleta << els8vals elVALDels8vals >>
               /TanX100 Ax100
             >> put
            }if
           }
           {  %% si no es CMYK el passem a Errades a EspaisDeColor
            XRay /EspaisDeColor get /Errades get aCercar ( Alternate Space for Underlying Color Space Not Supported) put
           }ifelse
          }
          {  %% si no es cap dels dos el passem a Errades a EspaisDeColor
           XRay /EspaisDeColor get /Errades get aCercar ( Underlying Color Space Not Supported) put
          }ifelse
         }ifelse
         %% reincrustem a l'array del Pattern el nom extern de l'Espai de Color utilitzat
         XRay /Patterns&Shadings get /Utilitzats get
         {
          exch pop dup 2 get NomIntern eq {2 araRay 1 get put}{pop}ifelse
         }forall
         XRay /EspaisDeColor get /Utilitzats get dup NomIntern null put  %% li posem ara un null com a valor que indica q es un Pattern ...
         /Pattern null put  %% ... i en donem d'alta un de generic
         /esBo false def  %% desactivem pel control de funcions de color
        }
        {
         dup /DeviceCMYK eq
         {
          pop
          XRay /EspaisDeColor get /Utilitzats get NomIntern  %% capturem l'array de % de l'espai de color corresponent al Pattern x pasar-lo al seu underlying
          get /TanX100 get dup /Ax100 exch def  %% no em fem res ara
          {  %% forall x tots els strings de valors de l'array
           cvx exec
           faPaletaCMYK2Hexa
           4 array astore {100 mul} forall  %% desem en una array els valors CMYK passats a %
           4 array astore
          } forall  %% com que nomes hi ha d'haver una sola string a l'array TanX100 aquest forall es inofensiu ¿?
          /elVALDels8vals exch def  %% no em fem res ara
          XRay /EspaisDeColor get /Utilitzats get dup
          /NoName9 known
          {
           /NoName9 get /Paleta get
           els8vals /Directe put  %% el valor /Directe es importantissim xq despres es pugui bastir l'array de valors TanX100 correctament
          }
          {
           /NoName9 <<
                      /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
                      /Paleta << els8vals /Directe >>  %% el valor /Directe es importantissim xq despres es pugui bastir l'array de valors TanX100 correctament (aqui com q es nova la deixem buida)
                      /TanX100 []
                    >> put
          } ifelse
          %% reincrustem a l'array del Pattern el nom extern de l'Espai de Color /DeviceCMYK utilitzat
          XRay /Patterns&Shadings get /Utilitzats get
          {
           exch pop dup 2 get NomIntern eq
           {2 /DeviceCMYK put}{pop}ifelse
          }forall
          XRay /EspaisDeColor get /Utilitzats get dup NomIntern null put  %% li posem ara un null com a valor que indica q es un Pattern ...
          /Pattern null put  %% ... i en donem d'alta un de generic
          /esBo false def  %% desactivem pel control de funcions de color
         }
         {  %% solucio DeviceGray
          dup /DeviceGray eq
          {
           pop
           XRay /EspaisDeColor get /Utilitzats get NomIntern  %% capturem l'array de % de l'espai de color corresponent al Pattern x pasar-lo al seu underlying
           get /TanX100 get dup /Ax100 exch def  %% no em fem res ara
           {  %% forall x tots els strings de valors de l'array
            cvx exec
            faPaletaG2Hexa
            4 array astore {100 mul} forall  %% desem en una array els valors CMYK passats a %
            4 array astore
           } forall  %% com que nomes hi ha d'haver una sola string a l'array TanX100 aquest forall es inofensiu ¿?
           /elVALDels8vals exch def  %% no em fem res ara
           XRay /EspaisDeColor get /Utilitzats get dup
           /DeviceGray known
           {
            /DeviceGray get /Paleta get
            els8vals /Directe put  %% el valor /Directe es importantissim xq despres es pugui bastir l'array de valors TanX100 correctament
           }
           {
            /DeviceGray
            <<
              /Tipus /PureCMYK /NomExtern /Black /FTipus null
              /Paleta << els8vals /Directe >>  %% el valor /Directe es importantissim xq despres es pugui bastir l'array de valors TanX100 correctament (aqui com q es nova la deixem buida)
              /TanX100 []
            >> put
           } ifelse
           %% reincrustem a l'array del Pattern el nom extern de l'Espai de Color /DeviceGray utilitzat
           XRay /Patterns&Shadings get /Utilitzats get
           {
            exch pop dup 2 get NomIntern eq
            {2 /DeviceGray put}{pop}ifelse
           }forall
           XRay /EspaisDeColor get /Utilitzats get dup NomIntern null put  %% li posem ara un null com a valor que indica q es un Pattern ...
           /Pattern null put  %% ... i en donem d'alta un de generic
           /esBo false def  %% desactivem pel control de funcions de color
           %% solucio DeviceGray
          }
          {  %% passem a Errades tot el que no sigui DeviceGray o DeviceCMYK ...
           <<
             %% /DeviceGray ( DeviceGray Color Space Not Supported)
             /DeviceRGB ( DeviceRGB Color Space Not Supported)
           >>
           dup 2 index known
           {
            %% sobreixidor x saber on es crida l'espai de color q encara no tractem
            %%(-- AQUI es crida:EspaiDcolor2: DeviceRGB) ==
            exch get
            XRay /EspaisDeColor get /Errades get
            exch NomIntern exch put
            %% i el donem de baixa a Utilizats i Separacions (no cal comprovar l'undef)
            XRay /EspaisDeColor get /Utilitzats get NomIntern undef
            XRay /Separacions get NomIntern undef
            /esBo false def  %% invalidem el gatell
           }
           {
            pop 128 string cvs dup length dup 38 add string dup 4 -1 roll 1 exch putinterval
            dup 3 -1 roll 1 add ( Underlying Color Space Not Supported) putinterval
            XRay /EspaisDeColor get /Errades get
            NomIntern 3 -1 roll put
            %% i el donem de baixa a Utilizats i Separacions (no cal comprovar l'undef)
            XRay /EspaisDeColor get /Utilitzats get NomIntern undef
            XRay /Separacions get NomIntern undef
            /esBo false def  %% invalidem el gatell
           }ifelse
          }ifelse
         }ifelse
        }ifelse
       }
       {  %%  o una array directe de color (/DeviceN o /Separation)
        araRay 1 get /araRay exch def  %% capturem l'array directe de l'underlying color space
        <</DeviceN null /Separation null>>
        araRay 0 get known
        {  %% comprovem si te un alternateSpace tipus /DeviceCMYK
         araRay 2 get /DeviceCMYK eq
         {
          araRay dup 0 get /DeviceN eq
          {  %% numerem l'array DeviceN directe     
           /araRay exch def
           XRay /EspaisDeColor get /Utilitzats get NomIntern get /TanX100 get  %% capturem l'array de % de l'espai de color corresponent al Pattern x pasar-lo al seu underlying
           dup /Ax100 exch def
           {  %% forall x tots els strings de valors de l'array
            cvx exec
            faPaletaCMYK2Hexa
            4 array astore {100 mul} forall  %% desem en una array els valors CMYK passats a %
            4 array astore
           } forall  %% com que nomes hi ha d'haver una sola string a l'array TanX100 aquest forall es inofensiu ¿?
           /elVALDels8vals exch def
           iAdirecte 6 string cvs dup length 13 add string dup dup
           0 (directDeviceN) putinterval 3 -1 roll 13 exch putinterval cvn
           %% deixem el nom numerat de directDeviceN a la pila i l'incrustem com a un nou espai de color a Utilitzats
           XRay /EspaisDeColor get /Utilitzats get exch dup /nomECad exch def
           <<
             /Tipus /directDeviceN /NomExtern araRay 1 get /FTipus null
 	     /Paleta << els8vals elVALDels8vals >>
             /TanX100 Ax100
           >> put
          }
          {  %% hauria de ser una Separation ...
           /araRay exch def
           XRay /EspaisDeColor get /Utilitzats get NomIntern get /TanX100 get  %% capturem l'array de % de l'espai de color corresponent al Pattern x pasar-lo al seu underlying
           dup /Ax100 exch def
           {  %% forall x tots els strings de valors de l'array
            cvx exec
            faPaletaCMYK2Hexa
            4 array astore {100 mul} forall  %% desem en una array els valors CMYK passats a %
            4 array astore
           } forall  %% com que nomes hi ha d'haver una sola string a l'array TanX100 aquest forall es inofensiu ¿?
           /elVALDels8vals exch def
           iAdirecte 6 string cvs dup length 16 add string dup dup
           0 (directSeparation) putinterval 3 -1 roll 16 exch putinterval cvn
           %% deixem el nom numerat de directSeparation a la pila i l'incrustem com a un nou espai de color a Utilitzats
           XRay /EspaisDeColor get /Utilitzats get exch dup /nomECad exch def
           <<
             /Tipus /directSeparation /NomExtern araRay 1 get /FTipus null
             /Paleta << els8vals elVALDels8vals >>
             /TanX100 Ax100
           >> put
           %% donem d'alta la separacio ...
           XRay /Separacions get nomECad araRay 1 get put
          }ifelse
          %% reincrustem a l'array del Pattern el nom extern de l'Espai de Color utilitzat
          XRay /Patterns&Shadings get /Utilitzats get
          {
           exch pop dup 2 get NomIntern eq {2 araRay 1 get put}{pop}ifelse
          }forall
          XRay /EspaisDeColor get /Utilitzats get dup NomIntern null put  %% li posem ara un null com a valor que indica q es un Pattern ...
          /Pattern null put  %% ... i en donem d'alta un de generic
          /esBo false def  %% desactivem pel control de funcions de color
         }
         {  %% si no es CMYK el passem a Errades d'EspaisDeColor
          iAdirecte 6 string cvs dup length 13 add string dup dup
          0 (direct_Carray) putinterval 3 -1 roll 13 exch putinterval cvn
          %% deixem el nom numerat de l'array de color generic (direct_Carray) a la pila i l'incrustem com a un nou espai de color a Errades
          XRay /EspaisDeColor get /Errades get exch ( Alternate Space for Underlying Color Space Not Supported) put
         }ifelse
        }
        {  %% si no es cap dels dos el passem a Errades d'EspaisDeColor
         iAdirecte 6 string cvs dup length 13 add string dup dup
         0 (direct_Carray) putinterval 3 -1 roll 13 exch putinterval cvn
         %% deixem el nom numerat de l'array de color generic (direct_Carray) a la pila i l'incrustem com a un nou espai de color a Errades
         XRay /EspaisDeColor get /Errades get exch ( Underlying Color Space Not Supported) put
        }ifelse
        iAdirecte 1 add /iAdirecte exch def  %% numerador per les arrays de color directes
       }ifelse
      }
      {  %% no es un Pattern ...
       araRay 2 get dup type /arraytype eq
       {  %% es dins una array directe
        0 get dup
       }
       {  %% si es un nom, descartem que no sigui una ref ind
        dup length 16 eq
        {
         dup 16 string cvs 10 get 95 eq{true}{false}ifelse
        }
        {
         false
        }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
        {
         /aCercar exch def
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
         dup type /arraytype eq {0 get dup}{dup}ifelse
        }
        {
         dup
        }ifelse
       }ifelse
       /DeviceCMYK eq
       {
        pop
       }  %% si ho es cap publema!
       {  %% desem l'error de l'espai de color alternatiu invalid
        XRay /EspaisDeColor get /Errades get exch
        NomIntern exch 128 string cvs dup length dup 1 add /sFa exch def 37 add string dup dup 0 ( ) putinterval
        3 -1 roll 1 exch putinterval dup sFa ( Alternate Color Space Not Supported) putinterval put
        %% i el donem de baixa a Utilizats i Separacions (no cal comprovar l'undef)
        XRay /EspaisDeColor get /Utilitzats get NomIntern undef
        XRay /Separacions get NomIntern undef
        /esBo false def  %% invalidem el gatell
       }ifelse
       araRay 0 get /DeviceN eq
       {  %% descartem per ara els nous DeviceN de l'1.6 definits amb NChannel
        araRay length 5 eq
        {
         XRay /EspaisDeColor get /Errades get NomIntern ( DeviceN Color Space with NChannel Not Supported) put
         %% i el donem de baixa a Utilizats i Separacions (no cal comprovar l'undef)
         XRay /EspaisDeColor get /Utilitzats get NomIntern undef
         XRay /Separacions get NomIntern undef
         /esBo false def  %% invalidem el gatell
        }if
       }if
      } ifelse
     }ifelse
    }ifelse
   }
   {
    /esBo false def  %% com que no existeix ni a Utilitzats ni a Separacions, invalidem el gatell
   }ifelse
   /nSp (0) def  %% posem un valor inicial i generic al pestell que indica el tipus d'error de la Funcio de Color (voldra dir que peta alguna pijada d'entremig)
   %% aqui ja estem segurs que l'espai de color es valid (o sigui un CMYK pur definit amb una array de 4 elements o amb color directe que detectem per un null a araRay)
   %% i llavors NOMES a Utilitzats (cUt) anem a buscar l'objecte del Tint Transform (x procedir + tard al farciment de la gamma de colors utilitzats ... )
   esBo cUt and  %% nomes si els dos son certs ... (espai de color valid i existent a Utilitzats) ... li farcim la Paleta de colors
  {
   araRay type /nulltype eq
   {  %% es un color CMYK definit directament (sense un valor d'array des ColorSpace o no)
    %%% de moment no fem res aqui
   }
   {  %% definit amb un valor d'array des ColorSpace
    araRay 3 get  %% anem a pescar el dic directe del TintTransform
    dup type /nametype eq
    {  %% es una ref ind o un dic directe ?
     /aCercar exch def
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }if
    dup /FunctionType get
    [
     {  %% Tipus 0 ...
      {  %% stopped
       %% 1.Que BitsPerSample sigui 8 (valors de 0 a 255)
       dup /BitsPerSample get 8 ne {clear /nSp (1) def stop}if
       %% 2.Que Range tingui 8 elements a l'array (2 valors x 4 canals de sortida)
       dup /Range get length 8 ne {clear /nSp (2) def stop}if
       %% 3.Que el resultat de la suma dels elements de l'array Size sigui igual que el nombre d'elements de l'array Encode (si hi es) dividit x 2!)
       dup dup /Size get
       length /sSize exch def exch /Encode known
       {
        dup /Encode get length 2 idiv sSize ne
        {clear /nSp (4) def stop}if
       } if
       XRay /EspaisDeColor get /Utilitzats get
       NomIntern get /TanX100
       get length 0 eq
       {  %% si l'array es buida aquest espai de color deu correspondre exclusivament a una imatge (inLine o XObject?)
        /execFunk false def  %% executarem la funcio d'equivalencia a CMYK ?
        XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
	/Utilitzats get
        {  %%  forall
         dup type /arraytype eq
         {  %% es un XObject
          pop
          /NomXobject exch def
          XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /dicEC exch def
          /Paleta get NomXobject known
          {  %% si l'espai de color que explorem es el de la imatge XObject, n'esbrinem el nombre de components
           %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
           %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
           dicEC /NomExtern get dup type /arraytype eq
           {length}{pop 1}ifelse /ComFaciFalta exch def
           NomXobject /LiTeRaLS exch def
           LiTeRaLS dup length 2 add dup /aDeS exch def string dup
           3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
           /iaRa exch def
           aDeS  %%4
           ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
           mul string /aDesiaRa exch def
           aDesiaRa /NullEncode filter
           ComFaciFalta {dup iaRa writestring} repeat
           closefile 
           [ aDesiaRa ]
           XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
          }
          {  %% si no, no fem res
          }ifelse
          %%pstack (XObject que te un espai de color exclusiu per a ell!) == quit
         }
         {  %% es una inLine
          dup /CS known {/CS get NomIntern eq}{false}ifelse
          {  %% si l'espai de color que explorem es el de la imatge inLine, n'esbrinem el nombre de components
           XRay /EspaisDeColor get /Utilitzats get NomIntern get /NomExtern get
           dup type /nametype eq
           {  %% es un nom en solitari d'una /Separation
            %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
            %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
            pop 1 /ComFaciFalta exch def
            /LiTeRaLS exch def
            LiTeRaLS dup length 2 add dup /aDeS exch def string dup
            3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
            /iaRa exch def
            aDeS  %%4
            ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
            mul string /aDesiaRa exch def
            aDesiaRa /NullEncode filter
            ComFaciFalta {dup iaRa writestring} repeat
            closefile pop [ aDesiaRa ] dup
            XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
           }
           {  %% es una array de noms d'un DeviceN
            %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
            %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
            length /ComFaciFalta exch def
            /LiTeRaLS exch def
            LiTeRaLS dup length 2 add dup /aDeS exch def string dup
            3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
            /iaRa exch def
            aDeS  %%4
            ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
            mul string /aDesiaRa exch def
            aDesiaRa /NullEncode filter
            ComFaciFalta {dup iaRa writestring} repeat
            closefile pop [ aDesiaRa ] dup
            XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
           }ifelse
          }
          {  %% si no, no fem res
           pop
          }ifelse
         }ifelse
        }forall
       }
       {
        /execFunk true def  %% executarem la funcio d'equivalencia a CMYK ?
       }ifelse
       %% 4.El nombre de valors numerics (ha de ser identic x a tots els strings) de qualsevol dels strings de l'array /TanX100 de gamma de colors ha de ser igual al nombre de valors de l'array Size
       dup XRay /EspaisDeColor get /Utilitzats get NomIntern get /TanX100 get
       %% per saber si totes les strings de l'array tenen els mateixos elements i quants son (Mesclen)
       /iM 0 def /Idem true def
       {  %% forall
        /Mesclen 0 def
        {
         ( ) search {pop pop Mesclen 1 add /Mesclen exch def}{pop exit}ifelse
        } loop
        iM 1 add /iM exch def
        iM 1 gt {Mesclen AMesclen ne{/Idem false def}if}if
        Mesclen /AMesclen exch def							    
       }forall
       Idem
       {  %% es igual al nombre de valors de l'array Size ?
        /Size get length Mesclen ne {clear /nSp (5) def stop}if
       }
       {
        clear /nSp (6) def stop
       }ifelse
       %% continuem tenint el dic de l'objecte de la funcio a la pila ...
       %% Per procedir al calcul fem:
       %% 1.Decodifiquem l'stream associat al diccionari (a fitxer o string?) ... si petes passariem aquest espai a Errors
       dup dup /Filter known
       {  %% fitxer stream amb algun tipus de filtre
        dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
	
     dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
     dup /DecodeParms known exch /DP known 2 copy or
     {
      {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
      {
       [ exch [ exch filtresstream ] ] /filtresstream exch def
      }
      {  %% es una array
       %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
       dup length filtresstream length ne
       {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
        (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
       }if
       /iDPF 0 def
       [ exch
        {  %% forall
         dup null eq
         {
          pop [filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }
         {
	  [exch filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }ifelse
        }forall
       ]
       /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
      }ifelse
     }
     {
      pop pop  %% ens carreguem els logics
      pop  %% ens carreguem el dic
      %% avaluem filtresstream per redefinir-lo com cal per /filtRa
      filtresstream type /arraytype eq
      {
       [filtresstream] /filtresstream exch def
      }
      {
       [[filtresstream]] /filtresstream exch def
      }ifelse
     }ifelse
	
        dadesstream
        %% comprovem si l'stream es un path dins una array o una string de dades directe
        type /arraytype eq
        {
         dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
        }
        {  %% convertim a fitxer de la cadena sense decodificar
         dadesstream 0 () /SubFileDecode filter
        } ifelse
        filtresstream
(F6) ==
	filtRa  %% decodifiquem el fitxer stream
        %% a l'estar filtrat el repiquem al disc
        funKy (w) file /REPIcA exch def
        {  %% loop
         dup
         65535 string readstring
         {
          REPIcA exch writestring
         }
         {
          REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit
         }ifelse
        }loop
        funKy dup
        status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
        (r) file /aLLeGiR exch def
       }
       {  %% fitxer stream sense filtres
        /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
        dadesstream  %% tibem el fitxer stream sense decodificar
        %% comprovem si l'stream es un path dins una array o una string de dades directe
        type /arraytype eq
        {
         dadesstream 0 get
         dup
         status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
         (r) file /aLLeGiR exch def
        }
        {  %% convertim a fitxer de la cadena sense decodificar
         dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
         0 () /SubFileDecode filter /aLLeGiR exch def
        } ifelse
       }ifelse
       %% 2.JA NO Dividirem per 2 la suma dels elements de l'array Size, doncs ja ens diu el nombre d'espais de color que intervenen en la mescla
       sSize  %%2 idiv
       /NeC exch def  %% nombre d'espais de color que intervenen en la mescla
       %% 3.Com que encara no sabem ben be com juguen els parells de valors dels arrays Range i Domain (cal fer un PDF de proves x esbrinar-ho), ara ens limitem a assegurar-nos que tenen exclusivament els valors 0 i 1 (si no ho passarem a Errors)
       dup /Range get
       /NOzerou false def
       /aRa 0 def
       {
        aRa ne {/NOzerou true def exit}if
        aRa 0 eq {/aRa 1 def}{/aRa 0 def}ifelse
       }forall
       NOzerou {clear /nSp (8) def stop}if
       /Domain get
       /NOzerou false def
       /aRa 0 def
       {
        aRa ne {/NOzerou true def exit}if
        aRa 0 eq {/aRa 1 def}{/aRa 0 def}ifelse
       }forall
       NOzerou {clear /nSp (9) def stop}if
       %% 4.Llegirem l'stream byte a byte en grups de 4 (CMYK) establint (per a cada espai de color que mescla que correspondra a cada string de l'array /TanX100) el seu valor /cfC /cfM /cfY /cfK (o sigui nomes final)
       /cC 0 def
       /4C [/cfC /cfM /cfY /cfK] def
       /dicPal << >> def  %% diccionari on hi hauram numerats els dics amb els valors CMYK (finals) dels components de l'espai
       NeC
       {  %% repeat, a l'stream d'una FunctionType 0 hi ha tants parells de 4 bytes com elements de color (calor NeC) componguin l'espai
        4{aLLeGiR read pop pop}repeat  %% llencem els 4 bytes corresponents als valors d'inici
        /icC 0 def
        4
        {  %% repeat
         icC 0 eq {dicPal begin cC 2 string cvs cvn <<>>def end}if
         dicPal cC 2 string cvs cvn get
         aLLeGiR read pop 4C icC get exch put
         icC 1 add /icC exch def
        }repeat  %% desem els 4 bytes corresponents als valors finals a un dic numerat dins dicPal
        cC 1 add /cC exch def
       }repeat
       %% el punt 5 i 6 els haurem de repetir x cada string de l'array TanX100 ...
       XRay /EspaisDeColor get /Utilitzats get NomIntern get /TanX100 get
       execFunk
       {  %% executem la funcio d'equivalencia a CMYK ?
        {  %% forall x cada un dels strings de l'array
         dup (/) search {pop pop pop true}{pop false}ifelse  %% x filtrar els espais de color compartits vectorials/imatges
         {
          pop
         }  %% es un literal d'una imatge
         {  %% es un nombre ...
          /cC 0 def
          %% 5.Com que amb Domain/Range treballem amb 0/1 (i nomes considerem els valors finals) multipliquem el valor corresponent a cada color de mescla pel seu valor sc/SC/scn/SCN de l'string de TanX100
          {  %% aquest loop del search venta un per un, cada element (cada valor de color que composa el CS) de la cadena
           ( ) search
           {  %% cada element de l'string (x ordre) correspondra a cada subdic (x ordre) de dicPal
            exch pop cvr /aMul exch def  %% factor (valor sc/SC/scn/SCN) a multiplicar
            dicPal cC 2 string cvs cvn get
            %% multipliquem el valor x cada component CMYK i el desem de nou
            dup /cfC get aMul mul /ffC exch def
            dup /cfM get aMul mul /ffM exch def
            dup /cfY get aMul mul /ffY exch def
            /cfK get aMul mul /ffK exch def
            dicPal cC 2 string cvs cvn
            <<
              /cfC ffC
              /cfM ffM
              /cfY ffY
              /cfK ffK
            >> put
            cC 1 add /cC exch def
           }
           {
            pop exit
           }ifelse
          } loop
          %% 6.Ens quedarem amb el valor mes alt de la col·leccio de components CMYK del dicPal
          /MaxC 0 def dicPal
          {
           /cfC get dup MaxC gt {/MaxC exch def}{pop}ifelse pop
          }forall  %% avaluem el valor + alt de cyan
          /MaxM 0 def dicPal
          {
           /cfM get dup MaxM gt {/MaxM exch def}{pop}ifelse pop
          }forall  %% avaluem el valor + alt de magenta
          /MaxY 0 def dicPal
          {
           /cfY get dup MaxY gt {/MaxY exch def}{pop}ifelse pop
          }forall  %% avaluem el valor + alt de groc
          /MaxK 0 def dicPal
          {
           /cfK get dup MaxK gt {/MaxK exch def}{pop}ifelse pop
          }forall  %% avaluem el valor + alt de negre
          %% 7.Ho passarem a valors hexa com a clau del dic Paleta per l'XRay i a % en una array com a valor (per fer comparacions amb el que ens diu l'Acrobat)
          MaxC 255 div MaxM 255 div MaxY 255 div MaxK 255 div  %% deixem els 4 valors passats a 0/1 per la funcio de conversio a Hexa
          faPaletaCMYK2Hexa
          4 array astore {100 mul} forall  %% desem en una array els valors CMYK passats a %
          4 array astore
          %% 8.Desem la clau/valor de gamma al dic Paleta
          XRay /EspaisDeColor get /Utilitzats get NomIntern get /Paleta get exch els8vals exch put
         } ifelse  %% x filtrar els espais de color compartits vectorials/imatges
        } forall
       }
       {
        pop
       }ifelse  %% executem la funcio d'equivalencia a CMYK ?
      } stopped
      {
       XRay /EspaisDeColor get /Errades get NomIntern ( Color Space Function Type 0 with Invalid or Not Supported parameter   ) dup dup length 2 sub nSp putinterval put
      }if
     }  %% fi de Tipus 0

     {
      XRay /EspaisDeColor get /Errades get NomIntern ( Color Space Function Type 1 Not Supported) put
     }  %% inexistents Tipus 1

     {  %% Tipus 2 ... Cal comprovar que (si no passarem aquest espai a Errades):
      { %% stopped
       %% 1.Que Range tingui 8 elements a l'array (2 valors x 4 canals de sortida)
       dup /Range get length 8 ne {clear /nSp (1) def stop}if
       %% 2.Que l'array Domain tingui 2 elements
       dup /Domain get length 2 ne {clear /nSp (2) def stop}if
       %% 3.Que N valgui 1
       dup /N get 1 ne {clear /nSp (3) def stop}if
       %% 4.Com que encara no sabem ben be com juguen els parells de valors dels arrays Range i Domain (cal fer un PDF de proves x esbrinar-ho), ara ens limitem a assegurar-nos que tenen exclusivament els valors 0 i 1 (si no ho passarem a Errors)
       dup /Range get
       /NOzerou false def
       /aRa 0 def
       {
        aRa ne {/NOzerou true def exit}if
        aRa 0 eq {/aRa 1 def}{/aRa 0 def}ifelse
       }forall
       NOzerou {clear /nSp (4) def stop}if
       dup /Domain get
       /NOzerou false def
       /aRa 0 def
       {
        aRa ne {/NOzerou true def exit}if
        aRa 0 eq {/aRa 1 def}{/aRa 0 def}ifelse
       }forall
       NOzerou {clear /nSp (5) def stop}if
       %% 5.Que C1 existeix i tingui 4 elements
       dup dup /C1 known exch /C1 get length 4 eq {true}{false}ifelse and  %% tots dos han de ser certs x tirar endavant
       {
        {  %% stopped
         /C1 get /vfCMYK exch def
         XRay /EspaisDeColor get /Utilitzats get NomIntern get /TanX100 get
         dup length 0 eq
         {  %% si l'array es buida aquest espai de color deu correspondre exclusivament a una imatge (inLine o XObject?)
          /execFunk false def  %% executarem la funcio d'equivalencia a CMYK ?
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
	  /Utilitzats get
          {  %% forall
           dup type /arraytype eq
           {  %% es un XObject
            pop /NomXobject exch def
            XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /dicEC exch def
            /Paleta get NomXobject known
            {  %% si l'espai de color que explorem es el de la imatge XObject, n'esbrinem el nombre de components
               %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
               %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
             dicEC /NomExtern get dup type /arraytype eq
             {length}{pop 1}ifelse /ComFaciFalta exch def
             NomXobject /LiTeRaLS exch def
             LiTeRaLS dup length 2 add dup /aDeS exch def string dup
             3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
             /iaRa exch def
             aDeS  %%4
             ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
             mul string /aDesiaRa exch def
             aDesiaRa /NullEncode filter
             ComFaciFalta {dup iaRa writestring} repeat
             closefile pop [ aDesiaRa ] dup
             XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
            }
            {  %% si no, no fem res
             pop pop
            }ifelse
            %%pstack (XObject que te un espai de color exclusiu per a ell!) == quit
           }
           {  %% es una inLine
            dup /CS known {/CS get NomIntern eq}{false}ifelse
            {  %% si l'espai de color que explorem es el de la imatge inLine, n'esbrinem el nombre de components
             XRay /EspaisDeColor get /Utilitzats get NomIntern get /NomExtern get
             dup type /nametype eq
             {  %% es un nom en solitari d'una /Separation
                %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
                %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
              pop 1 /ComFaciFalta exch def
              /LiTeRaLS exch def
              LiTeRaLS dup length 2 add dup /aDeS exch def string dup
              3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
              /iaRa exch def
              aDeS  %%4
              ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
              mul string /aDesiaRa exch def
              aDesiaRa /NullEncode filter
              ComFaciFalta {dup iaRa writestring} repeat
              closefile pop [ aDesiaRa ] dup
              XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
             }
             {  %% es una array de noms d'un DeviceN
                %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
                %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
              length /ComFaciFalta exch def
              /LiTeRaLS exch def
              LiTeRaLS dup length 2 add dup /aDeS exch def string dup
              3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
              /iaRa exch def
              aDeS  %%4
              ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
              mul string /aDesiaRa exch def
              aDesiaRa /NullEncode filter
              ComFaciFalta {dup iaRa writestring} repeat
              closefile pop [ aDesiaRa ] dup
              XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
             }ifelse
            }
            {  %% si no, no fem res
             pop
            }ifelse
           }ifelse
          }forall
         }
         {
          /execFunk true def  %% executarem la funcio d'equivalencia a CMYK ?
         }ifelse
         execFunk
         {  %% executem la funcio d'equivalencia a CMYK ? 
          {  %% forall
             %% x descartar les arrays que duen valors compartits amb imatges
           cvx exec dup type /nametype eq
           {pop}  %% es un literal d'un nom intern d'imatge
           {
            /Vscn exch def  %% convertim el valor de la cadena (nomes n'hi pot haver 1) a real
            vfCMYK {Vscn mul}forall  %% deixem els 4 elements de l'array a la pila i passem a desar-los a Paleta
            faPaletaCMYK2Hexa
            4 array astore {100 mul} forall  %% desem en una array els valors CMYK passats a %
            4 array astore
            %% 6.Desem la clau/valor de gamma al dic Paleta
            XRay /EspaisDeColor get /Utilitzats get NomIntern get /Paleta get exch els8vals exch put
           }ifelse
          }forall
         }
         {
          pop
         }ifelse  %% executem la funcio d'equivalencia a CMYK ?
        } stopped {clear /nSp (7) def stop}if
       }
       {
        clear /nSp (6) def stop
       }ifelse
      } stopped
      {
       XRay /EspaisDeColor get /Errades get NomIntern ( Color Space Function Type 2 with Invalid or Not Supported parameter   ) dup dup length 2 sub nSp putinterval put
      }if
      %%(tipus 2)==
     }  %% fi de Tipus 2

     {
      XRay /EspaisDeColor get /Errades get NomIntern ( Color Space Function Type 3 Not Supported) put
      %%(error x Tipus 3 no suportada)== pop
     }  %% Tipus 3 no suportades per CaLi2CoPi dins un espai de color

     {  %% Tipus 4 ... Cal comprovar que (si no passarem aquest espai a Errades):
      {  %% stopped
         %% 1.Que Range tingui 8 elements a l'array (2 valors x 4 canals de sortida)
       dup /Range get length 8 ne {clear /nSp (1) def stop}if
       %% 2.Que l'array Domain tingui tants elements parell com els que remenen scn/SCN
       %% i el nombre de valors numerics (ha de ser identic x a tots els strings) de qualsevol dels strings de l'array /TanX100 de gamma de colors ha de ser igual al nombre de valors parells de l'array Domain
       dup XRay /EspaisDeColor get /Utilitzats get NomIntern get /TanX100 get
       dup length 0 eq
       {  %% si l'array es buida aquest espai de color deu correspondre exclusivament a una imatge (inLine o XObject?)
        /execFunk false def  %% executarem la funcio d'equivalencia a CMYK ?
        XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
	/Utilitzats get
        {  %% forall
         dup type /arraytype eq
         {  %% es un XObject
          pop /NomXobject exch def
          XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /dicEC exch def
          /Paleta get NomXobject known
          {  %% si l'espai de color que explorem es el de la imatge XObject, n'esbrinem el nombre de components
             %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
             %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
           dicEC /NomExtern get dup type /arraytype eq
           {length}{pop 1}ifelse /ComFaciFalta exch def
           NomXobject /LiTeRaLS exch def
           LiTeRaLS dup length 2 add dup /aDeS exch def string dup
           3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
           /iaRa exch def
           aDeS  %%4
           ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
           mul string /aDesiaRa exch def
           aDesiaRa /NullEncode filter
           ComFaciFalta {dup iaRa writestring} repeat
           closefile  %%pop
           [ aDesiaRa ] dup
           XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
          }
          {  %% si no, no fem res
           pop  %%pop
          }ifelse
          %%pstack (XObject que te un espai de color exclusiu per a ell!) == quit
         }
         {  %% es una inLine
          dup /CS known {/CS get NomIntern eq}{false}ifelse
          {  %% si l'espai de color que explorem es el de la imatge inLine, n'esbrinem el nombre de components
           XRay /EspaisDeColor get /Utilitzats get NomIntern get /NomExtern get
           dup type /nametype eq
           {  %% es un nom en solitari d'una /Separation
              %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
              %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
            pop 1 /ComFaciFalta exch def
            /LiTeRaLS exch def
            LiTeRaLS dup length 2 add dup /aDeS exch def string dup
            3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
            /iaRa exch def
            aDeS  %%4 
            ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
            mul string /aDesiaRa exch def
            aDesiaRa /NullEncode filter
            ComFaciFalta {dup iaRa writestring} repeat
            closefile  %%pop
            [ aDesiaRa ] dup
            XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
           }
           {  %% es una array de noms d'un DeviceN
              %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
              %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
            length /ComFaciFalta exch def
            /LiTeRaLS exch def
            LiTeRaLS dup length 2 add dup /aDeS exch def string dup
            3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
            /iaRa exch def
            aDeS  %%4
            ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
            mul string /aDesiaRa exch def
            aDesiaRa /NullEncode filter
            ComFaciFalta {dup iaRa writestring} repeat
            closefile  %%pop
            [ aDesiaRa ] dup
            XRay /EspaisDeColor get /Utilitzats get NomIntern get exch /TanX100 exch put
           }ifelse
          }
          {  %% si no, no fem res
           pop
          }ifelse
         }ifelse
        }forall
       }
       {
        /execFunk true def  %% executarem la funcio d'equivalencia a CMYK ?
       }ifelse
       %% per saber si totes les strings de l'array tenen els mateixos elements i quants son (Mesclen)
       /iM 0 def /Idem true def
       {  %% forall
        /Mesclen 0 def
        {
         ( ) search {pop pop Mesclen 1 add /Mesclen exch def}{pop exit}ifelse
        } loop
        iM 1 add /iM exch def
        iM 1 gt {Mesclen AMesclen ne{/Idem false def}if}if
        Mesclen /AMesclen exch def							    
       }forall
       %%  Idem {  % es igual al nombre de valors parells de l'array Domain ?
       %%        /Domain get length 2 idiv Mesclen ne {clear /nSp (2) def stop}if
       %%       }{clear /nSp (3) def stop}ifelse
       execFunk
       {  %% executem la funcio d'equivalencia a CMYK ?
          %% Per procedir al calcul fem:
          %% 1.Decodifiquem l'stream associat al diccionari (a fitxer o string?) ... si petes passariem aquest espai a Errors
        {  %% stopped
         dup dup /Filter known
         {  %% fitxer stream amb algun tipus de filtre
          dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
	  
     dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
     dup /DecodeParms known exch /DP known 2 copy or
     {
      {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
      {
       [ exch [ exch filtresstream ] ] /filtresstream exch def
      }
      {  %% es una array
       %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
       dup length filtresstream length ne
       {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
        (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
       }if
       /iDPF 0 def
       [ exch
        {  %% forall
         dup null eq
         {
          pop [filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }
         {
	  [exch filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }ifelse
        }forall
       ]
       /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
      }ifelse
     }
     {
      pop pop  %% ens carreguem els logics
      pop  %% ens carreguem el dic
      %% avaluem filtresstream per redefinir-lo com cal per /filtRa
      filtresstream type /arraytype eq
      {
       [filtresstream] /filtresstream exch def
      }
      {
       [[filtresstream]] /filtresstream exch def
      }ifelse
     }ifelse
	  
          dadesstream
          %% comprovem si l'stream es un path dins una array o una string de dades directe
          type /arraytype eq
          {
           dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
          }
          {  %% convertim a fitxer de la cadena sense decodificar
           dadesstream 0 () /SubFileDecode filter
          } ifelse
          filtresstream
(F7) ==
	  filtRa  %% decodifiquem el fitxer stream
          %% a l'estar filtrat el repiquem al disc
          funKy (w) file /REPIcA exch def
          {  %% loop
           dup
           65535 string readstring
           {REPIcA exch writestring}
           {REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit}ifelse
          }loop
          /FoS true def  %% es un fitxer a disc
          %%funKy dup
          %%status pop pop pop /FiFtxr exch def pop  % bytes totals del fitxer
          %%(r) file /aLLeGiR exch def
         }
         {  %% fitxer stream sense filtres
          /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
          dadesstream  %% tibem el fitxer stream sense decodificar
          %% comprovem si l'stream es un path dins una array o una string de dades directe
          type /arraytype eq
          {
           dadesstream 0 get
           /funKy exch def  %% el path del fitxer amb la function
           /FoS true def  %% es un fitxer a disc
           %%dup
           %%status pop pop pop /FiFtxr exch def pop  % bytes totals del fitxer
           %%(r) file /aLLeGiR exch def
          }
          {  %% convertim a fitxer de la cadena sense decodificar
           dadesstream
           /funKy exch def  %% l'string amb la function
           /FoS false def  %% es una string (NO es un fitxer a disc)
           %%dup length /FiFtxr exch def pop  % bytes totals del fitxer
           %%0 () /SubFileDecode filter /aLLeGiR exch def
          } ifelse
         }ifelse
        }stopped {clear /nSp (4) def stop} if
        %% 2.Com que encara no sabem ben be com juguen els parells de valors dels arrays Range i Domain (cal fer un PDF de proves x esbrinar-ho), ara ens limitem a assegurar-nos que tenen exclusivament els valors 0 i 1 (si no ho passarem a Errors)
        dup /Range get
        /NOzerou false def
        /aRa 0 def
        {
         aRa ne {/NOzerou true def exit}if
         aRa 0 eq {/aRa 1 def}{/aRa 0 def}ifelse
        }forall
        NOzerou {clear /nSp (5) def stop}if
        /Domain get
        /NOzerou false def
        /aRa 0 def
        {
         aRa ne {/NOzerou true def exit}if
         aRa 0 eq {/aRa 1 def}{/aRa 0 def}ifelse
        }forall
        NOzerou {clear /nSp (6) def stop}if
        %% 3. Per a cada string (paquet de valors diferents gestionats per scn/SCN), deixem els seus valors a la pila
        %% i executem l'stream de la funcio (un petit programa PS) recollint de nou els valors per desar-los a la Paleta
        {  %% stopped
         XRay /EspaisDeColor get /Utilitzats get NomIntern get /TanX100 get
         {  %% forall
          cvx exec  %% deixem els valors de l'string a la pila
          %% com q ens podem trobar que l'espai de color sigui compartit per vectorials i imatges, llavors l'string de % pot estar formada de literals amb el nom de la imatge
          dup type /nametype eq
          {  %% son literals amb el nom de la imatge
           count 1 sub {pop}repeat  %% ens carreguem tots els literals menys 1
           %% 4.Desem la clau/valor de gamma al dic Paleta
           XRay /EspaisDeColor get /Utilitzats get NomIntern get /Paleta get exch /Imatge put
          }
          {  %% son xifres ...
           FoS
           {  %% rellegim cada vegada el fitxer a disc (assegurem aixi la seva correcte execucio)
            funKy (r) file
           }
           {  %% es una string
            funKy
           }ifelse
           cvx exec exec  %% executem el procediment PS
           faPaletaCMYK2Hexa
           4 array astore {100 mul} forall  %% desem en una array els valors CMYK passats a %
           4 array astore
           %% 4.Desem la clau/valor de gamma al dic Paleta
           XRay /EspaisDeColor get /Utilitzats get NomIntern get /Paleta get exch els8vals exch put
          } ifelse
         }forall
         clear  %% li hem posat xq apareixen p.e. a 22-AF21_Esko.pdf 2 misteriosos 1.0 (que semblen inofensius) a la pila ¿?
        } stopped {clear /nSp (7) def stop}if
       }
       {
        pop
       }ifelse  %% executem la funcio d'equivalencia a CMYK ?
      } stopped
      {
       XRay /EspaisDeColor get /Errades get NomIntern ( Color Space Function Type 4 with Invalid or Not Supported parameter   ) dup dup length 2 sub nSp putinterval put
      }if
      %%(tipus 4)==
     }  %% fi de Tipus 4

    ]
    exch get cvx exec
   } ifelse
   %% pstack (!!!!!) == quit  %%%DUMENGE ... XQ inLineCMYKaEspaiDcolor_A7.pdf a de passar per aqui ??
  }if
  %% Les 0 son les tipus Daaali, les 2 son linials i cal treballar amb el valor de C1 (valor CMYK al 100%) i les 4 son les que duen un proc PS
 }forall

 %% si hi ha Pattern amb continguts a Resources el classifiquem a XRay (despres ja el filtrarem al llistar els CSpaces)
 %%                        pAtrO {
 %%                               XRay /EspaisDeColor get dup /Desconeguts get /Pattern undef
 %%                               /Utilitzats get /Pattern null put
 %%                              }if
 %% incrustem a sac totes les claus/valor del dic d'espais de color concret al dic ampliat
 EspaisDeC
 {  %% ens refiem que no hi hauran noms repetits ...
  totalEspaisDeC 3 1 roll put
 }forall
}
{
 pop
 null /EspaisDeC exch def  %% desem un null en comptes del dic ColorSpace (encara no comprovem aquesta entrada mes endavant), doncs encara que no n'hi hagi pot ser un document valid amb CMYK directes!
}ifelse

} forall  %% forall x explorar els Estats Grafics i Espais de Color de tots els Resources utilitzats (Pagina+Patterns&Shadings)

%% } forall %% fi del forall x pagines
%%% FI d'Exploracio dels Estats Grafics i els Espais de Color del document

%#%30bis% posem l'espai de color que toca a l'array del Pattern
(%#%30bis%)==
%% el gatell nomDtp ens indica (si no es null) que hem reinterpretat streams de Patterns (Colored i Uncolored?)
nomDtp null ne
{
 XRay /Patterns&Shadings get /Utilitzats get
 {  %% forall de tots els Patterns per posar-hi el NomExtern a l'array si cal
  exch pop  %% ens carreguem el nom del Pattern
  dup 2 get
  dup type /nametype eq  %% CAL?
  {
   dup XRay /EspaisDeColor get /Utilitzats get exch known
   {
    XRay /EspaisDeColor get /Utilitzats get exch get
    /NomExtern get 2 exch put  %% incrustem a l'array del Pattern el NomExtern de l'espai de color utilitzat (fins ara hi teniem el NomIntern)
   }
   {
    pop pop
   }ifelse
  }
  {
   pop pop
  }ifelse
 } forall
} if

%% XRay /Patterns&Shadings get /Utilitzats get
%% XRay /EspaisDeColor get /Utilitzats get
%% /DN_0_1 get
%% /NoName9 get
%% /sepall get
%% XRay /ObjectesX get %/Utilitzats get
%%{== ==}forall

%#%31% Exploració dels XObjects del document
(%#%31%)==
%% aqui hi havia la cerca del dic Resources per anar pescar /XObject

%% ara validem els espais de color de les imatges localitzades (ho fem a part del forall anterior doncs si no, no detectariem mai les inLine)
%% Sempre que n'hi hagin! (sembla que no cal)
%% JectesX null ne {
XRay /ObjectesX get

%%{  % stopped

{  %% forall pagina a pagina d'ObjectesX
 exch /araPlana exch def  %% literal del num de pagina
 
 %%% EP!: cal q tinguem en compte que la informacio a EspaisDeColor d'XRay
 %%% encara no esta endreçada pagina a pagina (caldrà però?)
 
 /Utilitzats get  %% pesquem del dic de la plana on som
 {  %% forall del dic Utilitzats
  dup type /arraytype eq
  {  %% si duu un paquet es que es un XObject normal
   %% Form o image XObject?
   dup 0 get type /arraytype eq
   {  %% Form (aqui no els tractem ara)
    pop pop
   }
   {  %% image
    dup 2 get dup length 16 eq  %% descartem el fet que sigui una ref ind
    {
     dup 16 string cvs 10 get 95 eq{true}{false}ifelse
    }
    {
     false
    }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
    {  %% com que ho es, anem a pescar l'array de color o el nom del Device Color Space
     exch pop
     dup /aRefInd exch def  %% desem la referencia indirecte de l'array de color (clau unica que el diferencia) per us + endavant
     /aCercar exch def
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
     /araRay exch def  %% pot ser l'array del color
     araRay type /arraytype eq
     {  %% ho es ...
      /inomIntern exch def  %% desem el nom intern de la imatge
      %% Quan filtrem als espais de color Utilitzats podrem cercar directament l'entrada /NomExtern al dic que toqui ...
      XRay /EspaisDeColor get /Utilitzats get /ECi false def
      {  %% forall
       exch /cNomIntern exch def
       %% per salpassar els espais de color que duen un null en comptes d'un dic (tipus Pattern)
       dup type /dicttype eq {/NomExtern get dup type}{dup type}ifelse
       araRay 1 get type eq  %% primer ens assegurem que siguin dues arrays o dos noms (si no quadre la naturalesa de l'objecte mai seran iguals)
       {
        araRay 1 get dup type /arraytype eq
        {  %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
         /aComp exch def
         /iDeNTiQueS true def  %% gatell x saber si son identiques
         dup length
         aComp length eq
         {  %% si no tenen la mateixa quantitat d'elements segur que no son iguals ...
          /iaComp 0 def
          {  %% forall
           aComp iaComp get eq
           {
            iaComp 1 add /iaComp exch def
           }
           {
            /iDeNTiQueS false def exit
           }ifelse
          }forall
         }
         {
          /iDeNTiQueS false def pop
         } ifelse
         iDeNTiQueS {/ECi true def exit}if
        }
        {  %% segur son dos noms
         eq {/ECi true def exit}if
        }ifelse
       }
       {
        pop
       } ifelse
      }forall
      ECi
      {  %%(ES A Utilitzats) == %== quit
       %% hi afegim el nom intern de la imatge que ha processat aquest espai
       XRay /EspaisDeColor get /Utilitzats get cNomIntern get /Paleta get inomIntern null put
       %% hi posem el nom extern de l'espai de color a l'XRay x llistar-lo amb ObjectesX
       XRay /ObjectesX get araPlana get  % pesquem el dic de la plana on som
       /Utilitzats get inomIntern get 2 araRay 1 get put
      }
      {  %% Quan filtrem als espais de color NoUtilitzats haurem d'anar a cercar a ColorSpace de Resources a traves del nom intern per validar el color i pescar-hi el nom extern que correspongui ...
       XRay /EspaisDeColor get /NoUtilitzats get /ECi false def
       {  %% forall
        pop totalEspaisDeC exch
        dup /cNomIntern exch def  %% evitem l'error detectat a Test-CON-ICC.pdf i DefaultCMYK.pdf
        get  %% ens carreguem el tipus d'espai de color i amb el nom intern anem a pescar a ColorSpaces la ref ind de l'array de color
        dup type /nametype eq
        {  %% si es una ref ind l'anem a cercar ...
         /aCercar exch def  %% nom amb la ref ind del dic Resources
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
        } if
        dup length 1 eq
        {  %% si l'array es d'un sol element amb un Device directe ...
         0 get dup type araRay 0 get type eq  %% primer ens assegurem que siguin dues arrays o dos noms (si no quadre la naturalesa de l'objecte mai seran iguals)
        }
        {
         1 get dup type araRay 1 get type eq  %% primer ens assegurem que siguin dues arrays o dos noms (si no quadre la naturalesa de l'objecte mai seran iguals)
        }ifelse
        {
         araRay length 1 eq
         {  %% si l'array es d'un sol element amb un Device directe ...
          araRay 0 get dup type /arraytype eq
         }
         {
          araRay 1 get dup type /arraytype eq
         }ifelse
         {  %% son dues arrays, que comparem element x element (veure ComparArrays.ps)
          /aComp exch def
          /iDeNTiQueS true def  %% gatell x saber si son identiques
          dup length
          aComp length eq
          {  %% si no tenen la mateixa quantitat d'elements segur que no son iguals ...
           /iaComp 0 def
           {  %% forall
            aComp iaComp get eq
            {
             iaComp 1 add /iaComp exch def
            }
            {
             /iDeNTiQueS false def exit
            }ifelse
           }forall
          }
          {
           /iDeNTiQueS false def pop
          } ifelse
          iDeNTiQueS {/ECi true def exit}if
         }
         {  %% segur son dos noms
          eq {/ECi true def exit}if
         }ifelse
        }
        {
         pop
        }ifelse
       }forall
       ECi
       {  %%(ES A NoUtilitzats) == %== quit
        %% abans que res el donem de baixa a NoUtilitzats
        XRay /EspaisDeColor get /NoUtilitzats get cNomIntern undef
        %% ara primer comprovem si es /DeviceN o /Separation
        <</DeviceN null /Separation null>>
        araRay 0 get known
        {  %% despres comprovem si te un alternateSpace tipus /DeviceCMYK
         araRay 2 get /DeviceCMYK eq
         {  %% si es CMYK, com que no esta comptabilitzada com a espai de color, el donem d'alta als Utilitzats
          XRay /EspaisDeColor get /Utilitzats get dup
          cNomIntern known  %% mirem si ja hi es
          {
           cNomIntern get
           /Paleta get inomIntern null put
          }
          {
           cNomIntern  %% de nom intern hi posem el literal de 16c de la ref ind
           <<
             /Tipus araRay 0 get /NomExtern araRay 1 get /FTipus null
             /Paleta << inomIntern null >>
             /TanX100 []
           >> put
          }ifelse
          %% i posem el nom extern de l'espai de color a l'XRay x llistar-lo amb ObjectesX
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Utilitzats get inomIntern get 2 araRay 1 get put
         }
         {  %% si no es CMYK el passem a Errades tant a EspaisDeColor com a ObjectesX
          XRay /EspaisDeColor get /Errades get cNomIntern ( Color Space Not Supported) put
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Errades get inomIntern ( image with Color Space Not Supported) put
         }ifelse
        }
        {  %% si no es cap dels dos el passem a Errades tant a EspaisDeColor com a ObjectesX
         XRay /EspaisDeColor get /Errades get cNomIntern ( Color Space Not Supported) put
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Errades get inomIntern ( image with Color Space Not Supported) put
        }ifelse
       }
       {  %% voldra dir que es una array de color que no penja de cap nom de ColorSpace
        %% primer comprovem si es /DeviceN o /Separation
        <</DeviceN null /Separation null>>
        araRay 0 get known
        {  %% despres comprovem si te un alternateSpace tipus /DeviceCMYK
         araRay 2 get /DeviceCMYK eq
         {  %% si es CMYK, com que no esta comptabilitzada com a espai de color, el donem d'alta als Utilitzats
          XRay /EspaisDeColor get /Utilitzats get dup
          aRefInd known  %% mirem si ja hi es
          {
           aRefInd get
           /Paleta get inomIntern null put
          }
          {
           aRefInd  %% de nom intern hi posem el literal de 16c de la ref ind
           <<
             /Tipus araRay 0 get /NomExtern araRay 1 get /FTipus null
             /Paleta << inomIntern null >>
             /TanX100 []
           >> put
          }ifelse
          %% i posem el nom extern de l'espai de color a l'XRay x llistar-lo amb ObjectesX
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
	  /Utilitzats get inomIntern get 2 araRay 1 get put
         }
         {  %% si no es CMYK el passem a Errades tant a EspaisDeColor com a ObjectesX
          XRay /EspaisDeColor get /Errades get inomIntern ( Color Space Not Supported) put
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
	  /Errades get inomIntern ( image with Color Space Not Supported) put
         }ifelse
        }
        {  %% si no es cap dels dos el passem a Errades tant a EspaisDeColor com a ObjectesX
         XRay /EspaisDeColor get /Errades get inomIntern ( Color Space Not Supported) put
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Errades get inomIntern ( image with Color Space Not Supported) put
        }ifelse
        %%(NO ES A ENLLOC!) ==  %== araRay == quit
       }ifelse
      }ifelse
     }
     {  %% segur que es un nom d'un Device Color Space ...
      araRay /DeviceCMYK eq
      { %% si es aixi, desem el nom del image XObject com si fos un valor de color d'un espai /NoName9 al dic Paleta
       /NomXobject exch def
       XRay /EspaisDeColor get /Utilitzats get
       %% hi ha /NoName9?
       dup /NoName9 known
       {
        /NoName9 get /Paleta get NomXobject /Imatge put
       }
       {  %% si no hi es el creem de nou
        /NoName9
        <<
          /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
          /Paleta << NomXobject /Imatge >>
          /TanX100 []
        >> put
       }ifelse
      }
      {  %% solucio DeviceGray
       %% #% o es escala de grisos o es un color invalid per ara ...
       araRay /DeviceGray eq
       {  %% si es DeviceGray, desem el nom del image XObject com si fos un valor de color d'un espai /Black al dic Paleta
        /NomXobject exch def  %% desem el nom intern de la imatge
        XRay /EspaisDeColor get /Utilitzats get
        %% tots els elements definits sota l'espai DeviceGray passaran a formar part de la tinta /Black
        dup /DeviceGray known
        {
         /DeviceGray get /Paleta get NomXobject /Imatge put
        }
        {  %% si no hi es el creem de nou
         /DeviceGray
         <<
           /Tipus /PureCMYK /NomExtern /Black /FTipus null
           /Paleta << NomXobject /Imatge >>
           /TanX100 []
         >> put
        }ifelse
       }
       {  %% si no es /DeviceGray, pot ser qualsevol altre espai de color ara invalid, i el passem a Errades tant a EspaisDeColor com a ObjectesX
        /NomXobject exch def
        <<  %% diccionari dels espais de color directes no suportats amb el text del seu error associat
          /CalGray ( CIE CalGray Color Space Not Supported)
          /CalRGB ( CIE CalRGB Color Space Not Supported)
          /Lab ( CIE Lab Color Space Not Supported)
          /ICCBased ( CIE ICCBased Color Space Not Supported)
          /Indexed ( Indexed Color Space Not Supported)
          /Pattern ( Pattern Color Space Not Supported)
          %% tot hi que amb aquest potser n'hi hauria prou, els hi posem tots x si les mosques ...
          /DeviceRGB ( DeviceRGB Color Space Not Supported)
        >> dup
        araRay known
        {  %% posem l'error al dic d'objectes X
         araRay get /eMissatge exch def
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
	 /Errades get NomXobject eMissatge put
         %% ... i al dic d'espais de color
         XRay /EspaisDeColor get /Errades get araRay eMissatge put
        }
        {
         pop
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
	 /Errades get NomXobject ( image with Unknown Color Space) put
         %% ... i al dic d'espais de color
         XRay /EspaisDeColor get /Errades get araRay ( Unknown Color Space) put
        }ifelse
       }ifelse
      }ifelse
     }ifelse
    }
    {  %% potser una array directe de color o un nom de Device Space directe o ... etc
     pop
     %% primer mirem si es un CMYK directe
     2 get dup /DeviceCMYK eq
     { %% si es aixi, desem el nom del image XObject com si fos un valor de color d'un espai /NoName9 al dic Paleta
      pop /NomXobject exch def
      XRay /EspaisDeColor get /Utilitzats get
      %% hi ha /NoName9?
      dup /NoName9 known
      {
       /NoName9 get /Paleta get NomXobject /Imatge put
      }
      {  %% si no hi es el creem de nou
       /NoName9
       <<
         /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
         /Paleta << NomXobject /Imatge >>
         /TanX100 []
       >> put
      }ifelse
     }
     {  %% com a segona possibilitat mirem que no sigui un espai de color aprovat a utilitzats
      dup XRay /EspaisDeColor get /Utilitzats get exch known
      {  %% si ho es l'incrustem com un valor + de color del dic Paleta corresponent
       1 index /NomXobject exch def  %% desem el nom intern de la imatge
       XRay /EspaisDeColor get /Utilitzats get exch get
       dup /NN9 exch def  %% desem el dic x despres
       /Paleta get NomXobject /Imatge put
       /inomIntern exch def  %% tornem a desar el nom intern x farcir l'array de valors
       NN9 /TanX100 get  %% l'array a farcir
       dup length 1 add dup 1 sub /Dmes exch def
       array dup dup 4 -1 roll 0 exch putinterval Dmes
       %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
       %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
       inomIntern /LiTeRaLS exch def
       NN9 /NomExtern get dup type /arraytype eq {length}{pop 1}ifelse
       /ComFaciFalta exch def
       LiTeRaLS dup length 2 add dup /aDeS exch def string dup
       3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
       /iaRa exch def
       aDeS  %%4
       ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
       mul string /aDesiaRa exch def
       aDesiaRa /NullEncode filter
       ComFaciFalta {dup iaRa writestring} repeat
       closefile aDesiaRa
       put  %% en comptes de posar les dades normals de % d'imatge (aTxC) posem quatre vegades el nom inomIntern que ja ens fara la funcio que toca en aquest cas
       dup length array copy  %% en fem una copia x evitar possibles pinçats
       NN9 exch /TanX100 exch put  %% clavem l'array a lloc
       %%pstack (^) == quit
      }
      {  %% i com a tercera possibilitat mirem que no sigui un ColorSpace classificat a NoUtilitzats
       dup XRay /EspaisDeColor get /NoUtilitzats get exch known
       {  %% si hi es, mirarem que l'espai de color sigui valid
        %% solucio DeviceGray
        %% #% o es escala de grisos o es un color invalid per ara ...
        dup /DeviceGray eq
        {  %% si es DeviceGray, desem el nom del image XObject com si fos un valor de color d'un espai /Black al dic Paleta
         exch /NomXobject exch def  %% desem el nom intern de la imatge
         XRay /EspaisDeColor get /Utilitzats get
         %% tots els elements definits sota l'espai DeviceGray passaran a formar part de la tinta /Black
         %% com que no hi es segur el creem de nou
         /DeviceGray
         <<
           /Tipus /PureCMYK /NomExtern /Black /FTipus null
           /Paleta << NomXobject /Imatge >>
           /TanX100 []
         >> put
         %% i el donem de baixa de No utilitzats
         XRay /EspaisDeColor get /NoUtilitzats get exch undef
        }
        {  %% si no es /DeviceGray, pot ser qualsevol altre espai de color ara invalid, i el passem a Errades tant a EspaisDeColor com a ObjectesX
         XRay /EspaisDeColor get /NoUtilitzats get exch dup /NomIntern exch def get dup
         <<  %% diccionari dels espais de color directes no suportats amb el text del seu error associat
           /CalGray ( CIE CalGray Color Space Not Supported)
           /CalRGB ( CIE CalRGB Color Space Not Supported)
           /Lab ( CIE Lab Color Space Not Supported)
           /ICCBased ( CIE ICCBased Color Space Not Supported)
           /Indexed ( Indexed Color Space Not Supported)
           /Pattern ( Pattern Color Space Not Supported)
           /DeviceRGB ( DeviceRGB Color Space Not Supported)
         >>
         dup 3 -1 roll known
         {  %% posem l'error al dic d'objectes X
          exch get /eMissatge exch def /NomXobject exch def
          XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
          /Errades get NomXobject eMissatge put
          %% ... i al dic d'espais de color + la baixa a NoUtilitzats
          XRay /EspaisDeColor get /Errades get NomIntern eMissatge put
          XRay /EspaisDeColor get /NoUtilitzats get NomIntern undef
         }
         {
          pop dup
          <<  %% diccionari dels espais de color directes valids amb el text de ???
            %% /DeviceN /DeviceNxExplorar
            /DeviceCMYK /PureCMYK
            %% /Separation /SeparationXexplorar
          >> dup 3 -1 roll known
          {
           exch get
           /eMissatge exch def /NomXobject exch def
           %% i finalment el donem de baixa a NoUtilitzats i d'alta a Utilitzats incrustant-lo com un valor + de color del dic Paleta corresponent
           XRay /EspaisDeColor get /NoUtilitzats get exch undef
           exch /NomXobject exch def  %% desem el nom de la imatge
           XRay /EspaisDeColor get /Utilitzats get exch
           <<
             /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
             /Paleta << NomXobject /Directe >>
             /TanX100 []
           >> put
          }
          {  %% AQUEST ES UN CAS (que tot i poc provable) X ESTUDIAR encara i veure com realment hauria d'anar
           pop /eXexplorar exch def /NomXobject exch def
           %% i finalment el donem de baixa a NoUtilitzats i d'alta a Utilitzats incrustant-lo com un valor + de color del dic Paleta corresponent
           XRay /EspaisDeColor get /NoUtilitzats get eXexplorar undef
           XRay /EspaisDeColor get /Utilitzats get eXexplorar
           <<
             /Tipus /eXexplorar /NomExtern NomXobject /FTipus null
             /Paleta << NomXobject /Directe >>
             /TanX100 []
           >> put
          }ifelse
         } ifelse
        }ifelse
       }
       {  %% solucio DeviceGray
        %% #% o es escala de grisos o es un color invalid per ara ...
        /DeviceGray eq
        {  %% si es DeviceGray, desem el nom del image XObject com si fos un valor de color d'un espai /Black al dic Paleta
         /NomXobject exch def  %% desem el nom intern de la imatge
         XRay /EspaisDeColor get /Utilitzats get
         %% tots els elements definits sota l'espai DeviceGray passaran a formar part de la tinta /Black
         dup /DeviceGray known
         {
          /DeviceGray get /Paleta get NomXobject /Imatge put
         }
         {  %% si no hi es el creem de nou
          /DeviceGray
          <<
            /Tipus /PureCMYK /NomExtern /Black /FTipus null
            /Paleta << NomXobject /Imatge >>
            /TanX100 []
          >> put
         }ifelse
        }
        {  %% si no es /DeviceGray, pot ser qualsevol altre espai de color ara invalid, i el passem a Errades tant a EspaisDeColor com a ObjectesX
         /NomXobject exch def  %% desem el nom intern de la imatge
         XRay /EspaisDeColor get /Errades get /NoName13 ( Unknown Color Space) put
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Errades get NomXobject ( image with Unknown Color Space) put
        }ifelse
       }ifelse
      }ifelse
     }ifelse
    } ifelse  %% del nom de Device Space directe
   }ifelse  %% Form o image XObject?
  }
  %%canicula%test% aqui cal traslladar el q esta marcat com a 'solucio DeviceGray' pels Xobjects aqui a les inLines
  {  %% si no, es que es una inLine image
   %% 3 -1 roll
   %% pop  % ens carreguem /NoName0
   %% com que els elements del dic de les imatges inLine tenen prohibit a puntar a objectes indirectes ...
   dup /CS known
   {
    dup /CS get dup
    <<
      /I null
      /RGB null
      /G null
      /CMYK null
    >> exch known not  %% ... o no es cap device color directe?
   }
   {
    dup /BPC get 1 eq {/PLoMa false}{/DeSCoNeGuT false}ifelse
   }ifelse
   {  %% podria ser q no existis al dic?
    totalEspaisDeC 1 index known
    {true}{pop /DeSCoNeGuT false}ifelse
   }
   {
    false
   }ifelse
   {  %% com que ho es, anem a pescar l'array de color o el nom del Device Color Space
    exch pop  %% ens carreguem el dict de les dades d'inLine
    dup /cNomIntern exch def totalEspaisDeC exch get
    dup type /nametype eq 1 index length 16 eq
    {
     1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
    }
    {
     false
    }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
    and
    {  %% els dos han de ser certs (o sigui una ref ind segur), doncs es podria tractar d'un DeviceCMYK directe
     dup /aRefInd exch def  %% desem la referencia indirecte de l'array de color (clau unica que el diferencia) per us + endavant
     /aCercar exch def
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    } if
    /araRay exch def  %% pot ser l'array del color on Device directe
    araRay type /arraytype eq
    {  %% ho es ...
     /inomIntern exch def  %% desem el nom intern de la imatge
     %% Quan filtrem als espais de color Utilitzats podrem cercar directament l'entrada /NomExtern al dic que toqui ...
     XRay /EspaisDeColor get /Utilitzats get /ECi false def
     dup length  0 eq {/ECi false def}if  %% si el dic es buit cercarem a NoUtilitzats
     {  %% forall
      pop
      cNomIntern eq
      {
       totalEspaisDeC cNomIntern known {/ECi true def exit}if
      }if
     }forall  %% forall pels espais de color utilitzats
     ECi
     {
      %%(ES A Utilitzats) == %== quit
      %% hi afegim el nom intern de la imatge que ha processat aquest espai
      XRay /EspaisDeColor get /Utilitzats get cNomIntern get /Paleta get inomIntern null put
      %% hi posem el nom extern de l'espai de color a l'XRay x llistar-lo amb ObjectesX
      XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
      /Utilitzats get inomIntern get 2 araRay 1 get put
     }
     {  %% Quan filtrem als espais de color NoUtilitzats haurem d'anar a cercar a ColorSpace de Resources a traves del nom intern per validar el color i pescar-hi el nom extern que correspongui ...
      %%pop  % ens carreguem el /NoName0
      XRay /EspaisDeColor get /NoUtilitzats get /ECi false def
      dup length 0 eq {/ECi false def}if  %% si el dic es buit voldra dir que es una array de color directe
      {  %% forall
       pop
       cNomIntern eq
       {
        totalEspaisDeC cNomIntern known {/ECi true def exit}if
       }if
      }forall
      ECi
      {
       %%(ES A NoUtilitzats) == %== quit
       %% abans que res el donem de baixa a NoUtilitzats
       XRay /EspaisDeColor get /NoUtilitzats get cNomIntern undef
       %% ara primer comprovem si es /DeviceN o /Separation
       <</DeviceN null /Separation null>>
       araRay 0 get known
       {  %% despres comprovem si te un alternateSpace tipus /DeviceCMYK
        araRay 2 get /DeviceCMYK eq
        {  %% si es CMYK, com que no esta comptabilitzada com a espai de color, el donem d'alta als Utilitzats
         XRay /EspaisDeColor get /Utilitzats get dup
         cNomIntern known  %% mirem si ja hi es
         {
          cNomIntern get
          /Paleta get inomIntern null put
         }
         {
          cNomIntern  %% de nom intern hi posem el literal de 16c de la ref ind
          <<
            /Tipus araRay 0 get /NomExtern araRay 1 get /FTipus null
            /Paleta << inomIntern null >>
            /TanX100 []
          >> put
         }ifelse
         %% i posem el nom extern de l'espai de color a l'XRay x llistar-lo amb ObjectesX
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Utilitzats get inomIntern get 2 araRay 1 get put
        }
        {  %% si no es CMYK el passem a Errades tant a EspaisDeColor com a ObjectesX
         XRay /EspaisDeColor get /Errades get cNomIntern ( Color Space Not Supported) put
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Errades get inomIntern ( image with Color Space Not Supported) put
        }ifelse
       }
       {  %% si no es cap dels dos el passem a Errades tant a EspaisDeColor com a ObjectesX
        XRay /EspaisDeColor get /Errades get cNomIntern ( Color Space Not Supported) put
        XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
        /Errades get inomIntern ( image with Color Space Not Supported) put
       }ifelse
      }
      {  %% voldra dir que es una array de color que no penja de cap nom de ColorSpace
       %% primer comprovem si es /DeviceN o /Separation
       <</DeviceN null /Separation null>>
       araRay 0 get known
       {  %% despres comprovem si te un alternateSpace tipus /DeviceCMYK
        araRay 2 get /DeviceCMYK eq
        {  %% si es CMYK, com que no esta comptabilitzada com a espai de color, el donem d'alta als Utilitzats
         XRay /EspaisDeColor get /Utilitzats get dup
         cNomIntern known  %% mirem si ja hi es
         {
          cNomIntern get
          /Paleta get inomIntern null put
         }
         {
          cNomIntern  %% de nom intern
          <<
            /Tipus araRay 0 get /NomExtern araRay 1 get /FTipus null
            /Paleta << inomIntern null >>
            /TanX100 []
          >> put
         }ifelse
         %% i posem el nom extern de l'espai de color a l'XRay x llistar-lo amb ObjectesX
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Utilitzats get inomIntern get 2 araRay 1 get put
        }
        {  %% si no es CMYK el passem a Errades tant a EspaisDeColor com a ObjectesX
         XRay /EspaisDeColor get /Errades get inomIntern ( Color Space Not Supported) put
         XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
         /Errades get inomIntern ( image with Color Space Not Supported) put
        }ifelse
       }
       {  %% si no es cap dels dos el passem a Errades tant a EspaisDeColor com a ObjectesX
        XRay /EspaisDeColor get /Errades get inomIntern ( Color Space Not Supported) put
        XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
        /Errades get inomIntern ( image with Color Space Not Supported) put
       }ifelse
       %%(NO ES A ENLLOC!) ==  %== araRay == quit
      }ifelse
     }ifelse
    }
    {  %% segur que es un nom d'un Device Color Space ...
     araRay /DeviceCMYK eq
     {  %% si es aixi, desem el nom del image XObject com si fos un valor de color d'un espai /NoName9 al dic Paleta
      /NomXobject exch def
      cNomIntern /NoName9 eq
      {
       XRay /EspaisDeColor get /Utilitzats get
       %% hi ha /NoName9?
       dup /NoName9 known
       {
        /NoName9 get /Paleta get NomXobject /Imatge put
       }
       {  %% si no hi es, abans de crear-lo de nou, ens assegurem que no sigui un valor directe de l'espai de color
        /NoName9
        <<
          /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
          /Paleta << NomXobject /Imatge >>
          /TanX100 []
        >> put
       }ifelse
      }
      {
       XRay /EspaisDeColor get /Utilitzats get dup cNomIntern known
       {
        cNomIntern get dup /Paleta get NomXobject /Imatge put
        dup dup /NomExtern /PureCMYK put /Tipus /PureCMYK put
        /TanX100 [] put
       }
       {  %% si la inLine crides un nom de ColorSpace inexistent donariem un error
        XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
        /Errades get NomXobject ( image with Color Space Not Defined) put
        XRay /EspaisDeColor get /Errades get cNomIntern ( Not Defined or Wrong Color Space Name) put
       } ifelse
      }ifelse
     }
     {
      /NomXobject exch def
      <<  %% diccionari dels espais de color directes no suportats amb el text del seu error associat
        /CalGray ( CIE CalGray Color Space Not Supported)
        /CalRGB ( CIE CalRGB Color Space Not Supported)
        /Lab ( CIE Lab Color Space Not Supported)
        /ICCBased ( CIE ICCBased Color Space Not Supported)
        /Indexed ( Indexed Color Space Not Supported)
        /Pattern ( Pattern Color Space Not Supported)
        %% /DeviceGray ( DeviceGray Color Space Not Supported)  % tot hi que amb aquests dos n'hi hauria prou, els hi posem tots x si les mosques ...
        /DeviceRGB ( DeviceRGB Color Space Not Supported)
      >> dup
      araRay known
      {  %% posem l'error al dic d'objectes X
       %% sobreixidor x saber on es crida l'espai de color q encara no tractem
       %%(-- AQUI es crida:Inline0: DeviceRGB o Pattern o Indexed o ICCBased o Lab o CalRGB o CalGray) ==
       araRay get /eMissatge exch def
       XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
       /Errades get NomXobject eMissatge put
       %% ... i al dic d'espais de color
       XRay /EspaisDeColor get /Errades get araRay eMissatge put
      }
      {
       pop
       XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
       /Errades get NomXobject ( image with unknown Color Space) put
       %% ... i al dic d'espais de color
       XRay /EspaisDeColor get /Errades get araRay ( unknown Color Space) put
      }ifelse
     }ifelse
    }ifelse
   }
   {  %% es un nom de Device Space directe
    %%% ENGANX
    %% primer mirem si es un CMYK directe
    1 index /CS known
    {
     pop
     /CS get
     dup /CMYK eq
    }
    {
     false
    }ifelse
    {  %% si es aixi, desem el nom de la inLine image com si fos un valor de color d'un espai /NoName9 al dic Paleta
     %%pop
     /NomInline exch def
     XRay /EspaisDeColor get /Utilitzats get
     %% hi ha /NoName9?
     dup /NoName9 known
     {
      /NoName9 get /Paleta get NomInline /Imatge put
     }
     {  %% si no hi es el creem de nou
      /NoName9
      <<
        /Tipus /PureCMYK /NomExtern /PureCMYK /FTipus null
        /Paleta << NomInline /Imatge >>
        /TanX100 []
      >> put
     }ifelse
    }
    {
     <<
       /I ( Indexed Color Space Not Supported)
       /RGB ( DeviceRGB Color Space Not Supported)
       %% /G ( DeviceGray Color Space Not Supported)
     >> dup 2 index known
     {  %% com a segona possibilitat mirem si s'adiu a la resta d'entrades d'espai de color NO suportats i abreujades
      %% sobreixidor x saber on es crida l'espai de color q encara no tractem
      %%exch
      1 index get
      %%(-- AQUI es crida:Inline2: DeviceRGB o Indexed) pstack quit
      /eMissatge exch def /NomIntern exch def /NomInline exch def
      XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
      /Errades get NomInline eMissatge put
      %% ... i al dic d'espais de color + la baixa a NoUtilitzats
      XRay /EspaisDeColor get /Errades get NomIntern eMissatge put
      XRay /EspaisDeColor get /NoUtilitzats get NomIntern undef
     }
     {
      %% com a tercera possibilitat mirem que no sigui un espai de color DeviceGray
      pop
      %%canicula%test
      /G eq
     {  %% si es DeviceGray, desem el nom del image XObject com si fos un valor de color d'un espai /Black al dic Paleta
       %%(_:_:_:_:__:_:_:_:___:) == quit
       /NomXobject exch def  %% desem el nom intern de la imatge
       XRay /EspaisDeColor get /Utilitzats get
       %% tots els elements definits sota l'espai DeviceGray passaran a formar part de la tinta /Black
       dup /DeviceGray known
       {
        /DeviceGray get /Paleta get NomXobject /Imatge put
       }
       {  %% si no hi es el creem de nou
        /DeviceGray
        <<
          /Tipus /PureCMYK /NomExtern /Black /FTipus null
          /Paleta << NomXobject /Imatge >>
          /TanX100 []
        >> put
       }ifelse
       %% i donem de baixa a Desconeguts!
       XRay /EspaisDeColor get /Desconeguts get /G undef
      }
      {  %% si finalment l'espai de color no hi es, el passem a Errades com a no definit
       %%pop
       /NomInline exch def
       XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
       /Errades get NomInline ( image with Color Space Not Defined) put
      }ifelse
     } ifelse
    }ifelse  %% CMYK o una altra cosa
   } ifelse  %% Ref Ind o Device Space directe
  }ifelse  %% de l'XObject normal o la inLine image
 }forall  %% forall del dic Utilitzats
}forall  %% pagina a pagina d'ObjectesX a XRay


%%} if  % (sembla que no cal) els validem sempre que n'hi hagin (o sigui JectesX <> null)
%% fi de validacio d'espais de color de les imatges localitzades

%%% test a3copiseny
%% XRay /ObjectesX get /1 get %/Desconeguts get 
%% /Utilitzats
%% /trEncAclOsqUEs get {== ==}forall

%%{
%% /trEncAclOsqUEs get {== ==}forall(________________)== pop
%%}forall
%%iFenix {== ==}forall

%%i4cantons /1 get {== ==}forall
%%}stopped{(++++++++++++++)pstack quit}if

%%% fi d'Exploracio dels XObjects del document

%% test
%% XRay /ObjectesX get /Errades get {== ==}forall (*****) pstack quit
%%%

%#%31bis% afegim els noms dels FormXObject al dicicionari Paleta de l'espai de color corresponent
%# i afegim també els noms com a valors de l'array TanX100
(%#%31bis%)==
FormsiColorSpaces
{  %% forall pel dic nom Form / Espais de Color
 {  %% forall x saber si el nom de l'espai de color associat al Form es actiu
  pop dup
  XRay /EspaisDeColor get /Utilitzats get
  exch known  %% aquest espai de color apuntat al Form es realment actiu?
  {  %% SI es actiu recuperem el dic de descripcio ...  
   %%dup /sepall eq {pop}{
   XRay /EspaisDeColor get /Utilitzats get exch get
   dup /EDCU exch def  %% desem el dic x treballar TanX100
   /Paleta get  %% ... per afegir-hi el nom intern del Form a Paleta
   1 index /FormX put
   %% esbrinem el nombre de components de l'espai de color del Form
   %% com que ni analitzem ni escrivim tots els colors que pinta el Form ...
   %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
   EDCU /NomExtern get dup type /arraytype eq
   {length}
   {
    /PureCMYK eq
    {4}{1}ifelse
   }ifelse /ComFaciFalta exch def
   dup /LiTeRaLS exch def  %% desem el nom intern del Form
   LiTeRaLS dup length 2 add dup /aDeS exch def string dup
   3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
   /iaRa exch def
   aDeS
   ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
   mul string /aDesiaRa exch def
   aDesiaRa /NullEncode filter
   ComFaciFalta {dup iaRa writestring} repeat
   closefile 
   EDCU dup /TanX100 get  %% ... un cop farcida la cadena farcim l'array TanX100
   dup length 1 add dup 1 sub /Dmes exch def
   array dup dup
   4 -1 roll 0 exch putinterval Dmes aDesiaRa put
   /TanX100 exch put  %% ... i el redesem al dic de l'espai de color
   %%}ifelse
  }
  {  %% si NO ho es ens carreguem el nom i fora
   pop
  }ifelse
 }forall
 pop  %% ens carreguem el nom intern del Form
}forall

%% FormsiColorSpaces {{== ==}forall pop}forall
%% XRay /EspaisDeColor get /Utilitzats get {{== ==}forall ==}forall
%%(Aliana) pstack quit

%%% a3copiseny
%%% aqui modifiquem el dic dels XObject implicats (JectesX + imatgesXordre + docJpeg) en la reincrustacio d'imatges
%%% tret q fos un PDF sense imatges i llavors plegariem!
%%% QUINES COSES NO CONTEMPLAREM ENCARA EN AQUESTA VERSIO DE #7
%% No contemplarem mes d'1 XObject que estigui dins un Form (doncs llavors hauriem de llegir el seu stream x esbrinar-ne l'ordre)
%% No contemplarem les inLine (malgrat l'Acrobat les exporta) i llavors aixo ho filtrem saltant-nos el processament del JPEG exportat
%% No comprovarem que les imatges es corresponguin (ratio x, y), doncs si per error processem un PDF vinculat a un directori d'imatges extretes q no li correspon:
%% Al JPEG que s'hagi fet una imatge mirall o una rotacio de 180, depenent de com s'hagi salvat no ho detectarem (doncs hauriem de llegir aquesta dada dins el jpeg i alterar la cm al cridar la imatge)
%% l'altre solucio segurament seria passar la imatge a RAW i repicar-la de nou a JPG (o no)
%% Si hi ha imatges identiques al document (q comparteixen el mateix tou de dades), malgrat l'Acrobat les exporta tants cops
%% com vegades surten al reincrustar-se, *CALFER*de moment avisarem que hi ha imatges que es repeteixen*CALFER* al repicar-les nomes
%% valdra la darrera que s'escrigui (per ordre)
%% Hem detectat que a l'exportacio, Acrobat, no respecta la integritat de l'objecte XObject d'imatge intern, per exemple:
%% en cas que aquesta sobrepassi les mides del format de plana o estigui rotada, llavors (l'A7?) retalla la imatge per les
%% sangs de la plana fent que les dades del cm ja no quadrin amb el ratio x,y de les dades de l'XObject ... i llavors la
%% imatge reincrustada surt deformada! (que fem?) ... o en cas d'estar rotada, el que s'exporta es el rectangle que l'inscriu
%% (amb el blanc inclos!) mantenint la rotacio i al reincrustar-la, logicament queden alterades les mides i l'angle de rotacio (que fem?)

QueLiFemFer 7 eq  %:07 REINSEREIX IMATGES JPEG
{  %#%31bis2% modificació dels diccionaris XObject, pàgina a pàgina, sobre el mapa ordenat d'imatges cridades per Do a l'stream de Contents
 (%#%31bis2%)==

 %% aqui normalitzem amb nulls el paquet d'imatges x plana x tal que no peti l'algorisme al reinserir menys quantitat d'imatges x pagina q les q tocaria
 JectesX
 {
  length 1 add array dup  %% fem el paquet farcidor que normalitzara la quantitat de possibles imatges x plana a docJpeg
  docJpeg 3 index 5 string cvs cvx exec get  %% convertim la clau en index de plana i la tibem
  dup null eq {1 array astore}if  %% sempre han de ser arrays
  0 exch putinterval  %% refarcim x assegurar que la mida de l'array sempre quadrara amb el nombre d'imatges de la plana
  exch 5 string cvs cvx exec exch docJpeg 3 1 roll put
 }forall

 /iPMi 0 def  %% index de pagina del mapa d'imatges ordenat
 XRay /PeDeEfa get /imatgesXordre get
 {  %% forall x cadascuna de les planes
  /iiAr 1 def  %% index d'imatge a reinserir
  dup null eq
  {  %% la pagina no te imatges
   pop
  }
  {
   dup length /nExport exch def  %% x detectar possibles errors
   {  %% forall x cadascuna de les imatges de la plana per ordre d'aparicio dins l'stream
    %% aqui es on hauriem de filtrar amb null els elements que no siguin valids per a reinserir (Forms? inLine?)
    dup null eq
    {  %% un null ens hauria de dir que es una imatge cridada per Do o una inLine que ara no processem
     pop
    }
    {  %% anem a pescar l'objecte XObject per modificar-ne el seu dic
     JectesX iPMi 5 string cvs get exch get
     /aCercar exch def  %% nom amb la ref ind de l'XObject
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
     dup /Subtype get  %% es una imatge o es un FormXObject ?
     /Image eq
     {  %% es una imatge XObject
      docJpeg iPMi get  %% pesquem l'array corresponent a la pagina      
      dup
      null eq
      {
       pop pop  %% encarreguem l'array i el dic
      }
      {
       dup length 1 sub nExport ne  %% q no coincidis tan podria ser degut a l'estructura del PDF com a no tenir totes les imatges a reinserir al directori
       {
        (\n <<< el nombre de JPEGs a reinserir a la pagina NO COINCIDEIX amb el total d'imatges\n ... seguim\n\n\n) print flush  %%quit
       }if
       iiAr
       get  %% pesquem el dic de la imatge exportada q toca, amb les dades a repicar dins el dic original
       dup null eq
       {
        pop pop  %% ens carreguem el null i el dic
       }
       {
        dup /xiu get 2 index exch /XIU exch [ exch ] put  %% inserim el nou path dins l'array q indica q es un fitxer extern
        dup /Width get 2 index exch /Width exch put  %% inserim els pixels d'ample
        /Height get 1 index exch /Height exch put  %% inserim els pixels d'alt
        dup /ColorSpace /DeviceRGB put  %% inserim l'espai de color pactat
        dup /BitsPerComponent 8 put  %% inserim la fondaria d'imatge pactada
        dup /Filter /DCTDecode put  %% inserim el filtre (jpeg) pactat
        dup /DecodeParms undef /ImageMask undef  %% per assegurar-nos-en (hi ha + parametres q poden fer nosa?)
( ... imatge XObject directe ... ) ==
       }ifelse
      }ifelse
     }
     {  %% es un FormXObject
      /aDieNT true def  %% gatell x saber si tractem el Form
      {  %% loop
       dup /Resources known
       {  %% si els te, possiblement dugui una imatge XObject
        /Resources get
	dup type /dicttype ne  %% sera una ref ind?
	{
         /aCercar exch def  %% nom de la ref ind de Resources
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
	}if
	dup length 0 eq
	{  %% si el dic es buit es q no te Resources
         pop
         aCercar == (\n ... aquest FormXObject es incongruent amb el mapa d'imatges exportades\n) print flush
         /aDieNT false def  %% gatell x saber que NO tractarem el Form
         exit
	}
	{  %% en duu
         dup /XObject known
         {  %% en duu
          /XObject get
          %% donem x fet q es un dic directe
          dup length 1 gt
          {  %% si duu + d'1 imatge aturem la feina doncs encara no estem segurs de quin sera l'ordre d'exportacio en aquest cas
           %% se suposa q tambe manara l'ordre de descripcio de l'stream del propi Form ?
           (\n <<< CaLi2CoPi NO admet encara Forms amb + d'1 XObject\n ... PLEGUEM!\n\n) print flush stop  %%quit
          }
          {  %% nomes hi ha 1 imatge
           {  %% forall on donem x fet q sempre sera una ref ind
            exch pop  %% matem el literal de l'XObject
            /aCercar exch def  %% nom de la ref ind de l'XObject
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            } loop  %% d'interrogacio dels dicts de COMdimoni
            %% aqui si el /Subtype no es /Image, doncs tornem a fer una volta de loop
            dup /Subtype get /Image eq
            {  %% ja tenim el dic que necesitem modificar!
             /aquestSI true def
            }
            {
             /aquestSI false def
            }ifelse
           }forall
           aquestSI
           {
%%(Form d'1 NIVELL) ==
            exit
           }if
          }ifelse
         }
         {  %% no en duu
          pop
          aCercar == (\n ... aquest FormXObject es incongruent amb el mapa d'imatges exportades\n) print flush
          /aDieNT false def  %% gatell x saber que NO tractarem el Form
          exit
         }ifelse
	}ifelse
       }
       {  %% com q no te Resources o no tindra imatges XObject segur i llavors estariem davant d'una incongruencia?
         %% o som dins una XObject profunda: un Form dins un Form (i ja duriem dues voltes de loop com a minim)
        dup /Subtype get /Image eq
	{  %% ja tenim el dic que necessitem modificar!
%%(Form PROFUNDA) ==
	 exit
	}
	{
         pop
         aCercar == (\n ... aquest FormXObject es incongruent amb el mapa d'imatges exportades\n) print flush
         /aDieNT false def  %% gatell x saber que NO tractarem el Form
         exit
	}ifelse
       }ifelse
      } loop
      aDieNT
      {  %% aqui modifiquem el dic de l'XObject que hi ha dins el Form
       docJpeg iPMi get  %% pesquem l'array corresponent a la pagina
       dup
       null eq
       {
        pop pop  %% encarreguem l'array i el dic
       }
       {
        dup length 1 sub nExport ne  %% q no coincidis tan podria ser degut a l'estructura del PDF com a no tenir totes les imatges a reinserir al directori
        {
	 (\n <<< el nombre de JPEGs a reinserir a la pagina NO COINCIDEIX amb el total d'imatges\n ... seguim\n\n\n) print flush  %%quit
	}if
        iiAr
	get  %% pesquem el dic de la imatge exportada q toca, amb les dades a repicar dins el dic original
        dup null eq
	{
	 pop pop  %% ens carreguem el null i el dic
	}
	{
	 dup /xiu get 2 index exch /XIU exch [ exch ] put  %% inserim el nou path dins l'array q indica q es un fitxer extern
         dup /Width get 2 index exch /Width exch put  %% inserim els pixels d'ample
         /Height get 1 index exch /Height exch put  %% inserim els pixels d'alt
         dup /ColorSpace /DeviceRGB put  %% inserim l'espai de color pactat
         dup /BitsPerComponent 8 put  %% inserim la fondaria d'imatge pactada
         dup /Filter /DCTDecode put  %% inserim el filtre (jpeg) pactat
         dup /DecodeParms undef /ImageMask undef  %% per assegurar-nos-en (hi ha + parametres q poden fer nosa?)
( ... imatge dins un Form ... ) ==
        }ifelse
       }ifelse
      }if
      %%(listilluuuuuuuuuu)pstack quit
     }ifelse  %% es una imatge XObject o un FormXObject
    }ifelse
    iiAr 1 add /iiAr exch def  %% fem correr l'index d'imatge a reinserir
   }forall  %% x cadascuna de les imatges de la plana per ordre d'aparicio dins l'stream
  }ifelse
  iPMi 1 add /iPMi exch def  %% fem correr l'index de pagina
 }forall  %% x cadascuna de les planes
}if  %/07 REINSEREIX IMATGES JPEG

%#%32% Valors inicials per l'anàlisi complementari dels Espais de Color per saber ...
(%#%32%)==
%# 1. si hi ha CS amb valor zero de tinta (i quins són) i si aquest valor és sol o no
/csZero 2 dict def  % si el dic es buit es que no n'hi han
%# 2. si hi ha CS PureCMYK
/csPureCMYK false def  % gatell detector
%%% fi dels valors inicials x l'analisi dels Espais de Color

%% test
%% XRay /EspaisDeColor get /TintesiValors get
%% XRay /ObjectesX get /Utilitzats get
%% /DN_0_1 get /Paleta get {== ==} forall
%% /NoName9 get %/Paleta get
%%{== ==}forall  %%%DUMENGE ... cal assegurar-se que els noms de les imatges dins Paleta duen com a valor el nom /Imatge
%%(Aliana) pstack quit

%#%33% descabdellem totes les Tintes diferents i els seus valors perceptuals
(%#%33%)==
XRay /EspaisDeColor get /TintesiValors get /TiV exch def  %% desem el dic x tenir-lo a tret
XRay /EspaisDeColor get /Utilitzats get
{  %% forall x desar tots els noms diferents i tractar les tintes descrites en PureCMYK
 exch /NomIntern exch def  %% desem el nom intern de l'espai de color utilitzat
 dup null eq
 {  %% si es un null es que es un Pattern i llavors no fem res ...
  pop
 }
 {
  /NomExtern get
  %% primer cal filtrar de si es tracta d'una array (cas DeviceN) o d'un literal (cas PureCMYK o Separation)
  dup type /nametype eq
  {  %% es un literal
   %% primer mirem si es un PureCMYK o un DeviceCMYK
   dup /PureCMYK eq 1 index /DeviceCMYK eq or
   {  %% ho es (o sigui o un /NoName9 o un altre de nom intern)
    pop
    XRay /EspaisDeColor get /Utilitzats get NomIntern get
    /Paleta get
    {  %% forall al dic Paleta on hi han desats tots els valors hexa diferents ...
     dup
     /Directe eq
     {  %% ... ens assegurem q no sigui una imatge
      pop
      %% transforma el literal hexa a una string (aTxC) amb els valors 0/1 CMYK
      8 string cvs
      0 () /SubFileDecode filter 4 string readhexstring
      pop /aTxC () def
      {  %% forall
       255 div  %% passem a valor 0/1
       64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
       1 add  %% separem els valors amb espais en blanc
       dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
       ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
       laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
      } forall
      %% farcim el paquet /TanX100 amb el valor CMYK q ja sabem segur q es diferent
      XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /NN9 exch def  %% desem el dic d'aquest NoName9 o el que sigui x despres
      /TanX100 get  %% l'array a farcir
      dup length 1 add dup 1 sub /Dmes exch def
      array dup dup 4 -1 roll 0 exch putinterval Dmes aTxC put
      dup length array copy  %% en fem una copia x evitar possibles pinçats
      NN9 exch /TanX100 exch put  %% clavem l'array a lloc
     }
     {
      dup
      /Imatge eq
      {  %% es una imatge?
       pop /inomIntern exch def  %% tornem a desar el nom intern x farcir l'array de valors
       XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /NN9 exch def  %% desem el dic d'aquest NoName9 o el que sigui x despres
       /TanX100 get  %% l'array a farcir
       dup length 1 add dup 1 sub /Dmes exch def
       array dup dup 4 -1 roll 0 exch putinterval Dmes
       %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
       %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
       inomIntern /LiTeRaLS exch def
       4 /ComFaciFalta exch def
       LiTeRaLS dup length 2 add dup /aDeS exch def string dup
       3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
       /iaRa exch def
       aDeS  %%4 
       ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
       mul string /aDesiaRa exch def
       aDesiaRa /NullEncode filter
       ComFaciFalta {dup iaRa writestring} repeat
       closefile aDesiaRa
       put  %% en comptes de posar les dades normals de % d'imatge (aTxC) posem quatre vegades el nom inomIntern que ja ens fara la funcio que toca en aquest cas
       dup length array copy  %% en fem una copia x evitar possibles pinçats
       NN9 exch /TanX100 exch put  %% clavem l'array a lloc
      }
      {
       /Shading eq
       {  %% es un Shading Pattern?
        /SPnomIntern exch def  %% tornem a desar el nom intern x farcir l'array de valors
        XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /NN9 exch def  %% desem el dic d'aquest NoName9 o el que sigui x despres
        /TanX100 get  %% l'array a farcir
        dup length 1 add dup 1 sub /Dmes exch def
        array dup dup 4 -1 roll 0 exch putinterval Dmes
        %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
        %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
        SPnomIntern /LiTeRaLS exch def
        4 /ComFaciFalta exch def
        LiTeRaLS dup length 2 add dup /aDeS exch def string dup
        3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
        /iaRa exch def
        aDeS  %%4 
        ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
        mul string /aDesiaRa exch def
        aDesiaRa /NullEncode filter
        ComFaciFalta {dup iaRa writestring} repeat
        closefile aDesiaRa
        put  %% en comptes de posar les dades normals de % del Shading (aTxC) posem quatre vegades el nom PSnomIntern que ja ens fara la funcio que toca en aquest cas
        dup length array copy  %% en fem una copia x evitar possibles pinçats
        NN9 exch /TanX100 exch put  %% clavem l'array a lloc
       }if
      }ifelse
     }ifelse
    }forall
   }
   {  %% despres cal mirar si es un /None, i si no finalment sera un /All o un literal normal
    dup /None eq
    {  %% les Separations /None NO les donem de baixa ... pero potser haurem de controlar que no produeixin cap separacio indesitjada
     %%XRay /EspaisDeColor get /Utilitzats get NomIntern undef
     pop
    }  %% si es un None no fem res
    {  %% solucio DeviceGray
     dup /Black eq  %% es un DeviceGray ?
     {  %% ho es ...
      pop
      XRay /EspaisDeColor get /Utilitzats get NomIntern get
      /Paleta get
      {  %% forall al dic Paleta on hi han desats tots els valors hexa diferents ...
       dup
       /Directe eq
       {  %% ... ens assegurem q no sigui una imatge
        %%(Implementat DeviceGray pels vectorials) ==
        pop
        %% transforma el literal hexa a una string (aTxC) amb els valors 0/1 de BlacK
        %% transforma el literal hexa a una string (aTxC) amb els valors 0/1 CMYK
        8 string cvs
        0 () /SubFileDecode filter 4 string readhexstring
        pop /aTxC () def
        {  %% forall
         255 div  %% passem a valor 0/1
         64 string cvs /valG exch def aTxC length dup /aNT exch def valG length add
         1 add  %% separem els valors amb espais en blanc
         dup /ToTa exch def string dup /ToTalaC exch def /NullEncode filter /laC exch def
         ToTa {laC 32 write} repeat  %% ens assegurem que la cadena no dugui nulls!
         laC flushfile ToTalaC dup dup 0 aTxC putinterval aNT valG putinterval /aTxC exch def
        }forall
        %% farcim el paquet /TanX100 amb el valor CMYK q ja sabem segur q es diferent
        XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /NN9 exch def  %% desem el dic d'aquest NoName9 o el que sigui x despres
        /TanX100 get  %% l'array a farcir
        dup length 1 add dup 1 sub /Dmes exch def
        array dup dup 4 -1 roll 0 exch putinterval Dmes aTxC put
        dup length array copy  %% en fem una copia x evitar possibles pinçats
        NN9 exch /TanX100 exch put  %% clavem l'array a lloc
       }
       {
        dup
        /Imatge eq
        {  %% es una imatge?
         %%(Implementat DeviceGray per les imatges) ==
%%canicula%test%
%%(mmmmmmmmm) pstack quit

         pop /inomIntern exch def  %% tornem a desar el nom intern x farcir l'array de valors
         XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /NN9 exch def  %% desem el dic d'aquest NoName9 o el que sigui x despres
         /TanX100 get  %% l'array a farcir
         dup length 1 add dup 1 sub /Dmes exch def
         array dup dup 4 -1 roll 0 exch putinterval Dmes
         %% com que ni analitzem ni escrivim tots els colors que pinta la imatge ...
         %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
         inomIntern /LiTeRaLS exch def
         4 /ComFaciFalta exch def  %% per les DeviceGray simulem un CMYK
         LiTeRaLS dup length 2 add dup /aDeS exch def string dup
         3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
         /iaRa exch def
         aDeS
         ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
         mul string /aDesiaRa exch def
         aDesiaRa /NullEncode filter
         ComFaciFalta {dup iaRa writestring} repeat
         closefile aDesiaRa
         put  %% en comptes de posar les dades normals de % d'imatge (aTxC) posem Una vegada el nom inomIntern que ja ens fara la funcio que toca en aquest cas
         dup length array copy  %% en fem una copia x evitar possibles pinçats
         NN9 exch /TanX100 exch put  %% clavem l'array a lloc
        }
        {
         /Shading eq
         {  %% es un Shading Pattern?
          (<<<< Aqui CAL Implementar DeviceGray pels Shading) ==  %%stop
          /SPnomIntern exch def  %% tornem a desar el nom intern x farcir l'array de valors
          XRay /EspaisDeColor get /Utilitzats get NomIntern get dup /NN9 exch def  %% desem el dic d'aquest NoName9 o el que sigui x despres
          /TanX100 get  %% l'array a farcir
          dup length 1 add dup 1 sub /Dmes exch def
          array dup dup 4 -1 roll 0 exch putinterval Dmes
          %% com que ni analitzem ni escrivim tots els colors que pinta el Shading ...
          %% adesiara farceix en una cadena amb tants LiTeRaLS ComFaciFalta separats per un espai
          SPnomIntern /LiTeRaLS exch def
          1 /ComFaciFalta exch def  %%% segur q es nomes 1 ?
          LiTeRaLS dup length 2 add dup /aDeS exch def string dup
          3 -1 roll aDeS string cvs 1 exch putinterval dup aDeS 1 sub ( ) putinterval dup 0 (/) putinterval
          /iaRa exch def
          aDeS  %%?
          ComFaciFalta  %% hem de multiplicar pel nombre de components de color!!
          mul string /aDesiaRa exch def
          aDesiaRa /NullEncode filter
          ComFaciFalta {dup iaRa writestring} repeat
          closefile aDesiaRa
          put  %% en comptes de posar les dades normals de % del Shading (aTxC) posem quatre vegades el nom PSnomIntern que ja ens fara la funcio que toca en aquest cas
          dup length array copy  %% en fem una copia x evitar possibles pinçats
          NN9 exch /TanX100 exch put  %% clavem l'array a lloc
         } if
        }ifelse
       }ifelse
      }forall
     }  %% solucio DeviceGray
     {  %% es un /All o un altre nom qualsevol ...
      TiV exch [] put  %% desem a sac i de moment amb una array buida com a valor
     }ifelse
    }ifelse    
   }ifelse
  }
  {  %% es una array d'un DeviceN
   %%% cal filtrar un possible /None?
   {  %% desem a sac i de moment amb una array buida com a valor, dins del dic /TintesiValors, tots els noms diferents de color
    TiV exch [] put
   }forall
  }ifelse
 }ifelse
}forall

%% XRay /EspaisDeColor get /TintesiValors get
%% XRay /EspaisDeColor get /Utilitzats get
%% /DeviceGray get
%% /CS0 get %/Paleta get
%%{== ==}forall

%% atencio! detectada brosa de diccionaris i imatges inLine, si processem un PDF que en dugui!
%%(/////a3copiseny/////) pstack quit

%#%33bis% forall per desar dins tots els noms diferents (TiV) tots els seus valors perceptuals diferents
(%#%33bis%)==
XRay /EspaisDeColor get /Utilitzats get
{
 exch
 /NomIntern exch def  %% desem el nom intern de l'espai de color utilitzat
 dup null eq
 {pop}  %% si es un null es que es un Pattern i llavors no desem res
 {
  NomIntern dup /NoName9 eq exch /DeviceGray eq or  %% solucio DeviceGray
  {  %% si es un PureCMYK o DeviceGray l'array dels noms es aquest ...
   [/Cyan /Magenta /Yellow /Black] dup /elsNoms exch def  %% desem l'array de noms
  }
  {
   dup /NomExtern get
   %% filtrem encara la possibilitat que un ColorSpace dugui un DeviceCMYK directe ...
   dup /PureCMYK eq 1 index /DeviceCMYK eq or
   1 index /All eq or  %%(Aliana) pstack quit
   {pop [/Cyan /Magenta /Yellow /Black]}if
   dup type /nametype eq {1 array astore dup}{dup}ifelse  %% ens assegurem que sigui una array i si no li posem ...
   /elsNoms exch def  %% desem l'array de noms
  } ifelse

  length dup /FAelsNoms exch def  %% desem el que fa l'array de noms
  1 sub /iNom exch def  %% index x iniciar la lectura del nom
  /Petara false def  %% gatell x defecte a false x arrays TanX100 buides (¿?)

  %% contemplem l'excepcio de que el color nomes estigui definit com una quadricromia amb /Separation /All
  dup /NomExtern get /All eq 1 index /Tipus get /Separation eq and
  {  %% llavors quadripliquem el valor de color de l'string de l'array TanX100 xq treballi correctament com a CMYK
   /TanX100 get
   dup length 0 eq
   {
    pop
   }
   {
    0 get dup length dup /1tat exch def 4 mul 3 add  %% x farcir la string x 4 valors
    string /4tifiquem exch def /aFicar exch def
    4tifiquem /NullEncode filter dup aFicar writestring
    3 {dup dup 32 write aFicar writestring} repeat closefile
    4tifiquem dup dup dup 4 array astore  %% rectifiquem l'array TanX100
   }ifelse
  }
  {
   /TanX100 get
  }ifelse

  {  %% forall x cada una de les strings amb percentatges de les tintes usades
   mark exch cvx exec  %% ara tenim a la pila els valors de tinta
   
   %%canicula%test
   %% a /TanX100 de les imatges (Xob+InL) DeviceGray manca posar-hi tants noms com colors (4)
   %% /Im1 /Im1 /Im1 %(-----------) pstack quit
   
   counttomark FAelsNoms
   eq {/Petara false def}{/Petara true def exit}ifelse  %% si el nombre de valors de color no quadra amb el nombre de colors, sortim i activem el gatell
   {
    %% els llegim agafant el nom del color per la cua de l'array
    elsNoms iNom get dup /nT exch def  %% desem el nom de la tinta
    %% mirem si un valor (aVeure) existeix dins una array (aFicar) i si no hi es, li fiquem
    TiV exch
    %% podria ser que el nom de la Tinta encara no existis (com passa en alguns PDF que duen definicions de color amb k/K/ o DeviceCMYK) i llavors ens en assegurem ...
    known {TiV nT get}{ [] }ifelse
    /aFicar exch def
    /aVeure exch def
    /jaHIes false def
    aFicar {aVeure eq {/jaHIes true def exit} if}forall
    jaHIes not
    {  %% si el valor de la tinta encara no es desat li afegim a l'array de valors
     aFicar
     dup length 1 add dup 1 sub /Dmes exch def
     array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
     dup length array copy  %% en fem una copia x evitar possibles pinçats
     TiV exch nT exch put  %% desem al dic de TintesiValors l'array augmentada
    }if
    iNom 1 sub /iNom exch def
    iNom 0 lt {exit}if
   }loop
   cleartomark  %% ens carreguem la mark
   elsNoms length 1 sub /iNom exch def  %% inicialitzem l'index
  }forall
  Petara
  {
   XRay /EspaisDeColor get /Errades get NomIntern ( Wrong number of setcolor values) put
  }if
 }ifelse
}forall

%%% depurem un possible /None que s'arrossegui dels Espais de Color Utilitzats
TiV /None undef

%% ARAIAQUI
%% TiV {== ==}forall
%%(Aliana) == quit
%% XRay /Separacions get /All known  %{== ==} forall
%% XRay /EspaisDeColor get /Desconeguts get {== ==}forall

%#%33bis2% ara tractem l'entrada /All si hi és ...
(%#%33bis2%)==
TiV /All known
{  %% si duu /All ens hem d'assegurar que tots els valors duen el seus valors de tinta (els de l'array)
 TiV /All get dup /aAll exch def  %% desem l'array de All x pentinar-la pels Process Colors
 TiV /All undef  %% donem de baixa /All x rastrejar nomes la resta de valors
 {
  %% mirem si un valor (aVeure) existeix dins una array (aFicar) i si no hi es, li fiquem
  /aVeure exch def
  TiV
  {  %% repassem per a cada un dels valors de l'array d'All si existeix dins les arrays del dic TiV
   exch /LaClau exch def  %% desem la clau
   /aFicar exch def
   /jaHIes false def
   aFicar {aVeure eq {/jaHIes true def exit} if}forall
   jaHIes not
   {
    aFicar
    dup length 1 add dup 1 sub /Dmes exch def
    array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
    TiV exch LaClau exch put  %% clavem l'actualitzacio
   }if
  }forall
 }forall

 %% el raonament correcte pel tractament de /All en relacio al CMYK ens duu a saber si ja
 %% existeix alguna de les tintes del CMYK definides, i si es aixi llavors aixo ens dura a
 %% afegir el valor que correspon a l'existent i a la creacio de la resta que manquin amb
 %% els seu corresponent valors

 %#%33bis3% pentinem l'existència d'alguna de les Tintes /Cyan/Magenta/Yellow/Black (Process Colors)
 %# doncs en el cas que n'hi hagi alguna de creada, All (pel que sembla) força la creació de la resta, per dipositar-hi també els seus valors
 (%#%33bis3%)==
 XRay /EspaisDeColor get /Removed get /edcR exch def  %% ens desem el dic
 /HiHaProcessColors false def  %% gatell
 /ProcessColorsQHiHa << >> def  %% dic on desarem els ProcessColors que hi ha x saber si hem de generar la resta ...
 TiV
 {
  pop dup <</Cyan null /Magenta null /Yellow null /Black null>> exch known
  {
   /HiHaProcessColors true def ProcessColorsQHiHa exch null put
  }
  {
   pop
  }ifelse
 }forall
 HiHaProcessColors  %% en cas que hi hagi ProcessColors sabrem si hi ha tota la col.leccio o no
 {
  <</Cyan null /Magenta null /Yellow null /Black null>> /xCrear exch def
  ProcessColorsQHiHa length 4 ne
  {  %% si no hi ha la quadricromia sencera, /All ens obliga a crear els colors que manquen
   ProcessColorsQHiHa {pop xCrear exch undef} forall  %% a xCrear donem de baixa els que ja existeixen ...
   %% ... aixi ens queden els xCrear
   xCrear
   {
    pop dup TiV exch aAll put  %% que donem d'alta al dic de TiV
    edcR exch null put  %% i tambe al dic Removed x gestionar correctament les separacions de sortida i l'info de l'XRay
   }forall
  }if
 }if

 %#%33bis4% Tintes que només existeixen com a /Separation i que cal donar d'alta per l'acció de /All? (ara se'm presenta el dubte de que si no existís All també hauríem d'actuar així o no)
 %# per solucionar el cas 21_8034.pdf
 %# com que All actúa, mirem si existeix algun color a /Separacions que no haguem donat d'alta a TiV (ni a EspaisDeColor?)
 (%#%33bis4%)==
 XRay /Separacions get
 {
  exch dup /All eq
  {
   pop pop
  }
  {
   dup TiV exch known
   {pop pop}
   {  %% si la Separation no existeix a TiV doncs l'hem de donar d'alta!
    TiV exch aAll put pop
   }ifelse
  }ifelse
 }forall
 %%% fi d x solucionar el cas 21_8034.pdf
}
{
 XRay /EspaisDeColor get /Removed get /edcR exch def  %% ens desem el dic x l'escriptura d'XRay
 %% traslladat a 33bis4
 %% TiV {  % si algun dels valors CMYK nomes duu 0, doncs llavors l'eliminarem de les separacions de sortida ...
 %%      exch dup <</Cyan null /Magenta null /Yellow null /Black null>> exch known
 %%      {  % si es un component CMYK ...
 %%       /XedcR exch def  % el desem x donar-lo d'alta si cal a /Removed d'EspaisDeColor
 %%       dup length 1 eq {  % si nomes duu 1 component mirem si es zero
 %%                        0 get 0 eq {edcR XedcR null put}if  % el donem d'alta a /Removed
 %%                       }
 %%                       {
 %%                        pop
 %%                       }ifelse
 %%      }{pop pop}ifelse
 %%     }forall
}ifelse

%%canicula%test
%#%33bis4bis% degut a que les imatges (XObject+inLine) descrites amb DeviceGray les donem d'alta com si fossin CMYK, activem
%# un filtre per eliminar de TiV totes les imatges (XObject+inLine) DeviceGray que estiguin referenciades fora de Black
%# doncs si no es produiria un error en el procés de separació de colors %43
(%#%33bis4bis%)==
XRay /ObjectesX get araPlana get  % pesquem el dic de la plana on som
/Utilitzats get
{  %% forall
 dup type /arraytype eq
 {  %% es un XObject
  2 get /DeviceGray eq
  {  %% si es DeviceGray desem el nom de la imatge i la cerquem per les arrays de color de TiV que no siguin Black
   /iAllucar exch def
   TiV
   {  %% forall
    1 index /Black eq
    {pop pop}
    {  %% eliminem la referencia de la imatge iAllucar a tota la resta de tintes que no siguin Black
     %% eliminia un element de l'array i la refa de nou
     %% purguem els Occeix d'AraBorro que hi hagi
     iAllucar /Occeix exch def  %% element a eliminar
     /AraBorro exch def  %% l'array a explorar la tenim a la pila
     /tArepicar exch def  %% la tinta a repicar-li l'array
     /iKill 0 def  %% l'index a matar
     {  %% loop
      /iAo 0 def  %% index general del paquet original
      /iAr 0 def  %% index general del paquet a repicar
      AraBorro
      %% filtre x arrays buides
      dup length 0 eq {pop exit} if
      iKill get
      Occeix eq
      {  %% if
       AraBorro dup length 1 sub array
       /laNova exch def  %% el paquet repicat sempre tindra n-1 elements
       {  %% forall
        iAo iKill eq
        {
         pop
         iAr 1 sub /iAr exch def
        }  %% si es l'element que hem de matar, doncs el matem
        {
         laNova exch iAr exch put
        }  %% la resta els repiquem a laNova
        ifelse
        iAo 1 add /iAo exch def
        iAr 1 add /iAr exch def
       }forall
       laNova /AraBorro exch def
       iKill 1 sub /iKill exch def  %% comptador per saber l'index a matar
      }if
      iKill 1 add /iKill exch def  %% comptador per saber l'index a matar
      AraBorro length /maxLoop exch def  %% quan sortim
      iKill maxLoop ge {exit} if
     }loop
     TiV tArepicar AraBorro put  %% repiquem la nova array d'elements de la tinta
    }ifelse
   }forall
  }
  {pop}ifelse
 }
 {  %% es una inLine
  dup /CS known
  {
   /CS get /G eq
  }
  {
   pop false
  }ifelse
  {  %% si es DeviceGray desem el nom de la imatge i la cerquem per les arrays de color de TiV que no siguin Black
   /iAllucar exch def
   TiV
   {  %% forall
    1 index /Black eq
    {pop pop}
    {  %% eliminem la referencia de la imatge iAllucar a tota la resta de tintes que no siguin Black
     %% eliminia un element de l'array i la refa de nou
     %% purguem els Occeix d'AraBorro que hi hagi
     iAllucar /Occeix exch def  %% element a eliminar
     /AraBorro exch def  %% l'array a explorar la tenim a la pila
     /tArepicar exch def  %% la tinta a repicar-li l'array
     /iKill 0 def  %% l'index a matar
     {  %% loop
      /iAo 0 def  %% index general del paquet original
      /iAr 0 def  %% index general del paquet a repicar
      AraBorro
      %% filtre x arrays buides
      dup length 0 eq {pop exit} if
      iKill get
      Occeix eq
      {  %% if
       AraBorro dup length 1 sub array
       /laNova exch def  %% el paquet repicat sempre tindra n-1 elements
       {  %% forall
        iAo iKill eq
        {
         pop
         iAr 1 sub /iAr exch def
        }  %% si es l'element que hem de matar, doncs el matem
        {
         laNova exch iAr exch put
        }  %% la resta els repiquem a laNova
        ifelse
        iAo 1 add /iAo exch def
        iAr 1 add /iAr exch def
       }forall
       laNova /AraBorro exch def
       iKill 1 sub /iKill exch def  %% comptador per saber l'index a matar
      }if
      iKill 1 add /iKill exch def  %% comptador per saber l'index a matar
      AraBorro length /maxLoop exch def  %% quan sortim
      iKill maxLoop ge {exit} if
     }loop
     TiV tArepicar AraBorro put  %% repiquem la nova array d'elements de la tinta
    }ifelse
   }forall
  }
  {
   pop
  }ifelse
 }ifelse
}forall

%% TiV
%%{== ==}forall
%%(m'estic cagant) == quit

%#%33bis5% eliminem qualsevol Tinta que només dugui valor zero
(%#%33bis5%)==
TiV
{  %% forall de si algun dels valors de Tinta nomes duu 0, doncs llavors l'eliminarem de les separacions de sortida ...
 exch
 %%dup <</Cyan null /Magenta null /Yellow null /Black null>> exch known
 %%{  % si es un component CMYK ...
 /XedcR exch def  %% el desem x donar-lo d'alta si cal a /Removed d'EspaisDeColor
 dup length 1 eq
 {  %% si nomes duu 1 component mirem si es zero
  0 get 0 eq {edcR XedcR null put}if  %% el donem d'alta a /Removed
 }
 {  %% aqui mirem si no duu cap component ...
  length 0 eq {edcR XedcR null put}if  %% tambe el donem d'alta a /Removed
  %%pop
 }ifelse
 %%}{pop pop}ifelse
}forall

%% test
%% XRay /Lleixes get /nomIE get
%%edcR {== ==} forall (!) == quit  %aVeure
%%aAll == (!) == quit
%% XRay /EspaisDeColor get /Utilitzats get
%% /sepall get /Paleta get
%% TiV {== ==}forall (////) == quit
%%{
%% {== ==} forall
%% dup /NomExtern known {/NomExtern get ==}{pop}ifelse
%% ==
%%} forall

%%% x DILLUNS
%%% CAL FER UNA SELECCIO D'EXEMPLES MINIMS AMB TOTS ELS TIPUS DE PATTERN I ESPAIS DE COLOR RELACIONATS
%%% PER PODER ANAR CONSTRUINT ELS ALGORISMES DE CONTROL I SEPARACIO DE COLORS
%% XRay /Patterns&Shadings get /Utilitzats get {== ==}forall
%%% fi del descabdellat de tintes i valors

BaBeL 30 get print flush

%%% a3copiseny ... DESACTIVEM XRAY
%%false {

%#%34% escriptura del fitxer XRay (segona part)
(%#%34%)==
%% BoolXRay
%%{

%%!%! Hem traslladat la primera part de l'escriptura de l'XRay a %19bis1%

XRay /PeDeEfa get /Errades get dup length 0 eq
{
 pop
}
{  %% llistem els possibles errors greus que s'han detectat al llegir l'estructura del PDF
 {  %% forall
  wFitxerXRay (\015\012PDF:ERROR:) writestring
  exch 128 string cvs wFitxerXRay exch writestring wFitxerXRay exch writestring
 }forall
}ifelse

%%MASATS02
QueLiFemFer 15 eq  %:15 ELIMINA LLEIXES
{
 %% fabriquem una array de la capacitat de /nomIE...
 /MAXiOCkill 0 def
 XRay /Lleixes get

 /nomIE get dup
 { %% forall
  4 get dup MAXiOCkill gt
  {
   /MAXiOCkill exch def pop
  }
  {
   pop pop
  }ifelse
 }forall
 /LleixesMASATS MAXiOCkill 1 add array def
 {  %% forall
  [ 3 1 roll  %% ...on hi fiquem una array...
  %% com que hi poden haver nulls a OCGs cal saber primer quin és l'índex més alt per no provocar cap rangecheck
  dup 4 get dup /iLleixesMASATS exch def  %% ...a l'índex que toca
  3 1 roll dup 0 get exch 1 get  %% i on hi posem l'índex (redundant però visual), nom de l'objecte, nom intern i nom extern
  ]
  LleixesMASATS exch iLleixesMASATS exch put
 }forall
 %%Llistem pel prompt/log el contingut significatiu pel tractament de capes
 BaBeL 55 get print flush
 LleixesMASATS dup 0 get null eq
 {
  pop BaBeL 56 get print flush
 }
 {
  {
   dup 2 get null eq
   %% si duu un null vol dir que la capa és dins l'array de les /Properties de l'objecte /Page
   %% ni tampoc dins el tou de dades de l'stream
   {
    BaBeL 57 get print flush
   }if
   ==
  }forall
  BaBeL 54 get print flush
 }ifelse

 %% capturem, via índex, els noms interns de les lleixes per tal les detecti l'operador BDC
 iOCkill dup
 %% filtrem que a l'array del menú no hi hagin cossos estranys i s'hagin entrat només enters
 {
  type /integertype ne
  {  %% sortim si no es tracta d'un índex!
   BaBeL 49 get print flush stop
  }if
 }forall
 /bUit true def
 mark exch  %% anellat de l'array d'índex de lleixes existents a esborrar
 {  %% forall
  dup MAXiOCkill gt
  {  %% avisem quan un índex va més enllà del rang de lleixes
   (\n) print flush 6 string cvs print flush
   BaBeL 58 get print flush
  }
  {
   dup LleixesMASATS exch get null eq
   {  %% avisem quan un índex correspon a una posició null de l'array OCGs d'OCProperties (sense lleixa)
    (\n) print flush 6 string cvs print flush
    BaBeL 59 get print flush
   }
   {  %% deixem l'índex per farcir iLAesborrar
    dup LleixesMASATS exch get 2 get null eq
    {
     LleixesMASATS exch get BaBeL 60 get print flush ==
    }
    {
     /bUit false def
    }ifelse
   }ifelse
  }ifelse
 }forall
 ] /iLAesborrar exch def  %% array d'índex de lleixes existents a esborrar
 /PLleixesAeliminar <<>> def  %% diccionari on hi hauran els noms interns de les lleixes a eliminar del dic Properties
 /OLleixesAeliminar <<>> def  %% diccionari on hi hauran les ref ind de les lleixes a eliminar dins l'array Order
 bUit
 {  %% quan l'array és buida o amb índex a null, no fem re, avisem i redefinim QueLiFemFer a zero pel repicat ídem
  BaBeL 61 get print flush
  BaBeL 62 get print flush
  /QueLiFemFer 0 def
 }
 {  %% informem de l'índex i del nom literari de la lleixa que esborrarem
  iLAesborrar
  {  %% forall
   dup 6 string cvs BaBeL 52 get print flush print flush BaBeL 53 get print flush
   dup LleixesMASATS exch get 3 get print flush (\n) print flush
   dup LleixesMASATS exch get 1 get OLleixesAeliminar exch null put  %% diccionari amb les ref ind a null x l'array Order
   LleixesMASATS exch get 2 get /tIncidencies exch def
   PLleixesAeliminar tIncidencies null put  %% diccionari amb els noms a null que BDC ha detectat per donar de baixa
   %% informem de si les lleixes que eliminem tenen incidències a XRay
   XRay /Lleixes get
   dup /Errades get
   {  %% forall
    exch tIncidencies eq
    {
     BaBeL 63 get print flush
     pop exit
    }if
    pop
   }forall
   dup /Desconegudes get
   {  %% forall
    exch tIncidencies eq
    {
     BaBeL 64 get print flush
     pop exit
    }if
    pop
   }forall
   /Buides get
   {  %% forall
    exch tIncidencies eq
    {
     BaBeL 65 get print flush
     pop exit
    }if
    pop
   }forall
  }forall
 }ifelse
 (\n)print flush
}if  %/15 ELIMINA LLEIXES

%% ara escrivim l'info de les Layers
XRay /Lleixes get length 0 ne  %% si el diccionari no es buit es que n'hi ha ...
{
 XRay /Lleixes get  %% fem interrogacions successives del dic informatiu de les layers
 dup /nomIE get dup length dup /iLu exch def /_iLu exch def  %% necessari x netejar l'estructura a (%#%38%)
 /NPOff 0 def
 /NPOn 0 def  %% comptadors del PrintState
 {  %% forall
  exch pop dup 3 get
  {  %% gatell del PrintState ON
   wFitxerXRay (\015\012Layers:NonPrintingOff:name:) writestring
   NPOn 1 add /NPOn exch def
  }
  {  %% gatell del PrintState OFF
   wFitxerXRay (\015\012Layers:NonPrintingOn:name:) writestring
   NPOff 1 add /NPOff exch def
  }ifelse
  dup 1 get dup /LaLa exch def wFitxerXRay exch writestring
  2 get not
  {
   iLu 1 sub /iLu exch def wFitxerXRay dup dup (\015\012Layers:WARNING:) writestring
   LaLa writestring ( Layer is Unused in this Page) writestring
  }if
 }forall  %% llistem tots els noms externs de les layers i alertem si no es fa servir dins a Contents
 wFitxerXRay dup (\015\012Layers:NonPrintingOff:used:) writestring NPOn 7 string cvs writestring
 wFitxerXRay dup (\015\012Layers:NonPrintingOn:used:) writestring NPOff 7 string cvs writestring
 wFitxerXRay flushfile
 iLu 0 ne
 {
  dup /Unicode get
  {
   wFitxerXRay (\015\012Layers:encoding:unicode) writestring
  }
  {
   wFitxerXRay (\015\012Layers:encoding:8 bit) writestring
  }ifelse
 }if  %% escrivim el codificat de la cadena de text sempre que hi hagi layers al document
 wFitxerXRay flushfile
 dup /NoHeEscrit get dup length 0 eq
 {
  pop
 }
 {  %% llistem els possibles caracters que no s'han pogut reproduir be
  {  %% forall
   wFitxerXRay (\015\012Layers:WARNING:) writestring
   exch 128 string cvs wFitxerXRay exch writestring wFitxerXRay ( \174 ) writestring
   {  %% forall
    exch 128 string cvs wFitxerXRay exch writestring wFitxerXRay dup 32 write exch writestring
   }forall
  }forall
 }ifelse
 wFitxerXRay flushfile
 dup /Errades get dup length 0 eq
 {
  pop
 }
 {  %% llistem els possibles errors greus que s'han detectat al llegir l'estructura de les layers
  {  %% forall
   wFitxerXRay (\015\012Layers:ERROR:) writestring
   exch 128 string cvs wFitxerXRay exch writestring wFitxerXRay dup 32 write exch writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
 dup /Desconegudes get dup length 0 eq
 {
  pop
 }
 {  %% llistem els possibles errors deguts a que es crida a l'stream el nom d'una layer incorrecta o que no ha estat definida
  {  %% forall
   wFitxerXRay (\015\012Layers:ERROR:) writestring
   pop 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay ( Not Defined or Wrong Layer Name) writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
 /Buides get dup length 0 eq
 {
  pop
 }
 {  %% llistem els WARNINGS deguts a l'existencia de layers absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
  {  %% forall
   pop  %% ens carreguem el valor fix d'OC
   /nomOC exch def  %% desem el nom intern x cercar-ne l'extern q apareix a la solapa Layers del viewer
   XRay /Lleixes get /nomIE get  %% interroguem aquest dic x saber el nom extern de la layer que es buida
   {  %% forall
    exch pop  %% ens carreguem la ref ind
    dup 0 get nomOC eq
    {
     wFitxerXRay (\015\012Layers:WARNING:EmptyLayer:) writestring
     1 get wFitxerXRay exch writestring
    }
    {  %% ens carreguem l'array q descriu la layer
     pop
    }ifelse
   }forall
  }forall
 }ifelse
 wFitxerXRay flushfile
}
{
 0 /iLu exch def  %% no hi ha Layers
 wFitxerXRay (\015\012Layers:NonPrintingOff:used:0) writestring
 wFitxerXRay (\015\012Layers:NonPrintingOn:used:0) writestring
}ifelse
%% fi d'escriptura de l'info de les Layers
%% ara escrivim l'info dels Estats Grafics
%% de moment encara no escrivim els noms interns dels gs utilitzats ni el seu comportament d'overprint
XRay /EstatsGrafics get dup length 0 ne  %% si el diccionari no es buit es que n'hi ha ...
{
 %% fem interrogacions successives del dic informatiu dels Estats Grafics
 dup /Utilitzats get length  %% escrivim el nombre d'estats grafics utilitzats als streams de Contents
 wFitxerXRay dup (\015\012GStates:used:) writestring exch 7 string cvs writestring
 dup /Desconeguts get dup length 0 eq
 {
  pop
 }
 {  %% llistem els possibles errors deguts a que es crida a l'stream el nom d'una Estat Grafic incorrecte o que no ha estat definit
  {  %% forall
   wFitxerXRay (\015\012GStates:ERROR:) writestring
   pop 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay ( Not Defined or Wrong Graphic State Name) writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
 /NoUtilitzats get dup length 0 eq
 {
  pop
 }
 {  %% llistem les possibles alertes degudes a que hi ha Estats Grafics definits que no han estat utilitzats als streams de Contents
  {  %% forall
   wFitxerXRay (\015\012GStates:WARNING:) writestring
   pop 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay ( Graphic State is Unused in this Page) writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
}
{
 pop wFitxerXRay (\015\012GStates:used:0) writestring
 wFitxerXRay (\015\012GStates:WARNING:ExtGState undefined in Resources) writestring  %% (6) si el PDF no te Estats Grafics utilitzats a Resources ho donem com a WARNING (abans error)
}ifelse
%% fi d'escriptura de l'info dels Estats Grafics
%% ara escrivim l'info dels Espais de Color
XRay /EspaisDeColor get dup length 0 ne  %% si el diccionari no es buit es que n'hi ha ...
{
 %% fem interrogacions successives del dic informatiu dels EspaisDeColor
 dup /Utilitzats get dup
 %% llistem els noms externs dels espais de color utilitzats i la gamma de colors utilitzada
 {  %% forall
  exch dup /nIN exch def  %% desem el nom intern del color
  /Pattern eq
  {
   pop
   wFitxerXRay (\015\012CSpaces:begin:Pattern) writestring
   wFitxerXRay (\015\012CSpaces:end:Pattern) writestring
  }
  {
   dup null eq
   {  %% nova categoria d'espais de color que son Uncolored Patterns i que duran un null com a valor
    pop
    wFitxerXRay (\015\012CSpaces:begin:) writestring
    wFitxerXRay nIN 128 string cvs writestring
    wFitxerXRay (\015\012CSpaces:end:) writestring
    wFitxerXRay nIN 128 string cvs writestring
   }
   {
    wFitxerXRay (\015\012CSpaces:begin:) writestring
    dup /NomExtern get dup dup /nEX exch def  %% en desem una copia x repicar :end:
    type /arraytype eq
    {
     {  %% forall
      128 string cvs wFitxerXRay exch writestring wFitxerXRay 32 write
     }forall
    }
    {
     128 string cvs wFitxerXRay exch writestring
    }ifelse
    %% el dic Paleta te com a clau el color en hexa i com a valor el seu valor perceptual (ara encara no tenim clar si el posarem en una array amb un valor de % o que)
    /Paleta get dup length dup /faPa exch def 0 eq
    {
     pop
    }
    {
     {  %% forall
      pop  %% ens carreguem l'array del color descrit amb percentatges
      dup /00000000 eq
      {  %% incrustem a csZero el nom intern del color (com a clau) que duu un valor de tinta zero
       csZero nIN faPa 1 eq {true}{false}ifelse put  %% i com a valor incrustem un true si el zero es solitari o no (false)
      } if
      wFitxerXRay dup (\015\012) writestring exch 128 string cvs writestring
     }forall
    } ifelse  %% escrivim tota la gamma de colors
    wFitxerXRay (\015\012CSpaces:end:) writestring nEX
    dup type /arraytype eq
    {
     {  %% forall
      128 string cvs wFitxerXRay exch writestring wFitxerXRay 32 write
     }forall
    }
    {
     128 string cvs wFitxerXRay exch writestring
    }ifelse
   }ifelse
  }ifelse
 }forall
 length wFitxerXRay dup (\015\012CSpaces:used:) writestring exch 7 string cvs writestring  %% escrivim el nombre d'espais de color utilitzats als streams de Contents
 %% AQUI TENIM EL DUBTE de si en llistem els noms
 dup /Desconeguts get dup length 0 eq
 {
  pop
 }
 {  %% llistem els possibles errors deguts a que es crida a l'stream el nom d'un Espai de Color incorrecte o que no ha estat definit
  {  %% forall
   wFitxerXRay (\015\012CSpaces:ERROR:) writestring
   pop 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay ( Not Defined or Wrong Color Space Name) writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
 dup /NoUtilitzats get dup length 0 eq
 {
  pop
 }
 {  %% llistem les possibles alertes degudes a que hi ha Espais de Color definits que no han estat utilitzats als streams de Contents
  {  %% forall
   wFitxerXRay (\015\012CSpaces:WARNING:) writestring
   128 string cvs wFitxerXRay exch writestring wFitxerXRay (:) writestring 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay ( Color Space is Unused in this Page) writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
 /Errades get dup length 0 eq
 {
  pop
 }
 {  %% llistem els possibles errors emmagatzemats
  {  %% forall
   wFitxerXRay (\015\012CSpaces:ERROR:) writestring
   exch 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay exch writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
}
{
 pop wFitxerXRay (\015\012CSpaces:used:0) writestring
}ifelse
%% fi d'escriptura de l'info dels Espais de Color
%% ara escrivim l'info de totes les Tintes (colors) diferents i els seus valors perceptuals diferents
XRay /EspaisDeColor get /TintesiValors get dup length /tU exch def
{  %% forall x cada Tinta
 exch  %% escrivim el nom de la Tinta
 dup /nEX exch def  %% en desem una copia x repicar :end:
 edcR nEX known
 {  %% si la tinta existeix al dic Removed voldra dir que ha estat creada per /All i llavors en podem prescindir com a separacio final
  wFitxerXRay dup (\015\012Tint:removed:begin:) writestring exch 128 string cvs writestring
 }
 {
  wFitxerXRay dup (\015\012Tint:begin:) writestring exch 128 string cvs writestring
 }ifelse
 %% escrivim cadascun dels seus valors perceptuals diferents
 {  %% forall
  wFitxerXRay dup (\015\012) writestring exch 20 string cvs writestring
 }forall
 edcR nEX known
 {  %% si la tinta existeix al dic Removed voldra dir que ha estat creada per /All i llavors en podem prescindir com a separacio final
  wFitxerXRay dup (\015\012Tint:removed:end:) writestring nEX 128 string cvs writestring
 }
 {
  wFitxerXRay dup (\015\012Tint:end:) writestring nEX 128 string cvs writestring
 }ifelse
}forall
wFitxerXRay dup (\015\012Tint:used:) writestring tU 7 string cvs writestring
edcR
{  %% forall
 pop TiV exch undef
}forall  %% donem de baixa a sac totes les tintes existents al dic Removed dins el TintesiValors principal
wFitxerXRay dup (\015\012Tint:splitted:) writestring TiV length 7 string cvs writestring  %% aquest sera el nombre real de separacions (i nombre de PDF de sortida)
%% fi d'escriptura de l'info de totes les Tintes (colors) diferents i els seus valors perceptuals diferents
%% ara escrivim l'info de les Separacions
XRay /Separacions get dup length 0 ne  %% si el diccionari no es buit es que n'hi ha ...
{
 %% fem interrogacions successives del dic informatiu de les Separacions
 %% escrivim el nombre i el nom de les separacions utilitzades descartant les separacions tipus /All i /None
 /iS 0 def  %% x comptar les separacions
 {  %% forall
  pop dup <</All null /None null>> exch known
  {
   pop
  }
  {  %% llistem el nom extern i comptem el nombre de separacions
   wFitxerXRay dup (\015\012Separations:name:) writestring
   %% segurament son els noms de les tintes planes (PANTONE) o colors directes donats per l'usuari des de l'aplicacio de disseny
   %% son els mateixos noms que Acrobat7 llista a Advanced>Output Preview>Spot Plates
   exch 128 string cvs writestring iS 1 add /iS exch def
  }ifelse
 }forall
 wFitxerXRay dup (\015\012Separations:defined:) writestring iS 7 string cvs writestring
 wFitxerXRay flushfile
}
{
 /iS 0 def  %% no hi ha separacions
 pop wFitxerXRay (\015\012Separations:defined:0) writestring
}ifelse
%% fi d'escriptura de l'info de les Separacions
%%% ep! atencio! com es que queden InLines a la pila?????
%% ara escrivim l'info dels XObject
XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
%%% aquest raonament es bo? doncs malgrat no hi hagi XObjects aquest dic no es crea?
dup length 0 ne  %% si el diccionari no es buit es que n'hi ha ...
{
 %% fem interrogacions successives del dic informatiu dels ObjectesX
 dup /Utilitzats get dup
 %% llistem els noms interns dels ObjectesX utilitzats i les dades de les mides en pixels + l'espai de color utilitzat
 {  %% forall
  dup type /arraytype eq
  {
   %% Form o image XObject?
   dup 0 get type /arraytype eq
   {  %% Form
    %% llistem les dades del Form XObject
    wFitxerXRay (\015\012formXObject:begin:) writestring
    exch 128 string cvs dup /nEX exch def  %% en desem una copia x repicar :end:
    wFitxerXRay exch writestring wFitxerXRay dup (\015\012) writestring
    (boundingBox:) writestring  %% escrivim les dades que ens interessen ...
    0 get {128 string cvs wFitxerXRay exch writestring wFitxerXRay 32 write}forall
    wFitxerXRay dup (\015\012formXObject:end:) writestring nEX writestring
   }
   {  %% image
    %% llistem les dades d'una image XObject
    wFitxerXRay (\015\012imageXObject:begin:) writestring
    exch 128 string cvs dup /nEX exch def  %% en desem una copia x repicar :end:
    wFitxerXRay exch writestring wFitxerXRay dup (\015\012) writestring
    (pixelsWidth:) writestring  %% escrivim les dades del dic que ens interessen ...
    dup 0 get 10 string cvs wFitxerXRay exch writestring
    wFitxerXRay dup (\015\012) writestring (pixelsHeight:) writestring
    dup 1 get 10 string cvs wFitxerXRay exch writestring
    wFitxerXRay dup (\015\012) writestring (ColorSpace:) writestring
    2 get
    dup type /arraytype eq
    {
     0 get 128 string cvs wFitxerXRay exch writestring  %% escrivim només el primer component de l'espai de color
     %% només podem llistar i escriure tota l'array si sabem de quin espai es tracta
     %% doncs podem trobar-nos amb subarrays i tous de dades indexades dins una string
     %% {  %% forall
     %%  128 string cvs wFitxerXRay exch writestring wFitxerXRay 32 write
     %% }forall
    }
    {
     128 string cvs wFitxerXRay exch writestring
    }ifelse
    wFitxerXRay dup (\015\012imageXObject:end:) writestring nEX writestring
   }ifelse
  }
  {  %% llistem les dades d'una inLine image
   wFitxerXRay (\015\012imageXObject:begin:) writestring
   exch 128 string cvs dup /nEX exch def  %% en desem una copia x repicar :end:
   wFitxerXRay exch writestring wFitxerXRay dup (\015\012) writestring
   (pixelsWidth:) writestring  %% escrivim les dades del dic que ens interessen ...
   dup /W get 10 string cvs wFitxerXRay exch writestring
   wFitxerXRay dup (\015\012) writestring (pixelsHeight:) writestring
   dup /H get 10 string cvs wFitxerXRay exch writestring
   wFitxerXRay dup (\015\012) writestring (ColorSpace:) writestring
   dup /CS known
   {
    /CS get 128 string cvs
   }
   {
    pop ( image with Unknown Color Space)
   }ifelse
   wFitxerXRay exch writestring
   wFitxerXRay dup (\015\012imageXObject:end:) writestring nEX writestring
  }ifelse
 }forall
 length wFitxerXRay dup (\015\012form+imageXObject:used:) writestring exch 7 string cvs writestring  %% escrivim el nombre d'XObject utilitzats als streams de Contents
 %% AQUI TENIM EL DUBTE de si en llistem els noms
 dup /Desconeguts get dup length 0 eq
 {
  pop
 }
 {  %% llistem els possibles errors deguts a que es crida a l'stream el nom d'un XObject incorrecte o que no ha estat definit
  {  %% forall
   wFitxerXRay (\015\012imageXObject:ERROR:) writestring
   pop 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay ( Recursive or Not Defined or Wrong XObject Name) writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
 dup /NoUtilitzats get dup length 0 eq
 {
  pop
 }
 {  %% llistem les possibles alertes degudes a que hi ha XObject definits que no han estat utilitzats als streams de Contents
  {  %% forall
   wFitxerXRay (\015\012imageXObject:WARNING:) writestring
   pop 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay ( XObject is Unused in this Page) writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
 /Errades get dup length 0 eq
 {
  pop
 }
 {  %% llistem els possibles errors emmagatzemats
  {  %% forall
   wFitxerXRay (\015\012imageXObject:ERROR:) writestring
   exch 128 string cvs wFitxerXRay exch writestring
   wFitxerXRay exch writestring
  }forall
 }ifelse
 wFitxerXRay flushfile
}
{
 pop wFitxerXRay (\015\012imageXObject:used:0) writestring
}ifelse
%% fi d'escriptura de l'info dels XObject
%%}if  % fem l'XRay?
%%{  % NO fem l'XRay
%% %% el nombre de Tintes (colors) diferents
%% XRay /EspaisDeColor get /TintesiValors get length /tU exch def
%%}ifelse
%%% fi d'escriptura del fitxer XRay

%%% a3copiseny ... DESACTIVEM XRAY?
%%}if

%% test
%% XRay /Lleixes get /nomIE get {== ==}forall (?????) == quit

%% XRay /EspaisDeColor get /Errades get {== ==}forall ($) == quit
%% XRay /Separacions get {== ==}forall

%% XRay /EspaisDeColor get /Utilitzats get
%% XRay /EspaisDeColor get /NoUtilitzats get
%%{ 
%%dup /TanX100 known {/TanX100 get ==}{==}ifelse
%%{ /Paleta get {== ==} forall }forall
%%{
%% /Cs11 get
%%{pop ==}forall
%%== } forall
%%(+++++++) == quit
%%}forall

%% XRay /EspaisDeColor get /Utilitzats get /Cs8 get %/Paleta get {== ==} forall
%% per la llargada dels diccionaris veiem que passa
%% XRay /EstatsGrafics get /Utilitzats get
%% EstatsG

%% XRay /ObjectesX get /Desconeguts get {== ==} forall

%% XRay /EspaisDeColor get /TintesiValors get
%% /Utilitzats get /NoName9 get
%%{== ==}forall () == quit

%#%35% filtrat d'errades a XRay per determinar què fem ...
(%#%35%)==
%% BoolXRay
 /XRayError false def  %% guaita
 /grEUgEs () def  %% cadena on farcirem els errors numericament
 %% (0) filtrem els errors escrits sobre l'estructura del PDF
 XRay /PeDeEfa get /Errades get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 0 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% (1) filtrem els errors escrits sobre les Layers
 XRay /Lleixes get /Errades get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 1 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% (2) si el PDF te Layers Desconegudes ho donem com a error                       
 XRay /Lleixes get /Desconegudes get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 2 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if

 %% desactivat per les separacions
 %% (3) si el PDF te 1 o 0 Layers ho donem com a error (doncs no hi tenim cap feina a fer amb aquets fitxers!)
 %%iLu 1 le {
 %%          /XRayError true def  % guaita com l'error s'ha produit
 %%          grEUgEs length 1 add
 %%	  dup 1 sub /VaS exch def
 %%	  string dup 0 grEUgEs putinterval
 %%          dup VaS 3 put /grEUgEs exch def  % incrusta en una cadena l'index de l'error
 %%         }if

 %% EP! ara hem canviat aquest error que afecta directament a l'obtencio de Separacions i als Previews !!!
 %% (4) si el PDF no te Tintes ho donem com a error
 tU 0 eq
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 4 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% (5) filtrem els errors escrits als Estats Grafics
 XRay /EstatsGrafics get /Errades get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 5 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% cal passar d'ERROR a WARNING el fet de no tenir estats grafics predefinits a Resources
 %% (6) si el PDF no te Estats Grafics utilitzats a Resources ho donem com a WARNING (abans error)
 XRay /EstatsGrafics get /Utilitzats get length 0 eq
 {
  %% /XRayError true def  % guaita com l'error s'ha produit
  %% grEUgEs length 1 add
  %% dup 1 sub /VaS exch def
  %% string dup 0 grEUgEs putinterval
  %% dup VaS 6 put /grEUgEs exch def  % incrusta en una cadena l'index de l'error
  wFitxerXRay (\015\012GStates:WARNING:ExtGState undefined in Resources) writestring  %% (6) si el PDF no te Estats Grafics utilitzats a Resources ho donem com a WARNING (abans error)
 }if
 %% (7) si el PDF te Estats Grafics Desconeguts ho donem com a error
 XRay /EstatsGrafics get /Desconeguts get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 7 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% (8) filtrem els errors escrits als Espais de Color
 XRay /EspaisDeColor get /Errades get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 8 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% (9) si el PDF no te Espais de Color utilitzats a Resources ho donem com a error
 XRay /EspaisDeColor get /Utilitzats get length 0 eq
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 9 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% (10) si el PDF te Espais de Color Desconeguts ho donem com a error                       
 XRay /EspaisDeColor get /Desconeguts get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 10 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% (11) filtrem els errors escrits a les imatges XObjects
 XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
 /Errades get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 11 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if
 %% (12) si el PDF te XObjects Desconeguts ho donem com a error                       
 XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
 /Desconeguts get length 0 ne
 {
  /XRayError true def  %% guaita com l'error s'ha produit
  grEUgEs length 1 add
  dup 1 sub /VaS exch def
  string dup 0 grEUgEs putinterval
  dup VaS 12 put /grEUgEs exch def  %% incrusta en una cadena l'index de l'error
 }if

 wFitxerXRay closefile  %% hem traslladat aqui el tancament degut a q hem passat algun ERROR a WARNING

%%% atencio, si hi ha inLines queda brossa dels seus noms a l'stack!!!

QueLiFemFer 9 eq  %:09 EXTRAU IMATGES JPEG
{
 %#%35bis% mòdul exportador d'imatges a RGB pur
 (%#%35bis%)==
 %% explorem totes les pagines, exportant les imatges objecte a objecte, generant els numerats corresponents al nom d'arxiu
 1 1 JectesX
 null eq
 {
  pop pop pop
  ( ... AQUEST DOCUMENT NO TE IMATGES! ...) ==
 }
 {
  XRay /PeDeEfa get /imatgesXordre get
  length 1 sub  %% aquesta llargada si que es fiable! (abans ho feiem amb JectesX erroniament)
  {  %% for x cada plana
   (\n >>> exportant imatges de la plana: ) print flush dup 6 string cvs print flush
   /ioXplana 0 def  %% comptador ordinal d'imatges per ordre a Contents i per plana
   /imatgesExportades 0 def  %% comptador d'imatges exportades
   dup
   XRay /PeDeEfa get /imatgesXordre get exch get  %% extraiem l'array amb les imatges (XObjects cridats amb Do) per ordre d'aparicio dins l'stream de dades
   dup null eq  %% detectem si hi ha pagines sense imatges
   {
    pop pop  %% esborrem el null i el numeral
    ( ... exportades ... ) print flush imatgesExportades 6 string cvs print flush ( ... imatges\n)print flush
   }
   {
    exch 8 string cvs dup
    nomFITX dup length 2 index length dup /aRestar exch def
    add 1 add dup /faS exch def string dup 3 -1 roll 0 exch putinterval  %% copiem a la cadena ampliada x desar _ i el num de plana
    dup faS aRestar 1 add sub (_) putinterval dup 3 -1 roll faS aRestar sub exch putinterval  %% farcim el _ i el num de plana
    /itramDpagina exch def  %% desem el tram del nom corresponent a la pagina que dura la imatge (caldra afegir-hi el numerador d'imatge)
    JectesX exch get  exch  %% extraiem el diccionari de la plana q duu els nums dels objectes de cada imatge a exportar
    {  %% forall explorador de tots els objectes d'imatge x pagina i x ordre d'aparicio a l'stream de dades
     dup null eq
     {  %% es un null (deu ser una inLine!)
      pop
     }
     {
      ioXplana 1 add /ioXplana exch def  %% sequencial d'exportacio que NO COINCIDEIX amb imatgesExportades!
      imatgesExportades 1 add /imatgesExportades exch def  %% purament informatiu
      1 index exch get  %% literal del objecte que apunta al diccionari de la imatge a exportar
      /aCercar exch def
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      } loop  %% d'interrogacio dels dicts de COMdimoni
      dup /Subtype known
      {
       dup /Subtype get /Image eq
       {  %% es una imatge
        dup /BitsPerComponent get
        8 eq  %% es a 8 bits x pixel?
        {
         %% es RGB directe?
         dup /ColorSpace get
         dup type /nametype eq
         {
          dup length 16 eq
          {
           dup 16 string cvs 10 get 95 eq{true}{false}ifelse
          }
          {
           false
          }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
          {  %% primer descartem que no sigui una ref ind
           /aCercar exch def
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           } loop  %% d'interrogacio dels dicts de COMdimoni
           %% podria ser una array d'1 sol element amb RGB directe
           dup type /arraytype eq
           {
            dup length 1 eq {0 get}if  %% si es una array ens assegurem que nomes tingui 1 sol element
            /DeviceRGB eq
           }
           {
            /DeviceRGB eq
           }ifelse
          }
          {
           /DeviceRGB eq
          }ifelse
         }
         {  %% podria ser una array d'1 sol element amb RGB directe
          dup type /arraytype eq
          {dup length 1 eq {0 get}if}if  %% si es una array ens assegurem que nomes tingui 1 sol element
          /DeviceRGB eq
         }ifelse
         %% de l'analisi en deixa un true o false
         {
          %% duu filtres?
          dup /Filter known
          {
           %% es DCT?
           dup /Filter get
           /DCTDecode eq
           {
            /XIU get dup type /stringtype eq
            {  %% fitxer dins una cadena directe de dades
             itramDpagina dup length /araFa exch def (_imatge_) dup length araFa add string dup 4 -1 roll 0 exch putinterval
             dup 3 -1 roll araFa exch putinterval  %% incrustem el text amb guins baixos
             dup length /araFa exch def ioXplana 7 string cvs dup length araFa add string dup 4 -1 roll 0 exch putinterval
             dup 3 -1 roll araFa exch putinterval  %% incrustem el numerador d'imatges
             dup length /araFa exch def (.jpg) dup length araFa add string dup 4 -1 roll 0 exch putinterval
             dup 3 -1 roll araFa exch putinterval  %% incrustem l'extensio
             %% posem el nom del fitxer al path d'exportacio
             imatgesXreinserir dup dup length 1 sub get 47 ne  %% no duu la barra al final?
             {  %% hi afegim l'slash
              dup length dup 1 add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll (/) putinterval
             }if
             exch 1 index length /araFa exch def dup length araFa add string dup 4 -1 roll 0 exch putinterval
             dup 3 -1 roll araFa exch putinterval  %% incrustem el nom del jpeg al path d'exportacio	  
             (w) file dup  %% fem el fitxer d'escriptura a disc
             3 -1 roll writestring closefile  %% escrivim
            }
            {  %% fitxer en una array amb path a disc
             itramDpagina dup length /araFa exch def (_imatge_) dup length araFa add string dup 4 -1 roll 0 exch putinterval
             dup 3 -1 roll araFa exch putinterval  %% incrustem el text amb guins baixos
             dup length /araFa exch def ioXplana 7 string cvs dup length araFa add string dup 4 -1 roll 0 exch putinterval
             dup 3 -1 roll araFa exch putinterval  %% incrustem el numerador d'imatges
             dup length /araFa exch def (.jpg) dup length araFa add string dup 4 -1 roll 0 exch putinterval
             dup 3 -1 roll araFa exch putinterval  %% incrustem l'extensio
             %% posem el nom del fitxer al path d'exportacio
             imatgesXreinserir dup dup length 1 sub get 47 ne  %% no duu la barra al final?
             {  %% hi afegim l'slash
              dup length dup 1 add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll (/) putinterval
             }if
             exch 1 index length /araFa exch def dup length araFa add string dup 4 -1 roll 0 exch putinterval
             dup 3 -1 roll araFa exch putinterval  %% incrustem el nom del jpeg al path d'exportacio	  
             (w) file /imatgeAdisc exch def
             0 get (r) file  %% capturem el path de l'array
             {  %% loop
              dup 65535 string readstring
              {
               imatgeAdisc exch writestring
              }
              {
               imatgeAdisc exch writestring closefile exit
              } ifelse
             } loop  %% escrivim totes les dades del strEAm XIU a Objected'Ara
            }ifelse
           }
           {  %% imatge filtrada q cal passar a raw abans de repicar-la a jpeg (DCT)
            %% filtres de codificacio d'imatge que NO suportem encara ...
            /fQNs
            <<
              /JPXDecode null  %% jpeg 2000
              /JBIG2Decode null  %% jpeg a 1 bit
            >> def
            dup /XIU get  %% pesquem XIU del dic de la imatge q toca
            /strEAm exch def  %% capturem l'array o string del fitxer stream
            strEAm /dadesstream exch def  %% definim l'adreca de l'stream per despres (cal?)
            dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
            filtresstream
            %% comprovem que no sigui cap dels NO suportats fins ara ...
            dup type /arraytype eq
            {  %% filtre/s dins una array
             {  %% forall
              fQNs exch known
              {
               %% no tenim encara el decodificador d'aquest filtre
               filtresstream == (>>> CaLi2CoPi#9 ... filtre d'imatge NO suportat ... PLEGUEM!) == stop  %%quit
              }if
             }forall
            }
            {  %% filtre directe
             fQNs exch known
             {
              %% no tenim encara el decodificador d'aquest filtre
              filtresstream == (>>> CaLi2CoPi#9 ... filtre d'imatge NO suportat ... PLEGUEM!) == stop  %%quit
             }if
            }ifelse  %% no tenim encara el decodificador d'aquest filtre?
            dup /Width get /cOlUmnEs exch def dup /Height get /fIlEs exch def
            dup /DecodeParms known exch /DP known 2 copy or
            {
             {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
             {
              [ exch [ exch filtresstream ] ] /filtresstream exch def
             }
             {  %% es una array
              %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
              dup length filtresstream length ne
              {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
               (>>> CaLi2CoPi#9 ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
              }if
              /iDPF 0 def
              [
 	       exch
               {  %% forall
                dup null eq
                {
                 pop [filtresstream iDPF get]
                 iDPF 1 add/iDPF exch def
                }
                {
                 [exch filtresstream iDPF get]
                 iDPF 1 add/iDPF exch def
                }ifelse
               }forall
              ]
              /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
             }ifelse
            }
            {
             pop pop  %% ens carreguem els logics
             pop  %% ens carreguem el dic
             %% avaluem filtresstream per redefinir-lo com cal per /filtRa
             filtresstream type /arraytype eq
             {
              [filtresstream] /filtresstream exch def
             }
             {
              [[filtresstream]] /filtresstream exch def
             }ifelse
            }ifelse
            dadesstream
            %% comprovem si l'stream es un path dins una array o una string de dades directe
            type /arraytype eq
            {
             dadesstream 0 get (r) file  %% convertim a fitxer des del path
             filtresstream
             filtRa  %% decodifiquem el fitxer stream
             %%% a l'estar filtrat el repiquem al disc
             BRoSSa2 (w) file /REPIcA exch def
             {  %% loop
              dup
              65535 string readstring
              {
               REPIcA exch writestring
              }
              {
               REPIcA exch writestring REPIcA closefile closefile exit
              }ifelse
             }loop
            }
            {  %% traspassem les cadenes com a fitxers doncs poden inflar-se moltissim
             dadesstream
             0 () /SubFileDecode filter  %% convertim a fitxer des del path
             %% repiquem la cadena a fixter i decodifiquem a partid d'aqui x evitar ioerrors
             filtresstream
             filtRa  %% decodifiquem el fitxer stream
             %%% a l'estar filtrat el repiquem al disc
             BRoSSa2 (w) file /REPIcA exch def
             {  %% loop
              dup
              65535 string readstring
              {
               REPIcA exch writestring
              }
              {
               REPIcA exch writestring REPIcA closefile closefile exit
              }ifelse
             }loop
            } ifelse
            %% repicat a JPEG
            itramDpagina dup length /araFa exch def (_imatge_) dup length araFa add string dup 4 -1 roll 0 exch putinterval
            dup 3 -1 roll araFa exch putinterval  %% incrustem el text amb guins baixos
            dup length /araFa exch def ioXplana 7 string cvs dup length araFa add string dup 4 -1 roll 0 exch putinterval
            dup 3 -1 roll araFa exch putinterval  %% incrustem el numerador d'imatges
            dup length /araFa exch def (.jpg) dup length araFa add string dup 4 -1 roll 0 exch putinterval
            dup 3 -1 roll araFa exch putinterval  %% incrustem l'extensio
            %% posem el nom del fitxer al path d'exportacio
            imatgesXreinserir dup dup length 1 sub get 47 ne  %% no duu la barra al final?
            {  %% hi afegim l'slash
             dup length dup 1 add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll (/) putinterval
            }if
            exch 1 index length /araFa exch def dup length araFa add string dup 4 -1 roll 0 exch putinterval
            dup 3 -1 roll araFa exch putinterval  %% incrustem el nom del jpeg al path d'exportacio
            (w) file /PreSsor exch def
            /bufaBuffer 65535 string def
            /escup PreSsor << /Columns cOlUmnEs /Rows fIlEs /Colors 3 /ColorTransform 1>> /DCTEncode filter def
            /xucla BRoSSa2 (r) file def  %% rellegim el fitxer dexifrat a raw per repicar-lo a jpeg (DCT)
            {  %% loop
             xucla
             bufaBuffer readstring not
             {
              escup exch writestring
              exit
             }if
             escup exch writestring
            } loop
            escup closefile flush
           }ifelse
          }
          {  %% no duu filtres
           dup /XIU get  %% pesquem XIU del dic de la imatge q toca
           /strEAm exch def  %% capturem l'array o string del fitxer stream
           strEAm /dadesstream exch def  %% definim l'adreca de l'stream per despres (cal?)
           dup /Width get /cOlUmnEs exch def /Height get /fIlEs exch def
           dadesstream type /stringtype eq
           {  %% i es una cadena de dades
            %% la traspassem com a fitxer
            dadesstream 0 () /SubFileDecode filter  %% convertim a fitxer des del path
            %% el repiquem al disc
            BRoSSa2 (w) file /REPIcA exch def
            {  %% loop
             dup
             65535 string readstring
             {
              REPIcA exch writestring
             }
             {
              REPIcA exch writestring REPIcA closefile closefile exit
             }ifelse
            }loop
           }
           {  %% i encara que sigui a fitxer el traspassem a BRoSSa2 per unificar criteris
            dadesstream 0 get (r) file  %% convertim a fitxer des del path
            %% el repiquem novament a disc
            BRoSSa2 (w) file /REPIcA exch def
            {  %% loop
             dup
             65535 string readstring
             {
              REPIcA exch writestring
             }
             {
              REPIcA exch writestring REPIcA closefile closefile exit
             }ifelse
            }loop
           }ifelse
           itramDpagina dup length /araFa exch def (_imatge_) dup length araFa add string dup 4 -1 roll 0 exch putinterval
           dup 3 -1 roll araFa exch putinterval  %% incrustem el text amb guins baixos
           dup length /araFa exch def ioXplana 7 string cvs dup length araFa add string dup 4 -1 roll 0 exch putinterval
           dup 3 -1 roll araFa exch putinterval  %% incrustem el numerador d'imatges
           dup length /araFa exch def (.jpg) dup length araFa add string dup 4 -1 roll 0 exch putinterval
           dup 3 -1 roll araFa exch putinterval  %% incrustem l'extensio
           %% posem el nom del fitxer al path d'exportacio
           imatgesXreinserir dup dup length 1 sub get 47 ne  %% no duu la barra al final?
           {  %% hi afegim l'slash
            dup length dup 1 add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll (/) putinterval
           }if
           exch 1 index length /araFa exch def dup length araFa add string dup 4 -1 roll 0 exch putinterval
           dup 3 -1 roll araFa exch putinterval  %% incrustem el nom del jpeg al path d'exportacio
           (w) file /PreSsor exch def
           /bufaBuffer 65535 string def
           /escup PreSsor << /Columns cOlUmnEs /Rows fIlEs /Colors 3 /ColorTransform 1>> /DCTEncode filter def
           /xucla BRoSSa2 (r) file def  %% rellegim el fitxer dexifrat a raw per repicar-lo a jpeg (DCT)
           {  %% loop
            xucla
            bufaBuffer readstring not
            {
             escup exch writestring
             exit
            }if
            escup exch writestring
           } loop
           escup closefile flush
	  
           %%pop  % salpassem aquesta imatge
           %%(no duu filtres ... ens la saltem!) == 
           %%ioXplana 1 sub /ioXplana exch def
          }ifelse
         }
         {  %% no es RGB
          pop  %% salpassem aquesta imatge
          (no es RGB ... ens la saltem!) ==
	  imatgesExportades 1 sub /imatgesExportades exch def  %% purament informatiu
         }ifelse
        }
        {  %% no es a 8 bits
         pop
         (no es a 8 bits ... ens la saltem!) ==
	 imatgesExportades 1 sub /imatgesExportades exch def  %% purament informatiu
        }ifelse
       }
       {  %% aqui detectem els Forms pero no fem res amb ells doncs les imatges que contenen tambe es llisten a JectesX ...
        %% ... doncs a JectesX s'hi emmagatzemen tant les imatges contingudes dins el form com la mateixa carcassa del form
        %% i a FormsiXObjects hi podem veure el fet que si dos forms comparteixen recursos, sembla que continguin les
        %% mateixes imatges (doncs l'associacio de form/imatge es fa en base als Resources i no en base als Contents!)
        pop
        (\n\n ... carcassa d'un Form\n) print flush
	imatgesExportades 1 sub /imatgesExportades exch def  %% purament informatiu
       }ifelse
      }
      {
       pop
       (\n\n ... >>> aixo no es un XObject! ... pleguem\n) print flush stop  %%quit
      }ifelse
     }ifelse  %% es null i llavors no te imatges?
    }forall
    ( ... exportades ... ) print flush imatgesExportades 6 string cvs print flush ( ... imatges\n)print flush
    pop  %% ens carreguem el diccionari (de JectesX) de la plana q duu els nums dels objectes de cada imatge a exportar
   }ifelse
  }for
 }ifelse
 %%( ... exportat ...) pstack quit
}if  %/09 EXTRAU IMATGES JPEG


%% Simsi: projecte de Polynorma
QueLiFemFer 12 eq  %:12 arbre jeràrquic
QueLiFemFer 4 eq  %:04 ANÀLISI TEXTUAL
torsimany and or  %% només si fem l'anàlisi textual amb torsimany o l'arbre jeràrquic
{

%% per veure els rengs d'una plana ...
%% yRENGS /1 get {== ==}forall
%% (:-v)pstack quit
%% CalaixDeTipus /1 get {== ==}forall (:-jjjj)pstack quit

%% Mishima:
%% Simsi: la idea és generar una array amb la mateixa capacitat que les unitat de la Y del MediaBox
%% de la pàgina en la que treballem, p.e. si és un A4 vertical doncs l'array tindrà 842 elements.
%% Llavors això ens servirà facilment per endreçar les posicions, de baix (0) a dalt (n-1)
%% amb la posició de la línia Y definida com a clau, al dic yRENGS, de forma que la passarem a
%% enter (cvi) i això serà l'índex d'incrustació en aquesta array de cada pàgina.
%% Mishima:
%% Simsi: Muntem l'array ClavaLinies com a primer pas per ordenar el text per columnes i files, on:
%% cada element de l'array és una pàgina del document, i cada pàgina és una array amb les línies
%% ordenades de baix a dalt ...el segon pas serà netejar de nulls i endreçar ClavaLinies per
%% columnes i després per paràgrafs (això serà necessari pel torsimany!)
/ClavaLinies [] def
/iPln 1 def  %% index de plana
XRay /PeDeEfa get
{  %% loop per pagina
 %% aquí hi han els dics de pàgina (numerats des d'1) on hi ha el MediaBox de cadascuna 
 iPln 6 string cvs dup dup 3 index exch known
 {
  2 index exch get
  /MediaBox get 3 get cvi array /araClavo exch def  %% té tants elements com unitats enteres d'Y
  yRENGS exch get
  {  %% forall on clavem línia a línia per la seva clau (Y) com a índex farcint araClavo

%% Mishima: primer comprovem que el text no ve rotat, mirant si l'índex 4 és un null
dup 4 get dup null eq
{  %% no ve rotat
 pop exch 512 string cvs cvi
}
{  %% duu rotació, llavors hem de deslligar el _ (underscore) per quedar-nos amb la darrera dada
 %% i si fos zero?
 0 eq
 {  %% hauria de ser idem al no rotat
  exch 512 string cvs cvi
 }
 {
  %% si és escairat (90) la darrera dada (X) és en realitat la Y de la línia de base
  %% si és diferent a 90 la darrera dada és l'angle, que com a primer pas ja ens va bé per agrupar
  %% els textos, doncs amb un segon anàlisi a ClavaLinies és on haurem de destriar paràgrafs
  exch 512 string cvs (_) search pop pop pop cvi
 }ifelse
}ifelse
   araClavo 1 index get null eq
   {  %% l'índex és buit, llavors el clavem ficant l'array de valors de la línia dins una array
    exch 1 array astore araClavo 3 1 roll put
   }
   {  %% l'índex és ple i això vol dir que hi ha una altra línia amb una posició Y      %% unitat, però amb els decimals diferents... en aquest cas ampliem l'array
    araClavo 1 index get dup length dup /vaA exch def 1 add array dup 3 -1 roll 0 exch putinterval
    dup 4 -1 roll vaA exch put araClavo 3 1 roll put  %% ampliem l'array i desem
   }ifelse
  }forall
  araClavo dup length array copy  %% per profilaxi
  ClavaLinies dup length dup /vaA exch def 1 add array dup 3 -1 roll 0 exch putinterval
  dup 3 -1 roll vaA exch put /ClavaLinies exch def
 }
 {
  pop pop pop exit
 }ifelse
 iPln 1 add /iPln exch def
}loop

}if  %/04 ANÀLISI TEXTUAL
     %/12 arbre jeràrquic

%% Simsi: projecte de Polynorma
QueLiFemFer 12 eq  %:12 arbre jeràrquic
{
%%{  %% stopped

(\n\nAvaluant l'Arbre Jerarquic ...)print flush

%% Simsi: generem primer un diccionari transitori jeràrquic on la clau és el nivell i el valor és
%% un diccionari amb les equivalències /nomPDF AnomPScos
/dTj <<>> def
CalaixDeTipus
%% agafem la mida del valor maxPlana d'XRay doncs CalaixDeTipus poden mancar-li pàgines si
%% el document duu pàgines en blanc o sense text
maxPlana 1 add /fApdfPS exch def
{  %% forall per pàgina
 exch /araPgn exch def
 {  %% forall del diccionari de pàgina
  0 get /jTnomPS exch def  %% string amb el nom PS del tipus 
  /jTnomPDF exch def
  /araNji 0 def  %% valor del nivell jeràrquic actual
  Nji  %% nivells jeràrquics de l'índex
  {  %% forall de cada nivell jeràrquic
   {  %% forall de cada array d'estil [nomPS cos]
      %% per tant hi pot haver totes les equivalències possibles d'estil
    dup /AnomPScos exch def  %% desem l'array per si cal transferir-lo a dTj
    0 get  %% extraiem el literal PS de l'array del menú i el passem a string
    128 string cvs
    %% cerquem el nom pur PS del menú dins els noms PS del document amb afegits d'incrustació
    jTnomPS exch search  %% hem trobat el nom PS dels nivells jeràrquics de l'índex del menú?
    %% ens assegurem que el que cerquem és a la part final del nom de la tipografia, doncs per
    %% exemple amb l'Helvetica totes les variants tenen el mateix inici (amb l'Arial no passa)
    {pop pop length 0 eq{true}{false}ifelse}{pop false}ifelse
    {
%%     pop pop pop
     %% desem dins dTj (creant o afegint) al nivell corresponent, l'equivalència /nomPDF AnomPScos
     araNji 3 string cvs dup dTj exch known
     {  %% ja hi és, llavors l'afegim a l'existent
      dup dTj exch get dup
jTnomPDF known
{
 dup dup jTnomPDF get
 dup araPgn 6 string cvs cvx exec
       AnomPScos put
jTnomPDF exch put
%%(Scrabble)pstack quit
}
{
 dup
jTnomPDF fApdfPS array dup araPgn 6 string cvs cvx exec
       AnomPScos put
%%(Scrabble2)pstack quit
put
}ifelse
      exch dTj 3 1 roll exch put
     }
     {  %% no exiteix, el creem de nou
      dTj exch << jTnomPDF fApdfPS array dup araPgn 6 string cvs cvx exec AnomPScos put >> put
     }ifelse
    }if
%%    {
%%     pop
%%    }ifelse
   }forall  %% de cada array d'estil
   araNji 1 add /araNji exch def
  }forall %% de cada nivell jeràrquic
 }forall  %% pel diccionari de pàgina
%% pop  %% ens carreguem el literal de pàgina
}forall  %% per pàgina

%%}stopped{araPgn(:-jaaaarrrrrrggg!)pstack quit}if

%% Simsi: llistem el diccionari transitori jeràrquic on cada nivell (clau) podrà contenir dins el
%% seu diccionari (valor) totes les equivalències d'estil per aquest nivell amb /nomPDF AnomPScos
%% dTj {{== ==}forall ==}forall % dTj {== ==}forall

%% Simsi: generem els elements de treball per l'explorador de bookmarks del document...
%% diccionari on desarem totes les bookmarks amb les dades que necessitarem per construir l'arbre
/arbreDbookmarks <<>> def
%% estils tipogràfics i colors segons la jerarquia tipogràfica (_JERARQUiA) de cada bookmark
/taranna
[
 <<
   /C [.121 .286 .490]  %% blau fosc RGB:1F497D
   /F 2  %% negreta
   /tabula {COSi 3 mul}  %% identat del text
 >>  %% 0
 <<
   /C [.501 .501 .501]  %% gris RGB:808080
   /F 2  %% negreta
   /tabula {COSi 3 mul}  %% identat del text
 >>  %% 1
 <<
   /C [.329 .552 .831]  %% blau clar RGB:548DD4
   /F 2  %% negreta
   /tabula {COSi 3 mul}  %% identat del text
 >>  %% 2
 <<
   /C [.121 .286 .490]  %% blau fosc RGB:1F497D
   %% rodona (res, per defecte)
   /tabula {COSi 3 mul}  %% identat del text
 >>  %% 3
 <<
   /C [.501 .501 .501]  %% gris RGB:808080
   %% rodona (res, per defecte)
   /tabula {COSi 3 mul}  %% identat del text
 >>  %% 4
 <<
   /C [.329 .552 .831]  %% blau clar RGB:548DD4
   %% rodona (res, per defecte)
   /tabula {COSi 3 mul}  %% identat del text
 >>  %% 5
 <<
   /C [.329 .552 .831]  %% blau clar RGB:548DD4
   %% rodona (res, per defecte)
   /tabula {COSi 3 mul}  %% identat del text
 >>  %% 6
] def
/iBkmrk 11184640 def  %% enter d'inici del comptador i clau de bookmarks (en hexa equival a AAAA00)
%% diccionari on desarem una array per jerarquia amb les claus dels bookmarks caps
/parentela <<>>def
/suaraJ 0 def  %% índex del nivell de jerarquia de la darrera bookmark que hem desat

%% Simsi: ventem ClavaLinies per generar un primer arbre de bookmarks encara incomplet
%% purguem els nulls de ClavaLinies que hi hagin, pàgina a pàgina ...
/iClvlns 0 def  %% índex de pàgina
%% test per la qualitat del purgat
%% /ClavaLinies
%% [[null null null][null (1) null null][null (1)(2)][(1)(2)(3)null null][null (1)(2)(3)(4)]] def
ClavaLinies
{  %% forall pàgina a pàgina pel purgat
 /AraBorro_A exch def
 %% purguem els nulls d'AraBorro que hi hagin
 /iKill 0 def  %% l'índex a matar
 {  %% loop
  /iAo 0 def  %% índex general del paquet original
  /iAr 0 def  %% índex general del paquet a repicar
  AraBorro_A
  iKill get %% null
  null eq
  {
   AraBorro_A dup length 1 sub array
   /laNova exch def  %% el paquet repicat sempre tindrà n-1 elements
   {  %% forall
    iAo iKill eq
    {
     pop
     iAr 1 sub /iAr exch def
    }  %% si és l'element que hem de matar, doncs el matem
    {
     laNova exch iAr exch put
    } ifelse  %% la resta els repiquem a laNova
    iAo 1 add /iAo exch def
    iAr 1 add /iAr exch def
   } forall
   laNova /AraBorro_A exch def
   iKill 1 sub /iKill exch def  %% comptador per saber l'índex a matar
  } if
  iKill 1 add /iKill exch def  %% comptador per saber l'índex a matar
  AraBorro_A length /maxLoop exch def  %% quan sortim
  iKill maxLoop ge {exit} if
 } loop
 %% fi del purgat de nulls
 ClavaLinies iClvlns AraBorro_A put  %% actualitzem la pàgina purgada
 iClvlns 1 add /iClvlns exch def
}forall  %% del purgat

%% hem de capgirar les línies de cada pàgina d'aquest array doncs ara són ordenades de baix a dalt
%% i necessitem l'ordre normal de lectura de dalt a baix per generar l'arbre jeràrquic correctament
/iClavaLinies 0 def  %% index per la reinserció de pàgines
ClavaLinies
{  %% forall per pàgines
 mark
 exch aload pop
 %% aquest loop capgira tots els elements trobats a la pila mentre n'hi hagi més d'un
 counttomark 1 gt
 {
  counttomark /atura't exch def
  /ici 2 def
  {  %% loop
   ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if
  } loop
 } if
 counttomark array astore
 ClavaLinies exch iClavaLinies exch put
 pop  %% la mark
 iClavaLinies 1 add /iClavaLinies exch def
}forall

/iPln 1 def  %% index de plana
ClavaLinies
%% aquí generarem una primera versió (encara incompleta) del diccionari de bookmarks
{  %% forall per pàgines
 %% capturem la referència indirecta de l'objecte pàgina per muntar la Named Destination
 quinaPlana iPln 7 string cvs get /pDest exch def
 {  %% forall per posicions
  {  %% forall per línies
   %% ens interessa el contingut de les arrays a la posició 2 (nom PDF de la font) i 3 (cos)
   %% però de cada array amb el primer element, no null,ja en tindrem prou per comparar amb dTj
   dup 2 get  %% nom PDF de la font
   {  %% forall
    dup null eq
    {
     pop
    }
    {
     /araFontPDF exch def
     exit
    }ifelse
   }forall
   dup 3 get  %% cos
   {  %% forall
    dup null eq
    {
     pop
    }
    {
     /araCos exch def
     exit
    }ifelse
   }forall
   /arAlinia exch def
   dTj
   {  %% forall per totes les jerarquies (nivells)
    dup araFontPDF known
    {  %% si el tipus coincideix amb una jerarquia
     araFontPDF get

%% si es null és que hi ha una altra nom de fontPDF idèntica que correspon a una altra plana
%% degut a que hi poden haver noms de fontPDF idèntics, en planes diferents, per fonts PS diferents
iPln get dup null eq
{
 pop pop  %% eliminem la clau/valor del diccionari dTj
}
{
%%(bbbb)pstack quit

     %% només caldrà veure si el cos també quadra per saber si ho desem al diccionari de bookmarks
     1 get dup .5 add  %% comparem el cos pel la banda alta (tolerància .5 de mig punt?)
     araCos ge
     {
      .5 sub  %% comparem el cos per la banda baixa (tolerància .5 de mig punt?)
      araCos le
      {  %% hem localitzat una bookmark! (cal tenir en compte que els nivells comencen per zero)
       %% cal comprovar que la línia que s'adiu compleix totalment amb les convencions
       %% i si no, l'escapcem pel punt on deixa de complir-les (ara només mirem araFontPDF)
       /escaPcem false def  %% gatell per saber si hem d'escapçar els arrays de la línia
       arAlinia 2 get
       /iaraFontPDF 0 def
       {  %% forall de l'array de noms PDF de la font de cadascun dels caràcters de la línia
        dup null eq
        {
         pop iaraFontPDF 1 add /iaraFontPDF exch def
        }
        {
         araFontPDF eq
         {
          iaraFontPDF 1 add /iaraFontPDF exch def
         }
         {  %% deixa de complir la convenció, llavors escapcem
          /escaPcem true def
          exit
         }ifelse
        }ifelse
       }forall
       escaPcem
       {
        %% extraiem el tram de text que compleix les convencions tipogràfiques
        %% en cadascuna les arrays de dades de la línia i ho desem a la nova array arAliniaB
        arAlinia dup length array copy /arAliniaB exch def  %% fem una array idem
        %% escapcem l'array de posicions i desem a arAliniaB
        arAliniaB 0 arAlinia 0 get 0 iaraFontPDF getinterval put
        %% escapcem l'array de noms dels caràcters i desem a arAliniaB
        arAliniaB 1 arAlinia 1 get 0 iaraFontPDF getinterval put
        %% escapcem l'array de noms de la font PDF i desem a arAliniaB
        arAliniaB 2 arAlinia 2 get 0 iaraFontPDF getinterval put
        %% escapcem l'array de cossos i desem a arAliniaB
        arAliniaB 3 arAlinia 3 get 0 iaraFontPDF getinterval put
        %% l'element d'índex 4 (text rotat) ja ha quedat desat i no cal escapçar-lo
       }
       {
        arAlinia dup length array copy /arAliniaB exch def  %% fem una array idem
       }ifelse

/BenBlanc true def  %% gatell per saber si és una bookmark en blanc
arAliniaB 1 get
{  %% forall
 dup /space ne
 exch null ne and
 {  %% si algun caràcter no és null o /space és que NO és en blanc
  /BenBlanc false def  %% gatell per saber si és una bookmark en blanc
  exit
 }if
}forall
BenBlanc  %% ets una bookmark en blanc?
{  %% és en blanc, doncs no la fem
 %%(:-jfiltremBlanques?)pstack quit
 pop  %% eliminem el literal de la jerarquia
}
{  %% doncs la fem

       %% construim la primera versió i desem el bookmark al diccionari que els conté tots
       arbreDbookmarks iBkmrk 8 string cvs
       <<
       %% Title serà una string () de text xifrat com a PDFDocEncoding, si és bookmark, o WinAnsi
       %% si és text de pàgina (caldrà veure si es pot treballar també amb Unicode), però en una
       %% primera instància hi desarem un escarràs, doncs el repicat definitiu el deixarem pel
       %% moment de construir l'objecte al repicar el PDF
       /Title null

       /_JERARQUiA  %% a aquesta clau privada li donem l'enter de la jeràrquia
       6 index 3 string cvs cvx exec
       %% caldrà veure com desarem les dades fonamentals per escriure la NamedDestination
       %% /A [ /page /FitH /top ]  %% aquesta és una de les opcions de situació
       /Dest  %% aquesta crida actua com una NamedDestination (no hi fa res afegir o treure pàgines)
       [
        pDest  %% ref ind de la pàgina on s'adreça el link
        /FitH  %% tot l'ample de pàgina
        null  %% hi anirà la posició Y del text vinculat a la pàgina
       ]
       %% l'array de línia arAliniaB amb totes les dades tipogràfiques pel bookmark el desarem dins
       %% una clau privada (això donarà independència per repicar el text)
       /_BLiNiA arAliniaB
       >> put  %% desem el bookmark a arbreDbookmarks
       pop  %% eliminem el literal de la jerarquia
       %% numerem la bookmark següent
       iBkmrk 1 add /iBkmrk exch def
       %%(:-jRestaDelBookmark) pstack quit

}ifelse

      }
      {  %% bo és cap bookmark
%%(:-jNO) pstack quit
       pop  %% eliminem el literal de la jerarquia
      }ifelse
     }
     {
      pop pop  %% eliminem cos i el literal de la jerarquia
     }ifelse

}ifelse

    }
    {  %% el tipus no coincideix en cap jerarquia
     pop pop  %% eliminem la clau/valor del diccionari dTj
    }ifelse
   }forall  %% per totes les jerarquies
  }forall  %% per línies
 }forall  %% per posicions
 iPln 1 add /iPln exch def  %% numerador de pàgines
}forall  %% per pàgines

/saPrimeraB 11184640 def  %% el nombre màgic de la primera bookmark
%% deduïm quin és l'identificador de la darrera bookmark de l'arbre
arbreDbookmarks length saPrimeraB add 1 sub /saDarreraB exch def

%% aquí és on deduirem l'escalat jeràrquic particular de la mecànica de bookmarks de PDF, aquesta
%% mecànica dóna tota la preferència a l'ordre en que les bookmarks es despleguen de dalt a baix
%% i no permet que hi hagi salts o forats entre jerarquies

%% classificarem les jerarquies dels bookmarks de PDF fent una array de la capacitat de Nji
%% per a cadascun dels troncs, un tronc és cada jerarquia que arranca de l'arrel
Nji length array /TjPDF exch def  %% tronc de jerarquies de PDF
/jPDF [null] def  %% array que contindrà tots els troncs jeràrquics (com a mínim un!)

%% iniciem la deducció amb l'anàlisi de la primera bookmark i donant el valor inicial a arajPDF
/arajPDF 0 def  %% la primera bookmark sempre tindrà la màxima categoria a la jerarquia del PDF
%% suara_J és el valor d'estil tipogràfic que pot no coincidir amb arajPDF
saPrimeraB 8 string cvs dup
%% algun dels estils tipogràfics dels Nivells jeràrquics de l'índex (Nji) ha estat localitzat?
arbreDbookmarks exch known
{  %% si, s'han generat bookmarks
 arbreDbookmarks exch get dup /_JERARQUiA get dup /suara_J exch def
}
{  %% no s'ha generat cap bookmark ...pleguem!
 pop
 (\n\n ... >>> cap dels estils jerarquics del perfil tipografic ha estat localitzat ... pleguem!\n\n)
 print flush stop  %%quit
%%(:-jaaaarrrrrrggg!)pstack quit
}ifelse
%% màxima categoria que indicarà la creació d'un nou tronc jeràrquic, de manera que cada vegada
%% que llegim una bookmark amb valor de /_JERARQUiA igual o inferior a /maxTJ, obrirem un nou tronc
/maxTJ exch def
%% desarem dins la bookmark i en la clau privada /_arajPDF el valor de jerarquia de PDF que
%% ens servirà per avaluar la clau /Count al final de tot
/_arajPDF arajPDF put  %% desem el valor de jerarquia de PDF dins la bookmark
/iTJ 0 def  %% índex del tronc jeràrquic que treballem
%% desem al tronc allà on li toca i amb el format corresponent
TjPDF
arajPDF
[
 <<
   suara_J 3 string cvs [saPrimeraB]  %% ens convé que les id com saPrimeraB sigui un enter
 >>
] put
jPDF iTJ TjPDF put  %% desem el primer tronc

%% desem la id de la primera bookmark del tronc jeràrquic (la necessitem per tirar l'arbre enrera)
/1BTJ saPrimeraB def

%%arbreDbookmarks {pop 8 string cvs cvx exec}forall

%% explorem de dalt a baix totes les bookmarks començant per la segona (la primera ja l'hem fet!)
%% per tal de construir l'array jPDF amb tots els seus troncs de jerarquies (si n'hi ha més d'un)
%% que ens ha de permetre després assignar les claus /Prev /Next /First /Last /Count i /Parent
saPrimeraB 1 add 1 saDarreraB
{  %% for
 dup /araBkmrk exch def
 arbreDbookmarks exch 8 string cvs get
 /_JERARQUiA get
 dup maxTJ le  %% fem un nou tronc jeràrquic?
 {
  dup /maxTJ exch def  %% actualitzem el llindar per la creació d'un nou tronc 
  dup /suara_J exch def  %% reinicialitzem
  %% desaríem el tronc TjPDF al seu lloc
  jPDF iTJ TjPDF put
  iTJ 1 add /iTJ exch def  %% augmentem l'índex de troncs
  %% augmentem l'array de troncs 
  jPDF dup length 1 add array dup 0 4 -1 roll putinterval /jPDF exch def
  Nji length array /TjPDF exch def  %% reinicialitzem el tronc de jerarquies de PDF
  /arajPDF 0 def  %% reinicialitzem
  %% desem al tronc allà on li toca i amb el format corresponent
  TjPDF
  arajPDF
  [
   <<
     suara_J 3 string cvs []  %% ens convé deixar l'array buida
   >>
  ] put
  %% desem la id de la primera bookmark del tronc jeràrquic (la necessitem per tirar l'arbre enrera)
  /1BTJ araBkmrk def
 }if
 dup suara_J ge
 {  %% pugem o ens mantenim dins la jerarquia
  dup suara_J eq
  {  %% ens mantenim
   /suara_J exch def  %% redesem la nova _JERARQUiA
   %jPDF
   TjPDF arajPDF get  %%{==}forall
   /iDic_J 0 def  %% comptador d'índex per saber el diccionari que conté _JERARQUiA
   /HiEra false def  %% gatell per saber que suara_J hi és
   {  %% forall per tots els diccionaris de l'array que és a la posició arajPDF
    suara_J 3 string cvs known
    {  %% si, ja hi és dins el diccionari ens aturem aquí
     /HiEra true def  %% gatell per saber que hi era
     exit  %% sortim del forall
    }if
    iDic_J 1 add /iDic_J exch def
   }forall
   HiEra
   {  %% si
    %jPDF
    TjPDF arajPDF get iDic_J get suara_J 3 string cvs get  %% capturem l'array a ampliar
    dup length dup /Vaa exch def 1 add array dup 0 4 -1 roll putinterval  %% l'ampliem
    dup Vaa araBkmrk put  %% desem a l'array la id de la bookmark 
    %% desem l'array al dic i jerarquia corresponents
    %jPDF
    TjPDF dup arajPDF get dup 4 -1 roll iDic_J exch << exch suara_J 3 string cvs exch >> put
    arajPDF exch put  %% ho desem tot a TjPDF
%{== ==}forall
%%(:-jensmantenim)pstack quit
    %% desem el valor de jerarquia de PDF dins la bookmark
    arbreDbookmarks araBkmrk 8 string cvs get /_arajPDF arajPDF put
   }
   {  %% no hi és, hi cal veure si és un problema o és un nou cas a contemplar?
    suara_J arajPDF(...tenim un problema)pstack quit
%%(:-jO)pstack quit
   }ifelse
  }
  {  %% pugem
   %% sumem 1 a arajPDF i desem a TjPDF
   arajPDF 1 add /arajPDF exch def

   arajPDF TjPDF length eq  %% creixem més enllà dels valors de menú Nji?
   {  %% aquest tronc jeràrquic creix més enllà del nombre d'estils de Nji
    %% doncs el funcionament dels arbres de bookmarks en PDF permeten això indefinidament
    %% ampliem l'array del tronc jeràrquic i redesem
    TjPDF length 1 add array dup 0 TjPDF putinterval /TjPDF exch def
   }if

   %% de manera que si encara hi ha un null a la posició arajPDF de TjPDF ...
   TjPDF arajPDF get null eq
   {  %% és buida encara
    /suara_J exch def  %% redesem la nova _JERARQUiA
    %% ... crearem una nova array on hi desarem un diccionari on la clau serà suara_J
    %% i el valor serà un array amb l'id de la bookmark a dins
    TjPDF arajPDF [<< suara_J 3 string cvs [araBkmrk]>>] put  %% ens convé q la id sigui un enter?
    %% desem el valor de jerarquia de PDF dins la bookmark
    arbreDbookmarks araBkmrk 8 string cvs get /_arajPDF arajPDF put
   }
   {  %% ja hi ha una array
    /suara_J exch def  %% redesem la nova _JERARQUiA
    TjPDF arajPDF get
    /iDic_J 0 def  %% comptador d'índex per saber el diccionari que conté _JERARQUiA
    /HiEra false def  %% gatell per saber que suara_J hi és
    {  %% forall per tots els diccionaris de l'array que és a la posició arajPDF
      suara_J 3 string cvs known
     {  %% si, ja hi és dins el diccionari ens aturem aquí
      /HiEra true def  %% suara_J hi és
      exit  %% sortim del forall
     }if
     iDic_J 1 add /iDic_J exch def
    }forall
    HiEra
    {  %% HI HA suara_J, llavors

%% atenció: eliminem la clau de text /_BLiNiA per escurçar el llistat!
%%arbreDbookmarks {dup/_BLiNiA undef{== ==}forall ==}forall

     %% ampliarem l'array de la jerarquia suara_J amb una nova referència de bookmark
     %% voldrà dir que extraurem a TjPDF l'array ijPDF i d'aquí el dic posicionat a iDic_J
     TjPDF %ijPDF
     arajPDF get iDic_J get
     %% i a l'array de la clau suara_J hi afegirem el valor araBkmrk, ampliant-la
     suara_J 3 string cvs get dup length dup /Vaa exch def 1 add array dup 0 4 -1 roll putinterval
     dup Vaa araBkmrk put
     %% i tot seguit ho tornarem a desar amb la suara_J (_JERARQUiA) que toca i al iDic_J
     %% corresponent dins l'array
     TjPDF %ijPDF
     arajPDF get dup 3 -1 roll iDic_J exch << exch suara_J 3 string cvs exch >> put
     TjPDF exch %ijPDF
     arajPDF exch put
     %% desem el valor de jerarquia de PDF dins la bookmark
     arbreDbookmarks araBkmrk 8 string cvs get /_arajPDF arajPDF put

%% ventem tota l'estructura de jPDF pel control de qualitat
%%jPDF{([\n)print flush{dup null eq{pop(null\n)print flush}{([\n)print flush{(<<\n)print flush{exch == ==}forall(>>\n)print flush}forall(]\n)print flush}ifelse}forall(]\n\n)print flush}forall
%%(:-jahihaunaarrayIDjahies)pstack quit

%% TjPDF arajPDF get
%%iDic_J get {== ==}forall suara_J ==

    }
    {  %% NO hi ha suara_J, llavors ...
     %% afegim a la cua de l'array posicionat a arajPDF un nou diccionari amb suara_J i [araBkmrk]
     TjPDF dup arajPDF get dup length dup /Vaa exch def 1 add array dup 0 4 -1 roll putinterval
     dup Vaa << suara_J 3 string cvs [araBkmrk]>> put arajPDF exch put
     %%(:-jahihaunaarrayIDnova)pstack quit
     %% desem el valor de jerarquia de PDF dins la bookmark
     arbreDbookmarks araBkmrk 8 string cvs get /_arajPDF arajPDF put
    }ifelse
   }ifelse
  }ifelse  %% ens mantenim o pugem
 }
 {  %% baixem de jerarquia
%% ventem tota l'estructura de jPDF pel control de qualitat
%%jPDF{([\n)print flush{dup null eq{pop(null\n)print flush}{([\n)print flush{(<<\n)print flush{exch == ==}forall(>>\n)print flush}forall(]\n)print flush}ifelse}forall(]\n\n)print flush}forall

%% anant enrera a la jerarquia, sempre hem de comprovar si el salt jeràrquic és més d'1
%% doncs si ho és, hem d'avaluar a quina posició arajPDF li atorguem
dup suara_J sub abs 1 eq
{
  %% ara la nova posició jeràrquica serà l'anterior -1
  arajPDF 1 sub /arajPDF exch def
  dup
  /suara_J exch def  %% redesem la nova _JERARQUiA
}
{  %% per tirar l'arbre enrera més d'una jerarquia avaluem on posem arajPDF
  dup
  /suara_J exch def  %% redesem la nova _JERARQUiA

  %% hem d'explorar de la bookmark anterior a l'actual cap enrera
  %% fins la bookmark que és el cap del tronc jeràrquic 1BTJ
  araBkmrk 1 sub -1 1BTJ
  {  %% for
   %% fins que en trobem una amb el valor de _JERARQUiA més petit o igual
   %% si és igual va al valor de _arajPDF i si és més petita _arajPDF+1
   arbreDbookmarks exch 8 string cvs get
   dup /_JERARQUiA get dup suara_J le
   {
    suara_J eq
    {
     /_arajPDF get /arajPDF exch def
    }
    {  %% és més petita
     /_arajPDF get 1 add /arajPDF exch def
    }ifelse
    exit  %% i sortim!
   }
   {
    pop pop
   }ifelse
  }for
}ifelse


  3 string cvs /Ssuara_J exch def  %% valor amb string de suara_J

TjPDF arajPDF get

/ampliemDicJ false def

      dup /aDj exch def  %% array de diccionaris que és a la posició arajPDF
      /iDic_J 0 def  %% per saber on és dins aDj el diccionari que conté _JERARQUiA
      {  %% forall per tots els diccionaris de l'array que és a la posició arajPDF
       Ssuara_J known
       {  %% si, ja hi és dins el diccionari ens aturem aquí
/ampliemDicJ true def
        exit  %% sortim del forall
       }if
       iDic_J 1 add /iDic_J exch def
      }forall

ampliemDicJ
  {  %% ampliarem l'array de la jerarquia suara_J amb una nova referència de bookmark, llavors
   %% voldrà dir que extraurem a TjPDF l'array situat a arajPDF i d'aquí el dic posicionat a iDic_J
   TjPDF arajPDF get iDic_J get
   %% i a l'array de la clau Ssuara_J hi afegirem el valor araBkmrk, ampliant-la
   Ssuara_J get dup length dup /Vaa exch def 1 add array dup 0 4 -1 roll putinterval
   dup Vaa araBkmrk put
   %% i tot seguit ho tornarem a desar amb la Ssuara_J (_JERARQUiA) que toca i al iDic_J
   %% corresponent dins l'array
   TjPDF arajPDF get dup 3 -1 roll iDic_J exch << exch Ssuara_J exch >> put
   TjPDF exch arajPDF exch put
   %% desem el valor de jerarquia de PDF dins la bookmark
   arbreDbookmarks araBkmrk 8 string cvs get /_arajPDF arajPDF put
%%(lllllll)pstack quit
  }
  {  %% afegirem un nou diccionari a la cua de l'array de la jerarquia arajPDF
   TjPDF dup arajPDF get dup length 1 add array dup 0 4 -1 roll putinterval  %% ampliem l'array
   %% ... amb suara_J com a clau i una array com a valor amb l'enter araBkmrk a dins
   dup dup length 1 sub << Ssuara_J [araBkmrk]>> put
   arajPDF exch put  %% redesem a TjPDF

   %% desem el valor de jerarquia de PDF dins la bookmark
   arbreDbookmarks araBkmrk 8 string cvs get /_arajPDF arajPDF put
  }ifelse
 }ifelse
}for


%% desem el darrer tronc TjPDF pendent al seu lloc
jPDF iTJ TjPDF put

%% ventem tota l'estructura de jPDF pel control de qualitat
%%jPDF{([\n)print flush{dup null eq{pop(null\n)print flush}{([\n)print flush{(<<\n)print flush{exch == ==}forall(>>\n)print flush}forall(]\n)print flush}ifelse}forall(]\n\n)print flush}forall
%%(:-jkkkk)== quit

%% Prev: el definim per tot l'arbre de bookmarks
(\n\n ... generant la clau /Next i /Prev ...)print flush
%% primer definim els únics /Prev que lliguen bookmarks de diferent tronc: les de jerarquia màxima
mark
jPDF
{  %% forall pels troncs jeràrquics
 0 get 0 get  %% el primer array i el primer diccionari ens donaran les id de jerarquia màxima
 {  %% forall del diccionari
  exch pop aload pop  %% desempaquetem les id
 }forall
}forall
counttomark 1 sub
{  %% repeat
 /PrevVa exch def
 dup /seuPrev exch def
 %% posem la clau /Prev a la bookmark
 arbreDbookmarks PrevVa 8 string cvs get
 /Prev seuPrev
 16 6 string cvrs  %% convertim a string hexa per la detecció de l'objecte
 put
}repeat
pop pop  %% eliminem la darrera bookmark i la mark

%% array on desarem totes les id de les bookmarks per ordre també dins una array
/AidB Nji length array def
/iAidB 0 def  %% índex de jerarquia
%% primer definim els únics /Next que lliguen bookmarks de diferent tronc: les de jerarquia màxima
mark
jPDF
{  %% forall pels troncs jeràrquics
 0 get 0 get  %% el primer array i el primer diccionari ens donaran les id de jerarquia màxima
 {  %% forall del diccionari
  exch pop aload pop  %% desempaquetem les id
 }forall
}forall
counttomark /araRoll exch def
%% farcim AidB
araRoll copy araRoll array astore  %% capturem les id dins una array
AidB exch iAidB exch put
{  %% loop per posar la clau /Next a la bookmark
 araRoll 1 eq{exit}if
 araRoll -1 roll /NextVa exch def
 araRoll 2 sub index /seuNext exch def
 %% posem la clau /Next a la bookmark
 arbreDbookmarks NextVa 8 string cvs get
 /Next seuNext
 16 6 string cvrs  %% convertim a string hexa per la detecció de l'objecte
 put
 araRoll 1 sub /araRoll exch def
}loop
pop pop  %% eliminem la darrera bookmark i la mark

%% finalment definim els /Next i /Prev lligats a cada tronc
jPDF

%% hi desarem les arrays de jerarquia ordenades per cada tronc (ens serà útil per /Parent)
%% dup length array /TAidB exch def
%% dup length array /AidB exch def
%% /iTAidB 0 def  %% valor inicial de l'índex de troncs

{  %% forall pels troncs jeràrquics
 dup /AjB exch def length 1 sub 1 exch 1 exch

%% /iAidB 0 def  %% índex de jerarquia

 {  %% for pels arrays de jerarquia
  AjB exch get
  dup null eq
  {
   pop
  }
  {
   mark exch
   {  %% forall on posem per ordre a l'stack les id de les bookmarks a posar-hi el /Prev
    {
     exch pop aload pop
    }forall
   }forall
   %% ens cal comprovar si els id estan ordenats de menys a més, doncs poden no estar-ho!

   counttomark 1 ne
   {  %% si només n'hi ha un no cal passar l'algorisme
    %% ordena una seqüència numèrica existent a l'stack de menys a més (operador ge)
    %% o de més a menys (operador le)
    {  %% loop mentre estiguin desordenats
     counttomark 1 sub /iCul exch def
     %% escombrat d'ordenació
     iCul
     {  %% repeat
      iCul index /araCul exch def
      iCul 1 sub index araCul ge  %% le fa de més a menys
      {
       iCul 1 sub /iCul exch def
      }
      {
       iCul -1 roll
       iCul 1 add 1 roll
      }ifelse
     }repeat
     %% mirem si estan per ordre de menys a més (ge)
     %% o de més a menys (le), començant pel cul de l'stack
     /Ordenats true def
     counttomark 1 sub /iCul exch def
     iCul
     {  %% repeat
      iCul index /araCul exch def
      iCul 1 sub index araCul ge  %% le fa de més a menys
      {
       iCul 1 sub /iCul exch def
      }
      {
       /Ordenats false def
       exit
      }ifelse
     }repeat
     Ordenats{exit}if
    }loop
   }if

   counttomark /faTronc exch def
%% desem les arrays de jerarquia ordenades a AidB
%faTronc copy faTronc array astore AidB exch iAidB exch put

   faTronc 1 sub
   {  %% repeat
    /dePrev exch def
    dup /aNext exch def
    %% la parella aNext dePrev durà Next/Prev sempre que es compleixi:
    %% que la numeració de la id de la bookmark sigui contínua (amb la mateixa _arajPDF segur)
    dePrev aNext sub 1 eq
    {
     true
    }
    {
     %% primer ens cal saber el valor _arajPDF d'aNext per valorar si n'hi ha cap d'inferior
     %% entremig, doncs llavors la parella aNext dePrev no durà cap valor Next/Prev
     %% doncs al pertànyer a una altra branca es trenca el nexe per l'ús d'aquestes claus
     arbreDbookmarks aNext 8 string cvs get /_arajPDF get /empeltem exch def 
     /femPrevNext true def
     aNext 1 add 1 dePrev 1 sub
     {  %% for dels valors d'entremig
      arbreDbookmarks exch 8 string cvs get /_arajPDF get empeltem lt
      {
       /femPrevNext false def
       exit
      }if
     }for
     femPrevNext
    }ifelse

    {
     %% posem la clau /Prev a la bookmark
     arbreDbookmarks dePrev 8 string cvs get
     /Prev aNext
     16 6 string cvrs  %% convertim a string hexa per la detecció de l'objecte
     put
     %% posem la clau /Next a la bookmark
     arbreDbookmarks aNext 8 string cvs get
     /Next dePrev
     16 6 string cvrs  %% convertim a string hexa per la detecció de l'objecte
     put
    }if
   }repeat

   pop pop  %% eliminem la darrera bookmark i la mark

  }ifelse

%iAidB 1 add /iAidB exch def  %% sumador de l'índex de jerarquia

 }for

%TAidB iTAidB AidB put
%iTAidB 1 add /iTAidB exch def  %% sumador de l'índex de troncs

}forall

%(Strauß)pstack quit


jPDF
%% desarem les AidB de cada tronc jeràrquic doncs ens serà útil per escriure /Parent i???
dup length array /TAidB exch def
/iTAidB 0 def  %% índex per desar AidB al lloc de cada tronc
{  %% forall pels troncs jeràrquics
 %% array on desarem totes les id de les bookmarks per ordre també dins una array
 dup length array /AidB exch def  %% i la seva capacitat ha de ser idèntica a la del tronc!
 /iAidB 0 def  %% índex de jerarquia
 {  %% forall per tota l'estructura d'arrays de jerarquies de PDF
  dup null eq
  {
   pop
  }
  {
   mark exch
   {  %% forall on posem per ordre a l'stack les id de les bookmarks a posar-hi el /Next
    {
     exch pop aload pop
    }forall
   }forall
   counttomark /araRoll exch def

%% ens cal comprovar si els id estan ordenats de menys a més, doncs poden no estar-ho!
counttomark 1 ne
{  %% si només n'hi ha un no cal passar l'algorisme
%% ordena una seqüència numèrica existent a l'stack de menys a més (operador ge)
%% o de més a menys (operador le)
{  %% loop mentre estiguin desordenats
 counttomark 1 sub /iCul exch def
 %% escombrat d'ordenació
 iCul
 {
  iCul index /araCul exch def
  iCul 1 sub index araCul ge  %% le fa de més a menys
  {
   iCul 1 sub /iCul exch def
  }
  {
   iCul -1 roll
   iCul 1 add 1 roll
  }ifelse
 }repeat
 %% mirem si estan per ordre de menys a més (ge) o de més a menys (le), començant pel cul de l'stack
 /Ordenats true def
 counttomark 1 sub /iCul exch def
 iCul
 {
  iCul index /araCul exch def
  iCul 1 sub index araCul ge  %% le fa de més a menys
  {
   iCul 1 sub /iCul exch def
  }
  {
   /Ordenats false def
   exit
  }ifelse
 }repeat
 Ordenats{exit}if
}loop
}if

   %% farcim AidB
   araRoll array astore  %% capturem les id dins una array
   AidB exch iAidB exch put
   pop  %% eliminem la mark
  }ifelse 
  iAidB 1 add /iAidB exch def
 }forall
 %% desem AidB al seu lloc i fem còrrer l'índex troncal
 TAidB iTAidB AidB put
 iTAidB 1 add /iTAidB exch def
}forall


%% Parent: el definim per tot l'arbre de bookmarks
(\n\n ... generant la clau /Parent ...)print flush
%% primer definirem el /Parent a totes les bookmarks de màxim nivell, apuntant a l'objecte Outlines
jPDF
{  %% forall pels troncs jeràrquics
 0 get  %% treiem l'array de màxim nivell
 {  %% forall per l'array jeràrquic
  { %% forall dels diccionaris
   {  %% forall del valor d'array amb les id dels bookmarks
    %% posem la clau /Parent a la bookmark
    8 string cvs arbreDbookmarks exch get
    /Parent 0 put  %% com que és zero (apunta a Outlines) no convertim a string hexa
   }forall
   pop  %% eliminem la clau
  }forall
 }forall
}forall
%% després definim el /Parent per a cada tronc jeràrquic
/iTAidB 0 def  %% valor inicial de l'índex de troncs
jPDF
{  %% forall pels troncs jeràrquics
 /TjPDF exch def  %% tronc de jerarquies de PDF
 1 1 TjPDF length 1 sub
 {  %% for a partir de l'array 1 de jerarquia de PDF on consultarem a cada diccionari el primer
  dup /iAidB exch def  %% índex de jerarquia
  %% valor de la id de la bookmark i anirem a la categoria anterior a buscar la primera bookmark
  %% que tingui un valor d'id inferior: aquest serà el seu valor /Parent aplicable a tota l'array
  TjPDF exch get  %% diccionari
  dup null eq
  {
   pop
  }
  {
   {  %% forall per l'array de diccionaris
    {  %% forall per cada diccionari
     /esParent null def  %% el valor inicial d'aquesta variable ens dirà si trobat res
     dup /AonhivaParent exch def  %% array on haurem d'aplicar el mateix /Parent a totes les id
     0 get /QuinParent exch def  %% aquesta id ens servirà per cercar el /Parent
     pop  %% eliminem la clau
     %% a la jerarquia anterior (índex), la primera bookmark que tingui un valor d'id inferior
     %%AidB
     TAidB iTAidB get
     iAidB 1 sub get
     mark exch aload pop
     counttomark
     {  %% repeat
      dup QuinParent lt
      {  %% aquest és el valor de /Parent que cerquem
       /esParent exch def
       cleartomark exit  %% netegem i sortim del repeat!
      }
      {
       pop
      }ifelse
     }repeat
     %% aquí repiquem /Parent a totes les bookmarks de l'array
     AonhivaParent
     {  %% forall per a cada id
      8 string cvs arbreDbookmarks exch get
      /Parent esParent
      16 6 string cvrs  %% convertim a string hexa per la detecció de l'objecte
      put
     }forall
     esParent null eq
     {
      (\n\n ... quelcom relatiu a /Parent no va be! ...\n\n)print flush quit
     }if
    }forall
   }forall
  }ifelse
 }for
 iTAidB 1 add /iTAidB exch def  %% actualitzem l'índex de troncs
}forall

%% First+Last+Count: per tot l'arbre de bookmarks
(\n\n ... generant les claus /First /Last /Count\n\n)print flush

%% això és correcte?
%% AidB (:-jep)pstack quit
%%arbreDbookmarks {dup/_BLiNiA undef{== ==}forall ==}forall
%%(:-jNext)== quit

jPDF
{  %% forall on explorem el First+Last+Count per a cadascun dels troncs jeràrquics
 dup /TfesFirst exch def  %% tot l'array del tronc jeràrquic on ficar First+Last a les id on calgui
 length 1 sub 0 exch 1 exch
 {  %% for per recorrer tot el tronc jeràrquic
  dup /iFesFirst exch def  %% índex per l'array de jerarquia on cercar id que duguin First+Last
  TfesFirst exch get dup null eq
  {  %% no fem res i sortim del for
   pop exit
  }
  {  %% mirem de localitzar id que puguin dur First+Last
   TfesFirst
   dup length iFesFirst 1 add eq  %% som al final del tronc jeràrquic?
   {  %% sortim del for
    pop pop exit
   }
   {
    iFesFirst 1 add get dup null eq  %% la jerarquia següent existeix?
   }ifelse
   {  %% NO: no cal cercar res més ...i podem sortir del for
    pop pop exit
   }
   {  %% aquí tenim l'array on hi pot haver el valor de First+Last
    /AvalFirst exch def
    %% i aquí hi ha l'array on hi pot haver la id que pot dur aquest valor de First+Last
    /iEsFirst 0 def
    /fanFLC [] def  %% array on desarem les id on posar First Last Count
    {  %% forall sobre l'array de la id que pot dur First+Last
     {  %% forall al diccionari
      exch pop  %% eliminem el literal
%% dup 0 get 11184642 eq{(,,,,,,,,)pstack quit}if
%% (anem al Globus)pstack quit
      %% els darrers valors d'una seqüència seguida d'id dins l'array valDic seran els
      %% bookmarks que tinguin subentrades, o sigui valors de First, Last, Count
%% /fanFLC [] def  %% array on desarem les id on posar First Last Count
      dup /valDic exch def length 1 sub 0 exch 1 exch
      dup /foraDrang exch def
      {  %% for
       dup /araRang exch def
       valDic exch get /fesFirst exch def
       %% si és fora de rang, llavors desem fesFirst a fanFLC
       araRang foraDrang eq
       {
        fanFLC dup length dup /vaA exch def 1 add array dup 0 4 -1 roll putinterval
        dup vaA fesFirst put /fanFLC exch def
       }
       {
        %% si no augmenta d'1, llavors desem fesFirst a fanFLC
        fesFirst 1 add valDic araRang 1 add get ne
        { %% no augmenta d'1
         fanFLC dup length dup /vaA exch def 1 add array dup 0 4 -1 roll putinterval
         dup vaA fesFirst put /fanFLC exch def
%(:-jOOOOO)pstack quit
        }if
       }ifelse
      }for
     }forall  %% del diccionari
     iEsFirst 1 add /iEsFirst exch def
    }forall  %% sobre l'array
%% HI HA MÉS COSES QUE S'HAN D'ORDENAAAAAAAAARRRR!!!!
    %% i aquí hi ha l'array on hi pot haver la id que pot dur aquest valor de First+Last
    fanFLC  %% aquí hauríem de posar per ordre aquesta array?
    dup length 1 ne
    {
     mark exch aload pop
     %% ordena una seqüència numèrica existent a l'stack de menys a més (operador ge)
     %% o de més a menys (operador le)
     {  %% loop mentre estiguin desordenats
      counttomark 1 sub /iCul exch def
      %% escombrat d'ordenació
      iCul
      {
       iCul index /araCul exch def
       iCul 1 sub index araCul ge  %% le fa de més a menys
       {
        iCul 1 sub /iCul exch def
       }
       {
        iCul -1 roll
        iCul 1 add 1 roll
       }ifelse
      }repeat
      %% mirem si estan per ordre de menys a més (ge)
      %% o de més a menys (le), començant pel cul de l'stack
      /Ordenats true def
      counttomark 1 sub /iCul exch def
      iCul
      {
       iCul index /araCul exch def
       iCul 1 sub index araCul ge  %% le fa de més a menys
       {
        iCul 1 sub /iCul exch def
       }
       {
        /Ordenats false def
        exit
       }ifelse
      }repeat
      Ordenats{exit}if
     }loop
     counttomark array astore exch pop
    }if

    {  %% forall sobre fanFLC
     /fesFirst exch def  %% aquesta és la id que pot dur First+Last+Count
     %% cerquem el valor de First, si hi és
     AvalFirst

     /HiHaFirst false def  %% per saber si duu First/Last/Count

     %% el valor de First per fesFirst, si hi és, serà fesFirst+1
     fesFirst 1 add /EsFirst exch def  %% és el /First

     {  %% forall de l'array de la jerarquia AvalFirst
      {  %% forall del diccionari
       exch pop  %% eliminem el literal i deixem l'array a l'stack
       {  %% forall de l'array del diccionari amb les id
        EsFirst eq
        {
         /HiHaFirst true def  %% per saber si duu First/Last/Count
        }if
       }forall  %% de l'array del diccionari amb les id
      }forall  %% del diccionari
     }forall  %% de l'array de la jerarquia AvalFirst

     HiHaFirst
%(:-jUUUUUU)pstack quit
     {  %% desarem els valors First/Last/Count a fesFirst

      %% ara anem a cercar el valor de Last també dins AvalFirst
      %% el valor de Last per fesFirst serà el darrer valor que sumi d'1 a 1 seguit
      EsFirst /EsLast exch def  %% començant per EsFirst (primer valor possible de Last)

      %% cerquem el valor de Last
      AvalFirst
      {  %% forall de l'array de la jerarquia AvalFirst
       {  %% forall del diccionari
        exch pop  %% eliminem el literal i deixem l'array a l'stack
        {  %% forall de l'array del diccionari amb les id
         EsLast 1 add eq
         {
          EsLast 1 add /EsLast exch def
         }if
        }forall  %% de l'array del diccionari amb les id
       }forall  %% del diccionari
      }forall  %% de l'array de la jerarquia AvalFirst

%fesFirst 11184648 eq {EsFirst EsLast AvalFirst(.......)pstack quit}if

      arbreDbookmarks fesFirst 8 string cvs get dup dup
      /First EsFirst
      16 6 string cvrs  %% convertim a string hexa per la detecció de l'objecte
      put
      /Last EsLast
      16 6 string cvrs  %% convertim a string hexa per la detecció de l'objecte
      put
%% Count: per a la bookmark fesFirst que duu First+Last
%% primer mirem a fesFirst el valor de la clau privada /_arajPDF (nimCount) i explorem totes les
%% bookmarks una a una (BcomptaCount), sumant 1 (al valor araCount) sempre que /_arajPDF sigui més
%% gran que el valor de nimCount (_arajPDF de fesFirst)
      %% valors inicials per deduir Count
      dup /_arajPDF get /nimCount exch def  %% s'ha de superar per sumar 1 a araCount
      fesFirst 1 add /BcomptaCount exch def  %% primera bookmark on comencem a mirar
      /araCount 0 def  %% valor inicial de Count
      {  %% loop per cercar el valor de Count
       BcomptaCount 8 string cvs dup
       arbreDbookmarks exch known
       {
        arbreDbookmarks exch get /_arajPDF get nimCount gt
        {  %% computem Count
         araCount 1 add /araCount exch def
         BcomptaCount 1 add /BcomptaCount exch def
        }
        {  %% sortim del loop: som al final de la jerarquia computable per Count
         exit
        }ifelse
       }
       {  %% si no hi és, sóm definitivament al final
        pop exit
       }ifelse
      }loop
      %% aquí tenim el diccionari de fesFirst
      /Count araCount
      %% si volem desplegar o no els nivells inferiors, negativem el valor de Count
      arbreDbookmarks fesFirst 8 string cvs get /_JERARQUiA get
      polyFEM 4 get ge {neg}if put  %% i controlem a partir de quin nivell volem encongir l'arbre
     }if  %% desarem els valors First/Last/Count dins fesFirst

    }forall  %% sobre fanFLC
   }ifelse  %% aquí tenim l'array on hi pot haver el valor de First+Last
  }ifelse
 }for
}forall


%% ventem tota l'estructura de jPDF pel control de qualitat
%%jPDF{([\n)print flush{dup null eq{pop(null\n)print flush}{([\n)print flush{(<<\n)print flush{exch == ==}forall(>>\n)print flush}forall(]\n)print flush}ifelse}forall(]\n\n)print flush}forall

%% atenció: eliminem la clau de text /_BLiNiA per escurçar el llistat!
%%arbreDbookmarks {dup/_BLiNiA undef{== ==}forall ==}forall
%%arbreDbookmarks {{== ==}forall ==}forall
%%(:-jElsArbresEnsDeixenVeureElBosc?)== quit

%%arbreDbookmarks {{== ==}forall ==}forall
%%arbreDbookmarks length ==  %%{== ==}forall
%%parentela{== ==}forall

%% Simsi: llistar tots els noms PS de les tipografies del document (endreçades x pàgina) podria
%% servir de referència per deduir l'equivalència entre el nom de menú i el nom intern PS ...i per
%% fer-ho bé, hauríem de discriminar el que hi hagues abans de ####+ ...al que hi segueix el NomPS

%% constant per tot el 12
%% per evitar problemes de xifrat, creem de nou els objectes /Font amb el mínim de dades
[  %% array d'objectes Font manats segons /taranna pel comportament de les bookmarks
 %% 0 treballem amb romana
 <</Type/Font /Subtype/Type1 /Name/fontB0 /BaseFont/Helvetica /Encoding/WinAnsiEncoding>>
 %% 1 treballem amb itàlica
 <</Type/Font /Subtype/Type1 /Name/fontB1 /BaseFont/Helvetica-Oblique /Encoding/WinAnsiEncoding>>
 %% 2 treballem amb negreta
 <</Type/Font /Subtype/Type1 /Name/fontB2 /BaseFont/Helvetica-Bold /Encoding/WinAnsiEncoding>>
] /segonsF exch def  %% comportament segons l'entrada /F del diccionari de bookmarks
/COSi 11 def  %% definim el cos base per escriure l'índex

%% ENS CAL ACTIVAR POLYFEM I PURGAR EL BATIBULL D'ENCODINGS A %#%20% !!!!!!!!!!
polyFEM
1 get  %% generem l'índex amb pàgines?
{
%% dicionari on desarem com a clau el nom de l'objecte-pàgina on hi afegirem l'índex abans
%% i com a valor, de moment, hi haurà una array amb el nom dels fitxers amb el codi PDF
/paginesDindex <<>> def
/ViNGA false def  %% gatell per saber si engeguem la generació d'índex
/iL COSi 130 mul 100 div def  %% interliniat d'un 120% del cos
/ARATf 2 array def  %% variable per desar el valor tipogràfic al paginador

%% per evitar problemes de xifrat, creem de nou els objectes /Font amb el mínim de dades
%%[  %% array d'objectes Font manats segons /taranna pel comportament de les bookmarks
 %% 0 treballem amb romana
%% <</Type/Font /Subtype/Type1 /Name/fontB0 /BaseFont/Helvetica /Encoding/WinAnsiEncoding>>
 %% 1 treballem amb itàlica
%% <</Type/Font /Subtype/Type1 /Name/fontB1 /BaseFont/Helvetica-Oblique /Encoding/WinAnsiEncoding>>
 %% 2 treballem amb negreta
%% <</Type/Font /Subtype/Type1 /Name/fontB2 /BaseFont/Helvetica-Bold /Encoding/WinAnsiEncoding>>
%%] /segonsF exch def  %% comportament segons l'entrada /F del diccionari de bookmarks

%% controlem el tabulat de les jerarquies dins la pàgina amb la variable SUARAj per comparar amb
%% l'actual, per saber les vegades que cal multiplicar mTab per araX i saber el valor X de Td
/SUARAj 0 def  %% valor jeràrquic inicial (no fos que no s'iniciés l'arbre amb jerarquia màxima!)

/HEMescrit false def  %% gatell per saber si hem escrit re

/ARAxTd 0 def  %% valor actual i acumulat de l'X de Td

%% aquí bastim bboxBindexDpagina
%% desarem la clau del bookmark (link equivalent a l'índex de pàgina) associada al seu bbox
/bboxBindexDpagina <<>> def
%% desarem en una array (valor) totes les bookmarks lligades al path que apunta al nou fitxer
%% stream de la pàgina d'índex (clau), més tard generarem bookmarksXpaginaDindex per tal de canviar
%% la clau del path per la clau de la ref ind de la nova pàgina d'índex, així sabrem d'una vegada
%% quines bookmarks hi haurà relacionades en cadascuna de les noves pàgines d'índex
/bookmarksXstream <<>> def
/iDpQtMdP false def  %% índex de pàgina que té més d'una pàgina?
/mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades

saPrimeraB 1 saDarreraB
{  %% for on generem els fitxers amb el codi PDF de l'índex de contingut de pàgina
   %% per a inserir-los més tard com a nous streams d'objectes-pàgina
 arbreDbookmarks exch 8 string cvs
 %% aquí bastim bboxBindexDpagina
 %% desem la bookmark actual per desar-la com a clau a bboxBindexDpagina
 dup /CLAUbboxBindexDpagina exch def
 /araQP 4 array def  %% array per definir els QuadPoints o BBox del link
 get dup /_JERARQUiA get dup 0 eq  %% és de màxima jerarquia?
 {  %% si, és de màxima jerarquia
  0 /mTab exch def  %% inicialitzem el multiplicador del tabulador per Td
  /SUARAj exch def
  dup /Dest get 0 get
  dup /refindXnum exch def  %% la ref ind de l'stream ens assegura una correcta numeració
  /OiP exch def  %% objecte indirecte de la pàgina
  quinaPlana
  {  %% forall per saber el MediaBox de la pàgina del catàleg on cal intercalar l'índex
   OiP eq
   {  %% anem a cercar el MediaBox de la pàgina per tal de composar de forma dinàmica els índex
    %% de contingut de pàgina que afegirem just abans de OiP
    XRay /PeDeEfa get exch get /MediaBox get aload pop 3 -1 roll sub /altDpagina exch def
    exch sub /ampleDpagina exch def

%% manipulem manualment el format de pàgina per assaig
%%ProblemaD
%% /altDpagina 200 def

    %% oju amb l'ample doncs si la paraula més llarga composta no hi cap el programa petarà!
    %% /ampleDpagina 450 def

    0 /iPag exch def  %% numerador per les pàgines d'un mateix índex
    %% iniciem la composició dinàmica de la pàgina
    ViNGA  %% gatell per saber si engeguem la generació d'índex i si tanquem els fitxers stream
    {
     %% escrivim la cua de l'stream de pàgina i tanquem el fitxer
     ARAdex (ET\012Q\012) writestring
     %% esborrem el darrer stream buit de text?
     polimS  %% gatell per saber si hem d'eliminar la darrera stream escrita
     {
      paginesDindex suaraOiP get dup length 1 sub 0 exch getinterval
      paginesDindex exch suaraOiP exch put
     }if

     %% tirem totes les línies de la pàgina
     ARAdex (q 1 J .5 w [2]2 d\012) writestring
     mapaDlinies
     {  %% forall per totes les linies a pintar dins la pàgina
      dup 0 2 getinterval
      {  %% forall
       128 string cvs ARAdex exch writestring
       ARAdex 32 write
      }forall
      ARAdex (m ) writestring
      2 2 getinterval
      {  %% forall
       128 string cvs ARAdex exch writestring
       ARAdex 32 write
      }forall
      ARAdex (l S ) writestring
      pop  %% eliminem la clau
     }forall
     ARAdex dup (\012Q\012) writestring closefile
     /mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades

(cua1)==

    }
    {
     /ViNGA true def
    }ifelse
    %% generem el nom del fitxer amb el codi PDF per l'stream de contingut de pàgina
    /troncDindexPaper
    [
     20 string dup dup 0 OiP 16 string cvs putinterval dup  %% primer tram del nom
     iPag 3 string cvs dup length 16 exch sub exch putinterval  %% numerador
     16 (.000)putinterval  %% cua amb l'extensió
     dup length faPath add string dup /pAthXiU exch def
     0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
     pAthXiU dup dup /araPstream exch def (w) file /ARAdex exch def
    ]def
    %% desem
    paginesDindex OiP troncDindexPaper put
    %% inicialitzem el numerador per paginar els streams de l'índex per a cada inserció
    /nuDex 0 def
    taranna 0 get /tabula get dup /suaraTabula exch def cvx exec
    /araX exch def  %% x del punter componedor
    /araY altDpagina COSi 3 mul sub def  %% y del punter componedor
    %% amplada màxima de la línia compensada per que hi càpiga la numeració de pàgines
    /maxX ampleDpagina COSi 3 mul sub def
    /maxY COSi 6 mul def  %% posició màxima de la darrera línia abans de canviar de pàgina
    /ARAxTd 0 def  %% valor actual i acumulat de l'X de Td
    %% comencem a escriure l'stream de pàgina:
    ARAdex (q\012BT\0120 Tr\012) writestring  %% inici de l'estat gràfic, del text i rendering
    ARAdex dup iL 128 string cvs writestring ( TL\012) writestring  %% interliniat
    ARAdex dup dup dup araX dup ARAxTd add /ARAxTd exch def 128 string cvs writestring 32 write
    araY 128 string cvs writestring ( Td\012) writestring  %% posicionem el text
    taranna 0 get dup /F known
    {
     dup /F get dup 2 gt
     {  %% amb un gatell fora de rang, també vadrà zero
      %% color, tipus i cos de lletra
      pop /C get dup /ARArg exch def
      {  %% forall
       128 string cvs ARAdex exch writestring ARAdex 32 write
      }forall
      ARAdex dup dup dup dup dup (rg\012) writestring
      (/) writestring segonsF 0 get dup /BaseFont get /fontBase exch def
      /Name get 128 string cvs dup ARATf exch 0 exch put writestring
      32 write COSi 128 string cvs dup ARATf exch 1 exch put writestring ( Tf\012) writestring
     }
     {  %% som dins el rang canònic
      %% color, tipus i cos de lletra
      /araF exch def /C get dup /ARArg exch def
      {  %% forall
       128 string cvs ARAdex exch writestring ARAdex 32 write
      }forall
      ARAdex dup dup dup dup dup (rg\012) writestring
      (/) writestring segonsF araF get dup /BaseFont get /fontBase exch def
      /Name get 128 string cvs dup ARATf exch 0 exch put writestring
      32 write COSi 128 string cvs dup ARATf exch 1 exch put writestring ( Tf\012) writestring
     }ifelse
    }
    {  %% si no hi és, és que F val zero
     %% color, tipus i cos de lletra
     /C get dup /ARArg exch def
     {
      128 string cvs ARAdex exch writestring ARAdex 32 write
     }forall
     ARAdex dup dup dup dup dup (rg\012) writestring
     (/) writestring segonsF 0 get dup /BaseFont get /fontBase exch def
     /Name get 128 string cvs dup ARATf exch 0 exch put writestring
     32 write COSi 128 string cvs dup ARATf exch 1 exch put writestring ( Tf\012) writestring
    }ifelse
    /HEMescrit true def  %% gatell per saber si hem escrit re
    %% escrivim la línia de text de la bookmark repicada a WinAnsi
    /_BLiNiA get
    %% iniciem el repicat del text
    1024 string /sTitle exch def  %% buffer d'escriptura dins una string prou llarga
    sTitle /NullEncode filter /Frengs exch def  %% com a fitxer
    1 get  %% extraiem l'array de noms de signes
    %% repiquem els noms dels signes a la seva representacio escrita
    %% segons la taula d_WAE (WinAnsiEncoding)
    {  %% forall per tot l'array de noms de signes
     %% hem de purgar els nulls!!!!!
     dup null eq
     {
      pop
     }
     {
      d_WAE
      1 index known
      {
       %% protegim l'string contra signes conflictius que cal blindar
       dup /parenright eq
       {
        pop Frengs (\)) writestring  %% escrivim el signe tancar parentesi protegit
       }
       {
        dup /parenleft eq
        {
         pop Frengs
         (\() writestring  %% escrivim el signe d'obrir parentesi protegit
        }
        {
         dup /backslash eq
         {
          pop Frengs
          (\\) writestring  %% escrivim el signe backslash protegit
         }
         {  %% no és cap dels conflictius i existeix
          d_WAE exch get
          Frengs exch write  %% escrivim el signe
         }ifelse
        }ifelse
       }ifelse
      }
      {  %% si no existeix
       %% fem una substitució adaptada per mitjà del diccionari SOFIglyphs
       SOFIglyphs 1 index known
       {
        SOFIglyphs exch get
        Frengs exch writestring  %% escrivim el signe
       }
       {  %% si no existeix
        %% ara hi posem un espai en blanc i la pràctica continuada ja ens orientarà
        %% de com implementar el signe conflictiu de forma adequada
        == ( ... signe conflictiu ... l'exportem en blanc!)==
        Frengs 32 write
       }ifelse
      }ifelse
     }ifelse  %% del purgat de nulls
    }forall  %% per tot l'array de noms de signes
    Frengs closefile  %% tanquem el fitxer que, com a string, fa de buffer
    sTitle (\000) search  %% purguem els caràcters zero (\000) sobrants del buffer
    {
     exch pop exch pop
    }if
    %% abans d'escriure la cadena a l'stream, ens cal saber si cal tallar-la en dues línies o més
    gsave
    dup

%% test
%(aixo es mes llarg que un dia sense pa i sense vi i sense cardar i sense cagar i sense sentit de re, de re, de re, de re i prou? ...o es que encara no n'hi ha hagut prou, eh? que m'en dius tu ara, eh? cap de peres? bufarut? tros de quoniam? espantavelles? cap venecia? o vens d'Arbeca o tens migranya? o fas pudor? o rius d'escaire o pixes tort? es que no em sents? eeeeeeh? què hi dius ara, RistuMejida, verd dels collons, bufa tinters, titiu gairell, ostia podrida o fetid pollastre de Festa Major!) dup

    %% QUAN RESOLEM EL BATIBULL DE L'ENCODING, AIXÒ HA D'ANAR A FORA!!!!
    hemfetfindfont
    <</Helvetica 0 /Helvetica-Oblique 1 /Helvetica-Bold 2>> fontBase get get

    %% aquí bastim bboxBindexDpagina
    %% situem llX urX urY del futur vincle de l'índex de pàgina
    araQP dup dup 0 araX put 2 maxX put 3 araY put
    COSi scalefont setfont stringwidth pop araX add maxX gt
    {  %% ens cal recomposar la línia
     dup /reComposem exch def length 1 sub dup /tAllem exch def /idarrer exch def
     {  %% loop enrera en base a /space per extraure les línies que podem compondre senceres
      tAllem dup reComposem exch get WinAnsiEncoding exch get /space eq
      {
       reComposem exch 0 exch getinterval
       dup stringwidth pop araX add maxX gt  %% la linia no hi queb?
       {  %% encara no, doncs no fem re i anem tirant enrera per trobar on la trenquem
        /massallarga exch def  %% la desem per prevenció
        %% pop  %% eliminem la cadena avaluada
        tAllem 1 sub /tAllem exch def
        %% tret que tAllem fos negatiu, el que voldria dir que la paraula sola no hi cap dins
        %% l'ample de la pàgina establert, cosa greu, llavors aturaríem la feina avisant
        tAllem 0 le
        {
         (\n\n ... teniu una paraula mes ample que l'X de la pagina ... PLEGUEM!\n\n)
         print flush quit
        }if
       }
       {  %% ara si, doncs la componem
        %% escrivim el tabulat (es correcte doncs Td és acumulatiu?)
        ARAdex dup araX mTab mul dup ARAxTd add /ARAxTd exch def 64 string cvs writestring
        ( 0 Td\012) writestring
        %% escrivim la cadena normalitzada a WinAnsi amb l'operador '
        ARAdex (\() writestring ARAdex exch
%%avuipintem AQUI ENS CAL FILTRAR POSSIBLES CARÀCTERS CONFLICTIUS
        %%% salvaparent2.ps
        %%% de com reescriure una string x solucionar el problema de no deixar-nos
        %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
        %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
        /fora
        [  %% paquet de caracters a cercar
         (\134)  %% \ backslash
         (\050)  %% ( left parenthesis
         (\051)  %% ) right parenthesis
         (\012)  %% \n line feed (LF)
         (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
         (\011)  %% \t horizontal tab
         (\010)  %% \b backspace
         (\014)  %% \f form feed (FF)
        ] def
        /FAfora fora length def  %% pestell de sortida del loop
        /foraX
        [  %% paquet de substitucio de caracter
         (\\\\)  %% backslash
         (\\\()  %% left parenthesis
         (\\\))  %% right parenthesis
         (\\n)  %% line feed (LF)
         (\\r)  %% carriage return (CR)
         (\\t)  %% horizontal tab
         (\\b)  %% backspace
         (\\f)  %% form feed (FF)
        ] def
        /ifora 0 def  %% index de fora
        %%% aqui la cadena a reescriure correctament
        %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
        mark exch
        {  %% loop general
         {  %% loop cerca/subs de caracters
          fora ifora get search
          {
           exch pop
           dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
           dup 3 -1 roll 0 exch putinterval
          }
          {
           exit
          }ifelse
          exch
         } loop
         %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
         counttomark 1 gt
         {
          counttomark /atura't exch def
          /ici 2 def
          {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
          {  %% loop empalmador de les cadenes trobades en 1 sola
           dup length dup 3 index length add string dup 4 -1 roll
           0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
           counttomark 1 eq {exit} if
          } loop
         } if
         ifora 1 add /ifora exch def
         FAfora ifora eq {exit}if
        } loop
        exch pop  %% ens carreguem mark
        %%% fi de salvaparent2.ps
%(avuipintem 1)pstack quit
        writestring ARAdex (\)'\012) writestring
        %% actualitzem el valor per la nova línia de text
        araY iL sub /araY exch def

%% numeració provisional dels punts de l'índex per mitjà del seu objecte indirecte
%%OiP (provisional1)pstack quit
%%(prov1) ==
%1 0 0 rg 200 13.2 Td (22)' -200 0 Td

        %% canvi de pàgina?
        araY maxY le
        {
         %% escrivim la cua de l'stream de pàgina i tanquem el fitxer
         ARAdex (ET\012Q\012) writestring
         /araX suaraTabula cvx exec def  %% inicialitzem l'x del punter componedor

         %% tirem totes les línies de la pàgina
         ARAdex (q 1 J .5 w [2]2 d\012) writestring
         mapaDlinies
         {  %% forall per totes les linies a pintar dins la pàgina
          dup 0 2 getinterval
          {  %% forall
           128 string cvs ARAdex exch writestring
           ARAdex 32 write
          }forall
          ARAdex (m ) writestring
          2 2 getinterval
          {  %% forall
           128 string cvs ARAdex exch writestring
           ARAdex 32 write
          }forall
          ARAdex (l S ) writestring
          pop  %% eliminem la clau
         }forall
         ARAdex dup (\012Q\012) writestring closefile
         /mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades

(cua2)==

         /iDpQtMdP true def  %% índex de pàgina que té més d'una pàgina?
         araPstream /SUARAaraPstream exch def  %% el path de l'stream d'abans de canviar de pàgina

         %% cal inicialitzar aquesta variable al començar una nova pàgina
         /SUARAj 0 def
         /araY altDpagina COSi 3 mul sub def  %% inicialitzem l'y del punter componedor
         paginesDindex OiP get  %% rescatem la clau amb la ref ind que fa de posicionador
         %% el darrer stream escrit per numerar-ne el nou
         dup dup length dup /araVa exch def 1 sub get
         dup length string copy dup dup length
         nuDex 1 add dup /nuDex exch def  %% comptador d'streams d'un mateix índex 
         3 string cvs dup length 3 -1 roll exch sub exch putinterval
         dup dup /araPstream exch def (w) file /ARAdex exch def
         araVa 1 add array dup dup 5 -1 roll 0 exch putinterval 3 -1 roll araVa exch put
         paginesDindex exch OiP exch put
         /ARAxTd 0 def  %% valor actual i acumulat de l'X de Td
         %% comencem a escriure l'stream de pàgina:
         ARAdex (q\012BT\0120 Tr\012) writestring  %% inici de l'estat gràfic, del text i rendering
         ARAdex dup iL 128 string cvs writestring ( TL\012) writestring  %% interliniat
         ARAdex dup dup dup araX dup ARAxTd add /ARAxTd exch def 128 string cvs writestring 32 write
         araY 128 string cvs writestring ( Td\012) writestring  %% posicionem el text
         ARArg
         {  %% forall
          128 string cvs ARAdex exch writestring ARAdex 32 write
         }forall
         ARAdex dup dup dup dup dup (rg\012) writestring
         (/) writestring ARATf 0 get writestring 32 write ARATf 1 get writestring
         ( Tf\012) writestring

(:-0) ==  %% pstack quit

         /HEMescrit false def  %% gatell per saber si hem escrit re
        }
        {
         /iDpQtMdP false def  %% índex de pàgina que té més d'una pàgina?
        }ifelse

        %% comprovem si la resta de la cadena hi cap
        reComposem tAllem 1 add idarrer tAllem sub getinterval
        dup stringwidth pop araX add maxX gt  %% la linia no hi queb?
        {  %% encara no, llavors redefinim els valors de
         dup /reComposem exch def length 1 sub dup /tAllem exch def /idarrer exch def
%(:-YYYYY)pstack quit
        }
        {  %% ara si, doncs la componem i sortim del loop

         %% escrivim el tabulat (es correcte doncs Td és acumulatiu?)
         ARAdex dup araX mTab mul dup ARAxTd add /ARAxTd exch def
         64 string cvs writestring ( 0 Td\012) writestring

         %% escrivim la cadena normalitzada a WinAnsi amb l'operador '
         ARAdex (\() writestring ARAdex exch
%%avuipintem AQUI ENS CAL FILTRAR POSSIBLES CARÀCTERS CONFLICTIUS
         %%% salvaparent2.ps
         %%% de com reescriure una string x solucionar el problema de no deixar-nos
         %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
         %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
         /fora
         [  %% paquet de caracters a cercar
          (\134)  %% \ backslash
          (\050)  %% ( left parenthesis
          (\051)  %% ) right parenthesis
          (\012)  %% \n line feed (LF)
          (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
          (\011)  %% \t horizontal tab
          (\010)  %% \b backspace
          (\014)  %% \f form feed (FF)
         ] def
         /FAfora fora length def  %% pestell de sortida del loop
         /foraX
         [  %% paquet de substitucio de caracter
          (\\\\)  %% backslash
          (\\\()  %% left parenthesis
          (\\\))  %% right parenthesis
          (\\n)  %% line feed (LF)
          (\\r)  %% carriage return (CR)
          (\\t)  %% horizontal tab
          (\\b)  %% backspace
          (\\f)  %% form feed (FF)
         ] def
         /ifora 0 def  %% index de fora
         %%% aqui la cadena a reescriure correctament
         %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
         mark exch
         {  %% loop general
          {  %% loop cerca/subs de caracters
           fora ifora get search
           {
            exch pop
            dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
            dup 3 -1 roll 0 exch putinterval
           }
           {
            exit
           }ifelse
           exch
          } loop
          %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
          counttomark 1 gt
          {
           counttomark /atura't exch def
           /ici 2 def
           {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
           {  %% loop empalmador de les cadenes trobades en 1 sola
            dup length dup 3 index length add string dup 4 -1 roll
            0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
            counttomark 1 eq {exit} if
           } loop
          } if
          ifora 1 add /ifora exch def
          FAfora ifora eq {exit}if
         } loop
         exch pop  %% ens carreguem mark
         %%% fi de salvaparent2.ps
%(avuipintem 2)pstack quit
         writestring ARAdex (\)'\012) writestring
         %% actualitzem el valor per la nova línia de text
         araY iL sub /araY exch def

%% numeració provisional dels punts de l'índex per mitjà del seu objecte indirecte
%%OiP (provisional2)pstack quit
%%(prov2) ==
%1 0 0 rg 200 13.2 Td (22)' -200 0 Td

         %% canvi de pàgina?
         araY maxY le
         {
          %% escrivim la cua de l'stream de pàgina i tanquem el fitxer
          ARAdex (ET\012Q\012) writestring
          /araX suaraTabula cvx exec def  %% inicialitzem l'x del punter componedor
          %% tirem totes les línies de la pàgina
          ARAdex (q 1 J .5 w [2]2 d\012) writestring
          mapaDlinies
          {  %% forall per totes les linies a pintar dins la pàgina
           dup 0 2 getinterval
           {  %% forall
            128 string cvs ARAdex exch writestring
            ARAdex 32 write
           }forall
           ARAdex (m ) writestring
           2 2 getinterval
           {  %% forall
            128 string cvs ARAdex exch writestring
            ARAdex 32 write
           }forall
           ARAdex (l S ) writestring
           pop  %% eliminem la clau
          }forall
          ARAdex dup (\012Q\012) writestring closefile
          /mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades

(cua3)==

          /iDpQtMdP true def  %% índex de pàgina que té més d'una pàgina?
          araPstream /SUARAaraPstream exch def  %% el path de l'stream d'abans de canviar de pàgina

          %% cal inicialitzar aquesta variable al començar una nova pàgina
          /SUARAj 0 def
          /araY altDpagina COSi 3 mul sub def  %% inicialitzem l'y del punter componedor
          paginesDindex OiP get  %% rescatem la clau amb la ref ind que fa de posicionador
          dup dup length dup /araVa exch def 1 sub get  %% el darrer stream escrit per numerar-ne el nou
          dup length string copy dup dup length
          nuDex 1 add dup /nuDex exch def  %% comptador d'streams d'un mateix índex 
          3 string cvs dup length 3 -1 roll exch sub exch putinterval
          dup dup /araPstream exch def (w) file /ARAdex exch def
          araVa 1 add array dup dup 5 -1 roll 0 exch putinterval 3 -1 roll araVa exch put
          paginesDindex exch OiP exch put
          /ARAxTd 0 def  %% valor actual i acumulat de l'X de Td
          %% comencem a escriure l'stream de pàgina:
          ARAdex (q\012BT\0120 Tr\012) writestring  %% inici de l'estat gràfic, del text i rendering
          ARAdex dup iL 128 string cvs writestring ( TL\012) writestring  %% interliniat
          ARAdex dup dup dup araX dup ARAxTd add /ARAxTd exch def
          128 string cvs writestring 32 write araY
          128 string cvs writestring ( Td\012) writestring  %% posicionem el text
          ARArg
          {  %% forall
           128 string cvs ARAdex exch writestring ARAdex 32 write
          }forall
          ARAdex dup dup dup dup dup (rg\012) writestring
          (/) writestring ARATf 0 get writestring 32 write
          ARATf 1 get writestring ( Tf\012) writestring

 (:-1) ==  %%pstack quit

          /HEMescrit false def  %% gatell per saber si hem escrit re
         }
         {
          /iDpQtMdP false def  %% índex de pàgina que té més d'una pàgina?
         }ifelse
         exit
        }ifelse
        %% i desem el text restant per valorar-lo
       }ifelse
      }
      {
       pop  %% eliminem l'índex de posició
       tAllem 1 sub /tAllem exch def
       %% tret que tAllem fos negatiu, el que voldria dir que la paraula sola no hi cap dins
       %% l'ample de la pàgina establert, cosa greu, llavors aturaríem la feina avisant
       tAllem 0 le
       {
        (\n\n ... teniu una paraula mes ample que l'X de la pagina ... PLEGUEM!\n\n)print flush quit
       }if
      }ifelse
     }loop
     /polimS true def  %% gatell per saber si hem d'eliminar la darrera stream escrita
     %% aquí bastim bboxBindexDpagina
     araQP 1 araY COSi .2 mul sub put  %% situem llY del futur vincle de l'índex de pàgina
    }
    {  %% la línia hi cab perfectament
     /polimS false def  %% gatell per saber si hem d'eliminar la darrera stream escrita
     %% escrivim el tabulat (es correcte doncs Td és acumulatiu?)
     ARAdex dup araX mTab mul dup ARAxTd add /ARAxTd exch def
     64 string cvs writestring ( 0 Td\012) writestring
     %% escrivim la cadena normalitzada a WinAnsi amb l'operador '
     ARAdex (\() writestring ARAdex exch
     %% aquí planifiquem el puntejat
     %% ens caldria calcular des d'on i fins on hem d'escriure o traçar la ratlla puntejada?
     gsave
     %% QUAN RESOLEM EL BATIBULL DE L'ENCODING, AIXÒ HA D'ANAR A FORA!!!!
     dup
     hemfetfindfont
     <</Helvetica 0 /Helvetica-Oblique 1 /Helvetica-Bold 2>>
     %%(.....1)pstack quit
     fontBase get get
     COSi scalefont setfont stringwidth pop
     mapaDlinies araY 128 string cvs
     [
      ARAxTd 5 -1 roll add araY iL sub maxX COSi 3 mul sub araY iL sub
     ] put
     grestore
%%avuipintem AQUI ENS CAL FILTRAR POSSIBLES CARÀCTERS CONFLICTIUS
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %%% fi de salvaparent2.ps
%(avuipintem 3)pstack quit
     writestring ARAdex (\)'\012) writestring
     %% actualitzem el valor per la nova línia de text
     araY iL sub /araY exch def
     %%(prov3) ==
     %% numeració provisional dels punts de l'índex per mitjà del seu objecte indirecte refindXnum
     %% ajustem per l'ample màxim de línia la posició del numerador de pàgina
     ARAdex dup dup (0 0 0 rg /fontB0 ) writestring COSi
     64 string cvs writestring ( Tf\012) writestring
     ARAdex dup maxX
     COSi 2 mul sub
     ARAxTd sub dup /araN exch def 64 string cvs writestring 32 write
     ARAdex dup dup iL 64 string cvs writestring ( Td \()writestring refindXnum
     64 string cvs writestring
     ARAdex dup dup (\)' ) writestring araN neg 64 string cvs writestring ( 0 Td\012) writestring
     %% canvi de pàgina?
     araY maxY le
     {
      %% escrivim la cua de l'stream de pàgina i tanquem el fitxer
      ARAdex (ET\012Q\012) writestring
      /araX suaraTabula cvx exec def  %% inicialitzem l'x del punter componedor
      %% tirem totes les línies de la pàgina
      ARAdex (q 1 J .5 w [2]2 d\012) writestring
      mapaDlinies
      {  %% forall per totes les linies a pintar dins la pàgina
       dup 0 2 getinterval
       {  %% forall
        128 string cvs ARAdex exch writestring
        ARAdex 32 write
       }forall
       ARAdex (m ) writestring
       2 2 getinterval
       {  %% forall
        128 string cvs ARAdex exch writestring
        ARAdex 32 write
       }forall
       ARAdex (l S ) writestring
       pop  %% eliminem la clau
      }forall
      ARAdex dup (\012Q\012) writestring closefile
      /mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades

(cua4)==

      /iDpQtMdP true def  %% índex de pàgina que té més d'una pàgina?
      araPstream /SUARAaraPstream exch def  %% el path de l'stream d'abans de canviar de pàgina
      %% aquí bastim bboxBindexDpagina
      %% situem llY del futur vincle de l'índex de pàgina
      araQP 1 araY COSi .2 mul sub put
%% cal inicialitzar aquesta variable al començar una nova pàgina
      /SUARAj 0 def
      /araY altDpagina COSi 3 mul sub def  %% inicialitzem l'y del punter componedor
      paginesDindex OiP get  %% rescatem la clau amb la ref ind que fa de posicionador
      dup dup length dup /araVa exch def 1 sub get  %% el darrer stream escrit per numerar-ne el nou
      dup length string copy dup dup length
      nuDex 1 add dup /nuDex exch def  %% comptador d'streams d'un mateix índex 
      3 string cvs dup length 3 -1 roll exch sub exch putinterval
      dup dup /araPstream exch def (w) file /ARAdex exch def
      araVa 1 add array dup dup 5 -1 roll 0 exch putinterval 3 -1 roll araVa exch put
      paginesDindex exch OiP exch put
      /ARAxTd 0 def  %% valor actual i acumulat de l'X de Td
      %% comencem a escriure l'stream de pàgina:
      ARAdex (q\012BT\0120 Tr\012) writestring  %% inici de l'estat gràfic, del text i rendering
      ARAdex dup iL 128 string cvs writestring ( TL\012) writestring  %% interliniat
      ARAdex dup dup dup araX dup ARAxTd add /ARAxTd exch def
      128 string cvs writestring 32 write araY
      128 string cvs writestring ( Td\012) writestring  %% posicionem el text
      ARArg
      {  %% forall
       128 string cvs ARAdex exch writestring ARAdex 32 write
      }forall
      ARAdex dup dup dup dup dup (rg\012) writestring
      (/) writestring ARATf 0 get writestring 32 write ARATf 1 get writestring ( Tf\012) writestring

 (:-2) ==  %%pstack quit

      /HEMescrit false def  %% gatell per saber si hem escrit re
     }
     {
      /iDpQtMdP false def  %% índex de pàgina que té més d'una pàgina?
      %% aquí bastim bboxBindexDpagina
      %% situem llY del futur vincle de l'índex de pàgina
      araQP 1 araY COSi .2 mul sub put
     }ifelse
    }ifelse
    grestore
    %ARAdex closefile
   }
   {
    pop  %% eliminem el literal del número de pàgina
   }ifelse
  }forall  %% forall per saber el MediaBox de la pàgina del catàleg on cal intercalar l'índex
  %% aquí bastim bboxBindexDpagina
  %% desem la bookmark i el seu bbox pel link de la pàgina
  bboxBindexDpagina CLAUbboxBindexDpagina araQP dup length array copy put
  %%(:-D0)pstack quit
 }
 {
  ViNGA
  {  %% només si hem trobat una primera bookmark de màxima categoria (0)
   %% seguim amb la composició dinàmica de la pàgina per les altres categories
   %% la ref ind de l'stream ens assegura una correcta numeració
   1 index /Dest get 0 get /refindXnum exch def
   OiP /suaraOiP exch def  %% per poder accedir a esborrar el darrer stream buit?
   %% aquí hem de filtrar la jerarquia per tal de limitar l'índex fins un determinat nivell
   %% a l'stack hi tenim l'enter de la categoria i el diccionari del bookmark
%%ProblemaD
   dup 3 gt  %% és de la categoria que va com a contingut de pàgina (ara de zero a tres)?
   {
    pop pop  %% eliminem l'enter de la categoria i el diccionari del bookmark
   }
   {
    dup dup SUARAj sub /mTab exch def  %% multiplicador del tabulador per Td
    /SUARAj exch def
%(,,,,,,)pstack quit
    dup taranna exch get /tabula get dup /suaraTabula exch def cvx exec /araX exch def  %% x del punter componedor
    %% redefinim amplada màxima de la línia compensada per que hi càpiga la numeració de pàgines
    /maxX ampleDpagina COSi 3 mul sub def
    taranna exch get dup /F known
    {
     dup /F get dup 2 gt
     {  %% amb un gatell fora de rang, també vadrà zero
      %% color, tipus i cos de lletra
      pop /C get dup /ARArg exch def {128 string cvs ARAdex exch writestring ARAdex 32 write}forall
      ARAdex dup dup dup dup dup (rg\012) writestring
      (/) writestring segonsF 0 get dup /BaseFont get /fontBase exch def
      /Name get 128 string cvs dup ARATf exch 0 exch put writestring
      32 write COSi 128 string cvs dup ARATf exch 1 exch put writestring ( Tf\012) writestring
     }
     {  %% som dins el rang canònic
      %% color, tipus i cos de lletra
      /araF exch def /C get dup /ARArg exch def
      {  %% forall
       128 string cvs ARAdex exch writestring ARAdex 32 write
      }forall
      ARAdex dup dup dup dup dup (rg\012) writestring
      (/) writestring segonsF araF get dup /BaseFont get /fontBase exch def
      /Name get 128 string cvs dup ARATf exch 0 exch put writestring
      32 write COSi 128 string cvs dup ARATf exch 1 exch put writestring ( Tf\012) writestring
     }ifelse
    }
    {  %% si no hi és, és que F val zero
     %% color, tipus i cos de lletra
     /C get dup /ARArg exch def {128 string cvs ARAdex exch writestring ARAdex 32 write}forall
     ARAdex dup dup dup dup dup (rg\012) writestring
     (/) writestring segonsF 0 get dup /BaseFont get /fontBase exch def
     /Name get 128 string cvs dup ARATf exch 0 exch put writestring
     32 write COSi 128 string cvs dup ARATf exch 1 exch put writestring ( Tf\012) writestring
    }ifelse

    /HEMescrit true def  %% gatell per saber si hem escrit re
    %% escrivim la línia de text de la bookmark repicada a WinAnsi
    /_BLiNiA get
    %% iniciem el repicat del text
    1024 string /sTitle exch def  %% buffer d'escriptura dins una string prou llarga
    sTitle /NullEncode filter /Frengs exch def  %% com a fitxer
    1 get  %% extraiem l'array de noms de signes
    %% repiquem els noms dels signes a la seva representacio escrita
    %% segons la taula d_WAE (WinAnsiEncoding)
    {  %% forall per tot l'array de noms de signes
     %% hem de purgar els nulls!!!!!
     dup null eq
     {
      pop
     }
     {
      d_WAE
      1 index known
      {
       %% protegim l'string contra signes conflictius que cal blindar
       dup /parenright eq
       {
        pop Frengs (\)) writestring  %% escrivim el signe tancar parentesi protegit
       }
       {
        dup /parenleft eq
        {
         pop Frengs
         (\() writestring  %% escrivim el signe d'obrir parentesi protegit
        }
        {
         dup /backslash eq
         {
          pop Frengs
          (\\) writestring  %% escrivim el signe backslash protegit
         }
         {  %% no és cap dels conflictius i existeix
          d_WAE exch get
          Frengs exch write  %% escrivim el signe
         }ifelse
        }ifelse
       }ifelse
      }
      {  %% si no existeix
       %% fem una substitució adaptada per mitjà del diccionari SOFIglyphs
       SOFIglyphs 1 index known
       {
        SOFIglyphs exch get
        Frengs exch writestring  %% escrivim el signe
       }
       {  %% si no existeix
        %% ara hi posem un espai en blanc i la pràctica continuada ja ens orientarà
        %% de com implementar el signe conflictiu de forma adequada
        == ( ... signe conflictiu ... l'exportem en blanc!)==
        Frengs 32 write
       }ifelse
      }ifelse
     }ifelse  %% del purgat de nulls
    }forall  %% per tot l'array de noms de signes
    Frengs closefile  %% tanquem el fitxer que, com a string, fa de buffer
    sTitle (\000) search  %% purguem els caràcters zero (\000) sobrants del buffer
    {
     exch pop exch pop
    }if
    %% abans d'escriure la cadena a l'stream, ens cal saber si cal tallar-la en dues línies o més
    gsave
    dup

%% test
%(aixo es mes llarg que un dia sense pa i sense vi i sense cardar i sense cagar i sense sentit de re, de re, de re, de re i prou? ...o es que encara no n'hi ha hagut prou, eh? que m'en dius tu ara, eh? cap de peres? bufarut? tros de quoniam? espantavelles? cap venecia? o vens d'Arbeca o tens migranya? o fas pudor? o rius d'escaire o pixes tort? es que no em sents? eeeeeeh? què hi dius ara, RistuMejida, verd dels collons, bufa tinters, titiu gairell, ostia podrida o fetid pollastre de Festa Major!) dup

    %% QUAN RESOLEM EL BATIBULL DE L'ENCODING, AIXÒ HA D'ANAR A FORA!!!!
    hemfetfindfont
    <</Helvetica 0 /Helvetica-Oblique 1 /Helvetica-Bold 2>> fontBase get get

    %% aquí bastim bboxBindexDpagina
    %% situem llX urX urY del futur vincle de l'índex de pàgina
    araQP dup dup 0 araX put 2 maxX put 3 araY %COSi add
    put

    COSi scalefont setfont stringwidth pop araX add maxX gt
    {  %% ens cal recomposar la línia
     dup /reComposem exch def length 1 sub dup /tAllem exch def /idarrer exch def
     {  %% loop enrera en base a /space per extraure les línies que podem compondre senceres
      tAllem dup reComposem exch get WinAnsiEncoding exch get /space eq
      {
       reComposem exch 0 exch getinterval
       dup stringwidth pop araX add maxX gt  %% la linia no hi queb?
       {  %% encara no, doncs no fem re i anem tirant enrera per trobar on la trenquem
        /massallarga exch def  %% la desem per prevenció
        %% pop  %% eliminem la cadena avaluada
        tAllem 1 sub /tAllem exch def
        %% tret que tAllem fos negatiu, el que voldria dir que la paraula sola no hi cap dins
        %% l'ample de la pàgina establert, cosa greu, llavors aturaríem la feina avisant
        tAllem 0 le
        {
         (\n\n ... teniu una paraula mes ample que l'X de la pagina ... PLEGUEM!\n\n)print flush quit
        }if
       }
       {  %% ara si, doncs la componem
        %% escrivim el tabulat (es correcte doncs Td és acumulatiu?)
        ARAdex dup araX mTab mul dup ARAxTd add /ARAxTd exch def
        64 string cvs writestring ( 0 Td\012) writestring
        %% escrivim la cadena normalitzada a WinAnsi amb l'operador '
        ARAdex (\() writestring ARAdex exch
%%avuipintem AQUI ENS CAL FILTRAR POSSIBLES CARÀCTERS CONFLICTIUS
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %%% fi de salvaparent2.ps
%(avuipintem 4)pstack quit
        writestring ARAdex (\)'\012) writestring
        %% actualitzem el valor per la nova línia de text
        araY iL sub /araY exch def

%% numeració provisional dels punts de l'índex per mitjà del seu objecte indirecte
%%OiP (provisional4)pstack quit
%%(prov4) ==
%1 0 0 rg 200 13.2 Td (22)' -200 0 Td

        %% canvi de pàgina?
        araY maxY le
        {
         %% escrivim la cua de l'stream de pàgina i tanquem el fitxer
         ARAdex (ET\012Q\012) writestring
         /araX suaraTabula cvx exec def  %% inicialitzem l'x del punter componedor
         %% tirem totes les línies de la pàgina
         ARAdex (q 1 J .5 w [2]2 d\012) writestring
         mapaDlinies
         {  %% forall per totes les linies a pintar dins la pàgina
          dup 0 2 getinterval
          {  %% forall
           128 string cvs ARAdex exch writestring
           ARAdex 32 write
          }forall
          ARAdex (m ) writestring
          2 2 getinterval
          {  %% forall
           128 string cvs ARAdex exch writestring
           ARAdex 32 write
          }forall
          ARAdex (l S ) writestring
          pop  %% eliminem la clau
         }forall
         ARAdex dup (\012Q\012) writestring closefile
         /mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades

(cua5)==

         /iDpQtMdP true def  %% índex de pàgina que té més d'una pàgina?
         araPstream /SUARAaraPstream exch def  %% el path de l'stream d'abans de canviar de pàgina
         %% cal inicialitzar aquesta variable al començar una nova pàgina
         /SUARAj 0 def
         /araY altDpagina COSi 3 mul sub def  %% inicialitzem l'y del punter componedor
         paginesDindex OiP get  %% rescatem la clau amb la ref ind que fa de posicionador
         dup dup length dup /araVa exch def 1 sub get  %% el darrer stream escrit per numerar-ne el nou
         dup length string copy dup dup length
         nuDex 1 add dup /nuDex exch def  %% comptador d'streams d'un mateix índex 
         3 string cvs dup length 3 -1 roll exch sub exch putinterval
         dup dup /araPstream exch def (w) file /ARAdex exch def
         araVa 1 add array dup dup 5 -1 roll 0 exch putinterval 3 -1 roll araVa exch put
         paginesDindex exch OiP exch put
         /ARAxTd 0 def  %% valor actual i acumulat de l'X de Td
         %% comencem a escriure l'stream de pàgina:
         ARAdex (q\012BT\0120 Tr\012) writestring  %% inici de l'estat gràfic, del text i rendering
         ARAdex dup iL 128 string cvs writestring ( TL\012) writestring  %% interliniat
         ARAdex dup dup dup araX dup ARAxTd add /ARAxTd exch def
         128 string cvs writestring 32 write araY
         128 string cvs writestring ( Td\012) writestring  %% posicionem el text
         ARArg
         {  %% forall
          128 string cvs ARAdex exch writestring ARAdex 32 write
         }forall
         ARAdex dup dup dup dup dup (rg\012) writestring
         (/) writestring ARATf 0 get writestring 32 write
         ARATf 1 get writestring ( Tf\012) writestring

 (:-3) ==  %pstack quit

         /HEMescrit false def  %% gatell per saber si hem escrit re
        }
        {
         /iDpQtMdP false def  %% índex de pàgina que té més d'una pàgina?
        }ifelse
        %% comprovem si la resta de la cadena hi cap
        reComposem tAllem 1 add idarrer tAllem sub getinterval
        dup stringwidth pop araX add maxX gt  %% la linia no hi queb?
        {  %% encara no, llavors redefinim els valors de
         dup /reComposem exch def length 1 sub dup /tAllem exch def /idarrer exch def
%(:-YYYYY)pstack quit
        }
        {  %% ara si, doncs la componem i sortim del loop
         %% escrivim el tabulat (es correcte doncs Td és acumulatiu?)
         ARAdex dup araX mTab mul dup ARAxTd add /ARAxTd exch def
         64 string cvs writestring ( 0 Td\012) writestring
         %% escrivim la cadena normalitzada a WinAnsi amb l'operador '
         ARAdex (\() writestring ARAdex exch
%%avuipintem AQUI ENS CAL FILTRAR POSSIBLES CARÀCTERS CONFLICTIUS
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %%% fi de salvaparent2.ps
%(avuipintem 5)pstack quit
         writestring ARAdex (\)'\012) writestring
         %% actualitzem el valor per la nova línia de text
         araY iL sub /araY exch def

%% numeració provisional dels punts de l'índex per mitjà del seu objecte indirecte
%%OiP (provisional5)pstack quit
%%(prov5) ==
%1 0 0 rg 200 13.2 Td (22)' -200 0 Td

         %% canvi de pàgina?
         araY maxY le
         {
          %% escrivim la cua de l'stream de pàgina i tanquem el fitxer
          ARAdex (ET\012Q\012) writestring
          /araX suaraTabula cvx exec def  %% inicialitzem l'x del punter componedor
          %% tirem totes les línies de la pàgina
          ARAdex (q 1 J .5 w [2]2 d\012) writestring
          mapaDlinies
          {  %% forall per totes les linies a pintar dins la pàgina
           dup 0 2 getinterval
           {  %% forall
            128 string cvs ARAdex exch writestring
            ARAdex 32 write
           }forall
           ARAdex (m ) writestring
           2 2 getinterval
           {  %% forall
            128 string cvs ARAdex exch writestring
            ARAdex 32 write
           }forall
           ARAdex (l S ) writestring
           pop  %% eliminem la clau
          }forall
          ARAdex dup (\012Q\012) writestring closefile
          /mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades

(cua6)==

          /iDpQtMdP true def  %% índex de pàgina que té més d'una pàgina?
          araPstream /SUARAaraPstream exch def  %% el path de l'stream d'abans de canviar de pàgina
          %% cal inicialitzar aquesta variable al començar una nova pàgina
          /SUARAj 0 def
          /araY altDpagina COSi 3 mul sub def  %% inicialitzem l'y del punter componedor
          paginesDindex OiP get  %% rescatem la clau amb la ref ind que fa de posicionador
          dup dup length dup /araVa exch def 1 sub get  %% el darrer stream escrit per numerar-ne el nou
          dup length string copy dup dup length
          nuDex 1 add dup /nuDex exch def  %% comptador d'streams d'un mateix índex 
          3 string cvs dup length 3 -1 roll exch sub exch putinterval
          dup dup /araPstream exch def (w) file /ARAdex exch def
          araVa 1 add array dup dup 5 -1 roll 0 exch putinterval 3 -1 roll araVa exch put
          paginesDindex exch OiP exch put
          /ARAxTd 0 def  %% valor actual i acumulat de l'X de Td
          %% comencem a escriure l'stream de pàgina:
          ARAdex (q\012BT\0120 Tr\012) writestring  %% inici de l'estat gràfic, del text i rendering
          ARAdex dup iL 128 string cvs writestring ( TL\012) writestring  %% interliniat
          ARAdex dup dup dup araX dup ARAxTd add /ARAxTd exch def
          128 string cvs writestring 32 write
          araY 128 string cvs writestring ( Td\012) writestring  %% posicionem el text
          ARArg
          {  %% forall
           128 string cvs ARAdex exch writestring ARAdex 32 write
          }forall
          ARAdex dup dup dup dup dup (rg\012) writestring
          (/) writestring ARATf 0 get writestring 32 write
          ARATf 1 get writestring ( Tf\012) writestring

(:-4) ==  %pstack quit

          /HEMescrit false def  %% gatell per saber si hem escrit re
         }
         {
          /iDpQtMdP false def  %% índex de pàgina que té més d'una pàgina?
         }ifelse
         exit
        }ifelse
        %% i desem el text restant per valorar-lo
       }ifelse
      }
      {
       pop  %% eliminem l'índex de posició
       tAllem 1 sub /tAllem exch def
       %% tret que tAllem fos negatiu, el que voldria dir que la paraula sola no hi cap dins
       %% l'ample de la pàgina establert, cosa greu, llavors aturaríem la feina avisant
       tAllem 0 le
       {
        (\n\n ... teniu una paraula mes ample que l'X de la pagina ... PLEGUEM!\n\n)print flush quit
       }if
      }ifelse
     }loop
     /polimS true def  %% gatell per saber si hem d'eliminar la darrera stream escrita
     %% aquí bastim bboxBindexDpagina
     araQP 1 araY COSi .2 mul sub put  %% situem llY del futur vincle de l'índex de pàgina
    }
    {  %% la línia hi cab perfectament
     /polimS false def  %% gatell per saber si hem d'eliminar la darrera stream escrita
     %% escrivim el tabulat (es correcte doncs Td és acumulatiu?)
     ARAdex dup araX mTab mul dup ARAxTd add /ARAxTd exch def
     64 string cvs writestring ( 0 Td\012) writestring
     %% escrivim la cadena normalitzada a WinAnsi amb l'operador '
     ARAdex (\() writestring ARAdex exch
     %% aquí planifiquem el puntejat
     %% ens caldria calcular des d'on i fins on hem d'escriure o traçar la ratlla puntejada?
     gsave
     %% QUAN RESOLEM EL BATIBULL DE L'ENCODING, AIXÒ HA D'ANAR A FORA!!!!
     dup
     hemfetfindfont
     <</Helvetica 0 /Helvetica-Oblique 1 /Helvetica-Bold 2>>
     %%(.....0)pstack quit
     fontBase get get
     COSi scalefont setfont stringwidth pop
     mapaDlinies araY 128 string cvs
     [
      ARAxTd 5 -1 roll add araY iL sub maxX COSi 3 mul sub araY iL sub
     ] put
     grestore
%%avuipintem AQUI ENS CAL FILTRAR POSSIBLES CARÀCTERS CONFLICTIUS
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %%% fi de salvaparent2.ps
%(avuipintem 6)pstack quit
     writestring ARAdex (\)'\012) writestring
     %% actualitzem el valor per la nova línia de text
     araY iL sub /araY exch def
     %%(prov6) ==
     %% numeració provisional dels punts de l'índex per mitjà del seu objecte indirecte refindXnum
     %% ajustem per l'ample màxim de línia la posició del numerador de pàgina
     ARAdex dup dup (0 0 0 rg /fontB0 ) writestring COSi
     64 string cvs writestring ( Tf\012) writestring
     ARAdex dup maxX
     COSi 2 mul sub
     ARAxTd sub dup /araN exch def 64 string cvs writestring 32 write
     ARAdex dup dup iL 64 string cvs writestring ( Td \()writestring
     refindXnum 64 string cvs writestring
     ARAdex dup dup (\)' ) writestring araN neg 64 string cvs writestring ( 0 Td\012) writestring
     %% canvi de pàgina?
     araY maxY le
     {
      %% escrivim la cua de l'stream de pàgina i tanquem el fitxer
      ARAdex (ET\012Q\012) writestring
      /araX suaraTabula cvx exec def  %% inicialitzem l'x del punter componedor
      %% tirem totes les línies de la pàgina
      ARAdex (q 1 J .5 w [2]2 d\012) writestring
      mapaDlinies
      {  %% forall per totes les linies a pintar dins la pàgina
       dup 0 2 getinterval
       {  %% forall
        128 string cvs ARAdex exch writestring
        ARAdex 32 write
       }forall
       ARAdex (m ) writestring
       2 2 getinterval
       {  %% forall
        128 string cvs ARAdex exch writestring
        ARAdex 32 write
       }forall
       ARAdex (l S ) writestring
       pop  %% eliminem la clau
      }forall
      ARAdex dup (\012Q\012) writestring closefile
      /mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades

(cua7)==

      /iDpQtMdP true def  %% índex de pàgina que té més d'una pàgina?
      araPstream /SUARAaraPstream exch def  %% el path de l'stream d'abans de canviar de pàgina
      %% aquí bastim bboxBindexDpagina
      %% situem llY del futur vincle de l'índex de pàgina
      araQP 1 araY COSi .2 mul sub put
      %% cal inicialitzar aquesta variable al començar una nova pàgina
      /SUARAj 0 def
      /araY altDpagina COSi 3 mul sub def  %% inicialitzem l'y del punter componedor
      paginesDindex OiP get  %% rescatem la clau amb la ref ind que fa de posicionador
      dup dup length dup /araVa exch def 1 sub get  %% el darrer stream escrit per numerar-ne el nou
      dup length string copy dup dup length
      nuDex 1 add dup /nuDex exch def  %% comptador d'streams d'un mateix índex 
      3 string cvs dup length 3 -1 roll exch sub exch putinterval
      dup dup /araPstream exch def (w) file /ARAdex exch def
      araVa 1 add array dup dup 5 -1 roll 0 exch putinterval 3 -1 roll araVa exch put
      paginesDindex exch OiP exch put
      /ARAxTd 0 def  %% valor actual i acumulat de l'X de Td
      %% comencem a escriure l'stream de pàgina:
      ARAdex (q\012BT\0120 Tr\012) writestring  %% inici de l'estat gràfic, del text i rendering
      ARAdex dup iL 128 string cvs writestring ( TL\012) writestring  %% interliniat
      ARAdex dup dup dup araX dup ARAxTd add /ARAxTd exch def 128 string cvs writestring 32 write
      araY 128 string cvs writestring ( Td\012) writestring  %% posicionem el text
      ARArg
      {  %% forall
       128 string cvs ARAdex exch writestring ARAdex 32 write
      }forall
      ARAdex dup dup dup dup dup (rg\012) writestring
      (/) writestring ARATf 0 get writestring 32 write ARATf 1 get writestring ( Tf\012) writestring

 (:-5) ==  %%pstack quit
      /HEMescrit false def  %% gatell per saber si hem escrit re
     }
     {
      /iDpQtMdP false def  %% índex de pàgina que té més d'una pàgina?
      %% aquí bastim bboxBindexDpagina
      %% situem llY del futur vincle de l'índex de pàgina
      araQP 1 araY COSi .2 mul sub put
     }ifelse
    }ifelse
    grestore
    %% aquí bastim bboxBindexDpagina
    %% desem la bookmark i el seu bbox pel link de la pàgina
    bboxBindexDpagina CLAUbboxBindexDpagina araQP dup length array copy put
    %%(:-D1)pstack quit
   }ifelse  %% és de la categoria que va com a contingut de pàgina (ara de zero a tres)?
   %% MMMMM
   %ARAdex closefile(:-YY)pstack quit
  }
  {  %% ignorarem les bookmarks que no hagin sigut precedides inicialment d'una de màxima categoria (0)
   pop pop  %% eliminem la jerarquia i el diccionari de la bookmark
  }ifelse 
 }ifelse

 userdict /araPstream known not
 {  %% el document no duu cap element tipogràfic que coincideixi amb la categoria màxima?
 (\n\n ... >>> l'estil jerarquic del perfil tipografic de maxima categoria no ha estat localitzat ... pleguem!\n\n)
 print flush stop  %%quit
 }if
%%(:-jjjj)pstack quit

 %% aquí bastim bboxBindexDpagina
 bookmarksXstream
 iDpQtMdP  %% l'índex té més d'1 pàgina?
 {
  SUARAaraPstream
 }
 {
  araPstream
 }ifelse
 known
 {  %% ampliem l'array amb la nova bookmark relacionada
  bookmarksXstream
  iDpQtMdP  %% l'índex té més d'1 pàgina?
  {
   SUARAaraPstream
  }
  {
   araPstream
  }ifelse
  get dup length dup /Ava exch def 1 add array dup 3 -1 roll
  0 exch putinterval dup Ava CLAUbboxBindexDpagina put
  bookmarksXstream exch
  iDpQtMdP  %% l'índex té més d'1 pàgina?
  {
   SUARAaraPstream
  }
  {
   araPstream
  }ifelse
  exch put
 }
 {  %% generem la nova clau d'stream i l'array de bookmarks relacionades
  bookmarksXstream araPstream [CLAUbboxBindexDpagina] put
 }ifelse
}for  %% on generem els fitxers amb el codi PDF de l'índex de contingut de pàgina
      %% per a inserir-los més tard com a nous streams d'objectes-pàgina

%%ProblemaDD
%%paginesDindex {== ==}forall
%%bookmarksXstream {== ==}forall
%%(:-P)pstack quit

%ARAdex closefile  %% tanquem el darrer fitxer stream generat
 %% escrivim la cua de l'stream de pàgina i tanquem el fitxer
 ARAdex (ET\012Q\012) writestring

%% tirem totes les línies de la pàgina
ARAdex (q 1 J .5 w [2]2 d\012) writestring
mapaDlinies
{  %% forall per totes les linies a pintar dins la pàgina
 dup 0 2 getinterval
 {  %% forall
  128 string cvs ARAdex exch writestring
  ARAdex 32 write
 }forall
 ARAdex (m ) writestring
 2 2 getinterval
 {
  128 string cvs ARAdex exch writestring
  ARAdex 32 write
 }forall
 ARAdex (l S ) writestring
 pop  %% eliminem la clau
}forall
ARAdex dup (\012Q\012) writestring closefile
/mapaDlinies 2 dict def  %% coordenades moveto lineto de totes les línies puntejades
(cua8)==

%% evitem la generació d'una pàgina en blanc quan l'índex s'acaba just a la darrera línia
%% de text possible a compondre ... ho sabem demanant si hem escrit res
HEMescrit not
{
paginesDindex suaraOiP get dup length 1 sub 0 exch getinterval
paginesDindex exch suaraOiP exch put
}if

%%(:-Y)pstack quit
}if %% generem l'índex amb pàgines? 

}if  %/12 arbre jeràrquic
%% fi de Simsi: projecte Polynorma


%% per veure les caracteristiques dels tipus de la plana
%CalaixDeTipus /1 get {== ==}forall (:-Z)pstack quit
%% per veure el xifrat dels tipus de la plana
%Champollion /1 get {== ==}forall
%% per veure +encara
%yRENGS /1 get {== ==}forall
%(SOMvius)== quit

%%ClavaLinies (:-Z)pstack quit
%% Mishima: l'anàlisi dels paràgrafs

QueLiFemFer 4 eq  %:04 ANÀLISI TEXTUAL
QueLiFemFer 16 eq  %:16 cerca i substitució de text
or
{  %#%35bis1% repiquem el mapa d'exportació de vincles al txt, segons convencions ...
 (%#%35bis1%)==
 %%{  % stopped

/FarceixRdT
{
%false{  %% desactivem aquest algorisme ara?
%%AQUÍ és on detectem si cal una redistribució de l'ordre de lectura pel posicionament no seqüencial de caràcters dins el codi
   dup 0 get /adpdcc exch def  %% pesquem l'array de posicions de cada caràcter/glif
   dup 1 get /Lglifs exch def  %% pesquem l'array de literals dels glifs extrets
   /girigall adpdcc length array def  %% array de glifs endreçats per ordre de lectura (d'esquerra a dreta)
   /endreça
   {
    %% endreça una seqüència numèrica existent a l'stack de menys a més (operador ge) o de més a menys (operador le)
    %% a comptar des de la base de l'stack
    {  %% loop mentre estiguin desordenats
     counttomark 1 sub /iCul exch def
     %% escombrat d'ordenació
     iCul
     {  %% repeat
      iCul index /araCul exch def
      iCul 1 sub index araCul le  %% le fa de més a menys
      {
       iCul 1 sub /iCul exch def
      }
      {
       iCul -1 roll
       iCul 1 add 1 roll
      }ifelse
     }repeat
     %% mirem si estan per ordre de menys a més (ge)
     %% o de més a menys (le), començant pel cul de l'stack
     /Ordenats true def
     counttomark 1 sub /iCul exch def
     iCul
     {  %% repeat
      iCul index /araCul exch def
      iCul 1 sub index araCul le  %% le fa de més a menys
      {
       iCul 1 sub /iCul exch def
      }
      {
       /Ordenats false def
       exit
      }ifelse
     }repeat
     Ordenats{exit}if
    }loop
    %% detectem si cal una redistribució de l'ordre de lectura pel posicionament no seqüencial de caràcters dins el codi
    {  %% loop
     dup mark eq
     {  %% sortim
      pop exit
     }
     {
      /onVAS exch def  %% orígen X del glif
      0 1 adpdcc length 1 sub
      {  %% for
       dup adpdcc exch get dup null eq
       {
        pop pop
       }
       {
        0 get onVAS eq
        {  %% tenim l'índex del glif dins la seqüència del codi
         Lglifs exch get  %% treiem el glif
         girigall exch iGibberish exch put  %% el posicionem a l'array amb criteri d'ordre de lectura
        }
        {
         pop
        }ifelse
       }ifelse
      }for
      iGibberish 1 add /iGibberish exch def  %% comptador d'índex d'ordre de lectura
     }ifelse
    }loop
   }bind def
   %% si hi ha nulls, l'ordenació es duu a terme en cada cas amb els glifs d'entre els nulls
   /iGibberish 0 def  %% posició dins de girigall
   /suaraNULL true def  %% valor inicial del gatell per activar l'ordenació
   adpdcc
   {  %% forall
    dup null eq
    {  %% no cal posar el null a girigall perquè ja hi és
     pop  %% girigall iGibberish null put
     suaraNULL not
     {  %% aquí ordenem
      endreça
     }if
     /suaraNULL true def
     iGibberish 1 add /iGibberish exch def  %% comptador d'índex d'ordre de lectura
    }
    {
     suaraNULL
     {
      mark exch  %% posem la mark per poder ordenar
      /suaraNULL false def
     }if
     0 get  %% deixem a l'stack l'orígen X de posició de cada glif
    }ifelse
   }forall  %% per l'array de posicions de cada caràcter/glif
   %% si sortits del forall suaraNULL és false, vol dir que queda una ordenació pendent
   suaraNULL not
   {
    endreça 
   }if
   girigall Lglifs
   %% comparem dues arrays, element x element (veure ComparArrays.ps)
   /aComp exch def
   /iDeNTiQueS true def  %% gatell x saber si son identiques
   /iaComp 0 def
   {  %% forall
    aComp iaComp get eq   %% juguem amb la igualtat exacte
    {
     iaComp 1 add /iaComp exch def
    }
    {  %% aquí es confirma que l'ordre de lectura del codi vs render, ha canviat
     /iDeNTiQueS false def
%% >>> cal que ens mirem l'algorisme de refer línies del Torsimany!!!
%% doncs hauriem de filtrar altra cop via suaraKern per elminiar possibles nulls sobrers
%% o detectar paraules que apareixen trencades (un null entremig) però que comparteixen la darrera cadena d'ordre de lectura
     exit
    }ifelse
   }forall
%%FI de la redistribució de l'ordre de lectura pel posicionament no seqüencial de caràcters dins el codi
%}if /iDeNTiQueS true def  %% desactivem aquest algorisme ara?

%%++
   dup 5 get /araOC exch def
   1 index /cooY exch def  %% ara x MASATS hi afegim la clau de la coordenada Y per detectar les dades precises del text

   torsimany{Frengs(  [\015\012)writestring}if  %% obrimm el paquet que ens marca 1 linia de text
   %% detectem si el reng es girat x activar les correccions de l'eix corresponents
   dup 4 get dup null eq
   {
    pop /renGirat false def
   }
   {
    dup 0 eq{pop /renGirat false def}{/giReng exch def /renGirat true def}ifelse
   }ifelse
   dup 1 get  %% extraiem l'array de noms de signes
   %%% ara mateix el raonament del filtre per les referències de JBC és:
   %%% un mot entre minMot (mínim 1!) i maxMot signes de qualsevol mena, on s'exclouen només
   %%% l'espai en blanc (/space) i el 'null' doncs aquí actuen com a separador de mot, només
   %%% ens quedaria el dubte de comptar el guió com a signe a descomptar en el recompte
   %%% d'aquest màxim de # (això es problemàtic doncs de guions hi ha: hyphen, minus, endash)

   %% destriaNULLs.ps
   %% extrau els elements d'una array separats per 1 o + null i/o 1 o + /space
   %% segons el filtre establert per ...
   %%maxMot  % llargaria maxima del mot sospitos
   %%minMot  % llargaria minima del mot sospitos
   %% ... i q emmagatzemem a MotSeguit
   /araRai exch def
   /MotSeguit 0 def  %% sumador de signes que formen el mot
   /iMot 0 def  %% index d'inici del mot
   araRai length 1 sub 1 exch 0 3 1 roll
   {  %% for
    %% test: ON PETA PER dup ???
    %%iMot 0 eq {(:-/)pstack Frengs dup flushfile closefile quit}if  %%% CAL CONTROLAR si AIXO PETA
    dup /nMot exch def  %% index transitori
    araRai exch get
    %% elements q actuen de separadors de mots (null i /space)
    dup null eq
    exch /space eq
    or
    {
     %% filtrem segons llargaria ...
     MotSeguit minMot ge  %% minima
     MotSeguit maxMot le  %% maxima
     and
     {
      %% extraiem el mot
      araRai iMot MotSeguit getinterval

%% :-F
%% aquí és on avaluem excepcions com la proposada per JBC de les referències començades per
%% N.P.0123456 on 'N.P.' s'enganxa a la referència i no s'extrau per excés dels 7 caràcters
%% ara el màxim hauria de ser 11 i hauríem de corregir l'array de literals i iMot i MotSeguit
%% aquesta anàlisi s'ha de repetir pel darrer algorisme del 'darrer mot'
dup length 5 ge{  %% ha de tenir com a minim 5 caràcters!
dup 0 get /N eq
{
 dup 1 get /period eq
 {
  dup 2 get /P eq
  {
   dup 3 get /period eq
   {
dup length 4 sub 4 exch getinterval  %% eliminem el prefix N.P. enganxat a la possible referència
%% rectifiquem el valor iMot sumant 4 a l'índex
iMot 4 add /iMot exch def
%% rectifiquem el valor de MotSeguit restant 4 al nombre de caràcters
MotSeguit 4 sub /MotSeguit exch def
%(:-F)pstack quit
   }if
  }if
 }if
}if
}if

%%dup length array copy  %?
      %%==  % treiem l'array x la pantalleta
      Frengs ( \() writestring  %% inici de la cadena mot      
      %% repiquem els noms dels signes a la seva representacio escrita (codi ascii/WinAnsi)
      %% atencio: aqui pressuposem q ja som nets de nulls
      %% segons la taula d_WAE (Win Ansi Encoding)
%(:-###)pstack quit
      {  %% forall
       d_WAE
       1 index known
       {
        %% protegim l'string contra obrir/tancar parentesi q la fan petar
        dup /parenright eq
        {
         %% escrivim el signe tancar parentesi protegit xq no peti dins l'string
         pop Frengs

%% blindem per doble doncs si fem el torsimany hem de reescriure rengsDtext.txt
torsimany{(\\\\\\\)) writestring}{

          (\\\)) writestring

}ifelse

        }
        {
         dup /parenleft eq
         {
          %% escrivim el signe d'obrir parentesi protegit xq no peti dins l'string
          pop Frengs

%% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
torsimany{(\\\\\\\() writestring}{

          (\\\() writestring

}ifelse

         }
         {
          dup /backslash eq
          {  %% escrivim el signe protegit per que no peti dins l'string  %% (:-11)
           pop Frengs

%% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
torsimany{(\\\\\\\\) writestring}{

           (\\\\) writestring

}ifelse

          }
          {
           d_WAE exch get
           Frengs exch write  %% escrivim el signe
          }ifelse
         }ifelse
        }ifelse
       }
       {
        %% si no existeix fem una substitucio adaptada per mitja del diccionari SOFIglyphs
        SOFIglyphs 1 index known
        {
         SOFIglyphs exch get
         Frengs exch writestring  %% escrivim el signe
        }
        {  %% si no existeix ara hi posem un espai en blanc i la practica continuada
           %% ja ens orientara de com implementar el signe conflictiu de forma adequada
         == ( ... signe conflictiu ... l'exportem en blanc!)==
         Frengs 32 write  %% escrivim el signe d'espai en blanc!
        }ifelse
       }ifelse
      }forall
      Frengs (\) [) writestring  %% final de la cadena del mot i obrim l'array de posicions del mot
      dup 3 get
      %% aqui es on plora la criatura
      iMot MotSeguit getinterval
      %% desem el cos del primer signe del mot a extraure per mesurar la Yll Yur del BBox
      0 get /CosBBox exch def
      dup
      0 get  %% treiem la taula de posicions i escribim el Bbox
      dup
      %% aqui es on plora la criatura
      iMot MotSeguit getinterval
      0 get  %% array de posicions XX del signe d'inici dins l'interval actual
      %%% idem de cap al pap?
      %%(:-)pstack quit
      renGirat
      {  %% escrivim les 4 coordenades corregides del rectangle doncs les necessitem pels QuadPoints
       gsave
       %% rotem l'eix giReng fent primer un translate al punt d'inici del caracter
       [
        giReng 0 lt
        {  %% si l'angle es negatiu ...
         giReng cos neg giReng sin neg giReng sin giReng cos neg 
         6 -1 roll 2 2 getinterval aload pop
         %% si no ho es, redefinim en negatiu el cos pel bbox (l'angle negatiu obliga!)
         CosBBox 0 ge {CosBBox neg /CosBBox exch def}if
        }
        {  %% si l'angle es positiu ...
         giReng cos giReng sin giReng sin neg giReng cos 
         6 -1 roll 2 2 getinterval aload pop
        }ifelse
       ] dup /6concaT exch def  %% fem una copia del paquet de rotacio
       concat  %% fa un translate i un rotate (per aquest ordre!)
       %% l'X a zero i nomes juga l'Y per calcular el primer punt del rectangle xyUL
       0 CosBBox 75 mul 100 div  %% calculem l'ascendent des de la linia de base, un 75% del cos
       matrix currentmatrix  %% valor de la matriu rotada
       grestore
       transform  %% ens dona les coordenades del punt (amb l'eix normal) en unitats del dispositiu de sortida (device pixels)
       itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
       %% aqui tenim la nova coordenada x,y transformada a l'espai sense rotar del primer punt del rectangle xyUL
       exch Frengs exch 256 string cvs writestring  %% escrivim la X
       Frengs 32 write  %% espai en blanc
       Frengs exch 256 string cvs writestring  %% escrivim la Y
       Frengs 32 write  %% espai en blanc
       gsave
       6concaT
       concat  %% fa un translate i un rotate (per aquest ordre!)
       %% l'X a zero i nomes juga l'Y per calcular el segon punt del rectangle xyLL
       0 CosBBox 20 mul 100 div neg  %% calculem el descendent des de la linia de base, un 20% del cos en negatiu
       matrix currentmatrix  %% valor de la matriu rotada
       grestore
       transform  %% ens dona les coordenades del punt (amb l'eix normal) en unitats del dispositiu de sortida (device pixels)
       itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
%%grestore
       %% aqui tenim la nova coordenada x,y transformada a l'espai sense rotar del segon punt del rectangle xyLL
       exch Frengs exch 256 string cvs writestring  %% escrivim la X
       Frengs 32 write  %% espai en blanc
       Frengs exch 256 string cvs writestring  %% escrivim la Y
       Frengs 32 write  %% espai en blanc
       %% aqui es on plora la criatura
       iMot MotSeguit getinterval
       dup length 1 sub cvi  %% index de les posicions del darrer signe
       get  %% posicions XX del signe final
       4 2 getinterval
       6concaT dup 3 -1 roll 4 exch putinterval
       dup /6concaT exch def  %% fem una copia del paquet de rotacio
       gsave
       concat  %% fa un translate i un rotate (per aquest ordre!)
       %% l'X a zero i nomes juga l'Y per calcular el tercer punt del rectangle xyLR
       0 CosBBox 20 mul 100 div neg  %% calculem el descendent des de la linia de base, un 20% del cos en negatiu
       matrix currentmatrix  %% valor de la matriu rotada
       grestore
       transform  %% ens dona les coordenades del punt (amb l'eix normal) en unitats del dispositiu de sortida (device pixels)
       itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
       %% aqui tenim la nova coordenada x,y transformada a l'espai sense rotar del tercer punt del rectangle xyLR
       exch Frengs exch 256 string cvs writestring  %% escrivim la X
       Frengs 32 write  %% espai en blanc
       Frengs exch 256 string cvs writestring  %% escrivim la Y
       Frengs 32 write  %% espai en blanc
       gsave
       6concaT concat  %% fa un translate i un rotate (per aquest ordre!)
       %% l'X a zero i nomes juga l'Y per calcular el quart i darrer punt del rectangle xyUR
       0 CosBBox 75 mul 100 div  %% calculem l'ascendent des de la linia de base, un 75% del cos
       matrix currentmatrix  %% valor de la matriu rotada
       grestore
       transform  %% ens dona les coordenades del punt (amb l'eix normal) en unitats del dispositiu de sortida (device pixels)
       itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
       %%grestore
       %% aqui la nova coordenada x,y transformada a l'espai sense rotar del quart i darrer punt del rectangle xyUR
       exch Frengs exch 256 string cvs writestring  %% escrivim la X
       Frengs 32 write  %% espai en blanc
       Frengs exch 256 string cvs writestring  %% escrivim la Y
       Frengs 32 write  %% espai en blanc
       %%pop  % ens carreguem el literal unic
       %%(:-?)pstack quit
      }
      {  %% escriurem les 4 coordenades sense corregir (aqui el text no es rotat!) del rectangle
       %% aqui escrivim la coordenada x,y del primer punt del rectangle xyUL
       dup dup 2 get  %% inici X
       Frengs exch 256 string cvs writestring  %% escrivim la coordenada x del primer punt xUL
       Frengs 32 write  %% espai en blanc
       %% calculem el 75% del cos x sumar-li i mesurar l'ascendent Yur
       3 get  %% inici Y
       CosBBox 75 mul 100 div add 256 string cvs
       Frengs exch writestring  %% escrivim la coordenada y del primer punt yUL
       Frengs 32 write  %% espai en blanc
       %% aqui escrivim la coordenada x,y del segon punt del rectangle xyLL
       dup 2 get  %% inici X
       Frengs exch 256 string cvs writestring  %% escrivim la coordenada x del segon punt xLL
       Frengs 32 write  %% espai en blanc
       3 get  %% inici Y
       %% calculem el 20% del cos x restar-li i mesurar el descendent Yll
       CosBBox 20 mul 100 div sub
       Frengs exch 256 string cvs writestring  %% escrivim la coordenada y del segon punt yLL
       Frengs 32 write  %% espai en blanc
       %% aqui es on plora la criatura
       iMot MotSeguit getinterval
       dup length 1 sub cvi  %% index de les posicions del darrer signe
       get  %% posicions XX del signe final
       %% aqui escrivim la coordenada x,y del tercer punt del rectangle xyLR
       dup dup 4 get  %% final X
       Frengs exch 256 string cvs writestring  %% escrivim la coordenada x del tercer punt xLR
       Frengs 32 write  %% espai en blanc
       5 get  %% final Y
       %% calculem el 20% del cos x restar-li i mesurar el descendent Yll
       CosBBox 20 mul 100 div sub
       Frengs exch 256 string cvs writestring  %% escrivim la coordenada y del tercer punt yLR
       Frengs 32 write  %% espai en blanc
       %% aqui escrivim la coordenada x,y del quart i darrer punt del rectangle xyUR
       dup 4 get  %% final X
       Frengs exch 256 string cvs writestring  %% escrivim la coordenada x del quart punt xUR
       Frengs 32 write  %% espai en blanc
       5 get  %% final Y
       CosBBox 75 mul 100 div add 256 string cvs
       Frengs exch writestring  %% escrivim la coordenada y del quart punt yUR
       Frengs 32 write  %% espai en blanc
       %%pop  % ens carreguem el literal unic
       %%(:-!)pstack quit
      }ifelse
      %% fi d'idem de cap al pap?

      Frengs(\(\) /) writestring
      Frengs cooY
%(ja és un literal enter!)pstack quit
%      cvi  %% EP!MASATS treballarem només amb l'enter (a yRENGS també) per no tenir problemes amb la variabilitat decimal
      128 string cvs writestring  %% MASATS: hi afegim la clau de la coordenada Y per lligar amb yRENGS
      iDeNTiQueS  %% cal una redistribució de l'ordre de lectura?
      {  %% MASATS: afegim un darrer paràmetre que serà null si no hi ha canvis en l'ordre de lectura...
       Frengs ( null) writestring
      }
      {  %% ...però si n'hi han, reescrivim la cadena de text decodificada
       girigall  %% array amb la nova redistribució de l'ordre de lectura 
       Frengs ( \() writestring  %% inici de la cadena mot      
       %% repiquem els noms dels signes a la seva representacio escrita (codi ascii/WinAnsi)
       %% atencio: aqui pressuposem q ja som nets de nulls
       %% segons la taula d_WAE (Win Ansi Encoding)
       {  %% forall
        dup null eq
        {
         pop
        }
        {
         d_WAE
         1 index known
         {
          %% protegim l'string contra obrir/tancar parentesi q la fan petar
          dup /parenright eq
          {
           %% escrivim el signe tancar parentesi protegit xq no peti dins l'string
           pop Frengs
           %% blindem per doble doncs si fem el torsimany hem de reescriure rengsDtext.txt
           torsimany
           {
            (\\\\\\\)) writestring
           }
           {
            (\\\)) writestring
           }ifelse
          }
          {
           dup /parenleft eq
           {
            %% escrivim el signe d'obrir parentesi protegit xq no peti dins l'string
            pop Frengs
            %% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
            torsimany
            {
             (\\\\\\\() writestring
            }
            {
             (\\\() writestring
            }ifelse
           }
           {
            dup /backslash eq
            {  %% escrivim el signe protegit per que no peti dins l'string  %% (:-11)
             pop Frengs
             %% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
             torsimany
             {
              (\\\\\\\\) writestring
             }
             {
              (\\\\) writestring
             }ifelse
            }
            {
             d_WAE exch get
             Frengs exch write  %% escrivim el signe
            }ifelse
           }ifelse
          }ifelse
         }
         {
          %% si no existeix fem una substitucio adaptada per mitja del diccionari SOFIglyphs
          SOFIglyphs 1 index known
          {
           SOFIglyphs exch get
           Frengs exch writestring  %% escrivim el signe
          }
          {  %% si no existeix ara hi posem un espai en blanc i la practica continuada
             %% ja ens orientara de com implementar el signe conflictiu de forma adequada
           == ( ... signe conflictiu ... l'exportem en blanc!)==
           Frengs 32 write  %% escrivim el signe d'espai en blanc!
          }ifelse
         }ifelse
        }ifelse
       }forall
       Frengs (\)) writestring  %% final de la cadena del mot
%% (:-G)pstack quit
      }ifelse

%%++
%% aquí pot anar-hi el nom de l'OC
Frengs dup ( /) writestring araOC 128 string cvs writestring

      Frengs (]\015\012)writestring  %% string (buida) amb la possible adreça del vincle), tancament de l'array de posicions del mot
     }if
     /MotSeguit 0 def  %% inicialitzem el sumador
     nMot 1 add /iMot exch def  %% inicialitzem l'index dinici del mot
    }
    {
     MotSeguit 1 add /MotSeguit exch def  %% sumem signes del mot
    }ifelse
   }for

%% iMot MotSeguit(::::::)pstack quit
%% /gatellNP false def
   %% cap al pap?
   %% llista el darrer mot que hagi pogut quedar!
   mark
   %% filtrem segons llargaria ...
   MotSeguit minMot ge  %% minima
   MotSeguit maxMot le  %% maxima
   and
   {
    %% extraiem el mot
    araRai iMot MotSeguit getinterval

%% aquí és on avaluem excepcions com la proposada per JBC de les referències començades per
%% N.P.0123456 on 'N.P.' s'enganxa a la referència i no s'extrau per excés dels 7 caràcters
%% ara el màxim hauria de ser 11 i hauríem de corregir l'array de literals i iMot i MotSeguit
%% aquesta anàlisi s'ha de repetir pel darrer algorisme del 'darrer mot'
dup length 5 ge{  %% ha de tenir com a minim 5 caràcters!
dup 0 get /N eq
{
 dup 1 get /period eq
 {
  dup 2 get /P eq
  {
   dup 3 get /period eq
   {
dup length 4 sub 4 exch getinterval  %% eliminem el prefix N.P. enganxat a la possible referència
%% rectifiquem el valor iMot sumant 4 a l'índex
iMot 4 add /iMot exch def
%% rectifiquem el valor de MotSeguit restant 4 al nombre de caràcters
MotSeguit 4 sub /MotSeguit exch def
%% /gatellNP true def
%% (:-f)pstack quit
   }if
  }if
 }if
}if
}if

%%dup length array copy  %?
    %%==  % treiem l'array x la pantalleta
   }if

   %% fi destriaNULLs.ps
   counttomark 1 eq
   {
    Frengs ( \() writestring  %% inici de la cadena mot      
    %% repiquem els noms dels signes a la seva representacio escrita (codi ascii/WinAnsi)
    %% atencio: aqui pressuposem q ja som nets de nulls
    %% segons la taula d_WAE (Win Ansi Encoding)
%(:-#)pstack quit
    {  %% forall
     d_WAE
     1 index known
     {
      %% protegim l'string contra obrir/tancar parentesi q la fan petar
      dup /parenright eq
      {
       pop Frengs

%% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
torsimany{(\\\\\\\)) writestring}{

       (\\\)) writestring  %% escrivim el signe tancar parentesi protegit xq no peti dins l'string

}ifelse

      }
      {
       dup /parenleft eq
       {
        pop Frengs

%% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
torsimany{(\\\\\\\() writestring}{

        (\\\() writestring  %% escrivim el signe d'obrir parentesi protegit xq no peti dins l'string

}ifelse

       }
       {
        dup /backslash eq
        {  %% escrivim el signe protegit per que no peti dins l'string  %% (:-11)
         pop Frengs

%% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
torsimany{(\\\\\\\\) writestring}{

         (\\\\) writestring

}ifelse

        }
        {
         d_WAE exch get
         Frengs exch write  %% escrivim el signe
        }ifelse
       }ifelse
      }ifelse
     }
     {
      %% si no existeix fem una substitucio adaptada per mitja del diccionari SOFIglyphs
      SOFIglyphs 1 index known
      {
       SOFIglyphs exch get
       Frengs exch writestring  %% escrivim el signe
      }
      {  %% si no existeix ara hi posem un espai en blanc i la practica continuada aj ens orientara de com implementar el signe conflictiu de forma adequada
       == ( ... signe conflictiu ... l'exportem en blanc!)==
       Frengs 32 write  %% escrivim el signe d'espai en blanc!
      }ifelse
     }ifelse
    }forall
    pop  %% ens carreguem la mark
    Frengs (\) [) writestring  %% final de la cadena del mot i obrim l'array de posicions del mot
    dup 3 get


    %% aqui es on plora la criatura
    iMot MotSeguit getinterval
    0 get /CosBBox exch def  %% desem el cos del primer signe del mot a extraure per mesurar la Yll Yur del BBox
    0 get  %% treiem la taula de posicions i escribim el Bbox
%%dup length array copy  %?
    dup
    %% aqui es on plora la criatura
    iMot MotSeguit getinterval
    0 get  %% array de posicions XX del signe d'inici dins l'interval actual
%%2 get  % inici Xll
    renGirat
    {  %% escriurem les 4 coordenades corregides del rectangle doncs les necessitarem sobretot pels QuadPoints
     gsave
     %% rotem l'eix giReng fent primer un translate al punt d'inici del caracter
     [
      giReng 0 lt
      {  %% si l'angle es negatiu ...
       giReng cos neg giReng sin neg giReng sin giReng cos neg 
       6 -1 roll 2 2 getinterval aload pop
       %% si no ho es, redefinim en negatiu el cos pel bbox (l'angle negatiu obliga!)
       CosBBox 0 ge {CosBBox neg /CosBBox exch def}if
      }
      {  %% si l'angle es positiu ...
       giReng cos giReng sin giReng sin neg giReng cos 
       6 -1 roll 2 2 getinterval aload pop
      }ifelse
     ] dup /6concaT exch def  %% fem una copia del paquet de rotacio
     concat  %% fa un translate i un rotate (per aquest ordre!)
     %% l'X a zero i nomes juga l'Y per calcular el primer punt del rectangle xyUL
     0 CosBBox 75 mul 100 div  %% calculem l'ascendent des de la linia de base, un 75% del cos
     matrix currentmatrix  %% valor de la matriu rotada
     grestore
     transform  %% ens dona les coordenades del punt (amb l'eix normal) en unitats del dispositiu de sortida (device pixels)
     itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
     %%grestore
     %% aqui tenim la nova coordenada x,y transformada a l'espai sense rotar del primer punt del rectangle xyUL
     exch Frengs exch 256 string cvs writestring  %% escrivim la X
     Frengs 32 write  %% espai en blanc
     Frengs exch 256 string cvs writestring  %% escrivim la Y
     Frengs 32 write  %% espai en blanc
     gsave
     6concaT
     concat  %% fa un translate i un rotate (per aquest ordre!)
     %% l'X a zero i nomes juga l'Y per calcular el segon punt del rectangle xyLL
     0 CosBBox 20 mul 100 div neg  %% calculem el descendent des de la linia de base, un 20% del cos en negatiu
     matrix currentmatrix  %% valor de la matriu rotada
     grestore
     transform  %% ens dona les coordenades del punt (amb l'eix normal) en unitats del dispositiu de sortida (device pixels)
     itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
     %%grestore
     %% aqui tenim la nova coordenada x,y transformada a l'espai sense rotar del segon punt del rectangle xyLL
     exch Frengs exch 256 string cvs writestring  %% escrivim la X
     Frengs 32 write  %% espai en blanc
     Frengs exch 256 string cvs writestring  %% escrivim la Y
     Frengs 32 write  %% espai en blanc
     %% aqui es on plora la criatura
     iMot MotSeguit getinterval
     dup length 1 sub cvi  %% index de les posicions del darrer signe
     %%(:->) pstack quit
     get  %% posicions XX del signe final
     4 2 getinterval
     6concaT dup 3 -1 roll 4 exch putinterval
     dup /6concaT exch def  %% fem una copia del paquet de rotacio
     gsave
     concat  %% fa un translate i un rotate (per aquest ordre!)
     %% l'X a zero i nomes juga l'Y per calcular el tercer punt del rectangle xyLR
     0 CosBBox 20 mul 100 div neg  %% calculem el descendent des de la linia de base, un 20% del cos en negatiu
     matrix currentmatrix  %% valor de la matriu rotada
     grestore
     transform  %% ens dona les coordenades del punt (amb l'eix normal) en unitats del dispositiu de sortida (device pixels)
     itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
     %%grestore
     %% aqui tenim la nova coordenada x,y transformada a l'espai sense rotar del tercer punt del rectangle xyLR
     exch Frengs exch 256 string cvs writestring  %% escrivim la X
     Frengs 32 write  %% espai en blanc
     Frengs exch 256 string cvs writestring  %% escrivim la Y
     Frengs 32 write  %% espai en blanc
     gsave
     6concaT concat  %% fa un translate i un rotate (per aquest ordre!)
     %% l'X a zero i nomes juga l'Y per calcular el quart i darrer punt del rectangle xyUR
     0 CosBBox 75 mul 100 div  %% calculem l'ascendent des de la linia de base, un 75% del cos
     matrix currentmatrix  %% valor de la matriu rotada
     grestore
     transform  %% ens dona les coordenades del punt (amb l'eix normal) en unitats del dispositiu de sortida (device pixels)
     itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
     %%grestore
     %% aqui la nova coordenada x,y transformada a l'espai sense rotar del quart i darrer punt del rectangle xyUR
     exch Frengs exch 256 string cvs writestring  %% escrivim la X
     Frengs 32 write  %% espai en blanc
     Frengs exch 256 string cvs writestring  %% escrivim la Y
     Frengs 32 write  %% espai en blanc
     pop  %% ens carreguem el literal unic
     %%(:-?)pstack quit
    }
    {  %% escriurem les 4 coordenades sense corregir (aqui el text no es rotat!) del rectangle
     %% aqui escrivim la coordenada x,y del primer punt del rectangle xyUL
     dup dup 2 get  %% inici X
     Frengs exch 256 string cvs writestring  %% escrivim la coordenada x del primer punt xUL
     Frengs 32 write  %% espai en blanc
     %% calculem el 75% del cos x sumar-li i mesurar l'ascendent Yur
     3 get  %% inici Y
     CosBBox 75 mul 100 div add 256 string cvs
     Frengs exch writestring  %% escrivim la coordenada y del primer punt yUL
     Frengs 32 write  %% espai en blanc
     %% aqui escrivim la coordenada x,y del segon punt del rectangle xyLL
     dup 2 get  %% inici X
     Frengs exch 256 string cvs writestring  %% escrivim la coordenada x del segon punt xLL
     Frengs 32 write  %% espai en blanc
     3 get  %% inici Y
     %% calculem el 20% del cos x restar-li i mesurar el descendent Yll
     CosBBox 20 mul 100 div sub
     Frengs exch 256 string cvs writestring  %% escrivim la coordenada y del segon punt yLL
     Frengs 32 write  %% espai en blanc
     %% aqui es on plora la criatura
     iMot MotSeguit getinterval
     dup length 1 sub cvi  %% index de les posicions del darrer signe
     get  %% posicions XX del signe final
     %% aqui escrivim la coordenada x,y del tercer punt del rectangle xyLR
     dup dup 4 get  %% final X
     Frengs exch 256 string cvs writestring  %% escrivim la coordenada x del tercer punt xLR
     Frengs 32 write  %% espai en blanc
     5 get  %% final Y
     %% calculem el 20% del cos x restar-li i mesurar el descendent Yll
     CosBBox 20 mul 100 div sub
     Frengs exch 256 string cvs writestring  %% escrivim la coordenada y del tercer punt yLR
     Frengs 32 write  %% espai en blanc
     %% aqui escrivim la coordenada x,y del quart i darrer punt del rectangle xyUR
     dup 4 get  %% final X
     Frengs exch 256 string cvs writestring  %% escrivim la coordenada x del quart punt xUR
     Frengs 32 write  %% espai en blanc
     5 get  %% final Y
     CosBBox 75 mul 100 div add 256 string cvs
     Frengs exch writestring  %% escrivim la coordenada y del quart punt yUR
     Frengs 32 write  %% espai en blanc
     pop  %% ens carreguem el literal unic
     %%(:-!)pstack quit
    }ifelse

    Frengs(\(\) /)writestring
    Frengs cooY
%(ja és un literal enter!)pstack quit
%    cvi  %% EP!MASATS treballarem només amb l'enter (a yRENGS també) per no tenir problemes amb la variabilitat decimal
    128 string cvs writestring  %% MASATS: afegim la clau de la coordenada Y per lligar amb yRENGS
    iDeNTiQueS  %% cal una redistribució de l'ordre de lectura?
    {  %% MASATS: afegim un darrer paràmetre que serà null si no hi ha canvis en l'ordre de lectura...
     Frengs ( null) writestring
    }
    {  %% ...però si n'hi han, reescrivim la cadena de text decodificada
     girigall      
     Frengs ( \() writestring  %% inici de la cadena mot      
     %% repiquem els noms dels signes a la seva representacio escrita (codi ascii/WinAnsi)
     %% atencio: aqui pressuposem q ja som nets de nulls
     %% segons la taula d_WAE (Win Ansi Encoding)
     {  %% forall
      dup null eq
      {
       pop
      }
      {
       d_WAE
       1 index known
       {
        %% protegim l'string contra obrir/tancar parentesi q la fan petar
        dup /parenright eq
        {
         %% escrivim el signe tancar parentesi protegit xq no peti dins l'string
         pop Frengs
         %% blindem per doble doncs si fem el torsimany hem de reescriure rengsDtext.txt
         torsimany
         {
          (\\\\\\\)) writestring
         }
         {
          (\\\)) writestring
         }ifelse
        }
        {
         dup /parenleft eq
         {
          %% escrivim el signe d'obrir parentesi protegit xq no peti dins l'string
          pop Frengs
          %% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
          torsimany
          {
           (\\\\\\\() writestring
          }
          {
           (\\\() writestring
          }ifelse
         }
         {
          dup /backslash eq
          {  %% escrivim el signe protegit per que no peti dins l'string  %% (:-11)
           pop Frengs
           %% blindem per doble, doncs si fem el torsimany hem de reescriure rengsDtext.txt
           torsimany
           {
            (\\\\\\\\) writestring
           }
           {
            (\\\\) writestring
           }ifelse
          }
          {
           d_WAE exch get
           Frengs exch write  %% escrivim el signe
          }ifelse
         }ifelse
        }ifelse
       }
       {
        %% si no existeix fem una substitucio adaptada per mitja del diccionari SOFIglyphs
        SOFIglyphs 1 index known
        {
         SOFIglyphs exch get
         Frengs exch writestring  %% escrivim el signe
        }
        {  %% si no existeix ara hi posem un espai en blanc i la practica continuada
           %% ja ens orientara de com implementar el signe conflictiu de forma adequada
         == ( ... signe conflictiu ... l'exportem en blanc!)==
         Frengs 32 write  %% escrivim el signe d'espai en blanc!
        }ifelse
       }ifelse
      }ifelse
     }forall
     Frengs (\)) writestring  %% final de la cadena del mot
%% (:-g)pstack quit
    }ifelse

%%++
%% aquí pot anar-hi el nom de l'OC
Frengs dup ( /) writestring araOC 128 string cvs writestring

    Frengs(]\015\012)writestring  %% string (buida) amb la possible adreça del vincle, tancament de l'array de posicions del mot
   }
   {
    pop  %% ens carreguem la mark
   }ifelse
   %% cal ser + elegants esborrant els parells Ylinia array?
   count dup 0 eq {pop}{{pop}repeat}ifelse
%%(:-O)pstack Frengs dup flushfile closefile quit  %%% CAL CONTROLAR si AIXO PETA

%% (:-Z)
torsimany{Frengs(  ]\015\012)writestring}if  %% tanquem el paquet que ens marca 1 linia de text

}bind def

 rengsDtext  %% path i nom del fitxer dels rengs de text fruit de l'analisi de sortida
 (w) file /Frengs exch def  %% creem el fitxer a disc
 %% formatem un identat minim i retorns de carro durs, per facilitar la lectura del TXT a l'usuari
 Frengs ([\015\012 [\015\012) writestring  %% obrim el fitxer i la primera plana
 /iPln 1 def  %% index de plana pels dic que componen l'array
 {  %% loop per totes les planes del document
  yRENGS iPln 6 string cvs get

%dup /trepiTjats undef
%{== ==}forall(somVIUS)pstack quit

  {  %% forall on buidem, analitzem i escrivim tot el q ens cal dels rengs de text

%%Tret que a la pàgina hi hagi un dic /trepiTjats doncs llavors ho haurem de fer a cadascuna de les arrays
%%De cadascuna de les entrades de reng que hi hagi
%1 index /trepiTjats eq
%{
%(SOMvius)pstack quit
%}if

%%++
%% aquí hi havia l'inici del codi definit a /FarceixRdT

 1 index /trepiTjats eq
 {  %% duu /trepiTjats
  {  %% forall del dic
   exch /laY exch def
   {  %% forall de les arrays
    laY exch  %% x la clau
    FarceixRdT
   }forall
  }forall
 }
 {  %% la plana no duu /trepiTjats
  FarceixRdT
 }ifelse


%%++
%% aquí hi havia el final del codi definit a /FarceixRdT

%% gatellNP
%% {
%% rectifiquem el valor iMot sumant 4 a l'índex
%% iMot 4 sub /iMot exch def
%% rectifiquem el valor de MotSeguit restant 4 al nombre de caràcters
%% MotSeguit 4 add /MotSeguit exch def
%% /gatellNP false def
%% }if

  }forall  %% on buidem, analitzem i escrivim tot el q ens cal dels rengs de text

  iPln 1 add dup maxPlana gt
  {
   pop exit
  }
  {
   /iPln exch def
   Frengs ( ]\015\012 [\015\012) writestring  %% tanquem i obrim plana
  }ifelse
 }loop  %% per totes les planes del document

 Frengs dup ( ]\015\012]\015\012) writestring closefile  %% tanquem plana i fitxer

 torsimany  %% si fem torsimany
 {
%%Analitzem novament rengsDtext per unificar totes les paraules d'una línia
  %% i més endavant haurem de crear un analitzador de paràgrafs
  %% creem un fitxer de traducció intermig per fer l'anàlisi de rengsDtext
  rengsDtext dup length dup 1 add string dup 3 -1 roll 95 put  %% hi afegim un guió baix
  dup 3 -1 roll 0 exch putinterval /torsimanyDtext exch def
  torsimanyDtext (w) file /trsmny exch def
  rengsDtext (r) file cvx exec  %% posem a l'stack l'array de tota l'extracció de text
  trsmny ([\015\012)writestring  %% inici de document
  {  %% forall per pàgina
   trsmny ( [\015\012)writestring  %% inici de pàgina
   {  %% forall per línia
    %% muntem l'array amb els quatre xamfrans del rectangle que inscriu la línia
    dup dup length 1 sub  %% index de l'array de coordenades del darrer mot de la línia
    dup 0 gt  %% és una array plena?
    {
     get 4 4 getinterval /xDL exch def  %% extraiem les coordenades dels dos xamfrans de la dreta de la línia
     dup 1 get 0 4 getinterval /xEL exch def  %% extraiem les coordenades dels dos xamfrans de l'esquerra de la línia
     trsmny (  \()writestring  %% inici de línia
     {  %% forall per escriure el text de la línia i l'array de xamfrans
      dup type /stringtype eq
      {
       trsmny exch writestring  %% el mot
       trsmny 32 write  %% espai en blanc
      }
      {
       pop  %% ens carreguem l'array de posicions
      }ifelse
     }forall  %% per escriure el text i l'array de xamfrans de la línia
     trsmny dup (\) [) writestring
     xEL {1 index exch 256 string cvs writestring dup 32 write}forall
     xDL {1 index exch 256 string cvs writestring dup 32 write}forall
     %% hem afegit un darrer element de control de la línia de text (false)
     %% que ens indicarà si aquesta línia haurà estat traduïda (true) o no (false)
     %% dins l'interrogació que farem a LINIESTRADUiDES
     (null false]\015\012)writestring  %% final de línia
    }
    {  %% és una array buida
     pop pop pop
    }ifelse
   }forall  %% per línia
   trsmny ( ]\015\012)writestring  %% final de pàgina
  }forall  %% per pàgina
  trsmny (]\015\012)writestring  %% final de document
  trsmny closefile

  %% aquí és on hauríem de posar el futur analitzador de paràgrafs

  %% eliminem rengsDtext ...
  rengsDtext deletefile
  %% ... i renombrem torsimanyDtext com a rengsDtext
  torsimanyDtext rengsDtext renamefile
 }if

 torsimany  %% només si treballem pel traductor
 {
  %% llegim el fitxer rengsDtext.txt per extrauren només les cadenes a traduïr
  %% fins a la quantitat màxima que ens permet una sola crida del traductor de Google via URL
  %% extraurengsdetext.ps

  %% aquest fitxer el llegirà el PHP per muntar la URL que cridarà l'API de Google translator
  %% l'afegirem al mateix directori
  rengsDtext
  {  %% loop
   bUsca search
   {
    pop pop
   }
   {
    exit
   }ifelse
  }loop
  rengsDtext exch search pop exch pop exch pop
  %% extret el directori hi inserim el nou txt
  dup length (torsimanyentrada.txt) dup length 3 -1 roll add
  string dup 4 -1 roll dup length /VAa exch def 0 exch putinterval
  dup 3 -1 roll VAa exch putinterval
  (w) file /Te exch def

  /cMots 0 def  %% comptador de mots
  /maxURLmots 50 def  %% màxim de mots admesos per a cada crida via URL amb el blindat <span>
  %% aquest nombre màxim fa que si no hem exhaurit completament la línia --o sigui que no
  %% coincideixi amb el darrer mot--, aquesta quedarà completament eliminada del procés de traducció

  rengsDtext (r) file
  cvx exec
  {  %% forall on explorem l'array de cada plana i a tot el text extret del document
   Te (<span class=notranslate>[</span>)writestring  %% obrim l'array de pàgina (hem d'etiquetar [ per tal que sigui estable pel traductor de Google)
   /aPlana exch def
   0 2 aPlana length 1 sub  %% seqüència d'índex parells on hi han les cadenes de text
   {  %% for per pàgina
    aPlana exch get
%%% eeeeep el comptamots petaaaaa!!!!
    dup
    %% a l'stack tenim la cadena a avaluar
    %% comptem els mots a 'grosso modo' detectant l'espai en blanc (32)
    {  %% forall
     32 eq {cMots 1 add /cMots exch def}if
    }forall

%% el mètode de l'operador token, tal com està, fa petar algunes cadenes i el desestimem
%%    {  %% loop comptador
%%     token
%%     {
%%      pop cMots 1 add /cMots exch def
%%     }
%%     {
%%      exit
%%     } ifelse
%%    } loop

    %% hem assolit el màxim de mots admesos?
    cMots maxURLmots gt
    {
     exit
    }
    {  %% reescrivim una cadena al costat de l'altre preparades pel traductor
     Te (<span class=notranslate>\(</span>)writestring  %% només l'etiquetat el fa estable!
     Te exch writestring
     Te (<span class=notranslate>\)</span>)writestring
    }ifelse
   }for
   Te (<span class=notranslate>]</span>)writestring  %% tanquem l'array de pàgina (hem d'etiquetar ] per tal que sigui estable pel traductor de Google)
  }forall
  %% cMots(:-F)pstack quit
 }if  %% treballem pel traductor?

%%}stopped {exch {== ==}forall(:-X)pstack Frengs dup flushfile closefile quit}if
}if  %/16 cerca i substitució de text
     %/04 ANÀLISI TEXTUAL


QueLiFemFer 16 eq  %:16 cerca i substitució de text
{
%%MASATStext
 %%yCursivesMentideres 1 get {pop ==}forall (*********)== quit
 %% primer
 %% desem les Y úniques +dades dels mots trobats a treure (sempre xifrats en ISO-8859-1), dins l'objecte...
 /motsTrobatsAtreure [null] def
 %% la seva estructura serà:
 %% [  %% array de pàgines
 %%  null  %% 0
 %%  <<  %% 1 diccionari per pàgina
 %%    (moTrobatAtreure)
 %%    <<
 %%      /aFicar
 %%      [
 %%       (motAficar)  %% cadena del/s mot/s a ficar
 %%       0  %% flag de justificat
 %%      ]
 %%      /####  %% clau de la coordenada Y que ens enllaça amb yRENGS
 %%      [  %% cops que s'ha trobat dins una mateixa Y
 %%       true  %% és un fragment
 %%       false  %% mot sencer (no és un fragment)
 %%      ]
 %%    >>
 %%  >>
 %% ]
 rengsDtext (r) file cvx exec /_rengsDtext exch def
 /faremTREUiFICA
 [
  null  %% la zero no compta i ens serveix per detectar si és buida
 ]def  %% array paginat amb els diccionaris on desarem les clau/valor definitives a treure i ficar com: /motAtreure null

 FICAiTREU
 {  %% forall per a cadascun dels mots a cercar especificats a l'opció Fbis5
  /aqps 0 def  %% a quina pàgina hi ha el moTrobatAtreure
  dup 2 get /gJ exch def  %% gatell de justificat
  dup 1 get /mAf exch def  %% mot a ficar
  0 get  /mAt exch def  %% mot a treure
  %% ens caldrà saber si és un sol mot o en són diversos
  mAt ( ) search
  {  %% en són diversos, i avisem que només en cerquem el primer
   /mAt exch def pop pop  %% mot a cercar
   (\n :::MASATS::: cercarem només ... )print flush mAt print flush ( ... i deixarem la resta de mots x+endavant\n)print flush
  }
  {  %% un sol mot
   /mAt exch def  %% mot a cercar
   (\n :::MASATS::: cerquem ... )print flush mAt print flush (\n)print flush
  }ifelse
  _rengsDtext
  /NOtrobat true def
  /CmAt 0 def  %% comptador de vegades que hem trobat el mot
  {  %% forall per cadascuna de les pàgines del pdf
   aqps 1 add /aqps exch def  %% índex de pàgina
   dup /araP exch def length  %% array de mots trobats per l'extractor
   0 2 3 -1 roll 1 sub
   {  %% for per totes les cadenes de text extretes
    /imAt exch def
    araP imAt get mAt search
    {  %% trobat
     %% avisem a quina hem trobat mAt
     (\n :::MASATS::: HEM trobat... )print flush mAt print flush
     ( ...a la pàgina: ) print flush aqps 6 string cvs print flush
( ...a la capa: ) print flush araP imAt 1 add get 11 get 128 string cvs print flush  %% llistem la clau /OC
     (\n)print flush
     /esFragment1 false def
     /esFragment2 false def
     length 0 ne
     {
      /esFragment1 true def
     }if
     exch
     length 0 ne
     {
      /esFragment2 true def
     }if
     esFragment1 esFragment2 or /esFragment exch def  %% gatell per saber si és o no un fragment d'un mot
     /moTrobatAtreure exch def
     /NOtrobat false def
     %% cal desar el mot trobat a l'objecte /motsTrobatsAtreure que ens el lligarà amb la yRENGS
     motsTrobatsAtreure length aqps le
     {  %% el diccionari de pàgina NO existeix
      aqps 1 add array dup 0 motsTrobatsAtreure putinterval dup
      aqps
      <<
        moTrobatAtreure
        <<
          /aFicar
          [
           mAf   %% mot a ficar
           gJ  %% gatell  justificat
          ]
araP imAt 1 add get 11 get  %% pesquem la clau /OC que ens discriminarà mots per capes (molt útil x idèntics en capes diferents)
<<  %% un diccionari per capa /OC

          araP imAt 1 add get 9 get  %% pesquem la clau d'yRENGS de l'array associada del /moTrobatAtreure
          [
           esFragment
          ]
        >>
>>
      >> put  %% el fiquem a l'array /motsTrobatsAtreure
      /motsTrobatsAtreure exch def  %% desem
     }
     {  %% el diccionari de pàgina existeix
      motsTrobatsAtreure aqps get
      dup dup moTrobatAtreure known
      {  %% el mot trobat a treure ja existeix dins el diccionari de pàgina
       dup moTrobatAtreure get
%%Consultem a quina capa pertany dins rengsDtext.txt i podrem destriar-ho gràcies a la plana aqps-1 i l'índex imAt+1
dup
_rengsDtext aqps 1 sub get imAt 1 add get 11 get 2 copy
known  %% ja exiteix la clau d'OC al dic del /moTrobatAtreure?
{  %% si
 dup /araOC exch def  %% desem el literal de la capa
 get  %% extraiem el dic de la capa

 true
}
{  %% no

 %% la clau /OC que ens discriminarà mots per capes (molt útil x idèntics en capes diferents)
 <<  %% un diccionari per capa /OC
   araP imAt 1 add get 9 get  %% pesquem la clau d'yRENGS de l'array associada del /moTrobatAtreure
   [
    esFragment
   ]
 >>

 false
}ifelse

%% interroguem el dic de la clau /OC per saber si exiteix la clau d'yRENGS?
{ %% si
       dup araP imAt 1 add get 9 get known  %% ja exiteix la clau d'yRENGS dins el dic de la capa /araOC?
       {  %% si existeix, vol dir que el mot es repeteix dins la mateixa línia de composició
        dup dup araP imAt 1 add get 9 get get  %% cerquem l'array de cops que s'ha trobat dins una mateixa Y
        dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
        dup araVa esFragment put  %% llavors només ampliem l'array amb el valor de esFragment
        araP imAt 1 add get 9 get exch put  %% redesem l'entrada dins el diccionari de la capa /araOC
1 index exch  %% fem una còpia del diccionari d'araOC per conservar-lo a l'stack
araOC exch put %% aquí redesem /araOC i el seu dic dins el diccionari del moTrobatAtreure
        moTrobatAtreure exch put  %% redesem dins el diccionari de pàgina
        motsTrobatsAtreure exch aqps exch put  %% redesem dins l'array motsTrobatsAtreure
       }
       {  %% si no existeix, vol dir que el mot NO es repeteix dins la mateixa línia de composició
        %% desem la nova clau d'yRENGS dins el diccionari de la capa /araOC
        dup araP imAt 1 add get 9 get [ esFragment ] put
1 index exch  %% fem una còpia del diccionari del mot trobat a treure
araOC exch put %% aquí redesem /araOC i el seu dic dins el diccionari del moTrobatAtreure
        moTrobatAtreure exch put  %% desem el diccionari amploiat de moTrobatAtreure dins el diccionari de pàgina
        motsTrobatsAtreure exch aqps exch put  %% redesem dins l'array motsTrobatsAtreure
       }ifelse
}
{  %% no
 put  %% desem el dic de la capa /araOC dins el dic del mot trobat a treure
 moTrobatAtreure exch put  %% redesem dins el diccionari de pàgina
 motsTrobatsAtreure exch aqps exch put  %% redesem dins l'array motsTrobatsAtreure
}ifelse


      }
      {  %% el mot trobat a treure NO existeix dins el diccionari de pàgina
       moTrobatAtreure
       <<
         /aFicar
         [
          mAf   %% mot a ficar
          gJ  %% gatell  justificat
         ]
araP imAt 1 add get 11 get  %% pesquem la clau /OC que ens discriminarà mots per capes (molt útil x idèntics en capes diferents)
<<  %% un diccionari per capa /OC
         araP imAt 1 add get 9 get  %% pesquem la clau d'yRENGS de l'array associada del /moTrobatAtreure
         [
          esFragment
         ]
>>
       >>
       put  %% desem dins el diccionari de pàgina
       motsTrobatsAtreure exch aqps exch put  %% el fiquem a l'array /motsTrobatsAtreure
      }ifelse

     }ifelse
     %% cal avisar si el trobem més d'un cop i si alguna de les vegades és només un fragment
     CmAt 1 add /CmAt exch def
     /aQpHtM aqps def  %% desem a quina pàgina hem trobat el mot
    }
    {  %% no l'hem trobat
     pop
    }ifelse
   }for  %% per totes les cadenes de text extretes
  }forall  %% per cadascuna de les pàgines del pdf

  %% hem trobat el mot?
  NOtrobat
  {  %% avisem si no trobem el mot
   (\n :::MASATS::: NO hem trobat ... )print flush mAt print flush (\n)print flush
  }
  {  %% si trobem el mot, filtrem si l'hem trobat +d'1 cop i si és un fragment
   %% la qual cosa condicionarà els límits d'aquest algorisme que es restringirà a només mots sencers trobats 1 sol cop
   CmAt 1 eq
   {  %% l'hem trobat només 1 vegada
    esFragment not  %% NO és un fragment d'un mot més llarg o NO hi ha més mots separats per espais?
    {  %% desem només el mots a treure que siguin sencers i trobats 1 sol cop
     faremTREUiFICA length aQpHtM le
%% hem d'ampliar l'array i crear el diccionari
     {  %% NO tenim el diccionari i hem d'ampliar l'array
      aQpHtM 1 add array dup  %% creem la nova array capacitada per aQpHtM
      0 faremTREUiFICA putinterval  %% la fusionem com la teníem
      /faremTREUiFICA exch def  %% redesem
      %% desem a l'array paginat el diccionari on desem la clau/valor vàlida del mot a treure i ficar
      faremTREUiFICA dup aQpHtM 1 dict dup moTrobatAtreure null put put
      /faremTREUiFICA exch def  %% l'hem de tornar a desar, doncs el composite object no dóna l'abast
     }
     {  %% ja tenim el diccionari
      faremTREUiFICA aQpHtM get dup moTrobatAtreure null put  %% desem la clau/valor vàlida del mot a treure i ficar
      faremTREUiFICA exch aQpHtM exch put  %% desem a l'array paginat el diccionari
     }ifelse

    }if  %% desem només el mots a treure que siguin sencers i trobats 1 sol cop
   }if  %% descartem si l'hem trobat més d'1 cop
  }ifelse

 }forall  %% per cadascun els mots a cercar especificats a l'opció Fbis5

 %% informem de quins mots treurem i ficarem finalment
 (\n\n :::MASATS::: MOTS TROBATS QUE SERAN PROCESSATS:\n)print flush
 faremTREUiFICA dup length 1 eq
 {  %% només hi hauria el null
  pop
  (\n :::MASATS::: NO HI HA cap mot a processar !\n) print flush

  %% com que no hi ha cap mot a processar, si en trobem a motsTrobatsAtreure, llistarem el perquè
/iP 0 def  %% índex i núm. de pàgines
motsTrobatsAtreure
{  %% forall x totes les pàgines
 dup null eq
 {
  pop
 }
 {
  (\n pàg. )print flush iP 6 string cvs print flush (\n)print flush
  {  %% forall x tots els mots
   exch 256 string cvs print flush
/+d1Capa 0 def  %% gatell per saber, de moment, si és a més d'1 capa (+endavant pot servir per saber si l'acceptem)
   {  %% forall per explorar si hi ha repeticions i si és fragmentat
    exch /aFicar eq
    {  %% no interessa
      pop
    }
    {
     dup length /rEp exch def
{  %% forall de dins el dic de la capa
     dup length 1 sub rEp add /rEp exch def  %% sumador de repeticions
     {  %% forall el mot és fragmentat?
      {
       /esFragment true def
      }if
     }forall  %% el mot és fragmentat?
     pop   %% eliminem la clau de la posició Y
}forall
+d1Capa 1 add /+d1Capa exch def
    }ifelse
   }forall  %% per explorar si hi ha repeticions i si és fragmentat
   esFragment
   {
    ( ...és un mot fragmentat )print flush
   }if
   rEp 1 gt
   {
    ( ...ha estat trobat: )print flush
    rEp 6 string cvs print flush
    ( cops)print flush
   }if
   +d1Capa 1 gt
   {
    ( ...en +d'1 capa)print flush
   }if
   (\n)print flush
   
  }forall  %% x tots els mots
 }ifelse
 iP 1 add /iP exch def
}forall  %% x totes les pàgines

%yRENGS /1 get {== ==}forall
  (\n:::MASATS::: ATUREM LA FEINA\n\n)print flush stop
 }
 {
/iP 0 def  %% índex i núm. de pàgines
  {  %% forall per totes les pàgines
   dup null eq
   {
    pop
   }
   {
    (\n pàg. )print flush iP 6 string cvs print flush (\n)print flush
    {  %% forall per tots els mots trobats que processarem
     pop  /treUrem exch def
     1 1 motsTrobatsAtreure length 1 sub
     {  %% for per tots els dicionaris de pàgina
      motsTrobatsAtreure exch get
      dup null eq
      {
       pop
      }
      {
       dup treUrem known  %% hi ha el mot a processar?
       {
        (\n :::MASATS::: treurem... )print flush
        treUrem 256 string cvs print flush
        ( ...hi ficarem... )print flush
        treUrem get /aFicar get 0 get print flush
        (\n)print flush
       }
       {
        pop  %% ens carreguem el diccionari de pàgina
       }ifelse
      }ifelse
     }for  %% per tots els dicionaris de pàgina
    }forall  %% tots els mots trobats que processarem
   }ifelse
   iP 1 add /iP exch def
  }forall  %% per totes les pàgines

  %% quan almenys n'hem trobat 1 per processar, informem de quins mots trobats no processarem i el perquè
  /iNSP 0 def
  (\n\n :::MASATS::: mots trobats que NO SERAN PROCESSATS:\n)print flush
  1 1 motsTrobatsAtreure length 1 sub
  {  %% for per tots els diccionaris de pàgina
   dup /iP exch def
   motsTrobatsAtreure exch get dup null eq
   {
    pop
   }
   {

    {  %% forall per tots els mots trobats de la pàgina
     /esFragment false def
     faremTREUiFICA 2 index /mNSP exch def
%%     {  %% forall per totes les pàgines de l'array de mots definitius faremTREUiFICA

dup length iP lt   %% filtrem, doncs faremTREUiFICA pot no tenir el total de pàgines
{
 pop pop pop
}
{

iP get
      dup null eq
      {
       pop
pop pop
      }
      {
       mNSP known  %% hi ha el mot a processar?
       {
        pop pop  %% en carreguem nom i diccionari del mot
       }
       {  %% no serà processat
        (\n :::MASATS::: )print flush
        exch 256 string cvs print flush
/+d1Capa 0 def  %% gatell per saber, de moment, si és a més d'1 capa (+endavant pot servir per saber si l'acceptem)
%        dup length 1 sub /rEp exch def
        {  %% forall per explorar si hi ha repeticions i si és fragmentat
         exch /aFicar eq
         {  %% no interessa
          pop
         }
         {
dup length /rEp exch def
{  %% forall de dins el dic de la capa
          dup length 1 sub rEp add /rEp exch def  %% sumador de repeticions
          {  %% el mot és fragmentat?
           {
            /esFragment true def
           }if
          }forall
          pop   %% eliminem la clau de la posició Y
}forall
+d1Capa 1 add /+d1Capa exch def
         }ifelse
        }forall  %% per explorar si hi ha repeticions i si és fragmentat
        esFragment
        {
         ( ...és un mot fragmentat )print flush
        }if
        rEp 1 gt
        {
         ( ...ha estat trobat: )print flush
         rEp 6 string cvs print flush
         ( cops)print flush
        }if
   +d1Capa 1 gt
   {
    ( ...en +d'1 capa)print flush
   }if
        (\n)print flush
        iNSP 1 add /iNSP exch def
       }ifelse
      }ifelse

}ifelse

%%     }forall  %% per totes les pàgines

    }forall  %% per tots els mots trobats

   }ifelse
  }for  %% per tots els dicionaris de pàgina
  iNSP 0 eq
  {
   (\n :::MASATS::: TOTS els mots trobats seran processats\n)print flush 
  }if
 }ifelse

%(arasomaqui)pstack quit
%motsTrobatsAtreure 1 get {{== ==}forall ==}forall
%faremTREUiFICA % length == % {== ==}forall

%Champollion /1 get{== ==}forall(:-##)pstack quit
%%MASATStext fem un algorisme sui generis per deduïr de forma pràctica si les tipografies del document tenen glifs suficients
 %% o amples suficients per considerar que s'hi pot treballar sense risc (poder compondre més text en cas de reutilitzar-les)
 %% malgrat les convencions que la PDF Ref. ens dóna per deduir-ho (i mai 100% segur):
 %%   As discussed in Section 5.5.3, Font Subsets, an embedded font program may
 %%   contain only the subset of glyphs that are used in the PDF document. This may be
 %%   indicated by the presence of a CharSet or CIDSet entry in the font descriptor that
 %%   refers to the font file, although subset fonts are not always so identified.
%%A les fonts CID millorarem el filtre incorporant CIDSet quan hi sigui, doncs és clau per encertar l'encoding a Champollion
%%A les fonts Type1 CharSet ens podrà complementar la dada de quins glifs hi han
 %% nosaltres ens guiarem per l'Encoding net i planxat que reconstruïm per a cada font i pàgina del document a Champollion
 %% de forma que fixarem una quantitat mínima de glifs, ara 140, per sentenciar si els textos de l'esmentada font tenen risc
 %% o no de ser editats, i amb l'ajut de CalaixDeTipus sabrem si a l'array de Widths s'hi han definit prous amples i també
 %% el nom PS, les fonts amb risc les desarem a fontsDrisc amb tres possibles combinacions per a l'índex 1 de l'array de valor:
 %% /nomPDF [/nomPS 0] ... font amb només risc d'amples (la mètrica Widths no té prous amples definits pel nombre de glifs)
 %% /nomPDF [/nomPS 1] ... font amb només risc de glifs
 %% /nomPDF [/nomPS 2] ... font amb risc d'amples i de glifs
 %% en realitat podríem optimitzar aquest loop a només dues possibilitats: sense risc o amb risc (de glifs i/o d'amples)
 /fontsDrisc <<>> def  %% aquest diccionari també ha d'anar paginat!
 (\n\n :::MASATS::: FACTOR DE RISC D'EDICIÓ DE LES TIPOGRAFIES DEL DOCUMENT:\n)print flush
 /iPg 1 def  %% comptador de pàgines
 /minGlif 140 def  %% quantitat mínima de glifs per activar el risc d'edició i el llindar per activar l'inclusió d'un nou tipus
 {  %% loop
  iPg 6 string cvs /araPg exch def
  Champollion araPg known
  {
   (\n pàg. )print flush araPg print flush (\n)print flush
   %%(\n ...a la pàgina: ) print flush araPg print flush (\n)print flush
   Champollion araPg get
   {  %% forall
    %% per aquest recompte per ser exactes podriem aplicar tècniques diverses:
    %% o ponderar entre el FirstChar i LastChar, en cas d'existir aquestes entrades (mètode precís)
    %% o activar un comptador de glifs diferents de /.notdef a l'encoding net i planxat (precís si treballa amb Identity-H)
    %% o comptant a l'array d'amples de mètrica totes les entrades que no siguin zero (mètode precís)
    /cGlifs 0 def  %% comptador de glifs via codificat
    /cGlifs2 0 def  %% comptador de glifs via mètrica

    {  %% forall per activar el comptador de glifs diferents de /.notdef
     /.notdef ne
     {
      cGlifs 1 add /cGlifs exch def
     }if
    }forall

    dup CalaixDeTipus araPg get exch get 2 get  %% anem a pescar l'array d'amples del tipus
    {  %% forall per activar el comptador de glifs diferents de zero 
     0 ne
     {
      cGlifs2 1 add /cGlifs2 exch def
     }if
    }forall

    cGlifs minGlif ge
    {  %% podem editar sense riscos (joc de caràcters suficient)
     dup CalaixDeTipus araPg get exch get dup 0 get print flush  %% llistem el nom PS de la font sense risc
     ( ... sense risc de glifs \()print flush cGlifs 6 string cvs print flush ( glifs\) )print flush
     % 2 get length
     pop cGlifs2
     dup minGlif lt  %% hi ha risc d'amples?
     {
      ( ... AMB RISC de mètrica \()print flush 6 string cvs print flush ( widths\)\n)print flush
      CalaixDeTipus araPg get 1 index get 0 get 0 2 array astore  %% array amb la combinació de risc només mètrica
      fontsDrisc araPg known
      {  %% hi ha la pàgina
       fontsDrisc araPg get dup 4 -1 roll 4 -1 roll put fontsDrisc exch araPg exch put
      }
      {  %% NO hi ha la pàgina
       1 dict dup 4 -1 roll 4 -1 roll put fontsDrisc exch araPg exch put
      }ifelse
     }
     {
      ( ... sense risc de mètrica \()print flush 6 string cvs print flush ( widths\)\n)print flush
      pop
     }ifelse
    }
    {  %% hi ha risc d'edició (segur que hi manquen glifs)
     dup CalaixDeTipus araPg get exch get dup 0 get print flush  %% llistem el nom PS de la font sense risc
     ( ... AMB RISC de glifs \()print flush cGlifs 6 string cvs print flush ( glifs\) )print flush
     % 2 get length
     pop cGlifs2
     dup minGlif lt  %% hi ha risc d'amples?
     {
      ( ... AMB RISC de mètrica \()print flush 6 string cvs print flush ( widths\)\n)print flush
      CalaixDeTipus araPg get 1 index get 0 get 2 2 array astore  %% array amb la combinació de risc de glifs + mètrica
      fontsDrisc araPg known
      {  %% hi ha la pàgina
       fontsDrisc araPg get dup 4 -1 roll 4 -1 roll put fontsDrisc exch araPg exch put
      }
      {  %% NO hi ha la pàgina
       1 dict dup 4 -1 roll 4 -1 roll put fontsDrisc exch araPg exch put
      }ifelse
     }
     {
      ( ... sense risc de mètrica \()print flush 6 string cvs print flush ( widths\)\n)print flush
      CalaixDeTipus araPg get 1 index get 0 get 1 2 array astore  %% array amb la combinació de risc només glifs
      fontsDrisc araPg known
      {  %% hi ha la pàgina
       fontsDrisc araPg get dup 4 -1 roll 4 -1 roll put fontsDrisc exch araPg exch put
      }
      {  %% NO hi ha la pàgina
       1 dict dup 4 -1 roll 4 -1 roll put fontsDrisc exch araPg exch put
      }ifelse
     }ifelse

    }ifelse
   }forall
  }if
  iPg 1 add /iPg exch def
  iPg maxPlana gt
  {  %% sortim del loop xq ja hem exhaurit les pàgines
   (\n)print flush
   exit
  }if
 }loop

 %(999999)== quit
 %% Llistem tots els mots del document
 %rengsDtext (r) file cvx exec
 %{
 % dup /laPg exch def length 1 sub 0 exch 2 exch
 % {
 %  laPg exch get ==
 % }for
 %}forall
%yRENGS /1 get {== ==}forall
%CalaixDeTipus /1 get
%{0 get == ==}forall

%% ara /RISCaFORASTERES l'hem definit ben amunt

 faremTREUiFICA length 1 ne  %% si fos 1 només hi hauria el null inicial de creació
 {  %% si hi ha mots a treure i ficar
  %% al diccionari de l'índex de pàgina que toqui:
  %% desarem com a clau només els noms PDF de les fonts usades (valor de RISCaFORASTERES) i com a valor l'objecte /Font
  /afegeixFont [null] def
  %% muntem el diccionari TREUiFICAfinal, manat x yRENGS, amb els elements necessaris per fer la cerca i la substitució de text
  %% tot i que ara no hi ha paginació com a paràmetre de cerca, al no admetre mots repetits, haurem de saber a quina pàgina som
  /TREUiFICAfinal
  [
   null  %% l'índex zero és per començar a la pàgina 1
  ] def
  /iP 0 def  %% índex de pàgina
  faremTREUiFICA
  {  %% forall per l'array de pàgines
   dup null eq
   {
    pop
   }
   {
    {  %% forall dels mots de la pàgina a desar a TREUiFICAfinal
     pop 128 string cvs /HIva exch def  %% desem el mot a treure i passem el literal a cadena
     _rengsDtext iP 1 sub get  %% treiem l'array de dades de pàgina de rengsDtext
     {  %% forall per tots els parells dels mots extrets en cadenes de text i el seus arrays de dades
      dup type /stringtype eq
      {
       HIva eq
       {
        /HOes true def
       }
       {
        /HOes false def
       }ifelse
      }
      {  %% actuem sobre l'array de dades del mot extret
       HOes
       {
        9 get /ARAyRENG exch def  %% pesquem el valor Y

%%Desem el parell ARAyRENG/array de dades dins el diccionari per pàgina de l'array TREUiFICAfinal

        TREUiFICAfinal length iP le
        {  %% hem d'ampliar l'array i crear el diccionari
         iP 1 add array dup 0 TREUiFICAfinal putinterval /TREUiFICAfinal exch def
         /araTF <<>> def
        }
        {  %% el diccionari ja existeix
         TREUiFICAfinal iP get /araTF exch def
        }ifelse

        araTF
        ARAyRENG
        %% al literal li filtrem _ per deixar només el valor de Y en les claus de textos girats (són el detector per Tm)
        128 string cvs (_) search
        {  %% hi ha _
         exch pop exch pop
        }if

%%Ens cal saber si la Y ja existeix
araTF 1 index known
{
 araTF 1 index get dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval  %% ampliem l'array 
 dup araVa
%%(HHHHHH)pstack quit
}
{  %% NO
 [ null ] dup
 0
}ifelse

        %% on l'array té aquesta estructura
        [
         HIva  %% índex 0 cadena de text a treure

         FICAiTREU
         {  %% forall
          dup 0 get HIva eq
          {
           dup 1 get  %% índex 1 cadena de text a ficar
           exch 2 get  %% índex 2 justificat del text a ficar
           exit
          }
          {
           pop
          }ifelse
         }forall

         yRENGS iP 6 string cvs get
         %% no hi pot haver dues línies idèntiques en una pàgina però si en dues o + pàgines (però això ja ve filtrat)
         ARAyRENG get /araRaY exch def
         /HIhaRISC false def
         araRaY 1 get
         {  %% forall
%%Determinant per la fragmentació de mots?
          dup null eq exch /space eq or
          %% null eq
          {  %% si hi ha null o /space...
           /HIhaRISC true def
           exit  %% vol dir que hi ha 2 mots o més a la mateixa línia, però no ens assegura que l'operador els tracti plegats
          }if
         }forall
         %% índex 3 risc de trobar d'altres mots a la mateixa línia? (llavors hauríem de treballar les X?) true=si false=no
         HIhaRISC
 %% índex 4 nom PDF de la font (original o forastera)
         araRaY 2 get
%%VAL LA PENA QUE FILTREM SI HI POT HAVER CANVIS DE FONT EN UNA SOLA LÍNIA?
%%SI FESSIM AIXÒ HAURIA DE SER ABANS DESXIFRANT A LITERALS EL MOT A TREURE/FICAR
         {  %% forall
          dup null eq
          {
           pop
          }
          {  %% deixem el primer nom PDF de la font original que trobem
           %% si un mot estigués fet per lletres de fonts diferents aquest mètode no seria vàlid
           exit
          }ifelse
         }forall
         %% avaluem si la font original del pdf és a la llista de les fonts de risc i per quina serà substituida si es dóna el cas
         /fontO true def  %% mantenim la font original?
         fontsDrisc dup length 0 eq  %% si aquest diccionari estigués a zero, no hi hauria cap font de risc
         {
          pop false
         }
         {
          iP 6 string cvs get 1 index known  %% a la pàgina que toca!
         }ifelse
         {  %% si és una font de risc...
          fontsDrisc iP 6 string cvs get exch get 0 get
          (+) search  %% filtrem el possible signe + amb prefix de 6 lletres (cap amb + pot estar fora de risc?)
          {
           pop pop
          }if
%%Aquí podríem activar un segon search per detectar derivades familiars (Helvetica) (Arial) (Times) etc ...ja ho farem si cal
          RISCaFORASTERES 1 index known  %% per extraure el nom net de la tipografia i cercar-la a RISCaFORASTERES 
          {  %% la substituim pel seu equivalent idèntic de font forastera amb nous objectes
           dup print flush ( ... pel risc que suposa editar aquesta font, n'incrustarem una d'idèntica\n\n)print flush
           RISCaFORASTERES exch get
           %% emmagatzemem el literal del nom PDF de la font (a la plana que toca) per afegir els nous objectes Font
           dup afegeixFont length iP le  %% existeix el diccionari de pàgina?
           {  %% NO
            iP 1 add array dup 0 afegeixFont putinterval /afegeixFont exch def  %% ampliem l'array
            1 dict dup 3 -1 roll null put afegeixFont iP 3 -1 roll put  %% i creem el diccionari desant de nou
           }
           {  %% SI que existeix
            afegeixFont iP get dup 3 -1 roll null put afegeixFont iP 3 -1 roll put  %% afegim al diccionari desant de nou
           }ifelse
          }
          {  %% i si no hi és hi fiquem una Courier forastera amb nous objectes
           print flush ( ... pel risc que suposa editar aquesta font, el nou text s'editarà en Courier\n\n)print flush  /fMSTS0
           %% emmagatzemem el literal del nom PDF de la font (a la plana que toca) per afegir els nous objectes Font
           dup afegeixFont length iP le  %% existeix el diccionari de pàgina?
           {  %% NO
            iP 1 add array dup 0 afegeixFont putinterval /afegeixFont exch def  %% ampliem l'array
            1 dict dup 3 -1 roll null put afegeixFont iP 3 -1 roll put  %% i creem el diccionari desant de nou
           }
           {  %% SI que existeix
            afegeixFont iP get dup 3 -1 roll null put afegeixFont iP 3 -1 roll put  %% afegim al diccionari desant de nou
           }ifelse
          }ifelse
          /fontO false def
         }if

         %% índex 5 font original o forastera? true=original false=forastera 
         fontO

         %% índex 6 doble octet? true=si false=no
         fontO
         {  %% doble octet? true=si false=no
          CalaixDeTipus iP 6 string cvs get 2 index get 3 get
         }
         {  %% les forasteres no les tractarem, de moment, en doble octet
          false
         }ifelse
        ] put  %% fiquem dins l'array de possibles Y idèntiques
        put  %% fiquem dins el diccionari de pàgina araTF
        %% posem al seu lloc el diccionari per pàgina dins l'array TREUiFICAfinal
        /TREUiFICAfinal TREUiFICAfinal dup iP araTF put def
       }
       {
        pop
       }ifelse
      }ifelse
     }forall  %% per tots els parells de mots extrets en cadenes de text i el seus arrays de dades
    }forall  %% dels mots de la pàgina a desar a TREUiFICAfinal
   }ifelse
   iP 1 add /iP exch def
  }forall  %% per l'array de pàgines de faremTREUiFICA

 }if  %% si hi ha mots a treure i ficar

%% recordem l'estructura dels principals diccionaris que utilitza el gatell 16:

%% FICAiTREU ... és l'array de menú de l'opció 16 amb l'estructura:
%% [ (TEXTaTROBAR) (TEXTaFICAR) #gatellDjustificat ]

%% TREUiFICAfinal ... és una array paginada de diccionaris amb l'estructura:
%% /#Yreng 
%% [  %% ens permet poder ficar/treure textos que comparteixin una mateixa Y
%%  [ (TEXTaTREURE) (TEXTaFICAR) #Justificat AltresMotsALaMateixaLínia? /nomFontPDF originalOforastera Unicode? ]
%% ]

%% motsTrobatsAtreure ... és una array paginada de diccionaris amb l'estructura:
%% [
%%  null  %% 0
%%  <<  %% 1 diccionari per pàgina
%%    (moTrobatAtreure)
%%    <<
%%      /aFicar
%%      [
%%       (motAficar)  %% cadena del/s mot/s a ficar
%%       0  %% flag de justificat
%%      ]
%%      /####  %% clau de la coordenada Y que ens enllaça amb yRENGS (poden haver-n'hi diverses!)
%%      [  %% hi ha tans boolenis com cops que s'ha trobat dins una mateixa Y
%%       true  %% és un fragment d'un mot
%%       false  %% mot sencer (no és un fragment)
%%      ]
%%    >>
%%  >>
%% ]

%% faremTREUiFICA ... és una array paginada de diccionaris:
%% on desarem les clau/valor definitives a treure i ficar, amb el parell: /motAtreure null

%% afegeixFont ... és una array paginada de diccionaris:
%% on desarem les clau/valor dels objectes /Font a afegir, amb el parell: /nomPDF null

%%Estratègia a seguir:
%% 0 :: si no hi ha cap mot a processar...
%%  :::MASATS::: NO HI HA cap mot a processar !
%% ens cal aturar el procés
%% 1 :: és sospitosa?
%% 2 :: per què és sospitosa? glifs? mètrica? ambdues?
%% 3 :: si no és sospitosa, es compon i fora
%%Ens cal saber si la font que s'utilitza és l'original o forastera
%% doncs això condiciona que haguem de reescriure novament, abans del Tj, els operadors Tf Tm i/o d'altres de control de
%% l'espaiat del text o de l'estat gràfic com g gs Tc Tw
%% 4 :: si és sopitosa, cal saber:
%% 5 :: si és una de les --standard 14 fonts--
%% 14PDFcoreFonts diccionari on hi com a claus les --standard 14 fonts-- i com a valor els diccionaris amb les clau/valor
%% del nom del caràcter i el seu ample
%%ATENCIÓ: ens cal controlar l'entrada /Widths /LastChar /FirstChar de l'objecte font, doncs pot ser que, com és el cas del
%% 2mots3pagines1enBlanc.pdf, tot i que la font NO és incrustada i és una Helvetica, l'array de la mètrica es limita als
%% caràcters que s'han fet servir tal i com indiquen les dues entrades /LastChar /FirstChar, i això vol dir que ens veurem
%% obligats o a refer l'array dels /Widths /LastChar /FirstChar en base a Champollion o simplement a eliminar les 3 entrades
%% 6 :: si NO és una de les --standard 14 fonts-- cal decidir si la substituim per una font forastera que s'hi assembli
%% o n'hi posem una tipus Courier perquè quedi clara l'absència o directament abortem el treu i fica d'aquest mot
%%Ens cal saber si la font que s'utilitza és l'original o forastera
%% doncs això condiciona que haguem de reescriure novament, abans del Tj, els operadors Tf Tm i/o d'altres de control de
%% l'espaiat del text o de l'estat gràfic com g gs Tc Tw

%%Per mitjà de l'array de la tipografia x pàgina a... CalaixDeTipus  ...a l'índex 2 podem saber si l'array de la mètrica s'adiu
%% a la capacitat de l'encoding (l'índex 1 del FirtChar ja ens ho pot apuntar una mica) de manera que podem decidir si ens cal
%% refer l'objecte font que duu aquest informació (sigui eliminant-la si és estàndard o reescrivint-la)
%%Ens cal saber com localitzar l'objecte font quan es crea CalaixDeTipus x poder-lo modificar si cal
%CalaixDeTipus
%fontsDrisc
% /1 get
%{== ==}forall

%%Taula de la veritat per saber quins nous objectes hem de donar d'alta per poder continuar editant amb les fonts que necessiten
%% ser cridades al tou de dades de composició de text, de manera que hauríem de poder, si cal, ajustar l'encoding de l'objecte
%TREUiFICAfinal 1 get
%afegeixFont {== ==}forall (lllllll)pstack quit

 /objectStandard14Fonts
 <<
   %% la família estàndard Courier
   /fMSTS0 <</Type/Font /Subtype/Type1 /Name/fMSTS0 /BaseFont/Courier /Encoding/WinAnsiEncoding>>
   /fMSTS1 <</Type/Font /Subtype/Type1 /Name/fMSTS1 /BaseFont/Courier-Oblique /Encoding/WinAnsiEncoding>>
   /fMSTS2 <</Type/Font /Subtype/Type1 /Name/fMSTS2 /BaseFont/Courier-Bold /Encoding/WinAnsiEncoding>>
   /fMSTS3 <</Type/Font /Subtype/Type1 /Name/fMSTS3 /BaseFont/Courier-BoldOblique /Encoding/WinAnsiEncoding>>
   %% la família estàndard Helvètica
   /fMSTS4 <</Type/Font /Subtype/Type1 /Name/fMSTS4 /BaseFont/Helvetica /Encoding/WinAnsiEncoding>>
   /fMSTS5 <</Type/Font /Subtype/Type1 /Name/fMSTS5 /BaseFont/Helvetica-Oblique /Encoding/WinAnsiEncoding>>
   /fMSTS6 <</Type/Font /Subtype/Type1 /Name/fMSTS6 /BaseFont/Helvetica-Bold /Encoding/WinAnsiEncoding>>
   /fMSTS7 <</Type/Font /Subtype/Type1 /Name/fMSTS7 /BaseFont/Helvetica-BoldOblique /Encoding/WinAnsiEncoding>>
   %% la família estàndard Times
   /fMSTS8 <</Type/Font /Subtype/Type1 /Name/fMSTS8 /BaseFont/Times-Roman /Encoding/WinAnsiEncoding>>
   /fMSTS9 <</Type/Font /Subtype/Type1 /Name/fMSTS9 /BaseFont/Times-Italic /Encoding/WinAnsiEncoding>>
   /fMSTS10 <</Type/Font /Subtype/Type1 /Name/fMSTS10 /BaseFont/Times-Bold /Encoding/WinAnsiEncoding>>
   /fMSTS11 <</Type/Font /Subtype/Type1 /Name/fMSTS11 /BaseFont/Times-BoldItalic /Encoding/WinAnsiEncoding>>
   %% poc provable que la fem servir per aquesta feina
   /fMSTS12 <</Type/Font /Subtype/Type1 /Name/fMSTS12 /BaseFont/Symbol /Encoding/WinAnsiEncoding>>
   %% encara menys provable que la fem servir per aquesta feina
   /fMSTS13 <</Type/Font /Subtype/Type1 /Name/fMSTS13 /BaseFont/ZapfDingbats /Encoding/WinAnsiEncoding>>
 >> def

%% hem de crear el generador de nou(s) objecte(s) /Font per pàgina
%afegeixFont 1 get {pop objectStandard14Fonts exch get /BaseFont get ==}forall (KKKKK)pstack quit

}if  %/16 cerca i substitució de text

%TREUiFICAfinal
%motsTrobatsAtreure
%3 get /ema get {== ==}forall(briançon)== quit
%faremTREUiFICA
%1 get 
%{== ==}forall  %% ESTÀ MAL FET
%(GGGGGGG)pstack quit
%(SOMvius)== quit

QueLiFemFer 9 eq
QueLiFemFer 4 eq
or not
{
 %:01 SEPARACIÓ DE TINTES
 %#%35bis2% aquí decidirem si fem el repicat del PDF, sempre que NO fem l'opció 9 o 4
 (%#%35bis2%)==
 QueLiFemFer 1 eq 
 %% cal veure amb detall quins errors hauríem de matenir fixos per a totes les versions
 {
  XRayError
  {  %% si detectem errors pleguem i no fem res ...
   BaBeL 31 get print
   grEUgEs
   {
    7 string cvs print ( ) print
   } forall
   flush  %% posem 1 sol flush doncs la DLL llavors no trenca els missatges ...
   (\n) print flush
   BaBeL 50 get print flush
   stop  %%quit
  } if
  %%% fi del filtrat d'errades a XRay x determinar que fem ...
  %#%36% analitzem a fons tots els estats gràfics per controlar l'Overprint i preparar-nos a fer els Previews
  (%#%36%)==
  /RePintats
  [  %% hi desarem els noms interns dels GStates segons el seu valor OPM
   %% els GStates que no estiguin aqui no tenen OPM
   << >>  %% a l'index 0 hi haura els noms dels GStates amb OPM a 0
   << >>  %% a l'index 1 hi haura els noms dels GStates amb OPM a 1
  ] def
  XRay /EstatsGrafics get /Utilitzats get
  {  %% amb aquest forall classifiquem (de moment) els noms interns dels GStates utilitzats segons el seu valor op/OP i OPM
   pop  %% ens carreguem el null que duu d'XRay
   totalEstatsG  %% diccionari ampliat amb tots els ExtGState de tots els Resources (Pagina+Patterns&Shadings)
   exch dup /NomIntern exch def
   get dup type /nametype eq
   {
    /aCercar exch def
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
   } if
   %% aqui tenim el dic de cada GState utilitzat a punt x interrogar
   %% primer explorem l'OPM x situar-ne els valors
   dup /OPM known
   {
    dup /OPM get 1 eq
    {  %% si el valor OPM es a 1 desem el seu nom a dic d'index 1 de Repintats
     RePintats 1 get NomIntern null put
    }
    {  %% si el valor OPM es a 0 desem el seu nom a dic d'index 0 de Repintats
     RePintats 0 get NomIntern null put
    }ifelse
   }if
   %% despres explorem l'op/OP x fabricar-ne els clonics
   %% El criteri a seguir pels noms dels GS clonics serà ...
   %% /???_opT (per a op true)
   %% /???_opF (per a op false)
   %% /???_OPt (per a OP true)
   %% /???_OPf (per a OP false)

   %% llevem el valor null que ara duen les entrades a Utilitzats i afegim al seu lloc un paquet que contindra els dics clonics relatius a op/OP
   XRay /EstatsGrafics get /Utilitzats get
   NomIntern
   [
    [  %% l'array de posicio 0 sera x op
     null  %% el dic desat a la posicio 0 voldra dir que duu op true
     null  %% el dic desat a la posicio 1 voldra dir que duu op false
     null  %% hi haura el nom del GS clonic
    ]
    [  %% l'array de posicio 1 sera x OP
     null  %% el dic desat a la posicio 0 voldra dir que duu OP true
     null  %% el dic desat a la posicio 1 voldra dir que duu OP false
     null  %% hi haura el nom del GS clonic
    ]
   ] put
   dup
   dup length dict copy /clonGS exch def  %% fem una copia no vinculada d'aquest dic
   clonGS /OP known  %% fem el clon d'OP
   {  %% hi ha OP
    clonGS dup /OP get
    {  %% es /OP true
     dup /BM /Multiply put
     dup /CA 1 put
     dup /op undef
     /ca undef
     %% copiem el clon al seu lloc a l'array
     XRay /EstatsGrafics get /Utilitzats get NomIntern get 1
     [
      clonGS
      null
      %% bastim el nom unic del clonic
      NomIntern 128 string cvs dup length dup /vAs exch def 4 add string
      dup 3 -1 roll 0 exch putinterval dup vAs (_OPt) putinterval cvn
     ] put
    }
    { %% es /OP false
     dup /BM /Normal put
     dup /CA 1 put
     dup /op undef
     /ca undef
     %% copiem el clon al seu lloc
     XRay /EstatsGrafics get /Utilitzats get NomIntern get 1
     [
      null
      clonGS
      %% bastim el nom unic del clonic
      NomIntern 128 string cvs dup length dup /vAs exch def 4 add string
      dup 3 -1 roll 0 exch putinterval dup vAs (_OPf) putinterval cvn
     ] put
    }ifelse 
   } if
   dup length dict copy /clonGS exch def  %% altra cop fem una copia no vinculada del dic del GS
   clonGS /op known  %% fem el clon d'op
   {  %% hi ha op
    clonGS dup /op get
    {  %% es /op true
     dup /BM /Multiply put
     dup /ca 1 put
     dup /OP undef
     /CA undef
     %% copiem el clon al seu lloc
     XRay /EstatsGrafics get /Utilitzats get NomIntern get 0
     [
      clonGS
      null
      %% bastim el nom unic del clonic
      NomIntern 128 string cvs dup length dup /vAs exch def 4 add string
      dup 3 -1 roll 0 exch putinterval dup vAs (_opT) putinterval cvn
     ] put
    }
    {  %% es /op false
     dup /BM /Normal put
     dup /ca 1 put
     dup /OP undef
     /CA undef
     %% copiem el clon al seu lloc
     XRay /EstatsGrafics get /Utilitzats get NomIntern get 0
     [
      null
      clonGS
      %% bastim el nom unic del clonic
      NomIntern 128 string cvs dup length dup /vAs exch def 4 add string
      dup 3 -1 roll 0 exch putinterval dup vAs (_opF) putinterval cvn
     ] put
    }ifelse 
   }if
  }forall
%% nou aspecte del dic Utilitzats ...
%% XRay /EstatsGrafics get /Utilitzats get {== ==} forall
%%(**********************) == quit
%% test d'analisi d'OPM
%% RePintats 0 get {pop ==} forall (OPM a 0) ==
%% RePintats 1 get {pop ==} forall (OPM a 1) ==
%%% fi d'analisi a fons tots els estats grafics

  %#%37% Analitzem ara el diccionari especial csZero dels Espais de Color per saber ...
  (%#%37%)==
  csZero dup length 0 eq
  %# 1. si hi ha CS amb valor zero de tinta o no
  {  %% si el dic queda buit es que no n'hi han
   pop  %%(NO hi ha CS amb tinta ZERO) ==
  }
  {
   {  %% forall
    %# 2. si el valor de color zero es únic o no
    {
     /ZEROu true def  %% gatell x saber si la tinta zero es unica o no
     %%(ZERO unic !) ==
    }
    {
     /ZEROu false def  %% gatell x saber si la tinta zero es unica o no
     %%(+ 1 ZERO !) ==
    }ifelse
    %# 3. si és DeviceN o PureCMYK
    /PureCMYK eq
    {
     /esDN false def  %% gatell per saber si es DeviceN o PureCMYK
     %%(PureCMYK) ==
    }
    {
     /esDN true def  %% gatell per saber si es DeviceN o PureCMYK
     %%(DeviceN) ==
    }ifelse
   }forall
  }ifelse
  %%% fi de l'analisi del dic especial csZero dels Espais de Color
 }if  %/01 SEPARACIÓ DE TINTES

 QueLiFemFer 1 eq
 QueLiFemFer 8 eq
 QueLiFemFer 10 eq
 QueLiFemFer 13 eq
 QueLiFemFer 14 eq
 QueLiFemFer 15 eq
%:01 SEPARACIÓ DE TINTES
%:08 ETIQUETA TEXT
%:10 PREFLIGHT AMB CAPES
%:13 eliminem continguts de pàgina
%:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%:15 ELIMINA LLEIXES
 or or or or or
 {
  %#%38% inici del depurador de l'estructura de Layers
  %# aquest depurador cal tenir en compte que només actua sobre unes determinades entrades (/OCProperties /Properties /D)
  %# doncs per desactivar l'estructura ja es suficient, però donada la complexitat d'aquest apartat les anirem incorporant
  %# progressivament com a profilaxi de continguts inútils a mida que ens faci falta
  (%#%38%)==
  _iLu 0 gt
  {  %% sempre que hi hagi layers!
   %% algorisme per eliminar els noms de les Layers de la solapa lateral
   %% de l'A7 (nom extern) i la resta d'objectes Layer no utilitzats
   %% per eliminar l'estructura de les Layers en tenim prou donant de baixa tots els
   %% objectes de l'array obligatoria OCeGeEsa, el dic PRPRTS i l'entrada /OCProperties al Catalog
QueLiFemFer 15 ne  %% només eliminem lleixes determinades, per tant l'arrel de les layers no es toca
{
   %% 0 ... donem de baixa l'entrada /OCProperties
   %% el dic del Catalog ...
   CtLgViu dup /OCProperties get dup type /nametype eq
   {
    /aCercar exch def  %% nom amb la ref ind del dic /OCProperties
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte indirecte
     dup aCercar known
     {
      aCercar undef  %% donem de baixa el dic /OCProperties
      exit
     }
     {
      pop
     }ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
    /OCProperties undef  %% el donem de baixa del Catalog
   }
   {
    pop /OCProperties undef  %% el donem de baixa del Catalog
   } ifelse
}if
   %% 1 ... donem de baixa la ref ind de /Properties de RSRCS de cada plana, si hi es
   %% tret que fem 15 doncs només donarem de baixa les ref ind i entrades de les lleixes que eliminem
   RSRCS
   {  %% forall x plana
    dup dup
    /Properties known
    {
     /Properties get dup type /nametype eq
     {
      /aCercar exch def  %% nom amb la ref ind del dic Properties
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte indirecte
       dup aCercar known
       {
        QueLiFemFer 15 eq
        {
         %% abans de donar-lo de baixa cal que desem a OdeBaixa totes les ref ind dels objectes que hi ha al dic
         dup /dCOMdimoniProperties exch def aCercar get
         dup /dProperties exch def
         {  %% forall pel dic de Properties
          1 index PLleixesAeliminar exch known
          {
           exch dProperties exch undef 
           dup type /nametype eq
           {
            OdeBaixa exch null put  %% donem de baixa l'objecte indirecte de la lleixa
           }
           {  %% cas dels objectes directes
            pop
           }ifelse
          }
          {
           pop pop
          }ifelse
         }forall
         % aCercar undef  %% donem de baixa el dic Properties
         exit
        }
        {
         %% abans de donar-lo de baixa cal que desem a OdeBaixa totes les ref ind dels objectes que hi ha al dic
         dup aCercar get
         {  %% forall pel dic de Properties
          dup type /nametype eq
          {
           OdeBaixa exch null put pop
          }
          {
           pop pop
          }ifelse
         }forall
         aCercar undef  %% donem de baixa el dic Properties
         exit
        }ifelse
       }
       {
        pop
       }ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni
      QueLiFemFer 15 ne
      {
       /Properties undef  %% donem de baixa l'entrada al dic
      }if
     }
     {
      QueLiFemFer 15 eq
      {
       dup /dProperties exch def
      }if
      {  %% forall pel dic de Properties x donar de baixa totes les ref ind de les Layers
       dup type /nametype eq
       {
        QueLiFemFer 15 eq
        {
         1 index PLleixesAeliminar exch known
         {  %% donem de baixa
          OdeBaixa exch null put  %% l'objecte OCMD
          dProperties exch undef  %% l'entrada a Properties
         }
         {  %% la deixem
          pop pop
         }ifelse
        }
        {  %% la donem de baixa a sac
         OdeBaixa exch null put pop
        }ifelse
       }
       {
        QueLiFemFer 15 eq
        {  %% el cas dels objectes directes
         1 index PLleixesAeliminar exch known
         {
          pop dProperties exch undef  %% l'entrada a Properties
         }
         {
          pop pop
         }ifelse
        }
        {
         pop pop
        }ifelse
       }ifelse
      }forall
      QueLiFemFer 15 eq
      {
       pop
      }
      {
       /Properties undef  %% donem de baixa l'entrada al dic
      }ifelse
      pop  %% ens carreguem el literal de pagina
     }ifelse
    }
    {  %% no té /Properties
     pop pop pop
    }ifelse
   }forall  %% x plana

   %% 2 ... donem de baixa tots els objectes llistats a OCGs
QueLiFemFer 15 eq  %% tret que només donem de baixa les lleixes seleccionades
{
 mark
   OCeGeEsa
   {  %% forall
dup null ne
{
dup OLleixesAeliminar exch known
     {
      OdeBaixa exch null put
     }if

%    /dBaixa exch def
%    %% la baixa a sac ...
%    /iDimoni 0 def
%    {  %% loop d'interrogacio dels dicts de COMdimoni
%     currentdict iDimoni 4 string cvs cvn get
%     %% x cada dic trencat ...
%     dBaixa undef  %% ... donem de baixa a sac (no ens donara pas error) tots els elements de l'array amb les ref ind dels objectes Layer a descartar
%     iDimoni 1 add /iDimoni exch def
%     iDimoni MaxDimoni eq {exit} if
%    } loop  %% d'interrogacio dels dicts de COMdimoni  

}if
   } forall
 ] /OCeGeEsa exch def

 OCPROP  %% dic OCProperties
 /OCGs get  %% n'extraiem l'entrada obligatoria
 dup type /nametype ne
 {  %% només cal redesar si és una array directe?
  pop
  %CtLgViu /OCProperties get
  OCPROP /OCGs OCeGeEsa put  %% redesem l'array directe
 }
 {
  dCOMdimoniOCGs exch OCeGeEsa put  %% redesem l'array a l'objecte indirecte
 }ifelse
}
{
   OCeGeEsa
   {  %% forall
    /dBaixa exch def
    %% la baixa a sac ...
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% x cada dic trencat ...
     dBaixa undef  %% ... donem de baixa a sac (no ens donara pas error) tots els elements de l'array amb les ref ind dels objectes Layer a descartar
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni  
   } forall
}ifelse

QueLiFemFer 15 ne  %% només eliminem lleixes determinades, per tant l'objecte OCGs no es toca
{
   %% 3 ... donem de baixa /OCGs de OCPROP
   OCPROP /OCGs get
   dup type /nametype eq
   {
    /aCercar exch def  %% nom amb la ref ind del dic Properties
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte indirecte
     dup aCercar known
     {
      aCercar undef  %% donem de baixa l'array OCGs
      exit
     }
     {
      pop
     }ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
    OCPROP /OCGs undef  %% donem de baixa l'array
   }
   {
    pop OCPROP /OCGs undef  %% donem de baixa l'array
   } ifelse
}if

   %% 4 ... mirem si hi ha les ref ind de /D i /Order, i si hi son les donem de baixa
   %% tret que fem QueLiFemFer 15 on eliminem només les lleixes seleccionades
   OCPROP /D known
   {
    OCPROP /D get
    dup type /nametype eq
    {
     /aCercar exch def  %% nom amb la ref ind del dic Properties
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte indirecte
      dup aCercar known
      {
       aCercar get dup /Order known
       {  %% si hi ha /Order
        /Order get
        dup type /nametype eq
        {  %% donem de baixa la ref ind de /Order
         OdeBaixa exch null put
        }
        {
         pop
        }ifelse
       }
       {
        pop
       }ifelse
       exit
      }
      {
       pop
      }ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
     OdeBaixa aCercar null put  %% donem de baixa la ref ind de /D
    }
    {
     dup /Order known
     {  %% si hi ha /Order
dup /dD exch def  %% diccionari directe D que necessitem per repicar Order si és també és una array directe
      /Order get
      dup type /nametype eq
      {  %% és una ref ind
QueLiFemFer 15 eq
{
 %% refem l'array Order donant de baixa les ref ind de les lleixes que eliminem
 %% ens cal saber el tram d'objectes COMdimoni on es troba per tornar-la a redesar refeta
 /aCercar exch def  %% nom amb la ref ind d'Order
 /iDimoni 0 def
 {  %% loop d'interrogacio dels dicts de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  %% el diccionari de l'objecte indirecte
  dup aCercar known
  {
   dup /tramCOMdimoni exch def  %% on redesar l'array Order
   aCercar get

   mark exch  %% claudàtor inicial per refer l'array
   {  %% forall de totes les ref ind per refer l'array
    dup null ne
    {
     dup OLleixesAeliminar exch known
     {
      OdeBaixa exch null put
     }if
    }if
   }forall
   ]  %% claudàtor final per refer l'array

   tramCOMdimoni exch aCercar exch put  %% redesem l'array Order dins l'objecte indirecte al tram COMdimoni

   exit
  }
  {
   pop
  }ifelse
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq {exit} if
 }loop  %% d'interrogacio dels dicts de COMdimoni

}
{  %% donem de baixa sempre
       OdeBaixa exch null put
}ifelse
      }
      {  %% és una array directe
QueLiFemFer 15 eq
{
 mark exch  %% claudàtor inicial per refer l'array
 {  %% forall de totes les ref ind per refer l'array
  dup null ne
  {
   dup OLleixesAeliminar exch known
   {
    OdeBaixa exch null put
   }if
  }if
 }forall
 ]  %% claudàtor final per refer l'array
 dD exch /Order exch put  %% redesem al dic D d'OCProperties
}
{  %% eliminem sempre
       pop
}ifelse
      }ifelse
     }
     {
      pop
     }ifelse
    } ifelse
   }if  %% si hi ha /D

   %#%38bis% esborrem de COMdimoni els objectes indirectes depurats al desmuntar l'estructura de Layers
   (%#%38bis%)==
   %% OdeBaixa{== ==}forall (!) == quit
   /iDimoni 0 def
   {  %% loop de decarrega de definicions pels dic creats
    OdeBaixa
    {
     pop
     currentdict iDimoni 4 string cvs cvn get
     exch undef
    } forall
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   }loop  %% de descarrega
  }if  %% sempre que hi hagi Layers ...
  %%% fi del depurador de Layers
 }if
%/15 ELIMINA LLEIXES
%/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%/13 eliminem continguts de pàgina
%/10 PREFLIGHT AMB CAPES
%/08 ETIQUETA TEXT
%/01 SEPARACIÓ DE TINTES
 QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
 QueLiFemFer 5 eq  %:05 dada variable
 or
 {
  %%ep!** ... ho fem abans de clonar els dics !!!!
  %%totalST2  % paquet amb tots els dics dels Shadings
  %%{  % repiquem l'espai de color a tots els Shadings xq quedi permanent i no produexi errors als Shadings que encara q no s'utilitzen provoquen un estrany efecte de pantalla gris a l'Acrobat7
  %% /ColorSpace /DeviceGray put
  %%} forall
  %#%39% clonarem els diccionaris trencats del PDF per ComDimoni per poder reescriure cada vegada
  %# el PDF de sortida amb les mateixes condicions
  (%#%39%)==
  /clON << >> def  %% on clonarem el diccionari original
  /iDimoni 0 def
  {  %% loop de descarrega de definicions pels dic creats
   currentdict iDimoni 4 string cvs cvn get 
   %% fem una copia no vinculada dels diccionaris que actuen com a valor
   dup length
   %% dup ==
   dict copy
   iDimoni 3 string cvs (10#000)  %% i passem la clau numeral al seu radial
   dup 3 -1 roll dup length
   6 exch sub exch putinterval exch clON 3 1 roll put  %% copiem al dic on clonem 
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  }loop  %% de descarrega
  %% tinc els meus dubtes que aixo estigui B ...
  %% fem una copia no vinculada dels dics a segon nivell
  clON
  {  %% forall
   exch pop dup /AoN exch def
   {  %% forall
    dup type /dicttype eq
    {
     dup length dict copy
     AoN 3 1 roll                            
     put
    }
    {
     pop pop
    }ifelse
   }forall
  }forall
  %% clonem el dic noZero
  noZero dup length dict copy /clON2 exch def  %% on clonarem el diccionari original
  %% clonem el dic TAUxREF
  TAUxREF dup length dict copy /clON3 exch def  %% on clonarem el diccionari original
  %% clonem el dic amb arrays dels GStates Utilitzats
  XRay /EstatsGrafics get /Utilitzats get
  dup length dict copy dup /Fenix exch def
  {  %% forall, clona un dic amb estructura tipu aixi ... << /A [ [1 2] [3 4] ] >>
   exch /laClau exch def
   dup null eq
   {
    /AoN exch def
   }
   {
    dup length array copy dup /AoN exch def
    /iA 0 def
    {  %% forall
     dup length array copy
     AoN iA 3 -1 roll put
     iA 1 add /iA exch def
    }forall
   }ifelse
   Fenix laClau AoN put
  }forall
  %% fi de clonacio els dics trencats
  %% test
  %% XRay /EstatsGrafics get /Utilitzats get
  %% /op1 get == quit
      %/05 dada variable
 }if  %/01 SEPARACIÓ DE TINTES


 QueLiFemFer 1 eq
 QueLiFemFer 5 eq
 QueLiFemFer 6 eq
 QueLiFemFer 10 eq
 QueLiFemFer 12 eq
 QueLiFemFer 13 eq
 QueLiFemFer 14 eq
 QueLiFemFer 16 eq
 %:01 SEPARACIÓ DE TINTES
 %:05 dada variable
 %:06 COSIT D'IMATGES
 %:10 PREFLIGHT AMB CAPES
 %:12 arbre jeràrquic
 %:13 eliminem continguts de pàgina
 %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
 %:16 cerca i substitució de text
 or or or or or or or
 {
  %#%40% segon diccionari de repicat de Contents (versió revisada fins la 1.7)
  (%#%40%)==
  /OpContents_QueLiFemFer2
  <<
  %#%40bis% activem els valors d'índex corresponents a QueLiFemFer
  %# per activar la corresponent redefinició de cada operador
  (%#%40bis%)==
  [
   {  %% 0 reescriptura idem
    (sense implementar! ... pleguem!) == stop  %%quit
   }
   {  %% 1 separació de tintes
    /i_q 1 def
    /i_Q 1 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 1 def
    /i_g 1 def
    /i_G 1 def
    /i_rg 1 def
    /i_RG 1 def
    /i_k 1 def
    /i_K 1 def
    /i_cs 1 def
    /i_CS 1 def
    /i_sc 1 def
    /i_SC 1 def
    /i_scn 1 def
    /i_SCN 1 def
    /i_ri 1 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 1 def
    /i_S 1 def
    /i_f 1 def
    /i_F 1 def
    /i_f* 1 def
    /i_b 1 def
    /i_B 1 def
    /i_b* 1 def
    /i_B* 1 def
    /i_sh 1 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 1 def
    /i_BI 1 def
    /i_ID 1 def
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 1 def
    /i_BDC 1 def
    /i_EMC 1 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 2 marques de tall
    (sense implementar! ... pleguem!) == stop  %%quit
   }
   {  %% 3 corrector tipogràfic
    (sense implementar! ... pleguem!) == stop  %%quit
   }
   {  %% 4 anàlisi textual
    (sense implementar! ... pleguem!) == stop  %%quit
   }
   {  %% 5 dada variable
    /i_q 3 def
    /i_Q 3 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 3 def
    /i_g 2 def
    /i_G 2 def
    /i_rg 2 def
    /i_RG 2 def
    /i_k 2 def
    /i_K 2 def
    /i_cs 2 def
    /i_CS 2 def
    /i_sc 2 def
    /i_SC 2 def
    /i_scn 2 def
    /i_SCN 2 def
    /i_ri 2 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 2 def
    /i_S 2 def
    /i_f 2 def
    /i_F 2 def
    /i_f* 2 def
    /i_b 2 def
    /i_B 2 def
    /i_b* 2 def
    /i_B* 2 def
    /i_sh 2 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 2 def  %% dada variable
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 2 def  %% dada variable
    /i_' 2 def  %% dada variable
    /i_" 2 def  %% dada variable
    /i_TJ 2 def  %% dada variable
    /i_Do 4 def
    /i_BI 2 def
    /i_ID 2 def
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 2 def
    /i_BDC 4 def  %% dada variable
    /i_EMC 3 def  %% dada variable
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 6 cosit d'imatges
    /i_q 2 def
    /i_Q 2 def
    /i_cm 2 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 2 def
    /i_g 2 def
    /i_G 2 def
    /i_rg 2 def
    /i_RG 2 def
    /i_k 2 def
    /i_K 2 def
    /i_cs 2 def
    /i_CS 2 def
    /i_sc 2 def
    /i_SC 2 def
    /i_scn 2 def
    /i_SCN 2 def
    /i_ri 2 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 2 def
    /i_h 1 def
    /i_n 1 def
    /i_s 2 def
    /i_S 2 def
    /i_f 2 def
    /i_F 2 def
    /i_f* 2 def
    /i_b 2 def
    /i_B 2 def
    /i_b* 2 def
    /i_B* 2 def
    /i_sh 2 def
    /i_W 2 def
    /i_W* 2 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 2 def
    /i_BI 2 def
    /i_ID 2 def
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def
    /i_BMC 2 def
    /i_BDC 2 def
    /i_EMC 2 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 7 reinsereix imatges JPEG
    (sense implementar! ... pleguem!) == stop  %%quit
   }
   {  %% 8 etiqueta text
    (sense implementar! ... pleguem!) == stop  %%quit
   }
   {  %% 9 extrau imatges JPEG
    (sense implementar! ... pleguem!) == stop  %%quit
   }
   {  %% 10 preflight amb capes
    %% traslladem aqui les redefinicions indentiques a OpContents_QueLiFemFer1 index 0 redireccionades a sEdAs2 o mantenim
    %% les mateixes definicions OpContents_QueLiFemFer2 per tal de preservar un repicat identic de les dades
    %% tret dels operadors Do i BDC que redefinim x detectar els FormXObjects que configuraran la llesca dels Farcells Grafics
    %% aixo ens obliga a posar a BDC i EMC el gatell DuuLlesques x detectar en Forms recursius on encara no s'hagi llegit l'stream
    /i_q 3 def
    /i_Q 3 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 3 def
    /i_g 2 def
    /i_G 2 def
    /i_rg 2 def
    /i_RG 2 def
    /i_k 2 def
    /i_K 2 def
    /i_cs 2 def
    /i_CS 2 def
    /i_sc 2 def
    /i_SC 2 def
    /i_scn 2 def
    /i_SCN 2 def
    /i_ri 2 def
    /i_m 1 def
    /i_l 2 def  %% detector de les nostres llesques
    /i_c 2 def  %% detector de les nostres llesques
    /i_v 2 def  %% detector de les nostres llesques
    /i_y 2 def  %% detector de les nostres llesques
    /i_re 3 def  %% detector de les nostres llesques
    /i_h 1 def
    /i_n 2 def  %% detector de les nostres llesques
    /i_s 3 def  %% detector de les nostres llesques
    /i_S 3 def  %% detector de les nostres llesques
    /i_f 3 def  %% detector de les nostres llesques
    /i_F 3 def  %% detector de les nostres llesques
    /i_f* 3 def  %% detector de les nostres llesques
    /i_b 3 def  %% detector de les nostres llesques
    /i_B 3 def  %% detector de les nostres llesques
    /i_b* 3 def  %% detector de les nostres llesques
    /i_B* 3 def  %% detector de les nostres llesques
    /i_sh 3 def  %% detector de les nostres llesques
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 2 def  %% detector de les nostres llesques
    /i_ET 2 def  %% detector de les nostres llesques
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 3 def  %% redefinim x detectar Form XObjects i les nostres llesques
    /i_BI 3 def  %% detector de les nostres llesques
    /i_ID 3 def  %% detector de les nostres llesques + no escrivim a disc el raw de les inLines!
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def  %% no actua
    /i_BMC 2 def
    /i_BDC 3 def  %% redefinim per detectar Form XObjects
    /i_EMC 2 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 11
   }
   {  %% 12
    %% traslladem aqui les redefinicions indentiques a OpContents_QueLiFemFer1 index 0
    %% redireccionades a sEdAs2 o mantenim les mateixes definicions OpContents_QueLiFemFer2 per
    %% tal de preservar un repicat identic de les dades
    /i_q 3 def
    /i_Q 3 def
    /i_cm 1 def
    /i_i 1 def
    /i_J 1 def
    /i_d 1 def
    /i_j 1 def
    /i_w 1 def
    /i_M 1 def
    /i_gs 3 def
    /i_g 2 def
    /i_G 2 def
    /i_rg 2 def
    /i_RG 2 def
    /i_k 2 def
    /i_K 2 def
    /i_cs 2 def
    /i_CS 2 def
    /i_sc 2 def
    /i_SC 2 def
    /i_scn 2 def
    /i_SCN 2 def
    /i_ri 2 def
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_re 1 def
    /i_h 1 def
    /i_n 1 def
    /i_s 2 def
    /i_S 2 def
    /i_f 2 def
    /i_F 2 def
    /i_f* 2 def
    /i_b 2 def
    /i_B 2 def
    /i_b* 2 def
    /i_B* 2 def
    /i_sh 2 def
    /i_W 1 def
    /i_W* 1 def
    /i_Tc 1 def
    /i_Tw 1 def
    /i_Tz 1 def
    /i_TL 1 def
    /i_Tf 1 def
    /i_Tr 1 def
    /i_Ts 1 def
    /i_BT 1 def
    /i_ET 1 def
    /i_Td 1 def
    /i_TD 1 def
    /i_Tm 1 def
    /i_T* 1 def
    /i_Tj 1 def
    /i_' 1 def
    /i_" 1 def
    /i_TJ 1 def
    /i_Do 4 def
    /i_BI 2 def
    /i_ID 2 def  %% de moment idem A3copiseny 
    /i_d0 1 def
    /i_d1 1 def
    /i_BX 1 def
    /i_EX 1 def  %% no actua
    /i_BMC 2 def
    /i_BDC 2 def
    /i_EMC 4 def
    /i_MP 1 def
    /i_DP 1 def
   }
   {  %% 13 idem que preflight amb capes
%% però amb les funcions de neteja dels operadors classificats per capes que haguem triat per
%% eliminar en el repicat final, aniran totes a l'índex 0, llavors traslladem aqui les
%% redefinicions indentiques a OpContents_QueLiFemFer1 index 0 redireccionades a sEdAs2 o mantenim
%% les mateixes definicions OpContents_QueLiFemFer2 per tal de preservar un repicat identic de les
%% dades, tret dels operadors Do i BDC que redefinim per detectar els FormXObjects que configuraran
%% la llesca dels Farcells Grafics, aixo ens obliga a posar a BDC i EMC el gatell DuuLlesques per
%% detectar en Forms recursius on encara no s'hagi llegit l'stream
    /i_q 0 def
    /i_Q 0 def
    /i_cm 0 def
    /i_i 0 def
    /i_J 0 def
    /i_d 0 def
    /i_j 0 def
    /i_w 0 def
    /i_M 0 def
    /i_gs 0 def
    /i_g 0 def
    /i_G 0 def
    /i_rg 0 def
    /i_RG 0 def
    /i_k 0 def
    /i_K 0 def
    /i_cs 0 def
    /i_CS 0 def
    /i_sc 0 def
    /i_SC 0 def
    /i_scn 0 def
    /i_SCN 0 def
    /i_ri 0 def
    /i_m 0 def
    /i_l 0 def  %% detector de les nostres llesques
    /i_c 0 def  %% detector de les nostres llesques
    /i_v 0 def  %% detector de les nostres llesques
    /i_y 0 def  %% detector de les nostres llesques
    /i_re 0 def  %% detector de les nostres llesques
    /i_h 0 def
    /i_n 0 def  %% detector de les nostres llesques
    /i_s 0 def  %% detector de les nostres llesques
    /i_S 0 def  %% detector de les nostres llesques
    /i_f 0 def  %% detector de les nostres llesques
    /i_F 0 def  %% detector de les nostres llesques
    /i_f* 0 def  %% detector de les nostres llesques
    /i_b 0 def  %% detector de les nostres llesques
    /i_B 0 def  %% detector de les nostres llesques
    /i_b* 0 def  %% detector de les nostres llesques
    /i_B* 0 def  %% detector de les nostres llesques
    /i_sh 0 def  %% detector de les nostres llesques
    /i_W 0 def
    /i_W* 0 def
    /i_Tc 0 def
    /i_Tw 0 def
    /i_Tz 0 def
    /i_TL 0 def
    /i_Tf 0 def
    /i_Tr 0 def
    /i_Ts 0 def
    /i_BT 0 def  %% detector de les nostres llesques
    /i_ET 0 def  %% detector de les nostres llesques
    /i_Td 0 def
    /i_TD 0 def
    /i_Tm 0 def
    /i_T* 0 def
    /i_Tj 0 def
    /i_' 0 def
    /i_" 0 def
    /i_TJ 0 def
    /i_Do 0 def  %% redefinim x detectar Form XObjects i les nostres llesques
    /i_BI 0 def  %% detector de les nostres llesques
    /i_ID 0 def  %% detector de les nostres llesques + no escrivim a disc el raw de les inLines!
    /i_d0 0 def
    /i_d1 0 def
    /i_BX 0 def
    /i_EX 0 def  %% no actua
    /i_BMC 0 def
    /i_BDC 0 def  %% redefinim per detectar Form XObjects
    /i_EMC 0 def
    /i_MP 0 def
    /i_DP 0 def
   }
   {  %% 14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%% idem que 13 i idem que preflight amb capes ...
%% però amb les funcions de neteja dels operadors classificats per capes que haguem triat per
%% eliminar en el repicat final, aniran totes a l'índex 0, llavors traslladem aqui les
%% redefinicions indentiques a OpContents_QueLiFemFer1 index 0 redireccionades a sEdAs2 o mantenim
%% les mateixes definicions OpContents_QueLiFemFer2 per tal de preservar un repicat identic de les
%% dades, tret dels operadors Do i BDC que redefinim per detectar els FormXObjects que configuraran
%% la llesca dels Farcells Grafics, aixo ens obliga a posar a BDC i EMC el gatell DuuLlesques per
%% detectar en Forms recursius on encara no s'hagi llegit l'stream
%% ... però ...

    /i_q 0 def
    /i_Q 0 def
    /i_cm 0 def
    /i_i 0 def
    /i_J 0 def
    /i_d 0 def
    /i_j 0 def
    /i_w 0 def
    /i_M 0 def
    /i_gs 0 def
    /i_g 0 def
    /i_G 0 def
    /i_rg 0 def
    /i_RG 0 def
    /i_k 0 def
    /i_K 0 def
    /i_cs 0 def
    /i_CS 0 def
    /i_sc 0 def
    /i_SC 0 def
    /i_scn 0 def
    /i_SCN 0 def
    /i_ri 0 def
    /i_m 0 def
    /i_l 0 def  %% detector de les nostres llesques
    /i_c 0 def  %% detector de les nostres llesques
    /i_v 0 def  %% detector de les nostres llesques
    /i_y 0 def  %% detector de les nostres llesques
    /i_re 0 def  %% detector de les nostres llesques
    /i_h 0 def
    /i_n 0 def  %% detector de les nostres llesques
    /i_s 0 def  %% detector de les nostres llesques
    /i_S 0 def  %% detector de les nostres llesques
    /i_f 0 def  %% detector de les nostres llesques
    /i_F 0 def  %% detector de les nostres llesques
    /i_f* 0 def  %% detector de les nostres llesques
    /i_b 0 def  %% detector de les nostres llesques
    /i_B 0 def  %% detector de les nostres llesques
    /i_b* 0 def  %% detector de les nostres llesques
    /i_B* 0 def  %% detector de les nostres llesques
    /i_sh 0 def  %% detector de les nostres llesques
    /i_W 0 def
    /i_W* 0 def
    /i_Tc 0 def
    /i_Tw 0 def
    /i_Tz 0 def
    /i_TL 0 def
    /i_Tf 0 def
    /i_Tr 0 def
    /i_Ts 0 def
    /i_BT 0 def  %% detector de les nostres llesques
    /i_ET 0 def  %% detector de les nostres llesques
    /i_Td 0 def
    /i_TD 0 def
    /i_Tm 0 def
    /i_T* 0 def
    /i_Tj 0 def
    /i_' 0 def
    /i_" 0 def
    /i_TJ 0 def
    /i_Do 5 def  %% sap si ha de restaurar la capa d'imatge d'1 sol JPEG?
    /i_BI 4 def  %% sap si ha de restaurar la capa d'imatge d'1 sol JPEG?
    /i_ID 4 def  %% sap si ha de restaurar la capa d'imatge d'1 sol JPEG? 
    /i_d0 0 def
    /i_d1 0 def
    /i_BX 0 def
    /i_EX 0 def  %% no actua
    /i_BMC 0 def
    /i_BDC 0 def  %% redefinim per detectar Form XObjects
    /i_EMC 0 def
    /i_MP 0 def
    /i_DP 0 def
   }
   null  %% 15 ... sense ús aquí: eliminem continguts (MASATS)
   {  %% 16 EP! ara ídem 5? (dada variable) ... cerca i substtitució de text en unes condicions concretes (MASATS)
%% reorganitzem els operadors segons s'ordenen i s'agrupen a la darrera versió de pdf, la 1.7, validada per ISO
%% Compatibility 3.7.1 Content Streams
    /i_BX 1 def
    %%/i_EX 1 def  %% se'l menja BX
%% 4.3.3 Graphics State Operators
    /i_q 4 def  %% abans 3
    /i_Q 4 def  %% abans 3
    /i_cm 3 def  %% abans 1
    /i_w 2 def  %% abans 1
    /i_J 1 def  %% NO canviem xq aquest paràmetre ara no es desa a l'estat gràfic
    /i_j 1 def  %% NO canviem xq aquest paràmetre ara no es desa a l'estat gràfic
    /i_M 1 def  %% NO canviem xq aquest paràmetre ara no es desa a l'estat gràfic
    /i_d 1 def  %% NO canviem xq aquest paràmetre ara no es desa a l'estat gràfic
    /i_ri 2 def  %% NO canviem xq aquest paràmetre ara no es desa a l'estat gràfic
    /i_i 1 def  %% NO canviem xq aquest paràmetre ara no es desa a l'estat gràfic
    /i_gs 4 def  %% abans 3
%% (no implementats) 4.3.4 Graphics State Parameter Dictionaries
%% 4.4.1 Path Construction Operators
    /i_m 1 def
    /i_l 1 def
    /i_c 1 def
    /i_v 1 def
    /i_y 1 def
    /i_h 1 def
    /i_re 1 def
%% 4.4.2 Path-Painting Operators
    /i_S 2 def
    /i_s 2 def
    /i_f 2 def
    /i_F 2 def
    /i_f* 2 def
    /i_B 2 def
    /i_B* 2 def
    /i_b 2 def
    /i_b* 2 def
    /i_n 1 def
%% 4.4.3 Clipping Path Operators
    /i_W 1 def
    /i_W* 1 def
%% 4.5.7 Color Operators
    /i_CS 2 def
    /i_cs 2 def
    /i_SC 2 def
    /i_SCN 2 def
    /i_sc 2 def
    /i_scn 2 def
    /i_G 2 def
    /i_g 2 def
    /i_RG 2 def
    /i_rg 2 def
    /i_K 2 def
    /i_k 2 def
%% 4.6 Shading Patterns 
    /i_sh 2 def
%% XObjects 4.8 Images 4.9 Form XObjects
    /i_Do 4 def
%% 4.8.6 Inline Images
    /i_BI 2 def
    /i_ID 2 def
    %%/i_EI 0 def  %% se'l menja ID
%% 5.2 Text State Parameters and Operators
    /i_Tc 2 def  %% abans 1
    /i_Tw 2 def  %% abans 1
    /i_Tz 2 def  %% abans 1
    /i_TL 2 def  %% abans 1
    /i_Tf 3 def  %% abans 2
    /i_Tr 1 def  %% NO canviem xq aquest paràmetre ara no es desa a l'estat gràfic
    /i_Ts 2 def  %% abans 1
%% 5.3.1 Text-Positioning Operators
    /i_Td 2 def  %% abans 1
    /i_TD 2 def  %% abans 1
    /i_Tm 2 def  %% abans 1
    /i_T* 2 def  %% abans 1
%% 5.3.2 Text-Showing Operators
    /i_Tj 3 def  %% recomponedora de caràcters
    /i_' 3 def  %% pendent d'adaptar seguint el model Tj/TJ
    /i_" 3 def  %% pendent d'adaptar seguint el model Tj/TJ
    /i_TJ 3 def  %% recomponedora de caràcters
%% Text object
    /i_BT 3 def  %% abans 1
    /i_ET 3 def  %% abans 1
%% Type 3 fonts
    /i_d0 2 def  %% (abans 1) aquest operador treballa exclusivament dins l'stream de construcció del caràcter Type3
    /i_d1 2 def  %% (abans 1) aquest operador treballa exclusivament dins l'stream de construcció del caràcter Type3
%% 10.5 Marked Content
    /i_MP 1 def
    /i_DP 1 def
    /i_BMC 2 def  %% repicat ídem
    /i_BDC 2 def  %% repicat ídem
    /i_EMC 4 def  %% repicat ídem
   }
   {  %% 17 %%MASATSencvlct idèntic a reescriptura idem
    (sense implementar! ... pleguem!) == stop  %%quit
   }
  ] QueLiFemFer get cvx exec

  %% aqui cal?
  /iiLine 0 def  %% numerador pels noms de les imatges InLine

  %% definicions que necessitem pel gatell 16
  /gsARA [null] def  %% Estat Grafic actual

  %% (PDF Ref 1.7) %% Compatibility 3.7.1 Content Streams
  %% (PDF Ref ?) 8.10.2 Compatibility operators
  [  %% BX
   {  %% 0 eliminem continguts
    alFoc
    {
     %% llegim el tou de dades fins a EX sense escriure re
     currentfile
     <<
       /Filter /SubFileDecode
       /DecodeParms <</EODCount 0 /EODString (EX)>>
     >> /ReusableStreamDecode filter
     dup flushfile closefile
    }
    {
    %%{  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    %% els operadors BX EX s'haurien d'utilitzar nomes per marcar parts del tou de dades que no s'adiuen amb la sintaxi de
    %% PDF o per blindar incompatibilitats dins de la mateixa evolucio de format (hi ha fitxers que n'abusen!)
    (\n\n ... tou de dades blindat amb BX ... EX i amb possibles incompatibilitats\n) print flush  %% n'avisem
    sEdAs2 (BX\012) writestring
    %% llegim les definicions fins a EX i comprovem si es codi compatible per mitja d'stopped
    %% si NO ho es el reescrivim de forma identica sense interpretar-lo i SI ho es l'interpretem
    currentfile
    <<
      /Filter /SubFileDecode
      /DecodeParms <</EODCount 0 /EODString (EX)>>
    >> /ReusableStreamDecode filter
    dup dup flushfile {cvx exec} stopped  %% peta?
    {  %% NO es compatible
     dup 0 setfileposition  %% ens posicionem a l'inici del tou de dades per reescriure'l sense interpretar
     {
      65535 string readstring
      {sEdAs2 exch writestring}{sEdAs2 exch writestring sEdAs2 (EX\012) writestring exit}ifelse
     }loop
    }
    {  %% SI es compatible
     dup 0 setfileposition  %% ens posicionem a l'inici del tou de dades per interpretar-lo
     cvx exec
     sEdAs2 (EX\012) writestring
    } ifelse
    %%}{
    %%  currentfile 0 (EX) /SubFileDecode filter
    %%  closefile  % ens carreguem tot el que hi hagi entre BX/EX
    %% }ifelse  % de la tinta que toca ara
    %%}stopped{( ... peta BX) == quit}if
    }ifelse
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    %% els operadors BX EX s'haurien d'utilitzar nomes per marcar parts del tou de dades que no s'adiuen amb la sintaxi de
    %% PDF o per blindar incompatibilitats dins de la mateixa evolucio de format (hi ha fitxers que n'abusen!)
    (\n\n ... tou de dades blindat amb BX ... EX i amb possibles incompatibilitats\n) print flush  %% n'avisem
    sEdAs2 (BX\012) writestring
    %% llegim les definicions fins a EX i comprovem si es codi compatible per mitja d'stopped
    %% si NO ho es el reescrivim de forma identica sense interpretar-lo i SI ho es l'interpretem
    currentfile
    <<
      /Filter /SubFileDecode
      /DecodeParms <</EODCount 0 /EODString (EX)>>
    >> /ReusableStreamDecode filter
    dup dup flushfile {cvx exec} stopped  %% peta?
    {  %% NO es compatible
     dup 0 setfileposition  %% ens posicionem a l'inici del tou de dades per reescriure'l sense interpretar
     {
      65535 string readstring
      {sEdAs2 exch writestring}{sEdAs2 exch writestring sEdAs2 (EX\012) writestring exit}ifelse
     }loop
    }
    {  %% SI es compatible
     dup 0 setfileposition  %% ens posicionem a l'inici del tou de dades per interpretar-lo
     cvx exec
     sEdAs2 (EX\012) writestring
    } ifelse
    %%}{
    %%  currentfile 0 (EX) /SubFileDecode filter
    %%  closefile  % ens carreguem tot el que hi hagi entre BX/EX
    %% }ifelse  % de la tinta que toca ara
    }stopped{( ... peta BX) pstack quit}if
   }
  ] i_BX get /BX exch bind def

  %% /EX  % no cal definir-lo doncs ja l'escrivim dins BX
  %% {
  %%  sEdAs2 (EX\015) writestring
  %%  } bind def

  %% (PDF Ref ?) 8.3.2 Special Graphics State operators
  %% (PDF Ref 1.7) 4.3.3 Graphics State Operators
  [  %% q
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
    }
    {
     %% /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs2 (q\012) writestring
    }ifelse
    %%}stopped{( ... peta q) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%TiNTeM {  % es la tinta que toca ara ?

    %% l'operador 'q' sempre afegira un nou element null a la posicio 0 de l'array
    %% del valor actual que, actuant com una pila, augmentara en 1 element (tret que originalment nomes hi hagi 1 sol valor)
    csARA 0 get null ne  %% actuem sobre el ColorSpace actual per fill
    {
     csARA length 1 add array dup
     1 csARA putinterval
     dup 0 null put /csARA exch def
    } if
    CSARA 0 get null ne  %% actuem sobre el ColorSpace actual per stroke
    {
     CSARA length 1 add array dup
     1 CSARA putinterval
     dup 0 null put /CSARA exch def
    } if
    gsARA 0 get null ne  %% actuem sobre el GState actual
    {
     gsARA length 1 add array dup
     1 gsARA putinterval
     dup 0 null put /gsARA exch def
    } if
    tintARA 0 get null ne  %% actuem sobre el valor actual de tinta
    {
     tintARA length 1 add array dup
     1 tintARA putinterval
     dup 0 null put /tintARA exch def
    } if
    %%    sEdAs2 (q\015) writestring

    %%} if  % de la tinta que toca ara
    sEdAs2 (q\012) writestring  %% sembla que cal escriure sempre els anellats save/restore
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    %%{  % stopped
    %% l'operador 'q' sempre afegira un nou element false a la posicio 0 de l'array WARA o W*ARA, q voldra dir que en
    %% l'actual context (save/restore) encara no s'hi ha definit cap clip, malgrat n'hi pugui haver d'actius en contextos
    %% superiors (index 1 o + de l'actual array), doncs si te clips actius (true a 0 o +) els enretirara d'una posicio
    %% reconstruint l'array que, actuant com una pila, augmentara d'1 element
    %%WARA 0 get  % actuem sobre el clip actual sempre que 0 estigui a true
    %%{
    %% WARA length 1 add array dup
    %% 1 WARA putinterval
    %% dup 0 false put /WARA exch def
    %%} if
    %%W*ARA 0 get  % actuem sobre l'eoclip actual sempre que 0 estigui a true
    %%{
    %% W*ARA length 1 add array dup
    %% 1 W*ARA putinterval
    %% dup 0 false put /W*ARA exch def
    %%} if
    sEdAs2 (q\012) writestring
    %%}stopped{( ... peta q) == quit}if

    %% EP! cal veure si ens interessa mes aquesta estrategia de la copia identica
%%    EstatGrafic dup iEG get dup length dict copy  % deixem a la pila una copia identica (desvinculada) del dic de l'estat grafic actual
%%    % ampliarem el paquet EstatGrafic per posar-hi el nou dic
%%    exch dup length 1 add array dup 3 -1 roll 0 exch putinterval
    %% q no pas iniciar un diccionari buit que l'aniriem omplint d'elements de l'estat grafic a mida que anessin sortint,
    %% d'aquesta manera sempre podrem saber en quin context s'ha produit un determinat valor que ens interessi avaluar
    %% (de moment aixo nomes ho activem per #6 i aqui OpContents_QueLiFemFer2)
EstatGrafic
<<>>  %% posem un dic buit com a nou estat grafic
exch dup length 1 add array dup 3 -1 roll 0 exch putinterval

    iEG 1 add /iEG exch def  %% actualitzem l'index del dic de l'estat grafic actiu
    %% afegim el dic buit de l'estat grafic (ara ja es l'actual!) a la darrera posicio
    dup 3 -1 roll
    iEG exch put /EstatGrafic exch def  %% desem el paquet ampliat dels dics de l'estat grafic

   }
   {  %% 3 (repicat idem sense XRay) verificador de PDF
    %%{  % stopped
    %% /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs2 (q\012) writestring
    %%}stopped{( ... peta q) == quit}if
   }
   {  %% 4 gatell 16 MASATS
%(q gatell 16)pstack quit
    {  %% stopped
    %% l'operador 'q' sempre afegira un nou element null a la posicio 0 de l'array
    %% del valor actual que, actuant com una pila, augmentara en 1 element (tret que originalment nomes hi hagi 1 sol valor)
    csARA 0 get null ne  %% actuem sobre el ColorSpace actual per fill
    {
     csARA length 1 add array dup
     1 csARA putinterval
     dup 0 null put /csARA exch def
    }if
    CSARA 0 get null ne  %% actuem sobre el ColorSpace actual per stroke
    {
     CSARA length 1 add array dup
     1 CSARA putinterval
     dup 0 null put /CSARA exch def
    }if

    sEdAs2 (q\012) writestring

    %%% KTCS
    %% EP! cal veure si ens interessa mes aquesta estrategia de la copia identica q no pas iniciar un diccionari buit que
    %% l'aniriem omplint d'elements de l'estat grafic a mida que anessin sortint, d'aquesta manera sempre podrem saber en
    %% quin context s'ha produit un determinat valor que ens interessi avaluar (de moment aixo nomes ho activem per #6 i a OpContents_QueLiFemFer2)

    EstatGrafic dup iEG get dup length dict copy  %% deixem a la pila una copia identica (desvinculada) del dic de l'estat grafic actual
    %% ampliarem el paquet EstatGrafic per posar-hi el nou dic
    exch dup length 1 add array dup 3 -1 roll 0 exch putinterval
    
    iEG 1 add /iEG exch def  %% actualitzem l'index del dic de l'estat grafic actiu
    %% afegim la copia del dic de l'estat grafic anterior (ara ja es l'actual!) a la darrera posicio
    dup 3 -1 roll  
    iEG exch put
    /EstatGrafic exch def  %% desem el paquet ampliat dels dics l'estat grafic
    }stopped{( ... peta q) pstack quit}if
   }
  ] i_q get /q exch bind def

  [  %% Q
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
    }
    {
     %% /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs2 (Q\012) writestring
    }ifelse
    %%}stopped{( ... peta Q) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%TiNTeM {  % es la tinta que toca ara ?

    %% l'operador 'Q' sempre restara l'element de la posicio 0 de l'array
    %% del valor actual que, actuant com una pila, minvara d'1 element
    %% i si originalment nomes hi ha 1 sol valor, hi posara un null al seu lloc
    csARA 0 get null ne  %% actuem sobre el ColorSpace actual per fill
    {
     csARA length 1 sub
     0 eq
     {
      /csARA [null] def
     }
     {
      csARA dup length 1 sub 1 exch getinterval
      /csARA exch def
     }ifelse
    } if
    CSARA 0 get null ne  %% actuem sobre el ColorSpace actual per stroke
    {
     CSARA length 1 sub
     0 eq
     {
      /CSARA [null] def
     }
     {
      CSARA dup length 1 sub 1 exch getinterval
      /CSARA exch def
     }ifelse
    } if
    gsARA 0 get null ne  %% actuem sobre el GState actual
    {
     gsARA length 1 sub
     0 eq
     {
      /gsARA [null] def
     }
     {
      gsARA dup length 1 sub 1 exch getinterval
      /gsARA exch def
     }ifelse
    } if
    tintARA 0 get null ne  %% actuem sobre el valor actual de tinta
    {
     tintARA length 1 sub
     0 eq
     {
      /tintARA [null] def
     }
     {
      tintARA dup length 1 sub 1 exch getinterval
      /tintARA exch def
     }ifelse
    } if

    %%    sEdAs2 (Q\015) writestring

    %%} if  % de la tinta que toca ara
    sEdAs2 (Q\012) writestring  %% sembla que cal escriure sempre els anellats save/restore
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    %% l'operador 'Q' sempre restara l'element de la posicio 0 de l'array del valor actual de WARA i W*ARA que,
    %% actuant com una pila, minvara d'1 element, i si originalment nomes hi ha 1 sol valor, hi posara un null al seu lloc
    %%{  % stopped
    %%WARA length 1 sub  % actuem sobre el clip actual
    %%0 eq
    %%{
    %% /WARA [false] def
    %%}
    %%{
    %% WARA dup length 1 sub 1 exch getinterval
    %% /WARA exch def
    %%}ifelse
    %%W*ARA length 1 sub  % actuem sobre l'eoclip actual
    %%0 eq
    %%{
    %% /W*ARA [false] def
    %%}
    %%{
    %% W*ARA dup length 1 sub 1 exch getinterval
    %% /W*ARA exch def
    %%}ifelse
    sEdAs2 (Q\012) writestring
    %%}stopped{( ... peta Q) == quit}if

    %% retallem el paquet EstatGrafic a -1 eliminant el darrer dic de l'estat grafic
    EstatGrafic dup length 1 sub 0 exch getinterval /EstatGrafic exch def
    iEG 1 sub /iEG exch def  %% actualitzem l'index del dic de l'estat grafic actiu
    
    %% reexecutem els valors de l'estat grafic restablert x redefinir-ne les variables
    EstatGrafic iEG get  %% recuperem del dic de l'estat grafic actiu
    {def}forall  %% redefinim les variables

   }
   {  %% 3 (repicat idem sense XRay) verificador de PDF                             
    {  % stopped
    %% /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs2 (Q\012) writestring
    }stopped{( ... peta Q) == quit}if
   }
   {  %% 4 gatell 16 MASATS
    {  %% stopped
    %% l'operador 'Q' sempre restara l'element de la posicio 0 de l'array
    %% del valor actual que, actuant com una pila, minvara d'1 element
    %% i si originalment nomes hi ha 1 sol valor, hi posara un null al seu lloc
    csARA 0 get null ne  %% actuem sobre el ColorSpace actual per fill
    {
     csARA length 1 sub
     0 eq {/csARA [null] def}
     {
      csARA dup length 1 sub 1 exch getinterval
      /csARA exch def
     }ifelse
    } if
    CSARA 0 get null ne  %% actuem sobre el ColorSpace actual per stroke
    {
     CSARA length 1 sub
     0 eq {/CSARA [null] def}
     {
      CSARA dup length 1 sub 1 exch getinterval
      /CSARA exch def
     }ifelse
    } if

     sEdAs2 (Q\012) writestring

    %%% KTCS
    %% retallem el paquet EstatGrafic a -1 eliminant el darrer dic de l'estat grafic
    EstatGrafic dup length 1 sub 0 exch getinterval /EstatGrafic exch def
    iEG 1 sub /iEG exch def  %% actualitzem l'index del dic de l'estat grafic actiu

    %% reexecutem els valors de l'estat grafic restablert x redefinir-ne les variables
    EstatGrafic iEG get  %% recuperem del dic de l'estat grafic actiu
    {def}forall  %% redefinim les variables
    }stopped{( ... peta Q) pstack quit}if
   }
  ] i_Q get /Q exch bind def

  [  %% cm
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop pop pop pop pop pop
     }
     {
      %%TiNTeM {  % es la tinta que toca ara ?
      6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
      sEdAs2 (cm\012) writestring
      %%}{6 {pop}repeat}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta cm) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?

    6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
    sEdAs2 (cm\012) writestring

    %%}{6 {pop}repeat}ifelse  % de la tinta que toca ara
    }stopped{( ... peta cm) == quit}if
   }
   {  %% 2 (relligat d'imatges) + (correccio L·L + analisi textual)?
    {  % stopped
    6 copy
%%    /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
    sEdAs2 (cm\012) writestring
    %%test
    %%% KTCS
    %% d moment sumarem sempre aquests valors a TxTm TyTm i ...
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmPy exch put
    /cmPy exch def  %%% KTCS valor absolut de posicio Y de l'origen de l'eix de coordenades
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmPx exch put
    /cmPx exch def  %%% KTCS valor absolut de posicio X de l'origen de l'eix de coordenades
    %% d moment multiplicarem sempre aquest valor a SyTm i ...
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmSy exch put
    /cmSy exch def  %%% KTCS multiplicador d'escala Y de l'eix de coordenades
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cm_tanBsin exch put
    /cm_tanBsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un esbiaixat
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cm_tanAsin exch put
    /cm_tanAsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un esbiaixat
    %% d moment multiplicarem sempre aquest valor a SxTm i ...
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /cmSx exch put
    /cmSx exch def %%% KTCS multiplicador d'escala X del cos del text (seria el que al manual s'anomena com a 'text space unit')
    %% si algun dels dos valors (2 i 3 de l'array) es diferent de zero llavors avisem doncs caldria implementar un correcte localitzador de coordenades normalitzades
    cm_tanBsin abs cm_tanAsin abs add 0 ne
    {
     (EP!: eix cm rotat o esbiaixat!) ==
    }if
    }stopped{( ... peta cm) == quit}if
   }
   {  %% 3 gatell 16 MASATS
    {  % stopped
     6 copy
     6 array astore
     {
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     }forall
     sEdAs2 (cm\012) writestring
     %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     /LleixaBuida false def
     %% desactivem l'escriptura, doncs aqui es no la utilizem per a res!
     /eixcmGirat false def
     %% el valor de posicio Y actual necesssita ser multiplicada per l'escala Y del cm anterior
     EstatGrafic iEG get /cmSy get mul
     %% i despres necesssita ser sumat per la posicio Y del cm anterior
     EstatGrafic iEG get /cmPy get add
     dup EstatGrafic iEG get exch /cmPy exch put
     /cmPy exch def  %% valor absolut de posicio Y de l'origen de l'eix de coordenades
     %% el valor de posicio X actual necesssita ser multiplicada per l'escala X del cm anterior
     EstatGrafic iEG get /cmSx get mul
     %% i despres necesssita ser sumat per la posicio X del cm anterior
     EstatGrafic iEG get /cmPx get add
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /cmPx exch put
     /cmPx exch def  %% valor absolut de posicio X de l'origen de l'eix de coordenades
     EstatGrafic iEG get /cmSy get mul  %% la nova escala Y cal multiplicar per l'escala Y d'abans!
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /cmSy exch put
     /cmSy exch def  %% multiplicador d'escala Y de l'eix de coordenades
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /cm_tanBsin exch put
     /cm_tanBsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un esbiaixat
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /cm_tanAsin exch put
     /cm_tanAsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un esbiaixat
     %% d moment multiplicarem sempre aquest valor a SxTm i ...
     EstatGrafic iEG get /cmSx get mul  %% la nova escala X cal multiplicar per l'escala X d'abans!
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /cmSx exch put
     /cmSx exch def  %% multiplicador d'escala X de l'eix de coordenades
     %% redefinim dins /acm els valors de cm aqui, doncs podrien haver canviat per l'accio d'una altra cm
     [
      EstatGrafic iEG get /cmSx get  %% escala X a cm
      EstatGrafic iEG get /cm_tanAsin get  %% valor de la tangent o del sinus de l'angle a cm
      EstatGrafic iEG get /cm_tanBsin get  %% valor de la tangent o del sinus de l'angle a cm
      EstatGrafic iEG get /cmSy get  %% escala Y a cm
      EstatGrafic iEG get /cmPx get  %% X de l'origen de l'eix de coordenades a cm
      EstatGrafic iEG get /cmPy get  %% Y de l'origen de l'eix de coordenades a cm
     ]
     /acm exch def  %% desem l'array de la cm en aquesta variable x
     %% si algun dels valors 2 i 3 de l'array es diferent de zero llavors avisem doncs l'eix duu manipulat 
     cm_tanBsin abs cm_tanAsin abs add 0 ne
     {  %% eix amb manipulacio
      %% esbrinem si es una rotacio neta a 90 graus ...
      cmSx cmSy add 0 eq  %% si es true llavors cm_tanBsin i cm_tanAsin son valors del d'escala
      {  %% es una rotacio neta a 90 graus!
       cm_tanBsin  %%cmSy mul  % NO multipliquem el valor provinent de cm
       dup abs dup /cmSy exch def  %% nou valor d'escala Y cm establert pel sinus
       EstatGrafic iEG get exch /cmSy exch put  %% desem al dic de l'estat grafic
       %%cos_ mul abs /CyTm exch def  % (valor absolut!) redefinim el valor del cos vertical de la lletra
       cm_tanAsin %%cmSx mul  % NO multipliquem el valor provinent de cm
       dup abs dup /cmSx exch def  %% nou valor d'escala X cm establert pel sinus
       EstatGrafic iEG get exch /cmSx exch put  %% desem al dic de l'estat grafic
       %%cos_ mul abs /CxTm exch def  % (valor absolut!) redefinim el valor del cos horitzontal de la lletra
       %% gatell x detectar girs nets de 90 graus pel sinus
       /90NET true def
       %% esbrinem el signe de l'angle i desem el valor
       EstatGrafic iEG get /A_cm 90 cm_tanAsin 0 lt
       {
        neg dup /A_cm exch def
       }
       {
        dup /A_cm exch def
       }ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa
       /eixcmGirat true def
      }
      {  %% ha de ser una rotacio d'un altre valor
       %% llavors l'escala pren altra cop puntualment el valor d'1 (no cal desar-ho a l'estat grafic?)
       /cmSx 1 def  %% nou valor d'escala cm per les X
       /cmSy 1 def  %% nou valor d'escala cm per les Y
       %% gatell x detectar girs nets de 90 graus pel sinus
       /90NET false def
       (EP!: eix cm rotat o esbiaixat!) ==
       %% discriminem el tipus de rotacio o esbiaixat ...
       acm 0 4 getinterval aload pop  %% extraiem els quatre primers valors que ens interessen
       4 1 roll add 0 eq
       {  %% es una rotacio normal (sinus contraposats)
        pop pop
        ( ... es una rotacio normal) ==
        %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
        /girNOcontrolat false def
        EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
       }
       {
        %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
        /girNOcontrolat true def
        EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
        add 0 eq
        {  %% es una imatge mirall (cosinus contraposats)
         ( ... es una rotacio cm d'espill ... EP!)==  %% quit
        }
        {
         ( ... es un esbiaixat cm de l'eix ... EP!)==  %% quit
        }ifelse
       }ifelse
       /eixcmGirat true def
       girNOcontrolat not
       {  %% nomes analitzem l'angle si es tracta d'una rotacio normal
        %%% EP! HEM CANVIAT L'ESTRATEGIA PER L'OPERADOR atan
        %%% aqui fem el calcul de l'angle de rotacio (graus i signe!)
        acm dup 1 get /Asinus exch def  %% si el sinus es positiu: l'angle sera positiu (direccio contrarellotge)
        0 get /Acosinus exch def  %% pesquem el cosinus
        %% /anglES null def  % no fos q no el trobem
        %% /Acrement .001 def  % suficient per q la precisio d'angle no hagi d'iterar + d'1 cop?
        %% {  % loop
        Asinus 0 lt  %% si l'angle es negatiu (ho controlem amb l'index 1 de l'array Tm o cm)
        {
         %% -360 Acrement 0  
         Asinus Acosinus atan neg /anglES exch def
        }
        {
         %% 0 Acrement 360
         Asinus Acosinus atan /anglES exch def
        }ifelse
        %%       {  % for
        %%        dup dup sin 10000 mul truncate 10000 div Asinus 10000 mul truncate 10000 div eq
        %%        exch cos 10000 mul truncate 10000 div Acosinus 10000 mul truncate 10000 div eq
        %%        and
        %%        {  % donat que l'error es mil·limetric, donem x bo el primer angle q compleixi la condicio
        %%           % (pero n'hi poden haver +!)
        %%         /anglES exch def exit
        %%        }
        %%        {
        %%         pop
        %%        }ifelse
        %%       }for
        %%       anglES null eq  % iterem?
        %%       {  % si la precisio no es suficient li afegim 1 decimal!
        %%        Acrement 10 div /Acrement exch def
        %%        (no es prou acurat ... TORNEM-HI!) ==
        %%       }
        %%       {  % donem x bo el primer angle q compleixi la condicio (pero n'hi poden haver +!)
        anglES /A_cm exch def
        EstatGrafic iEG get /A_cm A_cm put  %% al desem al dic de l'estat grafic actiu
        %%        exit
        %%       }ifelse
        %%      }loop
        %%% fi del calcul de l'angle
       }if  %% nomes analitzem l'angle si es tracta d'una rotacio normal
      }ifelse  %% es una rotacio neta a 90 graus o d'un altre valor?
     }
     {
      %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
      /girNOcontrolat false def
      EstatGrafic iEG get /girNOcontrolat girNOcontrolat put  %% desem a l'estat grafic
     }ifelse
    }stopped{( ... peta cm) pstack quit}if
   }
  ] i_cm get /cm exch bind def

  %% 8.4.5 Line width
  [  %% w
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop
     }
     {
      %%TiNTeM {  % es la tinta que toca ara ?
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (w\012) writestring
      %%}{pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta w) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges  + verificador de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?

    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (w\012) writestring

    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta w) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  % stopped
     /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (w\012) writestring
    }stopped{( ... peta w) pstack quit}if
   }
  ] i_w get /w exch bind def

  %% 8.4.2 Line cap style
  [  %% J
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     1 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (J\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta J) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificador de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?

    1 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (J\012) writestring

    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta J) pstack quit}if
   }
  ] i_J get /J exch bind def

  %% 8.4.4 Line join style
  [  %% j
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     1 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (j\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta j) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificador de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?

    1 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (j\012) writestring

    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta j) pstack quit}if
   }
  ] i_j get /j exch bind def

  %% 8.4.6 Miter limit
  [  %% M
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (M\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta M) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificador de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?

    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (M\012) writestring

    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta M) pstack quit}if
   }
  ] i_M get /M exch bind def

  %% 8.4.3 Line dash pattern
  [  %% d
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     /phase exch def
     sEdAs2 ([ ) writestring
     {
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     } forall
     sEdAs2 (] ) writestring
     phase 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     sEdAs2 (d\012) writestring
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta d) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificador de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    /phase exch def
    sEdAs2 ([ ) writestring
    {
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    } forall
    sEdAs2 (] ) writestring
    phase 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    sEdAs2 (d\012) writestring
    %%}{pop pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta d) pstack quit}if
   }
  ] i_d get /d exch bind def

  %% 8.5.2.3 Color rendering intent
  [  %% ri
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (ri\012) writestring
    }ifelse
    %%}stopped{( ... peta ri) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    TiNTeM
    {  %% es la tinta que toca ara ?
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (ri\012) writestring
    }
    {
     pop
    }ifelse  %% de la tinta que toca ara
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    {  % stopped
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (ri\012) writestring
    }stopped{( ... peta ri) pstack quit}if
   }
  ] i_ri get /ri exch bind def

  %% 8.4.1 Flatness
  [  %% i
   {  %% 0 eliminem continguts
    %%{  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    alFoc
    {
     pop
    }
    {
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     sEdAs2 (i\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta i) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificador de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?

    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    sEdAs2 (i\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta i) pstack quit}if
   }
  ] i_i get /i exch bind def

  %% 8.4.7 Generic Graphics State operator
  [  %% gs
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %% /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 ( gs\012) writestring
    }ifelse
    %%}stopped{( ... peta gs) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %% avaluador del gatell OPactua i opactua
    %% com que gs pot ser invocat sense necessitat de canviar els valors i espais de color
    %% a cada punt on l'overprint es activat cal interrogar per mitja de l'espai de color
    %% actiu, en cas que siga DeviceN o Sep si es +1 o no i en cas de CMYK si OPM es 0 o no
    %% avaluem opactua
    dup XRay /EstatsGrafics get /Utilitzats get exch get
    0 get 0 get
    dup
    null eq
    {  %% Hi ha op i l'overprint es activat ?
     pop  %% ens carreguem el null
     dup XRay /EstatsGrafics get /Utilitzats get exch get
     0 get 2 get null eq
     {  %% definitivament si no duu el nom del dic clonic NO hi ha op
      dup XRay /EstatsGrafics get /Utilitzats get exch get
      1 get dup 2 get null eq  %% mirem si hi ha OP (doncs si no duu el dic clonic ... )
      {  %% no hi ha OP tampoc
       pop  %% ens carreguem l'array
       %% x saber si actua l'overprint
       false /opactua exch def
       false /OPactua exch def
      }
      {  %% SI que hi ha OP
       dup 0 get null eq
       {
        1 get  %% OP es a false pero ja interrogarem el dict ...
       }
       {  %% OP es a true pero ja interrogarem el dict ...
        0 get
       }ifelse
       dup /OP get
       {  %% OP es a true x tant l'overprint es activat
        dup /OPM known
        {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
         /OPM get 1 eq
         {  %% val 1 ... l'Overprint es actiu tret que l'espai de color actual sigui DeviceN amb +1 component
          es4c
          {  %% n'hi ha prou x saber si es CMYK ?
           %% x saber si actua l'overprint
           true /opactua exch def
          }
          {  %% sera DeviceN o Separation
           NomesUn {true /opactua exch def}{false /opactua exch def}ifelse        
          }ifelse       
         }
         {  %% val 0 ... l'Overprint no esta activat en cas q l'espai de color actual sigui CMYK o DeviceN tingui +1 component
          es4c
          {  %% n'hi ha prou x saber si es CMYK ?
           %% x saber si actua l'overprint
           false /opactua exch def
          }
          {  %% sera DeviceN o Separation
           NomesUn {true /opactua exch def}{false /opactua exch def}ifelse        
          }ifelse
         }ifelse
        }
        {  %% l'Overprint no esta activat
         pop
         %% x saber si actua l'overprint
         false /opactua exch def
        }ifelse
       }
       {  %% l'Overprint no esta activat
        pop
        %% x saber si actua l'overprint
        false /opactua exch def
       }ifelse
      }ifelse
     }
     {  %% hi ha op pero l'overprint es a false
      %% x saber si actua l'overprint
      false /opactua exch def
     }ifelse
    }
    {
     dup /op known  %% primer mirem si hi ha op al dic
     {  %% hi ha op
      dup /op get
      {  %% op es a true x tan l'overprint es activat
       dup /OPM known
       {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
        /OPM get 1 eq
        {  %% val 1 ... l'Overprint es actiu tret que l'espai de color actual sigui DeviceN amb +1 component
         es4c
         {  %% n'hi ha prou x saber si es CMYK ?
          %% x saber si actua l'overprint
          true /opactua exch def
         }
         {  %% sera DeviceN o Separation
          NomesUn {true /opactua exch def}{false /opactua exch def}ifelse        
         }ifelse
        }
        {  %% val 0 ... l'Overprint no esta activat en cas q l'espai de color actual sigui CMYK o DeviceN tingui +1 component
         es4c
         {  %% n'hi ha prou x saber si es CMYK ?
          %% x saber si actua l'overprint
          false /opactua exch def
         }
         {  %% sera DeviceN o Separation
          NomesUn {true /opactua exch def}{false /opactua exch def}ifelse        
         }ifelse
        }ifelse
       }
       {  %% l'Overprint no esta activat
        %% x saber si actua l'overprint
        false /opactua exch def
        pop
       }ifelse
      }
      {  %% op es a false x tant l'overprint esta desactivat
       %% x saber si actua l'overprint
       false /opactua exch def
       pop
      }ifelse
     }
     {  %% no hi ha op, doncs ara mirem si hi ha OP doncs en fa el paper en la seva absencia
      dup /OP known
      {
       dup /OP get
       {  %% OP es a true x tant l'overprint es activat
        dup /OPM known
        {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
         /OPM get 1 eq
         {  %% val 1 ... l'Overprint es actiu tret que l'espai de color actual sigui DeviceN amb +1 component
          es4c
          {  %% n'hi ha prou x saber si es CMYK ?
           %% x saber si actua l'overprint
           true /opactua exch def
          }
          {  %% sera DeviceN o Separation
           NomesUn {true /opactua exch def}{false /opactua exch def}ifelse        
          }ifelse
         }
         {  %% val 0 ... l'Overprint no esta activat en cas q l'espai de color actual sigui CMYK o DeviceN tingui +1 component
          es4c
          {  %% n'hi ha prou x saber si es CMYK ?
           %% x saber si actua l'overprint
           false /opactua exch def
          }
          {  %% sera DeviceN o Separation
           NomesUn {true /opactua exch def}{false /opactua exch def}ifelse        
          }ifelse
         }ifelse
        }
        {  %% l'Overprint no esta activat
         pop
         %% x saber si actua l'overprint
         false /opactua exch def
        }ifelse
       }
       {  %% l'Overprint no esta activat
        pop
        %% x saber si actua l'overprint
        false /opactua exch def
       }ifelse
      }
      {  %% l'Overprint no esta activat
       pop
       %% x saber si actua l'overprint
       false /opactua exch def
      }ifelse
     } ifelse
    }ifelse  %% del null
    %% fi opactua
    %% avaluem OPactua
    dup XRay /EstatsGrafics get /Utilitzats get exch get
    1 get 0 get dup
    null eq
    {  %% l'Overprint no esta activat
     pop
     %% x saber si actua l'overprint
     false /OPactua exch def
    }
    {
     dup /OP known  %% primer mirem si si ha OP al dic
     {
      dup /OP get
      {
       dup /OPM known
       {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
        /OPM get 1 eq
        {  %% val 1 ... l'Overprint es actiu tret que l'espai de color actual sigui DeviceN amb +1 component
         es4c
         {  %% n'hi ha prou x saber si es CMYK ?
          %% x saber si actua l'overprint
          true /OPactua exch def
         }
         {  %% sera DeviceN o Separation
          NomesUn {true /OPactua exch def}{false /OPactua exch def}ifelse        
         }ifelse
        }
        {  %% val 0 ... l'Overprint no esta activat en cas q l'espai de color actual sigui CMYK o DeviceN tingui +1 component
         es4c
         {  %% n'hi ha prou x saber si es CMYK ?
          %% x saber si actua l'overprint
          false /OPactua exch def
         }
         {  %% sera DeviceN o Separation
          NomesUn {true /OPactua exch def}{false /OPactua exch def}ifelse        
         }ifelse
        }ifelse
       }
       {  %% l'Overprint no esta activat
        pop
        %% x saber si actua l'overprint
        false /OPactua exch def
       }ifelse
      }
      {  %% l'Overprint no esta activat
       pop
       %% x saber si actua l'overprint
       false /OPactua exch def
      }ifelse
     }
     {  %% l'Overprint no esta activat
      pop
      %% x saber si actua l'overprint
      false /OPactua exch def
     } ifelse
    } ifelse  %% del null
    %% fi OPactua

    %%% fi d'avaluador del gatell OPactua i opactua
    %%opactua == es4c == NomesUn == () ==
    %%(?????????????) pstack quit

    %% cal jugar amb el gsARA ?
    dup gsARA exch 0 exch put

    %% NO estem segurs si els estats grafics els hem d'escriure sempre o no
    TiNTeMF TiNTeMS or  %% un dels dos ha de ser cert
    {  %% es la tinta que toca ara ?
     %% /DesTintem false def

     %%***1***% ep aqui hauriem de mirar si es un PureCMYK x controlar-li l'OPM ...
     %% ho completarem si ensopeguem amb el cas filtrat al final del punt %45% tambe marcat amb ***1***
     %%dup gsARA 0 3 -1 roll put  % afegim sempre a la posicio 0 el nom del GState actual
     %% tibarem la clau del GState i amb el numeric del gatell Tfill en treurem l'array que toca (per fill o stroke) i pescarem el nom del dic clonic, que hem d'utilitzar per la substitucio, a la posicio 2.
     %%dup XRay /EstatsGrafics get /Utilitzats get exch get Tfill get 2 get dup
     %%null eq {pop}{exch pop}ifelse  % si duu un null es que es un GState sense op/OP (no els hauriem d'anular d'origen?)
     %%% aquest gatell determina si escrivim o no la crida gs ...
     %%Tzero {pop}{  % si val true (hem pintat amb tinta zero --blanca--) NO escrivim res

     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 ( gs\012) writestring

     %%} ifelse

     %% TacaTintaF 0 eq TacaTintaS 0 eq and
     %% {
     %%  XRay /EstatsGrafics get /Utilitzats get gsARA 0 get get
     %%  Tfill get 0 get
     %%  null eq
     %%         {
     %%          % l'Overprint NO es actiu
     %%         }
     %%         {
     %%          % l'Overprint es actiu
     %%          /TiNTeM false def  % DESactivem l'escriptura
     %%         }ifelse
     %% } if
    }
    {  %% NO es la Tinta que toca ...
     %%          /DesTintem false def
     esUnPS
     {  %% ... pero es un Pattern&Shading ...
      sepPS
      {  %% ... i ens estem executant dins el context d'un stream de Patterns&Shadings
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %% /ppop true def
        Tfill 0 eq
        {
         sEdAs2 (0 0 0 0 k\012) writestring
         0 /TacaTintaF exch def
        }
        {
         sEdAs2 (0 0 0 0 K\012) writestring
         0 /TacaTintaS exch def
        }ifelse

        %% Tfill 0 eq {
        %%             [0 0 0 0] dup 3 TacaTinta put
        %%	    {
        %%	      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
        %%	     } forall
        %%             sEdAs2 (k\015) writestring
        %%            }
        %%            {
        %%             [0 0 0 0] dup 3 TacaTinta put
        %%	     {
        %%	      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
        %%	     } forall
        %%            sEdAs2 (K\015) writestring
        %%            }ifelse

        %%sEdAs2 (0 0 0 0 k\0150 0 0 0 K\015) writestring
        /TiNTeMF true def  %% reactivem l'escriptura
        /TiNTeMS true def  %% reactivem l'escriptura
          
        %%          /DesTintem true def
       
       }
       {  %% l'Overprint es actiu
        %% /ppop false def
        %%          /TiNTeM true def  % NO reactivem l'escriptura
        %%sEdAs2 (0 0 0 0 k\0150 0 0 0 K\015) writestring
       } ifelse
      }
      {  %% ... i NO ens estem executant dins el context d'un stream de Patterns&Shadings
       pop
       /TiNTeMF false def  %% DESactivem l'escriptura
       /TiNTeMS false def  %% DESactivem l'escriptura
      }ifelse
     }
     {  %% ... NO es un Pattern&Shading
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill get 0 get
      null eq
      {  %% l'Overprint no esta activat
       Tfill 0 eq
       {
        sEdAs2 (0 0 0 0 k\012) writestring
        0 /TacaTintaF exch def
        /TiNTeMF true def  %% reactivem l'escriptura
       }
       {
        sEdAs2 (0 0 0 0 K\012) writestring
        0 /TacaTintaS exch def
        /TiNTeMS true def  %% reactivem l'escriptura
       }ifelse
      }
      {  %% l'Overprint es actiu
      } ifelse
     } ifelse
    }ifelse  %% de la tinta que toca ara
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    %%{  % stopped
    dup /ARAgs exch def  %% desem l'estat grafic per reescriure'l al repicat de la imatge clau del mosaic
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 ( gs\012) writestring
    %%}stopped{( ... peta gs) == quit}if
   }
   {  %% 3 (repicat idem sense XRay) verificacio de PDF
    {  % stopped
    %% /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 ( gs\012) writestring
    }stopped{( ... peta gs) == quit}if
   }
   {  %% 4 gatell 16 MASATS
    {  % stopped
    dup /ARAgs exch def  %% desem l'estat grafic per reescriure'l al repicat, si cal
    dup XRay /EstatsGrafics get /Desconeguts get exch null put  %% desem a XRay els estats grafics utilitzats
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 ( gs\012) writestring
    }stopped{( ... peta gs) pstack quit}if
   }
  ] i_gs get /gs exch bind def

%% (no implementats) 4.3.4 Graphics State Parameter Dictionaries

  %% (PDF Ref ?) 8.6.1 Path segment operators
  %% (PDF Ref 1.7) 4.4.1 Path Construction Operators
  [  %% m
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop pop
     }
     {
      %%dup 292.218 eq {/nYaca true def}{/nYaca false def}ifelse
      %%TiNTeM {  % es la tinta que toca ara ?
      exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (m\012) writestring
      %%}{pop pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta m) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%dup 292.218 eq {/nYaca true def}{/nYaca false def}ifelse
    %%TiNTeM {  % es la tinta que toca ara ?
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (m\012) writestring
    %%}{pop pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta m) pstack quit}if
   }
  ] i_m get /m exch bind def

  [  %% l
   {  %% 0 eliminem continguts
    alFoc
    {
     pop pop
    }
    {
     DuuLlesques not
     {
      VectorViu not  %% sempre q NO estigui obert
      {
       %% anellem la llesca sense destriar, de moment, els Forms
       sEdAs2 dup dup (/OC ) writestring
       llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
       1 get writestring ( BDC\012) writestring
       /VectorViu true def  %% obrim el gatell de l'anellat vectorial
      }if
     }if
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (l\012) writestring
    }ifelse
   }
   {  %% 1 (separacions + relligat d'imatges)                    
    {  % stopped
    %%% TEST
    %%dup 144.606 eq {quinaTinta /Yellow eq {/Kfem true def}{/Kfem false def}ifelse}{/Kfem false def}ifelse
    %%TiNTeM {  % es la tinta que toca ara ?
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (l\012) writestring
    %%}{pop pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta l) pstack quit}if
   }
   {  %% 2  verificacio de PDF
    DuuLlesques not
    {
     VectorViu not  %% sempre q NO estigui obert
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
      1 get writestring ( BDC\012) writestring
      /VectorViu true def  %% obrim el gatell de l'anellat vectorial
     }if
    }if
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (l\012) writestring
   }
  ] i_l get /l exch bind def

  [  %% c
   {  %% 0 eliminem continguts
    alFoc
    {
     pop pop pop pop pop pop
    }
    {
     DuuLlesques not
     {
      VectorViu not  %% sempre q NO estigui obert
      {
       %% anellem la llesca sense destriar, de moment, els Forms
       sEdAs2 dup dup (/OC ) writestring
       llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
       1 get writestring ( BDC\012) writestring
       /VectorViu true def  %% obrim el gatell de l'anellat vectorial
      }if
     }if
     count dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs2 (c\012) writestring
    }ifelse
   }
   {  %% 1 (separacions + relligat d'imatges)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    6 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (c\012) writestring
    %%}{6{pop}repeat}ifelse  % de la tinta que toca ara
    }stopped{( ... peta c) pstack quit}if
   }
   {  %% 2 verificacio de PDF
    DuuLlesques not
    {
     VectorViu not  %% sempre q NO estigui obert
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
      1 get writestring ( BDC\012) writestring
      /VectorViu true def  %% obrim el gatell de l'anellat vectorial
     }if
    }if
    count dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (c\012) writestring
   }
  ] i_c get /c exch bind def

  [  %% v
   {  %% 0 eliminem continguts
    alFoc
    {
     pop pop pop pop
    }
    {
     DuuLlesques not
     {
      VectorViu not  %% sempre q NO estigui obert
      {
       %% anellem la llesca sense destriar, de moment, els Forms
       sEdAs2 dup dup (/OC ) writestring
       llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
       1 get writestring ( BDC\012) writestring
       /VectorViu true def  %% obrim el gatell de l'anellat vectorial
      }if
     }if
     count dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs2 (v\012) writestring
    }ifelse
   }
   {  %% 1 (separacions + relligat d'imatges)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (v\012) writestring
    %%}{4{pop}repeat}ifelse  % de la tinta que toca ara
    }stopped{( ... peta v) pstack quit}if
   }
   {  %% 2 verificacio de PDF
    DuuLlesques not
    {
     VectorViu not  %% sempre q NO estigui obert
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
      1 get writestring ( BDC\012) writestring
      /VectorViu true def  %% obrim el gatell de l'anellat vectorial
     }if
    }if
    count dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (v\012) writestring
   }
  ] i_v get /v exch bind def

  [  %% y
   {  %% 0 eliminem continguts
    alFoc
    {
     pop pop pop pop
    }
    {
     DuuLlesques not
     {
      VectorViu not  %% sempre q NO estigui obert
      {
       %% anellem la llesca sense destriar, de moment, els Forms
       sEdAs2 dup dup (/OC ) writestring
       llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
       1 get writestring ( BDC\012) writestring
       /VectorViu true def  %% obrim el gatell de l'anellat vectorial
      }if
     }if
     count dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs2 (y\012) writestring
    }ifelse
   }
   {  %% 1 (separacions + relligat d'imatges)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (y\012) writestring
    %%}{4{pop}repeat}ifelse  % de la tinta que toca ara
    }stopped{( ... peta y) pstack quit}if
   }
   {  %% 2 verificacio de PDF
    DuuLlesques not
    {
     VectorViu not  %% sempre q NO estigui obert
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
      1 get writestring ( BDC\012) writestring
      /VectorViu true def  %% obrim el gatell de l'anellat vectorial
     }if
    }if
    count dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (y\012) writestring
   }
  ] i_y get /y exch bind def

  [  %% h
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs2 (h\012) writestring
     %%}if  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta h) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs2 (h\012) writestring
    %%}if  % de la tinta que toca ara
    }stopped{( ... peta h) pstack quit}if
   }
  ] i_h get /h exch bind def

  [  %% re
   {  %% 0 eliminem continguts
    alFoc
    {
     pop pop pop pop
    }
    {
     DuuLlesques not
     {
      VectorViu not  %% sempre q NO estigui obert
      {
       %% anellem la llesca sense destriar, de moment, els Forms
       sEdAs2 dup dup (/OC ) writestring
       llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
       1 get writestring ( BDC\012) writestring
       /VectorViu true def  %% obrim el gatell de l'anellat vectorial
      }if
     }if
     count dup /RoLL exch def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs2 (re\012) writestring
    }ifelse
   }
   {  %% 1 (separacions)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    4 dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (re\012) writestring
    %%}{4{pop}repeat}ifelse  % de la tinta que toca ara
    }stopped{( ... peta re) pstack quit}if
   }
   {  %% 2 (relligat d'imatges)
    %%{  % stopped
    %%4 copy 4 array astore /DRaT exch def  % desem les coordenades del rectangle (podrien activar un clip a les imatges del trencaclosques)
    count dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (re\012) writestring
    %%}stopped{( ... peta re) == quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques not
    {
     VectorViu not  %% sempre q NO estigui obert
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 3 get dup 0 true put  %% marquem els Vectorials com actius
      1 get writestring ( BDC\012) writestring
      /VectorViu true def  %% obrim el gatell de l'anellat vectorial
     }if
    }if
    count dup /RoLL exch def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (re\012) writestring
   }
  ] i_re get /re exch bind def

  %% (PDF Ref ?) 8.6.2 Path painting operators
  %% (PDF Ref 1.7) 4.4.2 Path-Painting Operators
  [  %% S
   {  %% 0 eliminem continguts
    %%test
    %%{  % stopped
    alFoc
    {
    }
    {
     %% /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     DuuLlesques
     {
      sEdAs2 (S\012) writestring
     }
     {
      sEdAs2 (S\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
    %%test
    %%}stopped{( ... peta S) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    /Tfill 1 def  %% ara posem a l'inici de cada operador de pintat el gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    TiNTeMS
    {  %% es la tinta que toca ara ?
     LaQtocaS
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaS 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {
        %%(S0a) ==
        pop sEdAs2 (0 0 0 0 K S\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(S0b) ==
          sEdAs2 (0 0 0 0 K S\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(S0c) ==
          OPactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
          {  %% l'Overprint es actiu
           %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
           TacaTintaS 0 eq
           {  %% matem el path amb 'n'
            sEdAs2 (n\012) writestring
           }
           {
            sEdAs2 (S\012) writestring
           }ifelse
          }
          {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
           sEdAs2 (0 0 0 0 K S\012) writestring
          }ifelse 
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%(S0d) ==
           sEdAs2 (0 0 0 0 K S\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(S0e) ==
           OPactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaS 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (S\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 K S\012) writestring
           } ifelse
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%(S0f) ==
           sEdAs2 (0 0 0 0 K S\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(S0g) ==
           OPactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaS 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (S\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 K S\012) writestring
           } ifelse
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%(S0h) ==
       sEdAs2 (S\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {
       %%(S1) ==
       pop sEdAs2 (0 0 0 0 K S\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(S2) ==
         sEdAs2 (0 0 0 0 K S\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(S3) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% OPactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 K S\015) writestring
         %% }ifelse
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%(S4) ==
          sEdAs2 (0 0 0 0 K S\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(S5) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          %% OPactua
          %% {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
          %% }
          %% {
          %% sEdAs2 (0 0 0 0 K S\015) writestring
          %% }ifelse
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(S6) ==
          sEdAs2 (0 0 0 0 K S\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(S7) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          %% OPactua
          %% {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
          %% }
          %% {
          %% sEdAs2 (0 0 0 0 K S\015) writestring
          %% }ifelse
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% l'overprint no es actiu
      %%(S8) ==
      pop sEdAs2 (0 0 0 0 K S\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%(S9) ==
        sEdAs2 (0 0 0 0 K S\012) writestring
       }
       {  %% l'Overprint es actiu
        %%(S10) ==
        %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res                       
        %% OPactua
        %% {
        sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        %% }
        %% {
        %% sEdAs2 (0 0 0 0 K S\015) writestring
        %% }ifelse
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%(S11) ==
         sEdAs2 (0 0 0 0 K S\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(S12) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% OPactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 K S\015) writestring
         %% }ifelse
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(S13) ==
         sEdAs2 (0 0 0 0 K S\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(S14) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% OPactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 K S\015) writestring
         %% }ifelse
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    {  % stopped
    sEdAs2 (S\012) writestring
    }stopped{( ... peta S) pstack quit}if
   }
   {  %% 3 verificacio de PDF del Col·legi
    %%test
    %%{  % stopped
    %% /LleixaBuida false def  % gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    DuuLlesques
    {
     sEdAs2 (S\012) writestring
    }
    {
     sEdAs2 (S\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
    %%test
    %%}stopped{( ... peta S) == quit}if
   }
  ] i_S get /S exch bind def

  [  %% s
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (s\012) writestring
     }
     {
      sEdAs (s\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    /Tfill 1 def  %% ara posem a l'inici de cada operador de pintat el gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    TiNTeMS
    {  %% es la tinta que toca ara ?
     LaQtocaS
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaS 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {
        %%(s0a) ==
        pop sEdAs2 (0 0 0 0 K s\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(s0b) ==
          sEdAs2 (0 0 0 0 K s\012) writestring
         }
         {  %% l'Overprint es actiu?
          %%(s0c) ==
          OPactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
          {  %% l'Overprint es actiu
           %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
           TacaTintaS 0 eq
           {  %% matem el path amb 'n'
            sEdAs2 (n\012) writestring
           }
           {
            sEdAs2 (s\012) writestring
           }ifelse
          }
          {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
           sEdAs2 (0 0 0 0 K s\012) writestring
          }ifelse
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%(s0d) ==
           sEdAs2 (0 0 0 0 K s\012) writestring
          }
          {  %% l'Overprint es actiu?
           %%(s0e) ==
           OPactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaS 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (s\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 K s\012) writestring
           }ifelse
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%(s0f) ==
           sEdAs2 (0 0 0 0 K s\012) writestring
          }
          {  %% l'Overprint es actiu?
           %%(s0g) ==
           OPactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaS 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (s\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 K s\012) writestring
           }ifelse
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%(s0h) ==
       sEdAs2 (s\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {  %% l'overprint no es actiu
       %%(s1) ==
       pop sEdAs2 (0 0 0 0 K s\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(s2) ==
         sEdAs2 (0 0 0 0 K s\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(s3) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% OPactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 K s\015) writestring
         %% }ifelse
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%(s4) ==
          sEdAs2 (0 0 0 0 K s\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(s5) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          %% OPactua
          %% {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
          %% }
          %% {
          %% sEdAs2 (0 0 0 0 K s\015) writestring
          %% }ifelse
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(s6) ==
          sEdAs2 (0 0 0 0 K s\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(s7) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          %% OPactua
          %% {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
          %% }
          %% {
          %% sEdAs2 (0 0 0 0 K s\015) writestring
          %% }ifelse
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% l'Overprint no esta activat
      %%(s8) ==
      pop sEdAs2 (0 0 0 0 K s\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%(s9) ==
        sEdAs2 (0 0 0 0 K s\012) writestring
       }
       {  %% l'Overprint es actiu
        %%(s10) ==
        %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
        %% OPactua
        %% {
        sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        %% }
        %% {
        %% sEdAs2 (0 0 0 0 K s\015) writestring
        %% }ifelse
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%(s11) ==
         sEdAs2 (0 0 0 0 K s\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(s12) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% OPactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 K s\015) writestring
         %% }ifelse
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(s13) ==
         sEdAs2 (0 0 0 0 K s\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(s14) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% OPactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 K s\015) writestring
         %% }ifelse
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    {  % stopped
    sEdAs2 (s\012) writestring
    }stopped{( ... peta s) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (s\012) writestring
    }
    {
     sEdAs (s\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_s get /s exch bind def

  [  %% f
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (f\012) writestring
     }
     {
      sEdAs2 (f\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    /Tfill 0 def  %% ara posem a l'inici de cada operador de pintat el gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    TiNTeMF
    {  %% es la tinta que toca ara ?
     LaQtocaF
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaF 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {
        %%(f0a) ==
        pop sEdAs2 (0 0 0 0 k f\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(f0b) ==
          sEdAs2 (0 0 0 0 k f\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(f0c) ==
          opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
          {  %% l'Overprint es actiu
           %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
           TacaTintaF 0 eq
           {  %% matem el path amb 'n'
            sEdAs2 (n\012) writestring
           }
           {
            sEdAs2 (f\012) writestring
           }ifelse
          }
          {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
           sEdAs2 (0 0 0 0 k f\012) writestring
          } ifelse
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%(f0d) ==
           sEdAs2 (0 0 0 0 k f\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(f0e) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (f\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k f\012) writestring
           } ifelse
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%(f0f) ==
           sEdAs2 (0 0 0 0 k f\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(f0g) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (f\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k f\012) writestring
           } ifelse
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%(f0h) ==
       sEdAs2 (f\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {
       %%(f1) ==
       pop sEdAs2 (0 0 0 0 k f\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(f2) ==
         sEdAs2 (0 0 0 0 k f\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(f3) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% opactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 k f\015) writestring
         %% }ifelse
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%(f4) ==
          sEdAs2 (0 0 0 0 k f\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(f5) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          %% opactua
          %% {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
          %% }
          %% {
          %% sEdAs2 (0 0 0 0 k f\015) writestring
          %% }ifelse
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(f6) ==
          sEdAs2 (0 0 0 0 k f\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(f7) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          %% opactua
          %% {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
          %% }
          %% {
          %% sEdAs2 (0 0 0 0 k f\015) writestring
          %% }ifelse
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% overprint no actiu
      %%(f8) ==
      pop sEdAs2 (0 0 0 0 k f\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%(f9) ==
        sEdAs2 (0 0 0 0 k f\012) writestring
       }
       {  %% l'Overprint es actiu
        %%(f10) ==
        %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
        %% opactua
        %% {
        sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        %% }
        %% {
        %% sEdAs2 (0 0 0 0 k f\015) writestring
        %% }ifelse
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%(f11) ==
         sEdAs2 (0 0 0 0 k f\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(f12) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% opactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 k f\015) writestring
         %% }ifelse
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(f13) ==
         sEdAs2 (0 0 0 0 k f\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(f14) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %% opactua
         %% {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %% }
         %% {
         %% sEdAs2 (0 0 0 0 k f\015) writestring
         %% }ifelse
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    {  % stopped
    sEdAs2 (f\012) writestring
    }stopped{( ... peta f) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (f\012) writestring
    }
    {
     sEdAs2 (f\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_f get /f exch bind def

  [  %% F
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (F\012) writestring
     }
     {
      sEdAs2 (F\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    /Tfill 0 def  %% ara posem a l'inici de cada operador de pintat el gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    TiNTeMF
    {  %% es la tinta que toca ara ?
     LaQtocaF
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaF 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {
        %%(F0a) ==
        pop sEdAs2 (0 0 0 0 k F\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(F0b) ==
          sEdAs2 (0 0 0 0 k F\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(F0c) ==
          sEdAs2 (F\012) writestring  %% matem el path amb 'n'
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%(F0d) ==
           sEdAs2 (0 0 0 0 k F\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(F0e) ==
           sEdAs2 (F\012) writestring  %% matem el path amb 'n'
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%(F0f) ==
           sEdAs2 (0 0 0 0 k F\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(F0g) ==
           sEdAs2 (F\012) writestring  %% matem el path amb 'n'
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%(F0h) ==
       sEdAs2 (F\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {
       %%(F1) ==
       pop sEdAs2 (0 0 0 0 k F\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(F2) ==
         sEdAs2 (0 0 0 0 k F\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(F3) ==
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%(F4) ==
          sEdAs2 (0 0 0 0 k F\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(F5) ==
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(F6) ==
          sEdAs2 (0 0 0 0 k F\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(F7) ==
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% l'overprint no es actiu
      %%(F8) ==
      pop sEdAs2 (0 0 0 0 k F\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%(F9) ==
        sEdAs2 (0 0 0 0 k F\012) writestring
       }
       {  %% l'Overprint es actiu
        %%(F10) ==
        NomesUn %% gatell de control de si l'espai de color te 1 o + components
        {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        }
        {
         sEdAs2 (0 0 0 0 k F\012) writestring
        }ifelse
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%(F11) ==
         sEdAs2 (0 0 0 0 k F\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(F12) ==
         NomesUn  %% gatell de control de si l'espai de color te 1 o + components
         {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         }
         {
          sEdAs2 (0 0 0 0 k F\012) writestring
         }ifelse
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(F13) ==
         sEdAs2 (0 0 0 0 k F\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(F14) ==
         NomesUn  %% gatell de control de si l'espai de color te 1 o + components
         {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         }
         {
          sEdAs2 (0 0 0 0 k F\012) writestring
         }ifelse
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    {  % stopped
    sEdAs2 (F\012) writestring
    }stopped{( ... peta F) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (F\012) writestring
    }
    {
     sEdAs2 (F\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_F get /F exch bind def

  [  %% f*
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (f*\012) writestring
     }
     {
      sEdAs2 (f*\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    /Tfill 0 def  %% ara posem a l'inici de cada operador de pintat el gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    %% Kfem {( ... ) == TiNTeMF == LaQtocaF == TacaTintaF == gsARA 0 get == ( ... ) ==}if
    TiNTeMF
    {  %% es la tinta que toca ara ?
     LaQtocaF
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaF 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {  %% l'overprint no es actiu
        %%     (f*0a) ==
        pop sEdAs2 (0 0 0 0 k f*\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%       (f*0b) ==
          sEdAs2 (0 0 0 0 k f*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%       (f*0c) ==
          opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
          {  %% l'Overprint es actiu
           %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
           TacaTintaF 0 eq
           {  %% matem el path amb 'n'
            sEdAs2 (n\012) writestring
           }
           {
            sEdAs2 (f*\012) writestring
           }ifelse
          }
          {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
           sEdAs2 (0 0 0 0 k f*\012) writestring
          } ifelse
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%        (f*0d) ==
           sEdAs2 (0 0 0 0 k f*\012) writestring
          }
          {  %% l'Overprint es actiu
           %%        (f*0e) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (f*\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k f*\012) writestring
           } ifelse
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%        (f*0f) ==
           sEdAs2 (0 0 0 0 k f*\012) writestring
          }
          {  %% l'Overprint es actiu
           %%        (f*0g) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (f*\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k f*\012) writestring
           } ifelse
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%    (f*0h) ==
       sEdAs2 (f*\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {  %% l'overpint no es actiu
       %%    (f*1) ==
       pop sEdAs2 (0 0 0 0 k f*\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill
       %%              Kfem {pstack (-----) == quit} if
       1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%      (f*2) ==
         sEdAs2 (0 0 0 0 k f*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%      (f*3) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %%      opactua
         %%      {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %%      }
         %%      {
         %%       sEdAs2 (0 0 0 0 k f*\015) writestring
         %%      }ifelse
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%       (f*4) ==
          sEdAs2 (0 0 0 0 k f*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%       (f*5) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          %%       opactua
          %%       {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
          %%       }
          %%       {
          %%        sEdAs2 (0 0 0 0 k f*\015) writestring
          %%       }ifelse
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%       (f*6) ==
          sEdAs2 (0 0 0 0 k f*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%       (f*7) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          %%       opactua
          %%       {
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
          %%       }
          %%       {
          %%        sEdAs2 (0 0 0 0 k f*\015) writestring
          %%       }ifelse
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%%test
     %%nYaca {( ... ) ==}if
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% l'overprint no es actiu
      %%   (f*8) ==
      pop
      sEdAs2 (0 0 0 0 k f*\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%     (f*9) ==
        sEdAs2 (0 0 0 0 k f*\012) writestring
       }
       {  %% l'Overprint es actiu
        %%     (f*10) ==
        %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
        %%     opactua
        %%     {
        sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        %%     }
        %%     {
        %%      sEdAs2 (0 0 0 0 k f*\015) writestring
        %%     }ifelse
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%      (f*11) ==
         sEdAs2 (0 0 0 0 k f*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%      (f*12) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %%      opactua
         %%      {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %%      }
         %%      {
         %%       sEdAs2 (0 0 0 0 k f*\015) writestring
         %%      }ifelse
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%      (f*13) ==
         sEdAs2 (0 0 0 0 k f*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%      (f*14) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         %%      opactua
         %%      {
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         %%      }
         %%      {
         %%       sEdAs2 (0 0 0 0 k f*\015) writestring
         %%      }ifelse
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
     %%%test
     %%nYaca {( ... ) ==}if
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    {  % stopped
    sEdAs2 (f*\012) writestring
    }stopped{( ... peta f*) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (f*\012) writestring
    }
    {
     sEdAs2 (f*\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_f* get /f* exch bind def

  [  %% B
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (B\012) writestring
     }
     {
      sEdAs2 (B\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%% ep aqui no  li posem, doncs com li hauriem de dir si val tan x fill com x stroke ?
    %% /Tfill 1 def
    TiNTeMF
    {  %% es la tinta que toca ara ?
     LaQtocaF
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaF 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {
        %%(B0a) ==
        pop sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(B0b) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B0c) ==
          opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
          {  %% l'Overprint es actiu
           %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
           TacaTintaF 0 eq
           {  %% matem el path amb 'n'
            sEdAs2 (n\012) writestring
           }
           {
            sEdAs2 (B\012) writestring
           }ifelse
          }
          {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
           sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
          } ifelse
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%(B0d) ==
           sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(B0e) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (B\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
           } ifelse
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%(B0f) ==
           sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(B0g) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (B\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
           } ifelse
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%(B0h) ==
       sEdAs2 (B\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {
       %%(B1) ==
       pop sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(B2) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B3) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%(B4) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B5) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(B6) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B7) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% overprint no actiu
      %%(B8) ==
      pop sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%(B9) ==
        sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
       }
       {  %% l'Overprint es actiu
        %%(B10) ==
        %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
        sEdAs2 (n\012) writestring  %% matem el path amb 'n'
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%(B11) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B12) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(B13) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K B\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B14) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    {  % stopped
    sEdAs2 (B\012) writestring
    }stopped{( ... peta B) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (B\012) writestring
    }
    {
     sEdAs2 (B\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_B get /B exch bind def

  [  %% B*
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (B*\012) writestring
     }
     {
      sEdAs2 (B*\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%% ep aqui no  li posem, doncs com li hauriem de dir si val tan x fill com x stroke ?
    %% /Tfill 1 def
    TiNTeMF
    {  %% es la tinta que toca ara ?
     LaQtocaF
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaF 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {
        %%(B0a) ==
        pop sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(B0b) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B0c) ==
          opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
          {  %% l'Overprint es actiu
           %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
           TacaTintaF 0 eq
           {  %% matem el path amb 'n'
            sEdAs2 (n\012) writestring
           }
           {
            sEdAs2 (B*\012) writestring
           }ifelse
          }
          {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
           sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
          } ifelse
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%(B0d) ==
           sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(B0e) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (B*\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
           } ifelse
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%(B0f) ==
           sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(B0g) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (B*\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
           } ifelse
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%(B0h) ==
       sEdAs2 (B*\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {
       %%(B1) ==
       pop sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(B2) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B3) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%(B4) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B5) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(B6) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B7) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% overprint no actiu
      %%(B8) ==
      pop sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%(B9) ==
        sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
       }
       {  %% l'Overprint es actiu
        %%(B10) ==
        %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
        sEdAs2 (n\012) writestring  %% matem el path amb 'n'
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%(B11) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B12) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(B13) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K B*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B14) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    {  % stopped
    sEdAs2 (B*\012) writestring
    }stopped{( ... peta B*) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (B*\012) writestring
    }
    {
     sEdAs2 (B*\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_B* get /B* exch bind def

  [  %% b
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (b\012) writestring
     }
     {
      sEdAs2 (b*\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%% ep aqui no  li posem, doncs com li hauriem de dir si val tan x fill com x stroke ?
    %% /Tfill 1 def
    TiNTeMF
    {  %% es la tinta que toca ara ?
     LaQtocaF
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaF 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {
        %%(b0a) ==
        pop sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(b0b) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(b0c) ==
          opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
          {  %% l'Overprint es actiu
           %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
           TacaTintaF 0 eq
           {  %% matem el path amb 'n'
            sEdAs2 (n\012) writestring
           }
           {
            sEdAs2 (b\012) writestring
           }ifelse
          }
          {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
           sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
          } ifelse
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%(b0d) ==
           sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(b0e) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (b\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
           } ifelse
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%(b0f) ==
           sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(b0g) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (b\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
           } ifelse
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%(b0h) ==
       sEdAs2 (b\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {
       %%(b1) ==
       pop sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(b2) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(b3) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%(b4) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(b5) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(b6) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(b7) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% overprint no actiu
      %%(b8) ==
      pop sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%(b9) ==
        sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
       }
       {  %% l'Overprint es actiu
        %%(b10) ==
        %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
        sEdAs2 (n\012) writestring  %% matem el path amb 'n'
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%(b11) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(b12) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(b13) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K b\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(b14) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    {  % stopped
    sEdAs2 (b\012) writestring
    }stopped{( ... peta b) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (b\012) writestring
    }
    {
     sEdAs2 (b*\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_b get /b exch bind def
  %%%fins aqui els canvis amb les b !!!!! (manquen encara B, b* i B* ??)

  [  %% b*
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (b*\012) writestring
     }
     {
      sEdAs2 (b*\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%% ep aqui no  li posem, doncs com li hauriem de dir si val tan x fill com x stroke ?
    %% /Tfill 1 def
    TiNTeMF
    {  %% es la tinta que toca ara ?
     LaQtocaF
     {  %% apliquem tambe les lleis de l'overprint si la tinta toca ...
      TacaTintaF 0 eq  %% aqui si que cal fer el test de la tinta!
      {
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca 
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get}{0 get}ifelse
       }ifelse
       dup null eq
       {
        %%(B0a) ==
        pop sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
       }
       {  %% x filtrar Null
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill 1 eq
        {  %% com que es OP llavors, cap problema
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(B0b) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B0c) ==
          opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
          {  %% l'Overprint es actiu
           %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
           TacaTintaF 0 eq
           {  %% matem el path amb 'n'
            sEdAs2 (n\012) writestring
           }
           {
            sEdAs2 (b*\012) writestring
           }ifelse
          }
          {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
           sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
          } ifelse
         } ifelse
        }
        {  %% si es op cal assegurar-se que ...
         dup Tfill get 2 get  %% op es definit al gs actual ?
         null eq
         {  %% el gs actual NO te definit op
          1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
          null eq
          {  %% l'Overprint no esta activat
           %%(B0d) ==
           sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(B0e) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (b*\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
           } ifelse
          } ifelse
         }
         {  %% el gs actual SI te definit op
          Tfill get 0 get
          null eq
          {  %% l'Overprint no esta activat
           %%(B0f) ==
           sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
          }
          {  %% l'Overprint es actiu
           %%(B0g) ==
           opactua  %% ens en assegurem pel tema de l'OPM 0 de CMYK
           {  %% l'Overprint es actiu
            %% si es la tinta que toca + el % es zero i l'overprint es activat doncs ...
            TacaTintaF 0 eq
            {  %% matem el path amb 'n'
             sEdAs2 (n\012) writestring
            }
            {
             sEdAs2 (b*\012) writestring
            }ifelse
           }
           {  %% l'Overprint no esta activat segurament pel tema de l'OPM 0 de CMYK
            sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
           } ifelse
          } ifelse
         }ifelse
        }ifelse
       } ifelse  %% x filtrar Null
      }
      {  %% el valor de tinta es diferent de zero
       %%(B0h) ==
       sEdAs2 (b*\012) writestring
      }ifelse
     }
     {  %% potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {
       %%(B1) ==
       pop sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
      }
      {  %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(B2) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B3) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%(B4) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B5) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%(B6) ==
          sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
         }
         {  %% l'Overprint es actiu
          %%(B7) ==
          %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
          sEdAs2 (n\012) writestring  %% matem el path amb 'n'
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan LaQtoca?
     %%% TacaTinta 0 eq  % abandonem el test del valor de la tinta!
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca 
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get}{0 get}ifelse
     }ifelse
     dup null eq
     {  %% overprint no actiu
      %%(B8) ==
      pop sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
     }
     {  %% x filtrar Null
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill 1 eq
      {  %% com que es OP llavors, cap problema
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        %%(B9) ==
        sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
       }
       {  %% l'Overprint es actiu
        %%(B10) ==
        %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
        sEdAs2 (n\012) writestring  %% matem el path amb 'n'
       } ifelse
      }
      {  %% si es op cal assegurar-se que ...
       dup Tfill get 2 get  %% op es definit al gs actual ?
       null eq
       {  %% el gs actual NO te definit op
        1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
        null eq
        {  %% l'Overprint no esta activat
         %%(B11) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B12) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }
       {  %% el gs actual SI te definit op
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%(B13) ==
         sEdAs2 (0 0 0 0 k 0 0 0 0 K b*\012) writestring
        }
        {  %% l'Overprint es actiu
         %%(B14) ==
         %% si NO es la Tinta que toca i l'overprint es actiu no cal ni interrogar ni pintar res
         sEdAs2 (n\012) writestring  %% matem el path amb 'n'
        } ifelse
       }ifelse
      }ifelse
     } ifelse  %% x filtrar Null
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    {  % stopped
    sEdAs2 (b*\012) writestring
    }stopped{( ... peta b*) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (b*\012) writestring
    }
    {
     sEdAs2 (b*\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_b* get /b* exch bind def

  [  %% n
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (n\012) writestring
     }
     {
      sEdAs2 (n\012EMC\012) writestring
      /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions + relligat d'imatges)
    {  % stopped
    %%    TiNTeM
    %%    {  % es la tinta que toca ara ?
    %%     LaQtoca
    %%     {  % si es la tinta q toca llavors haruiem de tenir en compte l'overprint x veure q fem ...
    %%      gsARA 0 get  % mirem dins l'estat grafic que toca
    %%      dup null eq
    %%      {  % l'overprint no es actiu
    %%       pop sEdAs2 (n\015) writestring
    %%      }
    %%      {  % x filtrar Null
    %%       XRay /EstatsGrafics get /Utilitzats get exch get
    %%       Tfill 1 eq
    %%       {  % com que es OP llavors, cap problema
    %%        Tfill get 0 get
    %%        null eq
    %%        {  % l'Overprint no esta activat
    %%         sEdAs2 (n\015) writestring
    %%        }
    %%        {  % l'Overprint es actiu
    %%         sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%        } ifelse
    %%       }
    %%       {  % si es op cal assegurar-se que ...
    %%        dup Tfill get 2 get  % op es definit al gs actual ?
    %%        null eq
    %%        {  % el gs actual NO te definit op
    %%         1 get 0 get  % llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
    %%         null eq
    %%         {  % l'Overprint no esta activat
    %%          sEdAs2 (n\015) writestring
    %%         }
    %%         {  % l'Overprint es actiu
    %%          sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%         } ifelse
    %%        }
    %%        {  % el gs actual SI te definit op
    %%         Tfill get 0 get
    %%         null eq
    %%         {  % l'Overprint no esta activat
    %%          sEdAs2 (n\015) writestring
    %%         }
    %%         {  % l'Overprint es actiu
    %%          sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%         } ifelse
    %%        }ifelse
    %%       }ifelse
    %%      } ifelse  % x filtrar Null
    %%sEdAs2 (n\015) writestring
    %%     }
    %%     {  % potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
    %%      sEdAs2 (n\015) writestring
    %%     }ifelse
    %%    }
    %%    {
    %%     sEdAs2 (n\015) writestring
    %%    }ifelse  % si no es la tinta que toca matem el path amb 'n'
    %% repiquem 'n' a mas i groga
    sEdAs2 (n\012) writestring
    }stopped{( ... peta n) pstack quit}if
   }
   {  %% 2 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (n\012) writestring
    }
    {
     sEdAs2 (n\012EMC\012) writestring
     /VectorViu false def  %% tanquem el gatell de l'anellat vectorial
    }ifelse
   }
  ] i_n get /n exch bind def

  %% (PDF Ref ?) 8.6.3 Path clipping operators
  %% (PDF Ref 1.7) 4.4.3 Clipping Path Operators
  [  %% W
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
    }
    {
     sEdAs2 (W\012) writestring
    }ifelse
    %%}stopped{( ... peta W) == quit}if
   }
   {  %% 1 (separacions + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    %%        LaQtoca {
    sEdAs2 (W\012) writestring
    %%                }
    %%                {  % potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
    %%                 gsARA 0 get  % mirem dins l'estat grafic que toca
    %%                 
    %%                 dup null eq {pop sEdAs2 (W\015) writestring}{    % x filtrar Null
    %%                 XRay /EstatsGrafics get /Utilitzats get exch get
    %%                 Tfill 1 eq {  % com que es OP llavors, cap problema
    %%                             Tfill get 0 get
    %%                             null eq
    %%                             {  % l'Overprint no esta activat
    %%                              sEdAs2 (W\015) writestring
    %%                             }
    %%                             {  % l'Overprint es actiu
    %%                              sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%                             } ifelse
    %%                            }
    %%                            {  % si es op cal assegurar-se que ...
    %%                             dup Tfill get 2 get  % op es definit al gs actual ?
    %%                             null eq {  % el gs actual NO te definit op
    %%                                      1 get 0 get  % llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
    %%                                      null eq
    %%                                      {  % l'Overprint no esta activat
    %%                                       sEdAs2 (W\015) writestring
    %%                                      }
    %%                                      {  % l'Overprint es actiu
    %%                                       sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%                                      } ifelse
    %%                                     }
    %%                                     {  % el gs actual SI te definit op
    %%                                      Tfill get 0 get
    %%				      null eq
    %%				      {  % l'Overprint no esta activat
    %%				       sEdAs2 (W\015) writestring
    %%				      }
    %%				      {  % l'Overprint es actiu
    %%				       sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%                                      } ifelse
    %%                                     }ifelse
    %%                            }ifelse
    %%                 } ifelse  % x filtrar Null
    %%                }ifelse
    %%       }
    %%       {
    %%        sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%       }ifelse
    }stopped{( ... peta W) pstack quit}if
   }
   {  %% 2 (relligat d'imatges)
    %% aqui hauriem de detectar els clips q ens retallen les imatges a trossooooooos!
    %%lavapies!
    %% implementem un control similar a gsARA o csARA, on podem saber del cert si tenim un clip actiu (true) o no (false)
    %% i tambe W* treballa de la mateixa manera, i llavors x+ endavant caldria assegurar el tret (doncs podria tractar-se d'un clip que no s'inscribis dins la imatge ... i en teoria aquest l'hauriem de deixar passar)
    %% veure si el rectagle cridat x cm (que hauriem de desar a WARA o W*ARA) s'inscriu dins rectangle definit a /matriu de la imatge frontisa
    %%WARA 0 true put  % afegim sempre a la posicio 0 el true que ens indica que tenim un clip actiu

EstatGrafic iEG get /WARA true put  %% duu un clip actiu

    sEdAs2 (W\012) writestring
   }
  ] i_W get /W exch bind def

  [  %% W*
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
    }
    {
     sEdAs2 (W*\012) writestring
    }ifelse
    %%}stopped{( ... peta W*) == quit}if
   }
   {  %% 1 (separacions + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    %%        LaQtoca {
    sEdAs2 (W*\012) writestring
    %%                }
    %%                {  % potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
    %%                 gsARA 0 get  % mirem dins l'estat grafic que toca
    %%                 dup null eq {pop sEdAs2 (W*\015) writestring}{    % x filtrar Null
    %%                 XRay /EstatsGrafics get /Utilitzats get exch get
    %%                 Tfill 1 eq {  % com que es OP llavors, cap problema
    %%                             Tfill get 0 get
    %%                             null eq
    %%                             {  % l'Overprint no esta activat
    %%                              sEdAs2 (W*\015) writestring
    %%                             }
    %%                             {  % l'Overprint es actiu
    %%                              sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%                             } ifelse
    %%                            }
    %%                            {  % si es op cal assegurar-se que ...
    %%                             dup Tfill get 2 get  % op es definit al gs actual ?
    %%                             null eq {  % el gs actual NO te definit op
    %%                                      1 get 0 get  % llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
    %%                                      null eq
    %%                                      {  % l'Overprint no esta activat
    %%                                       sEdAs2 (W*\015) writestring
    %%                                      }
    %%                                      {  % l'Overprint es actiu
    %%                                       sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%                                      } ifelse
    %%                                     }
    %%                                     {  % el gs actual SI te definit op
    %%                                      Tfill get 0 get
    %%				      null eq
    %%				      {  % l'Overprint no esta activat
    %%				       sEdAs2 (W*\015) writestring
    %%				      }
    %%				      {  % l'Overprint es actiu
    %%				       sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%				      } ifelse
    %%                                     }ifelse
    %%                            }ifelse
    %%                 } ifelse    % x filtrar Null
    %%                }ifelse
    %%       }
    %%       {
    %%        sEdAs2 (n\015) writestring  % matem el path amb 'n'
    %%       }ifelse
    }stopped{( ... peta W*) pstack quit}if
   }
   {  %% 2 (relligat d'imatges)
    %% aqui hauriem de detectar els eoclips q ens retallen les imatges a trossooooooos!
    %%lavapies!
    %% implementem un control similar a gsARA o csARA, on podem saber del cert si tenim un eoclip actiu (true) o no (false)
    %% i tambe W* treballa de la mateixa manera, i llavors x+ endavant caldria assegurar el tret (doncs podria tractar-se d'un eoclip que no s'inscribis dins la imatge ... i en teoria aquest l'hauriem de deixar passar)
    %% veure si el rectagle cridat x cm (que hauriem de desar a WARA o W*ARA) s'inscriu dins rectangle definit a /matriu de la imatge frontisa
%%    W*ARA 0 true put  % afegim sempre a la posicio 0 el true que ens indica que tenim un eoclip actiu

EstatGrafic iEG get /W*ARA true put  %% duu un clip actiu

    sEdAs2 (W*\012) writestring
   }
  ] i_W* get /W* exch bind def

  %% (PDF Ref 1.7) 4.5.7 Color Operators
  %% (PDF Ref ?) 8.5.2.2 Generic color space operators
  [  %% CS
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (CS\012) writestring
    }ifelse
    %%}stopped{( ... peta CS) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    sepPS  %% ens executem dins un stream d'un Pattern&Shading?
    {
     %% solucio DeviceGray
     dup /araCS exch def
     %% solucio DeviceGray
     CSARA 0 3 -1 roll put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
     /Tfill 1 def  %% gatell per saber si l'espai de color es per fill (0) o stroke (1)
    }
    {
     %% solucio DeviceGray
     dup /araCS exch def
     %% solucio DeviceGray
     dup CSARA 0 3 -1 roll put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per stroke
     /Tfill 1 def  %% gatell per saber si l'espai de color es per fill (0) o stroke (1)
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (CS\012) writestring
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (CS\012) writestring
    }stopped{( ... peta CS) pstack quit}if
   }
  ] i_CS get /CS exch bind def

  [  %% cs
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (cs\012) writestring
    }ifelse
    %%}stopped{( ... peta cs) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    sepPS  %% ens executem dins un stream d'un Pattern&Shading?
    {
     %% solucio DeviceGray
     dup /ARAcs exch def
     %% solucio DeviceGray
     csARA 0 3 -1 roll put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
     /Tfill 0 def  %% gatell per saber si l'espai de color es per fill (0) o stroke (1)
    }
    {       
     %% solucio DeviceGray
     dup /ARAcs exch def
     %% solucio DeviceGray
     dup csARA 0 3 -1 roll
     put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
     /Tfill 0 def  %% gatell per saber si l'espai de color es per fill (0) o stroke (1)
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (cs\012) writestring
    } ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (cs\012) writestring
    }stopped{( ... peta cs) pstack quit}if
   }
  ] i_cs get /cs exch bind def

  [  %% SC
   {  %% 0 eliminem continguts
    %%{  % stopped
    %% només si mantenim les imatges soles ens cal eliminar aquest operador de forma fixa
    %% si mantenim les imatges juntament amb els vectorials, l'interroguem de forma normal,
    %% doncs podria correspondre a la capa de Text o la de Shading Patterns
    aEliminar 3 get  %% índex que ens indica de si eliminem els vectorials
    {  %% només si eliminem també els vectorials, aquest operador serà eliminat de forma fixa
     true
    }
    {  %% si no eliminem els vectorials, interroguem amb alFoc
     alFoc
    }ifelse

    {
     count {pop} repeat
    }
    {
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     }repeat
     sEdAs2 (SC\012) writestring
    }ifelse
    %%}stopped{( ... peta SC) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %% x saber si l'espai de color te + d'un component cara al comportament de l'overprint
    count 1 eq {true /NomesUn exch def}{false /NomesUn exch def}ifelse

    %% solucio DeviceGray
    CSARA 0 get null eq
    araCS null eq and {true}{araCS false}ifelse
    %% solucio DeviceGray

    {    %% si es un null tant a CSARA com araCS ens aturem temporalment
     (\n\nMRCT1959 0\n\n) print flush stop  %%quit
    }
    {
     %% hem trobat una incongruencia en el manual de PDF doncs pel que sembla aquest operador
     %% no hauria de suportar /DeviceN o /Separation, pero a l'exemple potser9SCa7.pdf es
     %% demostra que en realitat ho suporta perfectament. Davant d'aixo ara posem un filtre
     %% x saber abans si es tracta d'un Process Color (/DeviceCMYK o /PureCMYK) o d'un Spot Color (/DeviceN o /Separation)
     %% no hem provat si suportaria Pattern ¿?

     %% a traves de la variable faCOMscnOk emulem, si es true, el comportament de SCN
     %% i si es false el comportament de K

     %% entenem q si sc crida un color CMYK ho haurem desat a la primera execucio dels contents com a espai NoName9 dins XRay
     %% i l'espai de color actiu sera un /DeviceCMYK o /PureCMYK
     dup /DeviceCMYK eq
     1 index /PureCMYK eq or
     {pop /NoName9}if
     dup dup XRay /EspaisDeColor get /Utilitzats get
     exch known
     {
      XRay /EspaisDeColor get /Utilitzats get exch
      get /NomExtern get
      dup type /nametype eq
      {  %% si es un nom esbrinem si es un /All /PureCMYK o un /DeviceCMYK?
       dup /All eq exch dup /DeviceCMYK eq exch dup /PureCMYK eq exch
       4 1 roll or or
       {
        dup /All eq {false}{true}ifelse
       }
       {
        false
       }ifelse  %% x corregir els /All !!!!!!
       {  %% comportament k/K
        pop pop
        /faCOMscnOk false def
       }
       {  %% comportament scn/SCN
        pop
        /faCOMscnOk true def
       }ifelse
      }
      {  %% comportament scn/SCN
       pop
       /faCOMscnOk true def
      } ifelse
     }
     {  %% si no hi es ara donem un avis (de moment temporalment) i parem
      pop  %%==
      (\n\nMRCT1959 1c\n\n) print flush stop  %%quit
     } ifelse
     faCOMscnOk  %% emulem SCN o K ?
     {  %% emulem SCN
      dup XRay /EspaisDeColor get /Utilitzats get
      exch known
      {
       XRay /EspaisDeColor get /Utilitzats get exch
       get /NomExtern get  %% llistem x pantalleta el color actiu
       dup type /nametype eq
       {  %% si es un nom esbrinem si es un /All /PureCMYK o un /DeviceCMYK?
        dup /All eq exch dup /DeviceCMYK eq exch dup /PureCMYK eq exch
        4 1 roll or or
        {
         dup /All eq {false}{true}ifelse
        }
        {
         false
        }ifelse  %% x corregir els /All !!!!!!
        {  %% crida els 4 Process colors
         %% detector de 4cromia x SC
         true /es4c exch def
         pop
         TiV  %% es la Tinta que llesquem ara ?
         dup quinaTinta known
         {
          pop  %%quinaTinta ==
          /TiNTeMS true def  %% gatell x activar l'escriptura de continguts
          /LaQtocaS true def
          0 /iTinta exch def
         }
         {
          pop
          /TiNTeMS false def  %% gatell x NO activar l'escriptura de continguts
          /LaQtocaS false def
         }ifelse
        }
        {  %% es la Tinta que llesquem ara ?
         %% detector de 4cromia x SC
         false /es4c exch def  %% desactivat per All
         dup quinaTinta eq
         {
          pop  %%==
          /TiNTeMS true def
          /LaQtocaS true def
          0 /iTinta exch def
         }
         {
          pop
          /TiNTeMS false def
          /LaQtocaS false def
         }ifelse
        }ifelse
       }
       {  %% sera una array (no hauria de ser sempre una array en aquest cas?) ...
        %% detector de 4cromia x SC
        false /es4c exch def
        dup length 1 sub /iTinta exch def
        {  %% es la Tinta que llesquem ara ?
         dup quinaTinta eq
         {
          pop  %%==
          /TiNTeMS true def
          /LaQtocaS true def
          exit  %% un cop localitzada ja podem sortir!
         }
         {
          pop
          /TiNTeMS false def
          /LaQtocaS false def
          iTinta 1 sub /iTinta exch def
         }ifelse
        }forall
       }ifelse
      }
      {  %% si no hi es ara donem un avis (de moment temporalment) i parem
       pop  %%==
       (\n\nMRCT1959 1d\n\n) print flush stop  %%quit
      } ifelse
      TiNTeMS
      {  %% ES la tinta que toca
       dup type /nametype eq
       {  %% si duu nom es que esta pintant un Pattern
        /elNOM exch def
        count dup /RoLL exch def
        {
         RoLL -1 roll 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
         RoLL 1 sub /RoLL exch def
        } repeat
        elNOM sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
       }
       {
        /Tfill 1 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
        iTinta index /TacaTintaS exch def  %% ens quedem amb el % de la Tinta que toca
        count {pop}repeat  %% ens carreguem els valors de % de color de scn
        [0 0 0 0] dup 3 TacaTintaS put
        {  %% forall
         10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
        } forall
        sEdAs2 (K\012) writestring
       } ifelse
      }
      {  %% NO es la tinta que toca
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca
        /gs01 0 def
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
       }ifelse
       null eq
       {
        /ppop true def
       }  %% si es null es que l'Overprint no esta activat
       {
        gsARA gs01 get  %% mirem dins l'estat grafic que toca
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         /ppop true def
         %% x saber si actua l'overprint
         false /OPactua exch def
        }
        {  %% l'Overprint es actiu
         /ppop false def
         %% x saber si actua l'overprint
         NomesUn
         {  %% actua
          true /OPactua exch def
         }
         {  %% treballant amb + d'1 component no actua
          false /OPactua exch def
         }ifelse
        } ifelse
       } ifelse
       ppop
       {  %% si NO es la tinta que toca i l'Overprint NO es activat llavors hem de retallar (pintar de blanc)
        count {pop}repeat
        sEdAs2 (0 0 0 0 K\012) writestring
        /TiNTeMS true def  %% reactivem l'escriptura
       }
       {
        count {pop}repeat
        %% /TiNTeM true def  % reactivem l'escriptura
       } ifelse
      } ifelse  %% ES o NO es la Tinta que toca?             
     }  %% emulem SCN
     {  %% emulem K
      %% detector de 4cromia x SC
      true /es4c exch def
      %% si toca, capturem l'index iTinta x per pintar el % de Tinta de la separacio
      << /Cyan 3 /Magenta 2 /Yellow 1 /Black 0 >> dup quinaTinta known
      {
       quinaTinta get /iTinta exch def /TiNTeMS true def /LaQtocaS true def
      }
      {
       pop /TiNTeMS false def /LaQtocaS false def
      }ifelse
      TiNTeMS
      {  %% es la tinta que toca ara ?
       CSARA 0 /PureCMYK put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
       /Tfill 1 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
       %% com que ja sabem segur que es un /PureCMYK ...
       iTinta index dup /TacaTintaS exch def  %% ens quedem amb el % de la Tinta que toca
       %% aqui hauriem de comprovar que si la separacio a pintar es zero i
       %% l'Overprint esta activat, doncs NO ho pintem
       0 eq
       {
        gsARA
        %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
        dup length 1 eq
        {
         0 get  %% mirem dins l'estat grafic que toca
         /gs01 0 def
        }
        {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
         dup 0 get null eq
         {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
        }ifelse
        null eq
        {
         /ppop true def
         %% x saber si actua l'overprint
         false /OPactua exch def
        }  %% si es null es que l'Overprint no esta activat
        {
         gsARA gs01 get  %% mirem dins l'estat grafic que toca
         XRay /EstatsGrafics get /Utilitzats get exch get
         Tfill get 0 get dup
         null eq
         {  %% l'Overprint no esta activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /OPactua exch def
         }
         {
          dup
          /OP known  %% primer mirem si si ha OP al dic
          {
           dup /OP get
           {
            dup /OPM known
            {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
             /OPM get 1 eq
             {  %% l'Overprint es actiu
              /ppop false def
              /TiNTeMS false def  %% hem d'evitar que es pintin els objectes que segueixen
              %% x saber si actua l'overprint
              true /OPactua exch def
             }
             {  %% l'Overprint no esta activat
              /ppop true def
              %% x saber si actua l'overprint
              false /OPactua exch def
             }ifelse
            }
            {  %% l'Overprint no esta activat
             pop /ppop true def
             %% x saber si actua l'overprint
             false /OPactua exch def
            }ifelse
           }
           {  %% l'Overprint no esta activat
            pop /ppop true def
            %% x saber si actua l'overprint
            false /OPactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop /ppop true def
           %% x saber si actua l'overprint
           false /OPactua exch def
          } ifelse
         } ifelse  %% del null
        }ifelse
       }
       {
        /ppop true def
       }ifelse
       ppop
       {  %% pintem per l'overprint ?
        4 {pop} repeat  %% ens carreguem els 4 valors
        [0 0 0 0] dup 3 TacaTintaS put
        {  %% forall
         10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
        } forall
        sEdAs2 (K\012) writestring
       }
       {
        pop pop pop pop
       }ifelse
      }
      {
       pop pop pop pop
      }ifelse  %% de la tinta que toca ara
     } ifelse  %% emulem SCN o K ?
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    count dup /RoLL exch def
    {  %% repeat
     RoLL -1 roll 10000 mul truncate 10000 div
     64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (SC\012) writestring
    }stopped{( ... peta SC) pstack quit}if
   }
  ] i_SC get /SC exch bind def

  [  %% SCN
   {  %% 0 eliminem continguts
    %%{  % stopped
    %% només si mantenim les imatges soles ens cal eliminar aquest operador de forma fixa
    %% si mantenim les imatges juntament amb els vectorials, l'interroguem de forma normal,
    %% doncs podria correspondre a la capa de Text o la de Shading Patterns
    aEliminar 3 get  %% índex que ens indica de si eliminem els vectorials
    {  %% només si eliminem també els vectorials, aquest operador serà eliminat de forma fixa
     true
    }
    {  %% si no eliminem els vectorials, interroguem amb alFoc
     alFoc
    }ifelse

    {
     count {pop} repeat
    }
    {
     dup type /nametype eq
     {  %% si duu nom es que esta pintant un Pattern
      /elNOM exch def
      count dup /RoLL exch def
      {  %% repeat
       RoLL -1 roll 10000 mul truncate 10000 div
       64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       RoLL 1 sub /RoLL exch def
      }repeat
      elNOM sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     }
     {
      count dup /RoLL exch def
      {  %% repeat
       RoLL -1 roll 10000 mul truncate 10000 div
       64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       RoLL 1 sub /RoLL exch def
      }repeat
     }ifelse
     sEdAs2 (SCN\012) writestring
    }ifelse
    %%}stopped{( ... peta SCN) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %% x saber si l'espai de color te + d'un component cara al comportament de l'overprint
    count  %%dup /cOPS exch def
    1 eq
    {
     true /NomesUn exch def
     %% x saber si el valor de tinta actual es zero o no
     %%dup 0 eq {true/Tzero exch def}{false/Tzero exch def}ifelse
    }
    {
     false /NomesUn exch def
     %% x saber si el valor de tinta actual es zero o no
     %%cOPS copy cOPS 1 sub {add}repeat 0 eq {true/Tzero exch def}{false/Tzero exch def}ifelse
    }ifelse
    CSARA 0 get dup null eq
    {  %% si es un null ara ens aturem temporalment
     pop  %%==
     (\n\nMRCT1959 0\n\n) print flush stop  %%quit
    }
    {
     %% /esAll false def
     dup XRay /EspaisDeColor get /Utilitzats get
     exch known
     {
      XRay /EspaisDeColor get /Utilitzats get exch
      get
      dup null eq
      {  %% voldra dir que es un Pattern
       pop /esUnPS true def  %% flag x saber si es un Pattern&Shading
       XRay /Patterns&Shadings get /Utilitzats get
       %%nomDtp
       1 index
       get 2 get  %% posem a la pila el 'NomExtern' de l'espai de color que tenim desat a l'array
      }
      {
       /esUnPS false def  %% flag x saber si es un Pattern&Shading
       /NomExtern get
      }ifelse
      dup type /nametype eq
      {  %% si es un nom esbrinem si es un /All /PureCMYK o un /DeviceCMYK?
       dup /All eq
       %% si es /All sempre es la tinta que toca ...
       {
        pop
        /TiNTeMS true def
        /LaQtocaS true def
        0 /iTinta exch def
        %% detector de 4cromia x SCN
        %% de moment a /All no li donem validesa 4c
        false /es4c exch def
       }
       {
        dup /DeviceCMYK eq exch dup /PureCMYK eq exch
        3 1 roll or
        {  %% crida els 4 Process colors
         %% detector de 4cromia x SCN
         true /es4c exch def
         pop
         TiV  %% es la Tinta que llesquem ara ?
         dup quinaTinta known
         {
          pop  %%quinaTinta ==
          %% si toca, capturem l'index iTinta x per pintar el % de Tinta de la separacio
          << /Cyan 3 /Magenta 2 /Yellow 1 /Black 0 >> dup quinaTinta known
          {
           quinaTinta get /iTinta exch def /TiNTeMS true def /LaQtocaS true def
          }
          {
           pop /TiNTeMS false def /LaQtocaS false def
          }ifelse
         }
         {
          pop
          /TiNTeMS false def  %% gatell x NO activar l'escriptura de continguts
          /LaQtocaS false def
         }ifelse
        }
        {  %% es la Tinta que llesquem ara ?
         %% detector de 4cromia x SCN
         false /es4c exch def
         dup quinaTinta eq
         {
          pop  %%==
          /TiNTeMS true def
          /LaQtocaS true def
          0 /iTinta exch def
         }
         {
          pop
          /TiNTeMS false def
          /LaQtocaS false def
         }ifelse
        }ifelse
       } ifelse  %% es un literal /All ?
      }
      {  %% sera una array (no hauria de ser sempre una array en aquest cas?) ...
       %% detector de 4cromia x SCN
       false /es4c exch def
       esUnPS
       {  %% ... es un Pattern&Shading ...
        sepPS
        {  %% ... i ens estem executant dins el context d'un stream de Patterns&Shadings
         dup length 1 sub /iTinta exch def
         {  %% forall de si es la Tinta que llesquem ara ?
          dup quinaTinta eq
          {
           pop  %%==
           /TiNTeMS true def
           /LaQtocaS true def
           exit  %% un cop localitzada ja podem sortir!
          }
          {
           pop
           /TiNTeMS false def
           /LaQtocaS false def
           iTinta 1 sub /iTinta exch def
          }ifelse
         }forall
        }
        {
         dup length 1 sub /iTinta exch def
         {  %% forall de si es la Tinta que llesquem ara ?
          dup quinaTinta eq
          {
           pop  %%==
           /TiNTeMS true def
           /LaQtocaS true def
           exit  %% un cop localitzada ja podem sortir!
          }
          {
           pop
           /TiNTeMS false def
           /LaQtocaS false def
           iTinta 1 sub /iTinta exch def
          }ifelse
         }forall
        }ifelse
       }
       {
        dup length 1 sub /iTinta exch def
        {  %% forall de si es la Tinta que llesquem ara ?
         dup quinaTinta eq
         {
          pop  %%==
          /TiNTeMS true def
          /LaQtocaS true def
          exit  %% un cop localitzada ja podem sortir!
         }
         {
          pop
          /TiNTeMS false def
          /LaQtocaS false def
          iTinta 1 sub /iTinta exch def
         }ifelse
        }forall
       }ifelse
      }ifelse
     }
     {  %% si no hi es ara donem un avis (de moment temporalment) i parem
      pstack
      %%pop %==
      (\n\nMRCT1959 1f\n\n) print flush stop  %%quit
     } ifelse
    } ifelse
    %% treballem el gatell de /OPactua de forma independent
    /Tfill 1 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    %% detector de 4cromia x SCN
    es4c
    {  %% si es CMYK anem a veure si te OP a true i duu OPM a 0 o no
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca
      /gs01 0 def
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
     }ifelse
     null eq
     {
      %% x saber si actua l'overprint
      false /OPactua exch def
     }  %% si es null es que l'Overprint no esta activat
     {
      gsARA gs01 get  %% mirem dins l'estat grafic que toca
      XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill get 0 get dup
      null eq
      {  %% l'Overprint no esta activat
       pop
       %% x saber si actua l'overprint
       false /OPactua exch def
      }
      {
       dup /OP known  %% primer mirem si si ha OP al dic
       {
        dup /OP get
        {
         dup /OPM known
         {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
          /OPM get 1 eq
          {  %% l'Overprint es actiu
           %% x saber si actua l'overprint
           true /OPactua exch def
          }
          {  %% l'Overprint no esta activat
           %% x saber si actua l'overprint
           false /OPactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop
          %% x saber si actua l'overprint
          false /OPactua exch def
         }ifelse
        }
        {  %% l'Overprint no esta activat
         pop
         %% x saber si actua l'overprint
         false /OPactua exch def
        }ifelse
       }
       {  %% l'Overprint no esta activat
        pop
        %% x saber si actua l'overprint
        false /OPactua exch def
       } ifelse
      } ifelse  %% del null
     }ifelse  %% del null
    }
    {  %% haura de ser DeviceN o Separation
     NomesUn
     {  %% tornem a analitzar l'overprint doncs pot actuar ...
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       %% x saber si actua l'overprint
       false /OPactua exch def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get dup
       null eq
       {  %% l'Overprint no esta activat
        pop
        %% x saber si actua l'overprint
        false /OPactua exch def
       }
       {
        dup /OP known  %% primer mirem si si ha OP al dic
        {
         dup /OP get
         {  %% com que segur NO es CMYK ...
          %%dup /OPM known
          %%{  % en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
          %% /OPM get 1 eq
          %% {  % l'Overprint es actiu
          %%  % x saber si actua l'overprint
          %%  true /OPactua exch def
          %% }
          %% {  % l'Overprint no esta activat
          %%  % x saber si actua l'overprint
          %%  false /OPactua exch def
          %% }ifelse
          %%}
          %%{  % l'Overprint no esta activat
          %% pop
          %% % x saber si actua l'overprint
          %% false /OPactua exch def
          %%}ifelse
          pop
          %% x saber si actua l'overprint
          true /OPactua exch def
         }
         {  %% l'Overprint no esta activat
          pop
          %% x saber si actua l'overprint
          false /OPactua exch def
         }ifelse
        }
        {  %% l'Overprint no esta activat
         pop
         %% x saber si actua l'overprint
         false /OPactua exch def
        } ifelse
       } ifelse  %% del null
      }ifelse  %% del null
     }
     {  %% no cal q analitzem res doncs l'overprint segur q no pot actuar
      %% x saber si actua l'overprint
      false /OPactua exch def
     }ifelse
    }ifelse
    %%% fi de treball del gatell /OPactua x SCN
    TiNTeMS
    {  %% ES la tinta que toca
     dup type /nametype eq
     {  %% si duu nom es que esta pintant un Pattern
      /elNOM exch def
      /Tfill 1 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
      count 0 ne
      {  %% si nomes duu un nom es tracta d'un Colored Pattern i llavors no repiquem els valors cmyk aqui
       iTinta index /TacaTintaS exch def  %% ens quedem amb el % de la Tinta que toca
       count {pop}repeat  %% ens carreguem els valors de % de color de scn
       [0 0 0 0] dup 3 TacaTintaS put
       {  %% forall
        10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       } forall
      }
      {  %% si no es un Colored Pattern ...
       1 /TacaTintaF exch def  %% posem de forma fixa el valor 1 xq sigui diferent de Zero ...
       %% doncs llavors l'operador f ens treballara el ShadingPattern com cal ...
       %% ... pero q passaria si fos un ShadingPattern realment amb tinta zero? ... no hauriem llavors de tenir reflectits a XRay els valors a CSpaces:begin:Pattern x poder interrogar /C0 i /C1 i assegurar-nos si valen zero tots dos?
      }ifelse
      elNOM sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
      sEdAs2 (SCN\012) writestring
     }
     {
      /Tfill 1 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
      iTinta index /TacaTintaS exch def  %% ens quedem amb el % de la Tinta que toca
      count {pop}repeat  %% ens carreguem els valors de % de color de scn
      [0 0 0 0] dup 3 TacaTintaS put
      {  %% forall
       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      } forall
      sEdAs2 (K\012) writestring
     } ifelse
    }
    {  %% NO es la tinta que toca
     esUnPS
     {  %% ... pero es un Pattern&Shading ...
      sepPS
      {  %% ... i ens estem executant dins el context d'un stream de Patterns&Shadings
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca
        /gs01 0 def
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
       }ifelse
       null eq
       {
        /ppop true def
       }  %% si es null es que l'Overprint no esta activat
       {
        gsARA gs01 get  %% mirem dins l'estat grafic que toca
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         /ppop true def
        }
        {  %% l'Overprint es actiu
         /ppop false def
        } ifelse
       } ifelse
       %%esAll {/ppop true def}if
       %%ppop {  % si NO es la tinta que toca i l'Overprint NO es activat llavors hem de retallar (pintar de blanc)
       %%      count {pop}repeat
       %%      sEdAs2 (0 0 0 0 K\015) writestring
       %%      /TiNTeM true def  % reactivem l'escriptura
       %%     }
       %%     {
       %%      count {pop}repeat
       %%      % /TiNTeM false def  % NO reactivem l'escriptura
       %%     } ifelse
       ppop
       {  %% si NO es la tinta que toca i l'Overprint NO es activat llavors ...
        TacaTintaS 0 eq
        {
         count {pop}repeat
         sEdAs2 (0 0 0 0 K\012) writestring
         /TiNTeMS true def  %% reactivem l'escriptura 
        }
        {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
         count {pop}repeat
         sEdAs2 (0 0 0 0 K\012) writestring
         %% /TiNTeM true def  % reactivem l'escriptura
        }ifelse
       }
       {  %% si l'Overprint es activat llavors ...
        TacaTintaS 0 eq
        {
         count {pop}repeat
         sEdAs2 (0 0 0 0 K\012) writestring
         %% /TiNTeM true def  % reactivem l'escriptura
        }
        {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
         count {pop}repeat
         sEdAs2 (0 0 0 0 K\012) writestring
         /TiNTeMS true def  %% reactivem l'escriptura 
        }ifelse
       } ifelse
      }
      {  %% ... i NO ens estem executant dins el context d'un stream de Patterns&Shadings
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca
        /gs01 0 def
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
       }ifelse
       null eq
       {
        /ppop true def
       }  %% si es null es que l'Overprint no esta activat
       {
        gsARA gs01 get  %% mirem dins l'estat grafic que toca
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         /ppop true def
        }
        {  %% l'Overprint es actiu
         /ppop false def
        } ifelse
       } ifelse
       %%esAll {/ppop true def}if
       %%ppop {  % si NO es la tinta que toca i l'Overprint NO es activat llavors hem de retallar (pintar de blanc)
       %%      count {pop}repeat
       %%      sEdAs2 (0 0 0 0 K\015) writestring
       %%      /TiNTeM true def  % reactivem l'escriptura
       %%     }
       %%     {  % estem segurs d'aixo ?
       %%      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
       %%      sEdAs2 (SCN\015) writestring
       %%      %count {pop}repeat
       %%      %% /TiNTeM false def  % NO reactivem l'escriptura
       %%     } ifelse
       ppop
       {  %% si NO es la tinta que toca i l'Overprint NO es activat llavors ...
        TacaTintaS 0 eq
        {
         count {pop}repeat
         sEdAs2 (0 0 0 0 K\012) writestring
         /TiNTeMS true def  %% reactivem l'escriptura 
        }
        {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
         count {pop}repeat
         sEdAs2 (0 0 0 0 K\012) writestring
         %% /TiNTeM true def  % reactivem l'escriptura
        }ifelse
       }
       {  %% si l'Overprint es activat llavors ...
        TacaTintaS 0 eq
        {
         count {pop}repeat
         sEdAs2 (0 0 0 0 K\012) writestring
         %% /TiNTeM true def  % reactivem l'escriptura
        }
        {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
         count {pop}repeat
         sEdAs2 (0 0 0 0 K\012) writestring
         /TiNTeMS true def  %% reactivem l'escriptura 
        }ifelse
       } ifelse
      } ifelse
     }
     {  %% ... NO es un Pattern&Shading
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       /ppop true def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        /ppop true def
       }
       {  %% l'Overprint es actiu
        /ppop false def
       } ifelse
      } ifelse
      %%esAll {/ppop true def}if
      ppop
      {  %% si NO es la tinta que toca i l'Overprint NO es activat llavors ...
       TacaTintaS 0 eq
       {
        count {pop}repeat
        sEdAs2 (0 0 0 0 K\012) writestring
        /TiNTeMS true def  %% reactivem l'escriptura 
       }
       {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
        count {pop}repeat
        sEdAs2 (0 0 0 0 K\012) writestring
        %% /TiNTeM true def  % reactivem l'escriptura
       }ifelse
      }
      {  %% si l'Overprint es activat llavors ...
       TacaTintaS 0 eq
       {
        count {pop}repeat
        sEdAs2 (0 0 0 0 K\012) writestring
        %% /TiNTeM true def  % reactivem l'escriptura
       }
       {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
        count {pop}repeat
        sEdAs2 (0 0 0 0 K\012) writestring
        /TiNTeMS true def  %% reactivem l'escriptura 
       }ifelse
      } ifelse
     }ifelse
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    dup type /nametype eq
    {  %% si duu nom es que esta pintant un Pattern
     /elNOM exch def
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
     elNOM sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    }
    {
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
    }ifelse
    sEdAs2 (SCN\012) writestring
    }stopped{( ... peta SCN) pstack quit}if
   }
  ] i_SCN get /SCN exch bind def

  [  %% sc
   {  %% 0 eliminem continguts
    %%{  % stopped
    %% només si mantenim les imatges soles ens cal eliminar aquest operador de forma fixa
    %% si mantenim les imatges juntament amb els vectorials, l'interroguem de forma normal,
    %% doncs podria correspondre a la capa de Text o la de Shading Patterns
    aEliminar 3 get  %% índex que ens indica de si eliminem els vectorials
    {  %% només si eliminem també els vectorials, aquest operador serà eliminat de forma fixa
     true
    }
    {  %% si no eliminem els vectorials, interroguem amb alFoc
     alFoc
    }ifelse

    {
     count {pop} repeat
    }
    {
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
     sEdAs2 (sc\012) writestring
    }ifelse
    %%}stopped{( ... peta sc) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %% x saber si l'espai de color te + d'un component cara al comportament de l'overprint
    count 1 eq {true /NomesUn exch def}{false /NomesUn exch def}ifelse

    %% solucio DeviceGray
    csARA 0 get null eq
    ARAcs null eq and {true}{ARAcs false}ifelse
    %% solucio DeviceGray

    {  %% si es un null tant a csARA com ARAcs ens aturem temporalment
     (\n\nMRCT1959 0\n\n) print flush stop  %%quit
    }
    {
     %% hem trobat una incongruencia en el manual de PDF doncs pel que sembla aquest operador
     %% no hauria de suportar /DeviceN o /Separation, pero a l'exemple potser9SCa7.pdf es
     %% demostra que en realitat ho suporta perfectament. Davant d'aixo ara posem un filtre
     %% x saber abans si es tracta d'un Process Color (/DeviceCMYK o /PureCMYK) o d'un Spot Color (/DeviceN o /Separation)
     %% no hem provat si suportaria Pattern ¿?

     %% a traves de la variable faCOMscnOk emulem, si es true, el comportament de scn
     %% i si es false el comportament de k

     %% entenem q si sc crida un color CMYK ho haurem desat a la primera execucio dels contents com a espai NoName9 dins XRay
     %% i l'espai de color actiu sera un /DeviceCMYK o /PureCMYK
     dup /DeviceCMYK eq
     1 index /PureCMYK eq or
     {
      pop /NoName9
     }if
     dup dup XRay /EspaisDeColor get /Utilitzats get
     exch known
     {
      XRay /EspaisDeColor get /Utilitzats get exch
      get /NomExtern get
      dup type /nametype eq
      {  %% si es un nom esbrinem si es un /All /PureCMYK o un /DeviceCMYK?
       dup /All eq exch dup /DeviceCMYK eq exch dup /PureCMYK eq exch
       4 1 roll or or
       {
        dup /All eq {false}{true}ifelse
       }
       {
        false
       }ifelse  %% x corregir els /All !!!!!!
       {  %% comportament k/K
        pop pop
        /faCOMscnOk false def
       }
       {  %% comportament scn/SCN
        pop
        /faCOMscnOk true def
       }ifelse
      }
      {  %% comportament scn/SCN
       pop
       /faCOMscnOk true def
      } ifelse
     }
     {  %% si no hi es ara donem un avis (de moment temporalment) i parem
      pop  %%==
      (\n\nMRCT1959 1a\n\n) print flush stop  %%quit
     } ifelse
     faCOMscnOk  %% emulem scn o k ?
     {  %% emulem scn
      dup XRay /EspaisDeColor get /Utilitzats get
      exch known
      {
       XRay /EspaisDeColor get /Utilitzats get exch
       get /NomExtern get  %% llistem x pantalleta el color actiu
       dup type /nametype eq
       {  %% si es un nom esbrinem si es un /All /PureCMYK o un /DeviceCMYK?
        dup /All eq exch dup /DeviceCMYK eq exch dup /PureCMYK eq exch
        4 1 roll or or
        {
         dup /All eq {false}{true}ifelse
        }
        {
         false
        }ifelse  %% x corregir els /All !!!!!!
        {  %% crida els 4 Process colors
         %% detector de 4cromia x sc
         true /es4c exch def
         pop
         TiV  %% es la Tinta que llesquem ara ?
         dup quinaTinta known
         {
          pop  %%quinaTinta ==
          /TiNTeMF true def  %% gatell x activar l'escriptura de continguts
          /LaQtocaF true def
          0 /iTinta exch def
         }
         {
          pop
          /TiNTeMF false def  %% gatell x NO activar l'escriptura de continguts
          /LaQtocaF false def
         }ifelse
        }
        {  %% es la Tinta que llesquem ara ?
         %% detector de 4cromia x sc
         false /es4c exch def  %% desactivat per All
         dup quinaTinta eq
         {
          pop  %%==
          /TiNTeMF true def
          /LaQtocaF true def
          0 /iTinta exch def
         }
         {
          pop
          /TiNTeMF false def
          /LaQtocaF false def
         }ifelse
        }ifelse
       }
       {  %% sera una array (no hauria de ser sempre una array en aquest cas?) ...
        %% detector de 4cromia x sc
        false /es4c exch def
        dup length 1 sub /iTinta exch def
        {  %% forall, es la Tinta que llesquem ara ?
         dup quinaTinta eq
         {
          pop  %%==
          /TiNTeMF true def
          /LaQtocaF true def
          exit  %% un cop localitzada ja podem sortir!
         }
         {
          pop
          /TiNTeMF false def
          /LaQtocaF false def
          iTinta 1 sub /iTinta exch def
         }ifelse
        }forall
       }ifelse
      }
      {  %% si no hi es ara donem un avis (de moment temporalment) i parem
       pop  %%==
       (\n\nMRCT1959 1b\n\n) print flush stop  %%quit
      } ifelse
      TiNTeMF
      {  %% ES la tinta que toca
       dup type /nametype eq
       {  %% si duu nom es que esta pintant un Pattern
        /elNOM exch def
        count dup /RoLL exch def
        {
         RoLL -1 roll 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
         RoLL 1 sub /RoLL exch def
        } repeat
        elNOM sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
       }
       {
        /Tfill 0 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
        iTinta index /TacaTintaF exch def  %% ens quedem amb el % de la Tinta que toca
        count {pop}repeat  %% ens carreguem els valors de % de color de scn
        [0 0 0 0] dup 3 TacaTintaF put
        {  %% forall
         10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
        } forall
        sEdAs2 (k\012) writestring
       } ifelse
      }
      {  %% NO es la tinta que toca
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca
        /gs01 0 def
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
       }ifelse
       null eq
       {
        /ppop true def
       }  %% si es null es que l'Overprint no esta activat
       {
        gsARA gs01 get  %% mirem dins l'estat grafic que toca
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         /ppop true def
         %% x saber si actua l'overprint
         false /opactua exch def
        }
        {  %% l'Overprint es actiu
         /ppop false def
         %% x saber si actua l'overprint
         NomesUn
         {  %% actua
          true /opactua exch def
         }
         {  %% treballant amb + d'1 component no actua
          false /opactua exch def
         }ifelse
        } ifelse
       } ifelse
       ppop
       {  %% si NO es la tinta que toca i l'Overprint NO es activat llavors hem de retallar (pintar de blanc)
        count {pop}repeat
        sEdAs2 (0 0 0 0 k\012) writestring
        /TiNTeMF true def  %% reactivem l'escriptura
       }
       {
        count {pop}repeat
        %% /TiNTeM true def  % reactivem l'escriptura
       } ifelse
      } ifelse  %% ES o NO es la Tinta que toca?
     }  %% emulem scn
     {  %% emulem k
      %% detector de 4cromia x sc
      true /es4c exch def
      %% si toca, capturem l'index iTinta x per pintar el % de Tinta de la separacio
      << /Cyan 3 /Magenta 2 /Yellow 1 /Black 0 >> dup quinaTinta known
      {
       quinaTinta get /iTinta exch def /TiNTeMF true def /LaQtocaF true def
      }
      {
       pop /TiNTeMF false def /LaQtocaF false def
      }ifelse
      TiNTeMF
      {  %% es la tinta que toca ara ?
       csARA 0 /PureCMYK put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
       /Tfill 0 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
       %% com que ja sabem segur que es un /PureCMYK ...
       iTinta index dup /TacaTintaF exch def  %% ens quedem amb el % de la Tinta que toca
       %% aqui hauriem de comprovar que si la separacio a pintar es zero i
       %% l'Overprint esta activat, doncs NO ho pintem
       0 eq
       {
        gsARA
        %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
        dup length 1 eq
        {
         0 get  %% mirem dins l'estat grafic que toca
         /gs01 0 def
        }
        {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
         dup 0 get null eq
         {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
        }ifelse
        null eq
        {
         /ppop true def
         %% x saber si actua l'overprint
         false /opactua exch def
        }  %% si es null es que l'Overprint no esta activat
        {
         gsARA gs01 get  %% mirem dins l'estat grafic que toca
         XRay /EstatsGrafics get /Utilitzats get exch get
         Tfill get 0 get
         dup
         null eq
         {  %% l'Overprint no esta activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /opactua exch def
         }
         {
          dup
          /op known  %% primer mirem si si ha op al dic
          {
           dup /op get
           {
            dup /OPM known
            {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
             /OPM get 1 eq
             {  %% l'Overprint es actiu
              /ppop false def
              /TiNTeMF false def  %% hem d'evitar que es pintin els objectes que segueixen
              %% x saber si actua l'overprint
              true /opactua exch def
             }
             {  %% l'Overprint no esta activat
              /ppop true def
              %% x saber si actua l'overprint
              false /opactua exch def
             }ifelse
            }
            {  %% l'Overprint no esta activat
             pop /ppop true def
             %% x saber si actua l'overprint
             false /opactua exch def
            }ifelse
           }
           {  %% ara mirem si hi ha OP doncs en fa el paper en la seva absencia
            dup /OP known
            {
             dup /OP get
             {
              dup /OPM known
              {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
               /OPM get 1 eq
               {  %% l'Overprint es actiu
                /ppop false def
                /TiNTeMF false def  %% hem d'evitar que es pintin els objectes que segueixen
                %% x saber si actua l'overprint
                true /opactua exch def
               }
               {  %% l'Overprint no esta activat
                /ppop true def
                %% x saber si actua l'overprint
                false /opactua exch def
               }ifelse
              }
              {  %% l'Overprint no esta activat
               pop /ppop true def
               %% x saber si actua l'overprint
               false /opactua exch def
              }ifelse
             }
             {  %% l'Overprint no esta activat
              pop /ppop true def
              %% x saber si actua l'overprint
              false /opactua exch def
             }ifelse
            }
            {  %% l'Overprint no esta activat
             pop /ppop true def
             %% x saber si actua l'overprint
             false /opactua exch def
            }ifelse
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop /ppop true def
           %% x saber si actua l'overprint
           false /opactua exch def
          } ifelse
         }ifelse  %% del null
        }ifelse
       }
       {
        /ppop true def
       }ifelse
       ppop
       {  %% pintem per l'overprint ?
        4 {pop} repeat  %% ens carreguem els 4 valors
        [0 0 0 0] dup 3 TacaTintaF put
        {  %% forall
         10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
        } forall
        sEdAs2 (k\012) writestring
       }
       {
        pop pop pop pop
       }ifelse
      }
      {
       pop pop pop pop
      }ifelse  %% de la tinta que toca ara
     } ifelse  %% emulem scn o k ?
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    count dup /RoLL exch def
    {  %% repeat
     RoLL -1 roll 10000 mul truncate 10000 div
     64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (sc\012) writestring
    }stopped{( ... peta sc) pstack quit}if
   }
  ] i_sc get /sc exch bind def

  [  %% scn
   {  %% 0 eliminem continguts
    %%{  % stopped
    %% només si mantenim les imatges soles ens cal eliminar aquest operador de forma fixa
    %% si mantenim les imatges juntament amb els vectorials, l'interroguem de forma normal,
    %% doncs podria correspondre a la capa de Text o la de Shading Patterns
    aEliminar 3 get  %% índex que ens indica de si eliminem els vectorials
    {  %% només si eliminem també els vectorials, aquest operador serà eliminat de forma fixa
     true
    }
    {  %% si no eliminem els vectorials, interroguem amb alFoc
     alFoc
    }ifelse

    {
     count {pop} repeat
    }
    {
     dup type /nametype eq
     {  %% si duu nom es que esta pintant un Pattern
      /elNOM exch def
      count dup /RoLL exch def
      {  %% repeat
       RoLL -1 roll 10000 mul truncate 10000 div
       64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       RoLL 1 sub /RoLL exch def
      } repeat
      elNOM sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     }
     {
      count dup /RoLL exch def
      {  %% repeat
       RoLL -1 roll 10000 mul truncate 10000 div
       64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       RoLL 1 sub /RoLL exch def
      } repeat
     }ifelse
     sEdAs2 (scn\012) writestring
    }ifelse
    %%}stopped{( ... peta scn) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %% x saber si l'espai de color te + d'un component cara al comportament de l'overprint
    count  %%dup /cOPS exch def
    1 eq
    {
     true /NomesUn exch def
     %% x saber si el valor de tinta actual es zero o no
     %%dup 0 eq {true/Tzero exch def}{false/Tzero exch def}ifelse
    }
    {
     false /NomesUn exch def
     %% x saber si el valor de tinta actual es zero o no
     %%cOPS copy cOPS 1 sub {add}repeat 0 eq {true/Tzero exch def}{false/Tzero exch def}ifelse
    }ifelse
    csARA 0 get dup null eq
    {  %% si es un null ara ens aturem temporalment
     pop
     %%% (ARA) segurament cal esbrinar la causa del null a la posicio zero de l'exemple logo_18-O132.pdf ...
     %% csARA length 1 eq
     %% {  % donarem error si nomes hi ha null
     (\n\nMRCT1959 0\n\n) print flush stop  %%quit
     %% }
     %% {  % com que encara no sabem xq hi ha un null a la posicio 0 existint d'altres espais de color ...
     %%  csARA 1 get  % anem a pescar l'espai de color seguent al null
     %% }ifelse
     %%%
    }
    {
     %% /esAll false def
     %%%test
     %%dup /CS1 eq {/ColBo true def}{/ColBo false def}ifelse
     dup XRay /EspaisDeColor get /Utilitzats get
     exch known
     {
      XRay /EspaisDeColor get /Utilitzats get exch
      get
      dup null eq
      {  %% voldra dir que es un Pattern
       pop /esUnPS true def  %% flag x saber si es un Pattern&Shading
       XRay /Patterns&Shadings get /Utilitzats get
       %%nomDtp
       1 index
       get 2 get  %% posem a la pila el 'NomExtern' de l'espai de color que tenim desat a l'array
      }
      {
       /esUnPS false def  %% flag x saber si es un Pattern&Shading
       /NomExtern get
      } ifelse    
      dup type /nametype eq
      {  %% si es un nom esbrinem si es un /All /PureCMYK o un /DeviceCMYK?
       dup /All eq 
       %% si es /All sempre es la tinta que toca ...
       {
        pop
        /TiNTeMF true def
        /LaQtocaF true def
        0 /iTinta exch def
        %% detector de 4cromia x scn
        %% de moment a /All no li donem validesa 4c
        false /es4c exch def
       }
       {
        dup /DeviceCMYK eq exch dup /PureCMYK eq exch
        3 1 roll or     
        {  %% crida els 4 Process colors
         %% detector de 4cromia x scn
         true /es4c exch def
         pop
         TiV  %% es la Tinta que llesquem ara ?
         dup quinaTinta known
         {
          pop  %%quinaTinta ==
          %% si toca, capturem l'index iTinta x per pintar el % de Tinta de la separacio
          << /Cyan 3 /Magenta 2 /Yellow 1 /Black 0 >> dup quinaTinta known
          {
           quinaTinta get /iTinta exch def /TiNTeMF true def /LaQtocaF true def
          }
          {
           pop /TiNTeMF false def /LaQtocaF false def
          }ifelse
         }
         {
          pop
          /TiNTeMF false def  %% gatell x NO activar l'escriptura de continguts
          /LaQtocaF false def
         }ifelse
        }
        {  %% es la Tinta que llesquem ara ?
         %% detector de 4cromia x scn
         false /es4c exch def
         %% solucio DeviceGray
         dup /DeviceGray eq
         {/Black quinaTinta eq}{false}ifelse
         %% solucio DeviceGray
         {
          pop
          /TiNTeMF true def
          /LaQtocaF true def
          0 /iTinta exch def
          %%!!% aqui hauriem de retocar els valors de color del Pattern xq no fossin 4!
          %%TiV
          %%{== ==}forall(nnnn) pstack quit
         }
         {
          quinaTinta eq
          {
           /TiNTeMF true def
           /LaQtocaF true def
           0 /iTinta exch def
          }
          {
           /TiNTeMF false def
           /LaQtocaF false def
           %%0 /iTinta exch def
          }ifelse       
         }ifelse
        }ifelse
       } ifelse  %% es un literal /All ?
      }
      {  %% sera una array (no hauria de ser sempre una array en aquest cas?) ...
       %% detector de 4cromia x scn
       false /es4c exch def
       esUnPS
       {  %% ... es un Pattern&Shading ...
        sepPS
        {  %% ... i ens estem executant dins el context d'un stream de Patterns&Shadings
         dup length 1 sub /iTinta exch def
         {  %% forall de si es la Tinta que llesquem ara ?
          dup quinaTinta eq
          {
           pop  %%==
           /TiNTeMF true def
           /LaQtocaF true def
           exit  %% un cop localitzada ja podem sortir!
          }
          {
           pop
           /TiNTeMF false def
           /LaQtocaF false def
           iTinta 1 sub /iTinta exch def
          }ifelse
         }forall
        }
        {
         %% iTinta ja ha d'anar a l'inreves doncs + avall actua amb l'operador index !
         dup length 1 sub /iTinta exch def
         {  %% forall de si es la Tinta que llesquem ara ?
          dup quinaTinta eq
          {
           pop  %%==
           /TiNTeMF true def
           /LaQtocaF true def
           exit  %% un cop localitzada ja podem sortir!
          }
          {
           pop
           /TiNTeMF false def
           /LaQtocaF false def
           iTinta 1 sub /iTinta exch def
          }ifelse
         }forall
        }ifelse
       }
       {
        dup length 1 sub /iTinta exch def
        {  %% forall de si es la Tinta que llesquem ara ?
         dup quinaTinta eq
         {
          pop  %%==
          /TiNTeMF true def
          /LaQtocaF true def
          exit  %% un cop localitzada ja podem sortir!
         }
         {
          pop
          /TiNTeMF false def
          /LaQtocaF false def
          iTinta 1 sub /iTinta exch def
         }ifelse
        }forall
       }ifelse
      }ifelse
     }
     {  %% si no hi es ara donem un avis (de moment temporalment) i parem
      pop  %%==
      (\n\nMRCT1959 1e\n\n) print flush stop  %%quit
     } ifelse
    } ifelse
    %% treballem el gatell de /opactua de forma independent
    /Tfill 0 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    %% detector de 4cromia x scn
    es4c
    {  %% si es CMYK anem a veure si te op a true i duu OPM a 0 o no
     gsARA
     %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
     dup length 1 eq
     {
      0 get  %% mirem dins l'estat grafic que toca
      /gs01 0 def
     }
     {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
      dup 0 get null eq
      {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
     }ifelse
     null eq
     {
      %% x saber si actua l'overprint
      false /opactua exch def
     }  %% si es null es que l'Overprint no esta activat
     {
      gsARA gs01 get  %% mirem dins l'estat grafic que toca
      dup XRay /EstatsGrafics get /Utilitzats get exch get
      Tfill get 0 get
      dup
      null eq
      {  %% Hi ha op i l'overprint es activat ?
       pop  %% ens carreguem el null
       dup XRay /EstatsGrafics get /Utilitzats get exch get
       0 get 2 get null eq
       {  %% definitivament si no duu el nom del dic clonic NO hi ha op
        dup XRay /EstatsGrafics get /Utilitzats get exch get
        1 get dup 2 get null eq  %% mirem si hi ha OP (doncs si no duu el dic clonic ... )
        {  %% no hi ha OP tampoc
         pop pop  %% ens carreguem l'array i el nom del GS
         %% x saber si actua l'overprint
         false /opactua exch def
         false /OPactua exch def
        }
        {  %% SI que hi ha OP
         dup 0 get null eq
         {
          1 get  %% OP es a false pero ja interrogarem el dict ...
         }
         {  %% OP es a true pero ja interrogarem el dict ...
          0 get
         }ifelse
         dup /OP get
         {  %% OP es a true x tant l'overprint es activat
          dup /OPM known
          {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
           /OPM get 1 eq
           {  %% val 1 ... l'Overprint es actiu
            %% x saber si actua l'overprint
            pop
            true /opactua exch def       
           }
           {  %% val 0 ... l'Overprint no esta activat
            %% x saber si actua l'overprint
            pop
            false /opactua exch def       
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop pop
           %% x saber si actua l'overprint
           false /opactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop pop
          %% x saber si actua l'overprint
          false /opactua exch def
         }ifelse
        }ifelse
       }
       {  %% hi ha op pero l'overprint es a false
        pop
        %% x saber si actua l'overprint
        false /opactua exch def
       }ifelse
      }
      {
       exch pop  %% ens carreguem el nom del GS
       dup /op known  %% primer mirem si si ha op al dic
       {
        dup /op get
        {
         dup /OPM known
         {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
          /OPM get 1 eq
          {  %% l'Overprint es actiu
           %% x saber si actua l'overprint
           true /opactua exch def
          }
          {  %% l'Overprint no esta activat
           %% x saber si actua l'overprint
           false /opactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          %% x saber si actua l'overprint
          false /opactua exch def
          pop
         }ifelse
        }
        {  %% ara mirem si hi ha OP doncs en fa el paper en la seva absencia
         dup /OP known
         {
          dup /OP get
          {
           dup /OPM known
           {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
            /OPM get 1 eq
            {  %% l'Overprint es actiu
             %% x saber si actua l'overprint
             true /opactua exch def
            }
            {  %% l'Overprint no esta activat
             %% x saber si actua l'overprint
             false /opactua exch def
            }ifelse
           }
           {  %% l'Overprint no esta activat
            pop
            %% x saber si actua l'overprint
            false /opactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop
           %% x saber si actua l'overprint
           false /opactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop
          %% x saber si actua l'overprint
          false /opactua exch def
         }ifelse
        }ifelse
       }
       {  %% l'Overprint no esta activat
        pop
        %% x saber si actua l'overprint
        false /opactua exch def
       } ifelse
      }ifelse  %% del null
     }ifelse  %% del null
    }
    {  %% haura de ser DeviceN o Separation
     NomesUn
     {  %% tornem a analitzar l'overprint doncs actua ...
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       %% x saber si actua l'overprint
       false /opactua exch def
      }
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       dup XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get
       dup
       null eq
       {  %% Hi ha op i l'overprint es activat ?
        pop  %% ens carreguem el null
        dup XRay /EstatsGrafics get /Utilitzats get exch get
        0 get 2 get null eq
        {  %% definitivament si no duu el nom del dic clonic NO hi ha op
         dup XRay /EstatsGrafics get /Utilitzats get exch get
         1 get dup 2 get null eq  %% mirem si hi ha OP (doncs si no duu el dic clonic ... )
         {  %% no hi ha OP tampoc
          pop pop  %% ens carreguem l'array i el nom del GS
          %% x saber si actua l'overprint
          false /opactua exch def
          false /OPactua exch def
         }
         {  %% SI que hi ha OP
          dup 0 get null eq
          {
           1 get  %% OP es a false pero ja interrogarem el dict ...
          }
          {  %% OP es a true pero ja interrogarem el dict ...
           0 get
          }ifelse
          dup /OP get
          {  %% OP es a true x tant l'overprint es activat
           pop pop
           true /opactua exch def
          }
          {  %% l'Overprint no esta activat
           pop pop
           %% x saber si actua l'overprint
           false /opactua exch def
          }ifelse     
         }ifelse
        }
        {  %% hi ha op pero l'overprint es a false
         %% x saber si actua l'overprint
         pop
         false /opactua exch def
        }ifelse    
       }
       {
        exch pop  %% ens carreguem el nom del GS
        dup /op known  %% primer mirem si si ha op al dic
        {
         dup /op get
         {  %% com q segur NO es CMYK ...
          %%dup /OPM known
          %%{  % en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
          %% /OPM get 1 eq
          %% {  % l'Overprint es actiu
          %%  % x saber si actua l'overprint
          %%  true /opactua exch def
          %% }
          %% {  % l'Overprint no esta activat
          %%  % x saber si actua l'overprint
          %%  false /opactua exch def
          %% }ifelse
          %%}
          %%{  % l'Overprint no esta activat
          %% % x saber si actua l'overprint
          %% false /opactua exch def
          %% pop
          %%}ifelse      
          pop
          %% x saber si actua l'overprint
          true /opactua exch def
         }
         {  %% ara mirem si hi ha OP doncs en fa el paper en la seva absencia
          dup /OP known
          {
           dup /OP get
           {  %% com q segur NO es CMYK ...
            %% dup /OPM known
            %% {  % en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
            %%  /OPM get 1 eq
            %%  {  % l'Overprint es actiu
            %%   % x saber si actua l'overprint
            %%   true /opactua exch def
            %%  }
            %%  {  % l'Overprint no esta activat
            %%   % x saber si actua l'overprint
            %%   false /opactua exch def
            %%  }ifelse
            %% }
            %% {  % l'Overprint no esta activat
            %%  pop
            %%  % x saber si actua l'overprint
            %%  false /opactua exch def
            %% }ifelse
            pop
            %% x saber si actua l'overprint
            true /opactua exch def
           }
           {  %% l'Overprint no esta activat
            pop
            %% x saber si actua l'overprint
            false /opactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop
           %% x saber si actua l'overprint
           false /opactua exch def
          }ifelse
         }ifelse
        }
        {  %% l'Overprint no esta activat
         pop
         %% x saber si actua l'overprint
         false /opactua exch def
        } ifelse
       }ifelse  %% del null
      }ifelse  %% del null
     }
     {  %% no analitzem res doncs segur q no actua
      %% x saber si actua l'overprint
      %%%test
      %%(*************) ==
      false /opactua exch def
     }ifelse
    }ifelse
    %% fi de treball del gatell opactua de forma independent
    %%%test
    %%ColBo {( >>>>>>> ) == opactua ==}if
    TiNTeMF
    {  %% ES la tinta que toca
     dup type /nametype eq
     {  %% si duu nom es que esta pintant un Pattern
      /elNOM exch def
      /Tfill 0 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
      count 0 ne
      {  %% si nomes duu un nom es tracta d'un Colored Pattern i llavors no repiquem els valors cmyk aqui
       %%!!%
       (quartsde6) pstack stop  %%quit
       iTinta index /TacaTintaF exch def  %% ens quedem amb el % de la Tinta que toca
       count {pop}repeat  %% ens carreguem els valors de % de color de scn
       [0 0 0 0] dup 3 TacaTintaF put
       {  %% forall
        10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       } forall
      }
      {  %% si no es un Colored Pattern ...
       1 /TacaTintaF exch def  %% posem de forma fixa el valor 1 xq sigui diferent de Zero ...
       %% doncs llavors l'operador f ens treballara el ShadingPattern com cal ...
       %% ... pero q passaria si fos un ShadingPattern realment amb tinta zero? ... no hauriem llavors de tenir reflectits a XRay els valors a CSpaces:begin:Pattern x poder interrogar /C0 i /C1 i assegurar-nos si valen zero tots dos?
      }ifelse
      elNOM sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
      sEdAs2 (scn\012) writestring
     }
     {  %% es un DeviceN o una Separation o fins hi tot un CMYK
      /Tfill 0 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
      iTinta index /TacaTintaF exch def  %% ens quedem amb el % de la Tinta que toca
      count {pop}repeat  %% ens carreguem els valors de % de color de scn
      [0 0 0 0] dup 3 TacaTintaF put
      {  %% forall
       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      } forall
      sEdAs2 (k\012) writestring
     } ifelse
    }
    {  %% NO es la tinta que toca ...
     esUnPS
     {  %% ... pero es un Pattern&Shading ...
      sepPS
      {  %% ... i ens estem executant dins el context d'un stream de Patterns&Shadings
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca
        /gs01 0 def
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
       }ifelse
       null eq
       {
        /ppop true def
       }  %% si es null es que l'Overprint no esta activat
       {
        gsARA gs01 get  %% mirem dins l'estat grafic que toca
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         /ppop true def
        }
        {  %% l'Overprint es actiu
         /ppop false def
        } ifelse
       } ifelse
       %%esAll {/ppop true def}if
       %%ppop {  % si NO es la tinta que toca i l'Overprint NO es activat llavors hem de retallar (pintar de blanc)
       %%      count {pop}repeat
       %%      sEdAs2 (0 0 0 0 k\015) writestring
       %%      /TiNTeM true def  % reactivem l'escriptura
       %%     }
       %%     {
       %%      count {pop}repeat
       %%      % /TiNTeM false def  % NO reactivem l'escriptura
       %%     } ifelse
       ppop
       {  %% si NO es la tinta que toca i l'Overprint NO es activat llavors ...
        TacaTintaF 0 eq
        {
         count {pop}repeat
         sEdAs2 (0 0 0 0 k\012) writestring
         /TiNTeMF true def  %% reactivem l'escriptura 
        }
        {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
         count {pop}repeat
         sEdAs2 (0 0 0 0 k\012) writestring
         %%                /TiNTeM true def  % reactivem l'escriptura
        }ifelse
       }
       {  %% si l'Overprint es activat llavors ...
        TacaTintaF 0 eq
        {
         count {pop}repeat
         sEdAs2 (0 0 0 0 k\012) writestring
         %%                /TiNTeM true def  % reactivem l'escriptura
        }
        {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
         count {pop}repeat
         sEdAs2 (0 0 0 0 k\012) writestring
         /TiNTeMF true def  %% reactivem l'escriptura 
        }ifelse
       } ifelse
      }
      {  %% ... i NO ens estem executant dins el context d'un stream de Patterns&Shadings
       gsARA
       %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
       dup length 1 eq
       {
        0 get  %% mirem dins l'estat grafic que toca
        /gs01 0 def
       }
       {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
        dup 0 get null eq
        {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
       }ifelse
       null eq
       {
        /ppop true def
       }  %% si es null es que l'Overprint no esta activat
       {
        gsARA gs01 get  %% mirem dins l'estat grafic que toca
        XRay /EstatsGrafics get /Utilitzats get exch get
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         /ppop true def
        }
        {  %% l'Overprint es actiu
         /ppop false def
        } ifelse
       } ifelse
       %%esAll {/ppop true def}if
       %%ppop {  % si NO es la tinta que toca i l'Overprint NO es activat llavors hem de retallar (pintar de blanc)
       %%      count {pop}repeat
       %%      sEdAs2 (0 0 0 0 k\015) writestring
       %%      /TiNTeM true def  % reactivem l'escriptura
       %%     }
       %%     {  % estem segurs d'aixo ?
       %%      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
       %%      sEdAs2 (scn\015) writestring
       %%      %count {pop}repeat
       %%      %% /TiNTeM false def  % NO reactivem l'escriptura
       %%     } ifelse
       ppop
       {  %% si NO es la tinta que toca i l'Overprint NO es activat llavors ...
        TacaTintaF 0 eq
        {
         count {pop}repeat
         sEdAs2 (0 0 0 0 k\012) writestring
         /TiNTeMF true def  %% reactivem l'escriptura 
        }
        {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
         count {pop}repeat
         sEdAs2 (0 0 0 0 k\012) writestring
         %%                /TiNTeM true def  % reactivem l'escriptura
        }ifelse
       }
       {  %% si l'Overprint es activat llavors ...
        TacaTintaF 0 eq
        {
         count {pop}repeat
         sEdAs2 (0 0 0 0 k\012) writestring
         %% /TiNTeM true def  % reactivem l'escriptura
        }
        {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
         count {pop}repeat
         sEdAs2 (0 0 0 0 k\012) writestring
         /TiNTeMF true def  %% reactivem l'escriptura 
        }ifelse
       } ifelse
      } ifelse
     }
     {  %% ... NO es un Pattern&Shading
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       /ppop true def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get
       null eq
       {  %% l'Overprint no esta activat
        /ppop true def
       }
       {  %% l'Overprint es actiu
        /ppop false def
       } ifelse
      } ifelse
      %%esAll {/ppop true def}if
      ppop
      {  %% si NO es la tinta que toca i l'Overprint NO es activat llavors ...
       TacaTintaF 0 eq
       {
        count {pop}repeat
        sEdAs2 (0 0 0 0 k\012) writestring
        /TiNTeMF true def  %% reactivem l'escriptura 
       }
       {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
        count {pop}repeat
        sEdAs2 (0 0 0 0 k\012) writestring
        %% /TiNTeM true def  % reactivem l'escriptura
       }ifelse
      }
      {  %% si l'Overprint es activat llavors ...
       TacaTintaF 0 eq
       {
        count {pop}repeat
        sEdAs2 (0 0 0 0 k\012) writestring
        %% /TiNTeM true def  % reactivem l'escriptura
       }
       {  %% si NO pintem amb valor zero capgirem la logica de l'overprint
        count {pop}repeat
        sEdAs2 (0 0 0 0 k\012) writestring
        /TiNTeMF true def  %% reactivem l'escriptura 
       }ifelse
      } ifelse
     }ifelse
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    dup type /nametype eq
    {  %% si duu nom es que esta pintant un Pattern
     /elNOM exch def
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
     elNOM sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    }
    {
     count dup /RoLL exch def
     {  %% repeat
      RoLL -1 roll 10000 mul truncate 10000 div
      64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
    }ifelse
    sEdAs2 (scn\012) writestring
    }stopped{( ... peta scn) pstack quit}if
   }
  ] i_scn get /scn exch bind def

  %% PDF Ref ?) 8.5.2.1 Device-dependent color space operators
  [  %% G
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %% reescrivim identic com a G
     10000 mul truncate 10000 div 64 string cvs
     sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (G\012) writestring
    }ifelse
    %%}stopped{( ... peta G) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%    TiNTeMS
    %%    {  % es la tinta que toca ara ?
    %%     CSARA 0 get
    %%     XRay /EspaisDeColor get /Utilitzats get dup
    %%     2 index known
    %%     {
    %%      exch get
    %%      /NomExtern get /Black eq  % ara nomes admetem de fet el /Tipus /Separation amb el nom extern normatiu a Negre
    %%      {
    %%       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (G\015) writestring
    %%      }
    %%      {
    %%       % sobreixidor x saber on es crida l'espai de color q posarem en tractament progressivament
    %%       (-- Solucio DeviceGray :G: NO implementada!) == quit
    %%      }ifelse
    %%     }
    %%     {
    %%      pop pop
    %%      % sobreixidor x saber on es crida l'espai de color q posarem en tractament progressivament
    %%      (-- Solucio DeviceGray :G: NO implementada!) == quit
    %%     }ifelse
    %%    }
    %%    {
    %%     pop
    %%    }ifelse  % de la tinta que toca ara

    %% solucio DeviceGray (transformat a Black del CMYK)
    %% detector de 4cromia x K
    true /es4c exch def
    %% si toca, capturem l'index iTinta x per pintar el % de Tinta de la separacio
    << /Cyan 3 /Magenta 2 /Yellow 1 /Black 0 >> dup quinaTinta known
    {
     quinaTinta get /iTinta exch def /TiNTeMS true def /LaQtocaS true def
    }
    {
     pop /TiNTeMS false def /LaQtocaS false def
    }ifelse
    TiNTeMS
    {  %% es la tinta que toca ara ?
     CSARA 0 /PureCMYK put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
     /Tfill 1 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
     %% com que ja sabem segur que es un /PureCMYK ...
     iTinta index dup /TacaTintaS exch def  %% ens quedem amb el % de la Tinta que toca
     %% aqui hauriem de comprovar que si la separacio a pintar es zero i
     %% l'Overprint esta activat, doncs NO ho pintem
     0 eq
     {
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       /ppop true def
       %% x saber si actua l'overprint
       false /OPactua exch def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get dup
       null eq
       {  %% l'Overprint no esta activat
        pop /ppop true def
        %% x saber si actua l'overprint
        false /OPactua exch def
       }
       {
        dup
        /OP known  %% primer mirem si si ha OP al dic
        {
         dup /OP get
         {
          dup /OPM known
          {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
           /OPM get 1 eq
           {  %% l'Overprint es actiu
            /ppop false def
            /TiNTeMS false def  %% hem d'evitar que es pintin els objectes que segueixen
            %% x saber si actua l'overprint
            true /OPactua exch def
           }
           {  %% l'Overprint no esta activat
            /ppop true def
            %% x saber si actua l'overprint
            false /OPactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop /ppop true def
           %% x saber si actua l'overprint
           false /OPactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /OPactua exch def
         }ifelse
        }
        {  %% l'Overprint no esta activat
         pop /ppop true def
         %% x saber si actua l'overprint
         false /OPactua exch def
        } ifelse
       } ifelse  %% del null
      }ifelse
     }
     {
      /ppop true def
     }ifelse
     ppop
     {  %% pintem per l'overprint ?
      4 {pop} repeat  %% ens carreguem els 4 valors
      [0 0 0 0] dup 3 TacaTintaS put
      {
       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      } forall
      sEdAs2 (K\012) writestring
     }
     {
      pop pop pop pop
     }ifelse
    }
    {
     pop pop pop pop
    }ifelse  %% de la tinta que toca ara
    %% solucio DeviceGray (transformat a Black del CMYK)
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    {  % stopped
    %% reescrivim identic com a G
    10000 mul truncate 10000 div 64 string cvs
    sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (G\012) writestring
    }stopped{( ... peta G) pstack quit}if
   }
  ] i_G get /G exch bind def
  
  [  %% g
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %% reescrivim identic com a g
     10000 mul truncate 10000 div 64 string cvs
     sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (g\012) writestring
    }ifelse
    %%}stopped{( ... peta g) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%    TiNTeMF
    %%    {  % es la tinta que toca ara ?
    %%     csARA 0 get
    %%     XRay /EspaisDeColor get /Utilitzats get dup
    %%     2 index known
    %%     {
    %%      exch get
    %%      /NomExtern get /Black eq  % ara nomes admetem de fet el /Tipus /Separation amb el nom extern normatiu a Negre
    %%      {
    %%       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (g\015) writestring
    %%      }
    %%      {
    %%       % sobreixidor x saber on es crida l'espai de color q posarem en tractament progressivament
    %%       (-- Solucio DeviceGray :g: NO implementada!) == quit
    %%      }ifelse
    %%     }
    %%     {
    %%      pop pop
    %%      % sobreixidor x saber on es crida l'espai de color q posarem en tractament progressivament
    %%      (-- Solucio DeviceGray :g: NO implementada!) == quit
    %%     }ifelse
    %%    }
    %%    {
    %%     pop
    %%    }ifelse  % de la tinta que toca ara

    %% solucio DeviceGray (transformat a Black del CMYK)
    %% detector de 4cromia x k
    true /es4c exch def
    %% si toca, capturem l'index iTinta x per pintar el % de Tinta de la separacio
    << /Cyan 3 /Magenta 2 /Yellow 1 /Black 0 >> dup quinaTinta known
    {
     quinaTinta get /iTinta exch def /TiNTeMF true def /LaQtocaF true def
    }
    {
     pop /TiNTeMF false def /LaQtocaF false def
    }ifelse
    TiNTeMF
    {  %% es la tinta que toca ara ?
     csARA 0 /PureCMYK put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
     /Tfill 0 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
     %% com que ja sabem segur que es un /PureCMYK ...
     iTinta index dup /TacaTintaF exch def  %% ens quedem amb el % de la Tinta que toca
     %% aqui hauriem de comprovar que si la separacio a pintar es zero i
     %% l'Overprint esta activat, doncs NO ho pintem
     0 eq
     {
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       /ppop true def
       %% x saber si actua l'overprint
       false /opactua exch def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get
       dup
       null eq
       {  %% l'Overprint no esta activat
        pop /ppop true def
        %% x saber si actua l'overprint
        false /opactua exch def
       }
       {
        dup
        /op known  %% primer mirem si si ha op al dic
        {
         dup /op get
         {
          dup /OPM known
          {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
           /OPM get 1 eq
           {  %% l'Overprint es actiu
            /ppop false def
            /TiNTeMF false def  %% hem d'evitar que es pintin els objectes que segueixen
            %% x saber si actua l'overprint
            true /opactua exch def
           }
           {  %% l'Overprint no esta activat
            %% x saber si actua l'overprint
            false /opactua exch def
            /ppop true def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           %% x saber si actua l'overprint
           false /opactua exch def
           pop /ppop true def
          }ifelse
         }
         {  %% l'overprint es a false, doncs no es activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /opactua exch def
         }ifelse
        }
        {  %% ara mirem si hi ha OP doncs en fa el paper en la seva absencia
         dup /OP known
         {
          dup /OP get
          {
           dup /OPM known
           {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
            /OPM get 1 eq
            {  %% l'Overprint es actiu
             /ppop false def
             /TiNTeMF false def  %% hem d'evitar que es pintin els objectes que segueixen
             %% x saber si actua l'overprint
             true /opactua exch def
            }
            {  %% l'Overprint no esta activat
             /ppop true def
             %% x saber si actua l'overprint
             false /opactua exch def
            }ifelse
           }
           {  %% l'Overprint no esta activat
            pop /ppop true def
            %% x saber si actua l'overprint
            false /opactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop /ppop true def
           %% x saber si actua l'overprint
           false /opactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /opactua exch def
         }ifelse
        } ifelse
       }ifelse  %% del null
      }ifelse
     }
     {
      /ppop true def
     }ifelse
     ppop
     {  %% pintem per l'overprint ?
      4 {pop} repeat  %% ens carreguem els 4 valors
      [0 0 0 0] dup 3 TacaTintaF put
      {
       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      } forall
      sEdAs2 (k\012) writestring
     }
     {
      pop pop pop pop
     }ifelse
    }
    {
     pop pop pop pop
    }ifelse  %% de la tinta que toca ara
    %% solucio DeviceGray (transformat a Black del CMYK)
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    %% reescrivim identic com a g
    10000 mul truncate 10000 div 64 string cvs
    sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (g\012) writestring
    }stopped{( ... peta g) pstack quit}if
   }
  ] i_g get /g exch bind def

  [  %% RG
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop pop
    }
    {
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (RG\012) writestring
    }ifelse
    %%}stopped{( ... peta RG) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    TiNTeMS
    {  %% es la tinta que toca ara ?
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (RG\012) writestring
    }
    {
     pop pop pop
    }ifelse  %% de la tinta que toca ara
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (RG\012) writestring
    }stopped{( ... peta RG) pstack quit}if
   }
  ] i_RG get /RG exch bind def

  [  %% rg
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop pop pop
     }
     {
      3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (rg\012) writestring
     }ifelse
    }stopped{( ... peta rg) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    TiNTeMF
    {  %% es la tinta que toca ara ?
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (rg\012) writestring
    }
    {
     pop pop pop
    }ifelse  %% de la tinta que toca ara
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificador de PDF
    {  % stopped
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (rg\012) writestring
    }stopped{( ... peta rg) pstack quit}if
   }
  ] i_rg get /rg exch bind def

  [  %% K
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop pop pop
    }
    {
     4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (K\012) writestring
    }ifelse
    %%}stopped{( ... peta K) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %% detector de 4cromia x K
    true /es4c exch def
    %% si toca, capturem l'index iTinta x per pintar el % de Tinta de la separacio
    << /Cyan 3 /Magenta 2 /Yellow 1 /Black 0 >> dup quinaTinta known
    {
     quinaTinta get /iTinta exch def /TiNTeMS true def /LaQtocaS true def
    }
    {
     pop /TiNTeMS false def /LaQtocaS false def
    }ifelse
    TiNTeMS
    {  %% es la tinta que toca ara ?
     CSARA 0 /PureCMYK put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
     /Tfill 1 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
     %% com que ja sabem segur que es un /PureCMYK ...
     iTinta index dup /TacaTintaS exch def  %% ens quedem amb el % de la Tinta que toca
     %% aqui hauriem de comprovar que si la separacio a pintar es zero i
     %% l'Overprint esta activat, doncs NO ho pintem
     0 eq
     {
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       /ppop true def
       %% x saber si actua l'overprint
       false /OPactua exch def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get dup
       null eq
       {  %% l'Overprint no esta activat
        pop /ppop true def
        %% x saber si actua l'overprint
        false /OPactua exch def
       }
       {
        dup
        /OP known  %% primer mirem si si ha OP al dic
        {
         dup /OP get
         {
          dup /OPM known
          {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
           /OPM get 1 eq
           {  %% l'Overprint es actiu
            /ppop false def
            /TiNTeMS false def  %% hem d'evitar que es pintin els objectes que segueixen
            %% x saber si actua l'overprint
            true /OPactua exch def
           }
           {  %% l'Overprint no esta activat
            /ppop true def
            %% x saber si actua l'overprint
            false /OPactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop /ppop true def
           %% x saber si actua l'overprint
           false /OPactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /OPactua exch def
         }ifelse
        }
        {  %% l'Overprint no esta activat
         pop /ppop true def
         %% x saber si actua l'overprint
         false /OPactua exch def
        } ifelse
       } ifelse  %% del null
      }ifelse
     }
     {
      /ppop true def
     }ifelse
     ppop
     {  %% pintem per l'overprint ?
      4 {pop} repeat  %% ens carreguem els 4 valors
      [0 0 0 0] dup 3 TacaTintaS put
      {
       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      } forall
      sEdAs2 (K\012) writestring
     }
     {
      pop pop pop pop
     }ifelse
    }
    {  %% tret que sigui zero (pintaria en blanc) mirem l'overprint x si ens carreguem les dades de color
     4 copy add add add 0 eq
     {
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       /ppop true def
       %% x saber si actua l'overprint
       false /OPactua exch def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get dup
       null eq
       {  %% l'Overprint no esta activat
        pop /ppop true def
        %% x saber si actua l'overprint
        false /OPactua exch def
       }
       {
        dup
        /OP known  %% primer mirem si si ha OP al dic
        {
         dup /OP get
         {
          dup /OPM known
          {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
           /OPM get 1 eq
           {  %% l'Overprint es actiu
            /ppop false def
            /TiNTeMS false def  %% hem d'evitar que es pintin els objectes que segueixen
            %% x saber si actua l'overprint
            true /OPactua exch def
           }
           {  %% l'Overprint no esta activat
            /ppop true def
            %% x saber si actua l'overprint
            false /OPactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop /ppop true def
           %% x saber si actua l'overprint
           false /OPactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /OPactua exch def
         }ifelse
        }
        {  %% l'Overprint no esta activat
         pop /ppop true def
         %% x saber si actua l'overprint
         false /OPactua exch def
        } ifelse
       } ifelse  %% del null
      }ifelse
      ppop
      {  %% conservem les dades   
       4 array astore
       {  %% conservem les dades
        10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       } forall
       sEdAs2 (K\012) writestring
      }
      {  %% ens les carreguem
       pop pop pop pop
      }ifelse
     }
     {  %% ens les carreguem
      pop pop pop pop
     }ifelse
    }ifelse  %% de la tinta que toca ara
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    {  % stopped
    4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (K\012) writestring
    }stopped{( ... peta K) pstack quit}if
   }
  ] i_K get /K exch bind def

  [  %% k
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop pop pop
    }
    {
     4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (k\012) writestring
    }ifelse
    %%}stopped{( ... peta k) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %% detector de 4cromia x k
    true /es4c exch def
    %% si toca, capturem l'index iTinta x per pintar el % de Tinta de la separacio
    << /Cyan 3 /Magenta 2 /Yellow 1 /Black 0 >> dup quinaTinta known
    {
     quinaTinta get /iTinta exch def /TiNTeMF true def /LaQtocaF true def
    }
    {
     pop /TiNTeMF false def /LaQtocaF false def
    }ifelse
    TiNTeMF
    {  %% es la tinta que toca ara ?
     csARA 0 /PureCMYK put  %% afegim sempre a la posicio 0 el nom de l'espai de color actual per fill
     /Tfill 0 def  %% gatell per saber si el valor de tinta es per fill (0) o stroke (1)
     %% com que ja sabem segur que es un /PureCMYK ...
     iTinta index dup /TacaTintaF exch def  %% ens quedem amb el % de la Tinta que toca
     %% aqui hauriem de comprovar que si la separacio a pintar es zero i
     %% l'Overprint esta activat, doncs NO ho pintem
     0 eq
     {
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       /ppop true def
       %% x saber si actua l'overprint
       false /opactua exch def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get
       dup
       null eq
       {  %% l'Overprint no esta activat
        pop /ppop true def
        %% x saber si actua l'overprint
        false /opactua exch def
       }
       {
        dup
        /op known  %% primer mirem si si ha op al dic
        {
         dup /op get
         {
          dup /OPM known
          {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
           /OPM get 1 eq
           {  %% l'Overprint es actiu
            /ppop false def
            /TiNTeMF false def  %% hem d'evitar que es pintin els objectes que segueixen
            %% x saber si actua l'overprint
            true /opactua exch def
           }
           {  %% l'Overprint no esta activat
            %% x saber si actua l'overprint
            false /opactua exch def
            /ppop true def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           %% x saber si actua l'overprint
           false /opactua exch def
           pop /ppop true def
          }ifelse
         }
         {  %% l'overprint es a false, doncs no es activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /opactua exch def
         }ifelse
        }
        {  %% ara mirem si hi ha OP doncs en fa el paper en la seva absencia
         dup /OP known
         {
          dup /OP get
          {
           dup /OPM known
           {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
            /OPM get 1 eq
            {  %% l'Overprint es actiu
             /ppop false def
             /TiNTeMF false def  %% hem d'evitar que es pintin els objectes que segueixen
             %% x saber si actua l'overprint
             true /opactua exch def
            }
            {  %% l'Overprint no esta activat
             /ppop true def
             %% x saber si actua l'overprint
             false /opactua exch def
            }ifelse
           }
           {  %% l'Overprint no esta activat
            pop /ppop true def
            %% x saber si actua l'overprint
            false /opactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop /ppop true def
           %% x saber si actua l'overprint
           false /opactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /opactua exch def
         }ifelse
        } ifelse
       }ifelse  %% del null
      }ifelse
     }
     {
      /ppop true def
     }ifelse
     ppop
     {  %% pintem per l'overprint ?
      4 {pop} repeat  %% ens carreguem els 4 valors
      [0 0 0 0] dup 3 TacaTintaF put
      {
       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      } forall
      sEdAs2 (k\012) writestring
     }
     {
      pop pop pop pop
     }ifelse
    }
    {
     4 copy add add add 0 eq
     {  %% tret que sigui zero (pintaria en blanc) mirem l'overprint x si ens carreguem les dades de color
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca
       /gs01 0 def
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get /gs01 1 def}{0 get /gs01 0 def}ifelse
      }ifelse
      null eq
      {
       /ppop true def
       %% x saber si actua l'overprint
       false /opactua exch def
      }  %% si es null es que l'Overprint no esta activat
      {
       gsARA gs01 get  %% mirem dins l'estat grafic que toca
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill get 0 get
       dup
       null eq
       {  %% l'Overprint no esta activat
        pop /ppop true def
        %% x saber si actua l'overprint
        false /opactua exch def
       }
       {
        dup
        /op known  %% primer mirem si si ha op al dic
        {
         dup /op get
         {
          dup /OPM known
          {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
           /OPM get 1 eq
           {  %% l'Overprint es actiu
            /ppop false def
            /TiNTeMF false def  %% hem d'evitar que es pintin els objectes que segueixen
            %% x saber si actua l'overprint
            true /opactua exch def
           }
           {  %% l'Overprint no esta activat
            %% x saber si actua l'overprint
            false /opactua exch def
            /ppop true def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           %% x saber si actua l'overprint
           false /opactua exch def
           pop /ppop true def
          }ifelse
         }
         {  %% l'overprint es a false, doncs no es activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /opactua exch def
         }ifelse
        }
        {  %% ara mirem si hi ha OP doncs en fa el paper en la seva absencia
         dup /OP known
         {
          dup /OP get
          {
           dup /OPM known
           {  %% en colors PureCMYK o DeviceCMYK nomes si OPM es a 1 actua l'Overprint
            /OPM get 1 eq
            {  %% l'Overprint es actiu
             /ppop false def
             /TiNTeMF false def  %% hem d'evitar que es pintin els objectes que segueixen
             %% x saber si actua l'overprint
             true /opactua exch def
            }
            {  %% l'Overprint no esta activat
             /ppop true def
             %% x saber si actua l'overprint
             false /opactua exch def
            }ifelse
           }
           {  %% l'Overprint no esta activat
            pop /ppop true def
            %% x saber si actua l'overprint
            false /opactua exch def
           }ifelse
          }
          {  %% l'Overprint no esta activat
           pop /ppop true def
           %% x saber si actua l'overprint
           false /opactua exch def
          }ifelse
         }
         {  %% l'Overprint no esta activat
          pop /ppop true def
          %% x saber si actua l'overprint
          false /opactua exch def
         }ifelse
        } ifelse
       }ifelse  %% del null
      }ifelse
      ppop
      {  %% conservem les dades
       4 array astore
       {
        10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       } forall
       sEdAs2 (k\012) writestring
      }
      {  %% ens les carreguem
       pop pop pop pop
      }ifelse
     }
     {  %% ens les carreguem
      pop pop pop pop
     }ifelse
    }ifelse  %% de la tinta que toca ara
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    {  % stopped
    4 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (k\012) writestring
    }stopped{( ... peta k) pstack quit}if
   }
  ] i_k get /k exch bind def

  %% (PDF Ref 1.7) 4.6 Shading Patterns
  [  %% sh
   {  %% 0 eliminem continguts
    alFoc
    {
     pop
    }
    {
     DuuLlesques
     {
      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 ( sh\012) writestring
     }
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 4 get dup 0 true put  %% marquem els Shading Patterns com actius
      1 get writestring ( BDC\012) writestring
      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (sh\012EMC\012) writestring
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%% ep aqui considerem l'operador del Shadings com a fill sempre
    /Tfill 0 def  %% ara posem a l'inici de cada operador de pintat el gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    %% ens arrisquem a considerar sempre el valor de TacaTintaF com a *diferent de zero*
    %% doncs no resultaria massa logic que algu fes un Shading de zero a zero de tinta
    %% de tota manera x treballar al 100% l'hauriem de deduir d'interrogar C0 i C1
    %% de la Function associada, pero ho deixarem x+ endavant si es dona el cas ...
    /TacaTintaF 1 def
    %% donat que l'espai de color es contingut dins el Shading, el reinterroguem x saber si es la tinta que toca ara ...
    dup /elSha exch def
    XRay /Patterns&Shadings get /Utilitzats get elSha known
    {
     XRay /Patterns&Shadings get /Utilitzats get elSha get 2 get      
     dup type /nametype eq
     {
      dup /DeviceCMYK eq
      {  %% Process Color
       pop [/Cyan /Magenta /Yellow /Black]
       /ToCa false def
       {quinaTinta eq{/ToCa true def exit}if}forall
      }
      {
       quinaTinta eq {/ToCa true def}{/ToCa false def}ifelse
      }ifelse
     }
     {  %% es un array
      /ToCa false def
      {quinaTinta eq{/ToCa true def exit}if}forall
     }ifelse
    }
    {
     /ToCa false def
    }ifelse
    %%TiNTeM
    ToCa
    {  %% es la tinta que toca ara ?
     %%        LaQtoca {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (sh\012) writestring
     %%% desactivem la gestio de la variable LaQtoca
     %%                }
     %%                {  % potser que tinguem Tintem actiu pero que no sigui la tinta que toqui ara separar
     %%                 gsARA 0 get  % mirem dins l'estat grafic que toca
     %%                 dup null eq {
     %%                              pop
     %%                              sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     %%                              sEdAs2 (sh\015) writestring
     %%                             }{    % x filtrar Null
     %%                 XRay /EstatsGrafics get /Utilitzats get exch get
     %%                 Tfill 1 eq {  % com que es OP llavors, cap problema
     %%                             Tfill get 0 get
     %%                             null eq
     %%                             {  % l'Overprint no esta activat
     %%                              sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     %%                              sEdAs2 (sh\015) writestring
     %%                             }
     %%                             {  % l'Overprint es actiu
     %%                              pop
     %%                              sEdAs2 (n\015) writestring  % matem el path amb 'n'
     %%                             } ifelse
     %%                            }
     %%                            {  % si es op cal assegurar-se que ...
     %%                             dup Tfill get 2 get  % op es definit al gs actual ?
     %%                             null eq {  % el gs actual NO te definit op
     %%                                      1 get 0 get  % llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
     %%                                      null eq
     %%                                      {  % l'Overprint no esta activat
     %%                                       sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     %%                                       sEdAs2 (sh\015) writestring
     %%                                      }
     %%                                      {  % l'Overprint es actiu
     %%                                       pop
     %%                                       sEdAs2 (n\015) writestring  % matem el path amb 'n'
     %%                                      } ifelse
     %%                                     }
     %%                                     {  % el gs actual SI te definit op
     %%                                      Tfill get 0 get
     %%				      null eq
     %%				      {  % l'Overprint no esta activat
     %%				       sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     %%				       sEdAs2 (sh\015) writestring
     %%				      }
     %%				      {  % l'Overprint es actiu
     %%				       pop
     %%				       sEdAs2 (n\015) writestring  % matem el path amb 'n'
     %%                                      } ifelse
     %%                                     }ifelse
     %%                            }ifelse
     %%                 } ifelse  % x filtrar Null
     %%                }ifelse
    }
    {  %% si NO tintem les lleis de l'overprint son les mateixes q quan ho gestionavem amb LaQtoca
     %% es a false, tret que no pintem amb valor zero ...
     TacaTintaF 0 eq  %% hem pintat (aquest es el valor de tinta de la separacio) amb valor zero?
     {  %% si
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {  %% l'Overprint no esta activat
       pop
       pop sEdAs2 (n\012) writestring  %% si no es la tinta q toca doncs no cal pintar res!!
      }
      {    %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         pop sEdAs2 (n\012) writestring  %% si no es la tinta q toca doncs no cal pintar res!!
        }
        {  %% l'Overprint es actiu
         %%(*) ==
         pop
         %%% com q hem comprovat que Coords no sempre dona l'area rectangular del Shading (haria de ser l'entrada no obligatoria BBox) ...
         %%                       XRay /Patterns&Shadings get /Utilitzats get elSha known
         %%                       {
         %%                        % estem segurs que hi sera x poder pescar-ne el dic ...
         %%                        JectesPS /Shading get elSha get
         %%                        dup type /nametype eq
         %%                        {
         %%                         /laBranca exch def
         %%                         % amb aquesta estrategia aconseguim treballar amb el 'currentdict' que en condicions normals ens rutllaria directe pero en aquest context no
         %%                         countdictstack array dictstack  % emmagatzemem els dics actius en un paquet
         %%                         {dup /0 known {/CURRENTdict exch def}{pop}ifelse} forall           
         %%                         % pesquem la branca ...
         %%                         /iDimoni 0 def
         %%                         {  % loop d'interrogacio dels dicts de COMdimoni
         %%                          CURRENTdict iDimoni 4 string cvs cvn get
         %%                          % el diccionari de l'objecte
         %%                          dup laBranca known {laBranca get exit}{pop}ifelse 
         %%                          iDimoni 1 add /iDimoni exch def
         %%                          iDimoni MaxDimoni eq {exit} if
         %%                         } loop  % d'interrogacio dels dicts de COMdimoni
         %%                         currentdict /CURRENTdict undef
         %%                        }if
         %%                        % aquesta entrada es obligatoria a tots els ShadingType 2 i 3 (els unics q ara acceptem a CaLi2CoPi)
         %%                        /Coords get
         %% ... o solucionem pintant tot l'area de la pagina de blanc, doncs el Shading sempre vindra definit dins una clip area (W/W*)
         AMedia
         sEdAs2 (q 0 0 0 0 k ) writestring  %% tapem tot el MediaBox aixi encertem segur l'area retallada rectangular ocupada pel Shading
         {64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
         sEdAs2 (re f Q\012) writestring  %% definim i omplim el rectangle
         %%                       }
         %%                       {  % si no existis el shading (cosa rara) ...
         %%                        sEdAs2 (n\015) writestring  % matem el path amb 'n'
         %%                       }ifelse
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          pop sEdAs2 (n\012) writestring  %% si no es la tinta q toca doncs no cal pintar res!!
         }
         {  %% l'Overprint es actiu
          %%(**) ==
          pop
          %% ... o solucionem pintant tot l'area de la pagina de blanc, doncs el Shading sempre vindra definit dins una clip area (W/W*)
          AMedia
          sEdAs2 (q 0 0 0 0 k ) writestring  %% tapem tot el MediaBox aixi encertem segur l'area retallada rectangular ocupada pel Shading
          {64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
          sEdAs2 (re f Q\012) writestring  %% definim i omplim el rectangle
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          pop sEdAs2 (n\012) writestring  %% si no es la tinta q toca doncs no cal pintar res!!
         }
         {  %% l'Overprint es actiu
          %%(***) ==
          pop
          %% ... o solucionem pintant tot l'area de la pagina de blanc, doncs el Shading sempre vindra definit dins una clip area (W/W*)
          AMedia
          sEdAs2 (q 0 0 0 0 k ) writestring  %% tapem tot el MediaBox aixi encertem segur l'area retallada rectangular ocupada pel Shading
          {64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
          sEdAs2 (re f Q\012) writestring  %% definim i omplim el rectangle
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }
     {  %% no pintem amb valor zero ...
      %%% EP! amb valor de tinta diferent de zero capgirem la logica de l'overprint
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse         
      dup null eq
      {  %% l'Overprint no esta activat
       pop
       pop
       %% ... o solucionem pintant tot l'area de la pagina de blanc, doncs el Shading sempre vindra definit dins una clip area (W/W*)
       AMedia
       sEdAs2 (q 0 0 0 0 k ) writestring  %% tapem tot el MediaBox aixi encertem segur l'area retallada rectangular ocupada pel Shading
       {64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
       sEdAs2 (re f Q\012) writestring  %% definim i omplim el rectangle
      }
      {    %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         pop
         %% ... o solucionem pintant tot l'area de la pagina de blanc, doncs el Shading sempre vindra definit dins una clip area (W/W*)
         AMedia
         sEdAs2 (q 0 0 0 0 k ) writestring  %% tapem tot el MediaBox aixi encertem segur l'area retallada rectangular ocupada pel Shading
         {64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
         sEdAs2 (re f Q\012) writestring  %% definim i omplim el rectangle
        }
        {  %% l'Overprint es actiu
         %%(*1) ==
         pop sEdAs2 (n\012) writestring  %% si no es la tinta q toca doncs no cal pintar res!!
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          pop
          %% ... o solucionem pintant tot l'area de la pagina de blanc, doncs el Shading sempre vindra definit dins una clip area (W/W*)
          AMedia
          sEdAs2 (q 0 0 0 0 k ) writestring  %% tapem tot el MediaBox aixi encertem segur l'area retallada rectangular ocupada pel Shading
          {64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
          sEdAs2 (re f Q\012) writestring  %% definim i omplim el rectangle
         }
         {  %% l'Overprint es actiu
          %%(**1) ==
          pop sEdAs2 (n\012) writestring  %% si no es la tinta q toca doncs no cal pintar res!!
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          pop
          %% ... o solucionem pintant tot l'area de la pagina de blanc, doncs el Shading sempre vindra definit dins una clip area (W/W*)
          AMedia
          sEdAs2 (q 0 0 0 0 k ) writestring  %% tapem tot el MediaBox aixi encertem segur l'area retallada rectangular ocupada pel Shading
          {64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
          sEdAs2 (re f Q\012) writestring  %% definim i omplim el rectangle
         }
         {  %% l'Overprint es actiu
          %%(***1) ==
          pop sEdAs2 (n\012) writestring  %% si no es la tinta q toca doncs no cal pintar res!!
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse  %% pintem o no amb valor zero?
    }ifelse
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    {  % stopped
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 ( sh\012) writestring
    }stopped{( ... peta sh) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 ( sh\012) writestring
    }
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs2 dup dup (/OC ) writestring
     llesques 4 get dup 0 true put  %% marquem els Shading Patterns com actius
     1 get writestring ( BDC\012) writestring
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (sh\012EMC\012) writestring
    }ifelse
   }
  ] i_sh get /sh exch bind def

%%% ATENCIO ... MANCA INCLOURE LES MATEIXES MODIFICACIONS DE sh, a la resta d'operadors sensibles a llesques
%%    /i_l 2 def  % activa les llesques dels vectorials
%%    /i_c 2 def  % activa les llesques dels vectorials
%%    /i_v 2 def  % activa les llesques dels vectorials
%%    /i_y 2 def  % activa les llesques dels vectorials
%%    /i_re 2 def  % activa les llesques dels vectorials
%%    /i_h 1 def
%%    /i_n 2 def  % activa les llesques dels vectorials
%%    /i_s 2 def  % activa les llesques dels vectorials
%%    /i_S 2 def  % activa les llesques dels vectorials
%%    /i_f 2 def  % activa les llesques dels vectorials
%%    /i_F 2 def  % activa les llesques dels vectorials
%%    /i_f* 2 def  % activa les llesques dels vectorials
%%    /i_b 2 def  % activa les llesques dels vectorials
%%    /i_B 2 def  % activa les llesques dels vectorials
%%    /i_b* 2 def  % activa les llesques dels vectorials
%%    /i_B* 2 def  % activa les llesques dels vectorials
%%    /i_sh 2 def  % activa les llesques dels Shading Patterns

  %% (PDF Ref 1.7) XObjects 4.8 Images 4.9 Form XObjects
  %% (PDF Ref ?) 8.8.1 XObject operators
  [  %% Do
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
    DuuLlesques
    {
     HiHaForms
     {  %% si hi ha Forms XObjects
      QuiSapSiFXO
      {  %% si es sospitos de ser un Form XObject
       dup
       XRay /ObjectesX get araPlana get  %% pesquem el dic dels XObjects de la plana on som
       /Utilitzats get dup 2 index known
       {
        exch get  %% confiem q sempre hi sera!
        dup 0 get type /arraytype eq
        {  %% es un Form XObject!
         %% llavors cal reescriure el valor de la llesca com a tal ...
         sEdAs2 dup dup (/OC ) writestring
         llesques 1 get dup 0 true put  %% marquem els Forms XObjects com actius
         1 get writestring ( BDC\012) writestring
         %% llavors com afegim a Properties dels Resources del Form la llesca farcell?
         1 2 getinterval  %% pesquem les ref ind dels Resources i de l'objecte FormXObject dins una array
         rsrcsFormsXObjects dup length dup /fotliA exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll fotliA exch put userdict exch /rsrcsFormsXObjects exch put  %% ampliem l'array amb la nova ref ind i desem a la base dels diccionaris (doncs estem dins d'un altre!)
         %% sembla que podem clonar tranquil·lament el contingut del Properties de la pagina amb el del propi FormXObject
         %% veure ... llesquesApel_fa1imatge1vectorial1textDins1FormXObject_i1XObjectIndependent.pdf
        }
        {  %% es un XObject normal
         pop  %% eliminem l'array q el descriu
         %% llavors cal reescriure el valor de la llesca com a tal ...
         sEdAs2 dup dup (/OC ) writestring
         llesques 0 get dup 0 true put  %% marquem els XObjects com actius
         1 get writestring ( BDC\012) writestring
userdict /HiHaXObjects true put
        }ifelse
       }
       {  %%  pertany a un Do d'un XObject normal (de l'stream del Form i per aixo no es localitzat?)
        pop pop
        %% llavors cal reescriure el valor de la llesca com a tal ...
        sEdAs2 dup dup (/OC ) writestring
        llesques 0 get dup 0 true put  %% marquem els XObjects com actius
        1 get writestring ( BDC\012) writestring
userdict /HiHaXObjects true put
       }ifelse
      }if
     }if
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 ( Do\012) writestring
    }
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs2 dup dup (/OC ) writestring
     llesques 0 get dup 0 true put  %% marquem els XObjects com actius
     1 get writestring ( BDC\012) writestring
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 ( Do\012EMC\012) writestring
    }ifelse
    }ifelse
    %%}stopped{( ... peta Do 3) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %% aqui considerem l'operador dels XObject com a fill sempre
    /Tfill 0 def  %% ara posem a l'inici de cada operador de pintat el gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    %% ens arrisquem a considerar sempre el valor de TacaTintaF com a *diferent de zero*
    %% doncs no resultaria massa logic que algu fes un XObject a zero de tinta
    %% de tota manera x treballar al 100% l'hauriem de deduir d'interrogant el RAW?
    %% pero ho deixarem x + endavant si es dona el cas ...
    /TacaTintaF 1 def
    /XBJCT exch def  %% desem el nom de l'XObject
    /iTiNTeM false def  %% gatell x saber si llistem o no
    %% interroguem l'array de la tinta que toca x saber si llista la imatge ...
    XRay /EspaisDeColor get /TintesiValors get quinaTinta get
    {  %% forall
     dup XBJCT eq
     {
      pop /iTiNTeM true def exit
     }
     {  %% ens assegurem que no sigui un Form
      FormsiXObjects XBJCT known
      {  %% si existeix aqui dins es que ho es
       /noXBJCT exch def  %% desem el nom que no s'ha igualat en el primer intent
       FormsiXObjects XBJCT get
       %% explorant l'array mirem si es tracta d'una imatge XObject continguda dins el Form
       {noXBJCT eq{/iTiNTeM true def exit}if}forall
      }
      {
       pop
      }ifelse
      %%iTiNTeM (waiting for RedOnion) pstack quit
     }ifelse
    }forall
    iTiNTeM
    {  %% es la tinta que toca ara ?
     XBJCT
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 32 write sEdAs2 (Do\012) writestring
    }
    {  %% si no es la tinta q toca cal consultar l'overprint!
     TacaTintaF 0 eq  %% hem pintat (aquest es el valor de tinta de la separacio) amb valor zero?
     {  %% si
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse   
      dup null eq
      {  %% l'Overprint no esta activat
       pop 
       %% si no es la tinta q toca doncs no cal pintar res!!
      }
      {    %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %% si no es la tinta q toca doncs no cal pintar res!!
        }
        {  %% l'Overprint es actiu
         %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
         %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
         sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %% si no es la tinta q toca doncs no cal pintar res!!
         }
         {  %% l'Overprint es actiu
          %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
          %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
          sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %% si no es la tinta q toca doncs no cal pintar res!!
         }
         {  %% l'Overprint es actiu
          %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
          %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
          sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }
     {  %% NO pintem amb valor zero ...
      %%% EP! amb valor de tinta diferent de zero capgirem la logica de l'overprint
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {  %% l'Overprint no esta activat
       pop
       %%( Overprint NO actiu 0) ==
       %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
       %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
       sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
      }
      {    %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%( Overprint NO actiu 1) ==
         %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
         %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
         sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
        }
        {  %% l'Overprint es actiu
         %%( Overprint Actiu 0) ==
         %% si no es la tinta q toca doncs no cal pintar res!!
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%( Overprint NO actiu 2) ==
          %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
          %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
          sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
         }
         {  %% l'Overprint es actiu
          %%( Overprint Actiu 1) ==
          %% si no es la tinta q toca doncs no cal pintar res!!
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%( Overprint NO actiu 3) ==
          %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
          %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
          sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
         }
         {  %% l'Overprint es actiu
          %%( Overprint Actiu 2) ==
          %% si no es la tinta q toca doncs no cal pintar res!!
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse  %% pintem o no amb valor zero?
    }ifelse  %% de la tinta que toca ara, apliquem les lleis de l'overprint
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    %%{  % stopped
    dup iFenix dup length 0 eq
    {  %% en aquest fitxer nomes hi ha imatges isolades
     pop == (<<<< imatge NORMAL!)==
     dup JectesX araPlana get exch get FRoNTiSeS exch null put  %% desem la seva ref ind al dic de control FRoNTiSeS que fara que no pugui esborrar-se malgrat estigui compartida per una altra de nom diferent pertanyent a un mosaic
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 ( Do\012) writestring
    }
    {  %% es una imatge frontisa (la clau del mosaic) ?
     dup araPlana known  %% en aquesta plana hi ha trencaclosques?
     {
      araPlana get exch known
      {  %%% en aquest procediment es on modifiquem el metode d'aillar el clips que duen les imatges
       dup  %%==
       dup == (<<<< imatge FRONTISA del trencaclosques!)==
       iFenix araPlana get exch get /matriu get  %% aqui capturem la matriu modificada pel darrer cm d'aquesta imatge frontisa
%%% EP AIXO NO HAURIA D'ANAR LLIGAT TAMBE A EstatGrafic ??
       %% reescrivim el darrer estat grafic (aixo potser ho haurem de canviar + endavant pel gsARA original)
       ARAgs null ne  %% mentre no sigui un null (no se n'hauria cridat cap encara)
       {
        sEdAs2 (/) writestring ARAgs 128 string cvs sEdAs2 exch writestring sEdAs2 ( gs ) writestring
       }if

%% veiem que:
%% PENSO Q ABANS Q RES CAL DEMANAR-SE SI EL PROPI cm DUU CAP CLIP DONCS SI NO EL DUU ...
%% posem tants 'Q' de tancament fins el darrer estat on hi hagi WARA o W*ARA (cap enrera) i posem els mateixos 'q' d'obertura

%%% I SI TANQUEM A PINYO FIX EL PROPI ESTAT GRAFIC I PROU???
false {

/qUANTS 0 def  %% comptador d'obertures (q) de l'estat grafic q cal escriure
/HiHaW false def  %% gatell x saber si hi ha clip

0 /darreRcm exch def  %% valor inicial de l'index de l'estat grafic actiu q dugui 

        EstatGrafic

	length 1 sub -1 1  %% anem de fora cap endins
        {  %% for
	 EstatGrafic exch get
         dup /WARA known exch /W*ARA known or
         {
	  /HiHaW true def
	  HiHaW
	  {
	   qUANTS 1 add /qUANTS exch def
	   exit
	  }
	  {
           qUANTS 1 add /qUANTS exch def
	  }ifelse
         }
	 {
	  HiHaW
	  {
	   exit
	  }
	  {
           qUANTS 1 add /qUANTS exch def
	  }ifelse
	 }ifelse
        }for

       %% tanquem els estats grafics i els tornem a obrir per ...
       HiHaW
       {
        qUANTS {sEdAs2 (Q ) writestring}repeat
        qUANTS {sEdAs2 (q ) writestring}repeat
       }if
%%% TANQUEM A PINYO FIX EL PROPI ESTAT GRAFIC I PROU
}{sEdAs2 ( Q q ) writestring}ifelse
       
       %% cal reescriure la cm del primer estat actiu (cap enrera) sempre que els valor d'escala /cmSx i /cmSy sigui diferent d'1
       %% (p.e. l'exemple Qpassa.pdf duu un valor d'escala q cal conservar)
       EstatGrafic
       length 1 sub -1 1  %% anem de fora cap endins
       {  %% for
	dup EstatGrafic exch get
        dup /cmSx known
	{  %% si hi es, es que l'escala de la cm ha estat modificada
%%{== ==}forall (+++++?+++++)pstack quit
	pop pop
%%	 dup /cmSx get

%%	 /darreRcm exch def  % al sortir del for tindrem l'index del darrer estat grafic actiu significatiu pel clip
	}
	{  %% si no hi es, doncs la cm s'hereta d'un estat grafic anterior
	 pop pop
	}ifelse
       }for

%%	  get /araEG exch def
%%          [
%%	   araEG /cmSx get  % escala X a cm
%%           araEG /cm_tanAsin get  % valor de la tangent o del sinus de l'angle a cm
%%           araEG /cm_tanBsin get  % valor de la tangent o del sinus de l'angle a cm
%%	   araEG /cmSy get  % escala Y a cm
%%           araEG /cmPx get  % X de l'origen de l'eix de coordenades a cm
%%           araEG /cmPy get  % Y de l'origen de l'eix de coordenades a cm
%%          ]
%%          % escrivim la matriu modificada de la imatge frontisa
%%          {10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
%%          sEdAs2 (cm\012) writestring

       %% escrivim la matriu modificada de la imatge frontisa
       {10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
       sEdAs2 (cm /) writestring 128 string cvs sEdAs2 exch writestring
       sEdAs2 ( Do\012) writestring
      }   %%% en aquest procediment es on modifiquem el metode d'aillar el clips que duen les imatges
      {  %% es una imatge del mosaic a eliminar ?
       KaMPoRa 1 index known
       {  %% si es en aquest dic l'hem d'esborrar de l'stream, de XObject i tambe l'objecte associat
        == (<<<< imatge del trencaclosques que eliminem!)==
       }
       {  %% es una imatge normal i corrent que no fa trencaclosques amb res
        dup == (<<<< imatge NORMAL!)==
        dup JectesX araPlana get exch get FRoNTiSeS exch null put  %% desem la seva ref ind al dic de control FRoNTiSeS que fara que no pugui esborrar-se malgrat estigui compartida per una altra de nom diferent pertanyent a un mosaic
        sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
        sEdAs2 32 write sEdAs2 (Do\012) writestring
       }ifelse
      }ifelse
     
     }
     {  %% en aquesta plana NO hi ha trencaclosques ...
      pop == (<<<< imatge NORMAL!)==
      dup JectesX araPlana get exch get FRoNTiSeS exch null put  %% desem la seva ref ind al dic de control FRoNTiSeS que fara que no pugui esborrar-se malgrat estigui compartida per una altra de nom diferent pertanyent a un mosaic
      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
      sEdAs2 32 write sEdAs2 (Do\012) writestring
     }ifelse
    }ifelse
    %%}stopped{( ... peta Do) == quit}if
   }
   {  %% 3 verificacio de PDF
    %%{  % stopped
    DuuLlesques
    {
     HiHaForms
     {  %% si hi ha Forms XObjects
      QuiSapSiFXO
      {  %% si es sospitos de ser un Form XObject
       dup
       XRay /ObjectesX get araPlana get  %% pesquem el dic dels XObjects de la plana on som
       /Utilitzats get dup 2 index known
       {
        exch get  %% confiem q sempre hi sera!
        dup 0 get type /arraytype eq
        {  %% es un Form XObject!
         %% llavors cal reescriure el valor de la llesca com a tal ...
         sEdAs2 dup dup (/OC ) writestring
         llesques 1 get dup 0 true put  %% marquem els Forms XObjects com actius
         1 get writestring ( BDC\012) writestring
         %% llavors com afegim a Properties dels Resources del Form la llesca farcell?
         1 2 getinterval  %% pesquem les ref ind dels Resources i de l'objecte FormXObject dins una array
         rsrcsFormsXObjects dup length dup /fotliA exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll fotliA exch put userdict exch /rsrcsFormsXObjects exch put  %% ampliem l'array amb la nova ref ind i desem a la base dels diccionaris (doncs estem dins d'un altre!)
         %% sembla que podem clonar tranquil·lament el contingut del Properties de la pagina amb el del propi FormXObject
         %% veure ... llesquesApel_fa1imatge1vectorial1textDins1FormXObject_i1XObjectIndependent.pdf
        }
        {  %% es un XObject normal
         pop  %% eliminem l'array q el descriu
         %% llavors cal reescriure el valor de la llesca com a tal ...
         sEdAs2 dup dup (/OC ) writestring
         llesques 0 get dup 0 true put  %% marquem els XObjects com actius
         1 get writestring ( BDC\012) writestring
userdict /HiHaXObjects true put
        }ifelse
       }
       {  %%  pertany a un Do d'un XObject normal (de l'stream del Form i per aixo no es localitzat?)
        pop pop
        %% llavors cal reescriure el valor de la llesca com a tal ...
        sEdAs2 dup dup (/OC ) writestring
        llesques 0 get dup 0 true put  %% marquem els XObjects com actius
        1 get writestring ( BDC\012) writestring
userdict /HiHaXObjects true put
       }ifelse
      }if
     }if
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 ( Do\012) writestring
    }
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs2 dup dup (/OC ) writestring
     llesques 0 get dup 0 true put  %% marquem els XObjects com actius
     1 get writestring ( BDC\012) writestring
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 ( Do\012EMC\012) writestring
    }ifelse
    %%}stopped{( ... peta Do 3) == quit}if
   }
   {  %% 4 reescriptura idem
    {  % stopped
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
    sEdAs2 ( Do\012) writestring
    }stopped{( ... peta Do) pstack quit}if
   }
   {  %% 5 restaurem continguts
    %%{  % stopped
    alFoc
    {
     pop  %% eliminem el literal d'imatge a refer
     restauraJPEGs araPlana 4 string cvs cvx exec 1 sub dup /Psom exch def
     get dup null eq  %% és el primer XObject que processem en aquesta pàgina?

%%MattBianco
pop true  %% eliminem a pinyo fix totes les imatges

     {  %% no, o sigui que l'ignorem o li seguim la pista per donar-lo de baixa?
      %% per donar-lo de baixa, hauríem de treure'l del dic Resources i matar l'objecte
      %% XObject completament donant-lo d'alta a NomXdBaixa o a OdeBaixa?
      pop
     }
     {  %% si, per tant el fem servir per restaurar la capa d'imatge rasteritzada
      %% i marquem amb un null per fer saber que aquesta pàgina ja ha estat intervinguda
      restauraJPEGs Psom null put

%%MattBianco
%% aquí hauríem de consultar l'estat gràfic per deduir-ne la gestió de cm, q i Q
%% cal implementar l'estructura de control d'EstatGrafic de #6 a les redefinicions de #14
%% EstatGrafic iEG %get  %% recuperem del dic de l'estat grafic actiu
%%{== ==}forall
%%(UUUUUUUUU)pstack quit

      sEdAs2 (Q q ) writestring  %% restaurem l'estat gràfic
      %% per restablir l'eix de coordenades ens cal interrogar el format de pàgina ...
      XRay /PeDeEfa get araPlana get /MediaBox get  %% ens determinarà l'escala d'imatge
      aload pop 3 -1 roll sub /altDpagina exch def exch sub /ampleDpagina exch def
      %% escrivim la matriu de l'espai de coordenades
      sEdAs2 dup dup dup ampleDpagina 128 string cvs writestring ( 0 0 ) writestring altDpagina
      128 string cvs writestring ( 0 0 cm\012) writestring  %% orígen de la imatge i tancament
      %% exraiem el nom del fitxer com a literal intern de l'XObject (per Do i per Resources)
      {
       bUsca search
       {pop pop}{exit}ifelse
      }loop dup /nomXObj exch def
      sEdAs2 dup (/) writestring exch writestring sEdAs2 ( Do\012) writestring
%%(+++++Do+++++)pstack quit
     }ifelse
    }
    {
    DuuLlesques
    {
     HiHaForms
     {  %% si hi ha Forms XObjects
      QuiSapSiFXO
      {  %% si es sospitos de ser un Form XObject
       dup
       XRay /ObjectesX get araPlana get  %% pesquem el dic dels XObjects de la plana on som
       /Utilitzats get dup 2 index known
       {
        exch get  %% confiem q sempre hi sera!
        dup 0 get type /arraytype eq
        {  %% es un Form XObject!
         %% llavors cal reescriure el valor de la llesca com a tal ...
         sEdAs2 dup dup (/OC ) writestring
         llesques 1 get dup 0 true put  %% marquem els Forms XObjects com actius
         1 get writestring ( BDC\012) writestring
         %% llavors com afegim a Properties dels Resources del Form la llesca farcell?
         1 2 getinterval  %% pesquem les ref ind dels Resources i de l'objecte FormXObject dins una array
         rsrcsFormsXObjects dup length dup /fotliA exch def 1 add array dup 3 -1 roll 0 exch putinterval
         dup 3 -1 roll fotliA exch put userdict exch /rsrcsFormsXObjects exch put  %% ampliem l'array amb la nova ref ind i desem a la base dels diccionaris (doncs estem dins d'un altre!)
         %% sembla que podem clonar tranquil·lament el contingut del Properties de la pagina amb el del propi FormXObject
         %% veure ... llesquesApel_fa1imatge1vectorial1textDins1FormXObject_i1XObjectIndependent.pdf
        }
        {  %% es un XObject normal
         pop  %% eliminem l'array q el descriu
         %% llavors cal reescriure el valor de la llesca com a tal ...
         sEdAs2 dup dup (/OC ) writestring
         llesques 0 get dup 0 true put  %% marquem els XObjects com actius
         1 get writestring ( BDC\012) writestring
userdict /HiHaXObjects true put
        }ifelse
       }
       {  %%  pertany a un Do d'un XObject normal (de l'stream del Form i per aixo no es localitzat?)
        pop pop
        %% llavors cal reescriure el valor de la llesca com a tal ...
        sEdAs2 dup dup (/OC ) writestring
        llesques 0 get dup 0 true put  %% marquem els XObjects com actius
        1 get writestring ( BDC\012) writestring
userdict /HiHaXObjects true put
       }ifelse
      }if
     }if
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 ( Do\012) writestring
    }
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs2 dup dup (/OC ) writestring
     llesques 0 get dup 0 true put  %% marquem els XObjects com actius
     1 get writestring ( BDC\012) writestring
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 ( Do\012EMC\012) writestring
    }ifelse
    }ifelse
    %%}stopped{( ... peta Do 3) == quit}if
   }
  ] i_Do get /Do exch bind def

  %% (PDF Ref 1.7) 4.8.6 Inline Images
  %% (PDF Ref ?) 8.9 In-line image objects
  [  %% BI
   {  %% 0 eliminem continguts
    alFoc
    {
     mark
    }
    {
     DuuLlesques
     {
      sEdAs2 (BI\012) writestring mark
     }
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 2 get dup 0 true put  %% marquem les inLine com actives
      1 get writestring ( BDC\012) writestring
      sEdAs2 (BI\012) writestring mark
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%% temporalment l'eliminarem de forma fixa
    %%false {  % es la tinta que toca ara ?
    %%     sEdAs2 (BI\015) writestring mark
    %%}if  % de la tinta que toca ara
    mark  %% deixem la mark per polir-nos totes les dades del dic inline
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny                     
    {  % stopped
    sEdAs2 (BI\012) writestring mark
    }stopped{( ... peta BI) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     sEdAs2 (BI\012) writestring mark
    }
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs2 dup dup (/OC ) writestring
     llesques 2 get dup 0 true put  %% marquem les inLine com actives
     1 get writestring ( BDC\012) writestring
     sEdAs2 (BI\012) writestring mark
    }ifelse
   }
   {  %% 4 restaurem continguts
    %% de moment no intervindrem!
    %%(+++++BI+++++)pstack quit
    alFoc
    {
     mark
    }
    {
     DuuLlesques
     {
      sEdAs2 (BI\012) writestring mark
     }
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 2 get dup 0 true put  %% marquem les inLine com actives
      1 get writestring ( BDC\012) writestring
      sEdAs2 (BI\012) writestring mark
     }ifelse
    }ifelse
   }
  ] i_BI get /BI exch bind def

  [  %% ID
   {  %% 0 eliminem continguts
    alFoc
    {
     cleartomark
     %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
     %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
     %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
     %%% llegimOctetAoctetXquadrar1patro.ps
     /Toctets 0 def  %% total d'octets llegits
     /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
     /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
     /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
     /3veritats
     [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
      [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
 %%      0  % Null
 %%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
       10  %% Line Feed
       12  %% Form Feed
       13  %% Carriage Return
 %%      32  % Space
      ]
      [
       69  %% caracter E
      ]
      [
       73  %% caracter I
      ]
     ] def
     %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
     %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
     /maxB 4 1024 mul def
     /maxIL maxB string def
     /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
     currentfile
     3
     {  %% posara els 3 primer bytes a l'array
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
       i3o 1 add /i3o exch def       
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     } repeat
     /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
     {  %% loop
      0 1 2
      {  %% for on muntem l'array d'avaluacio 3Boctets
       dup /ara1B exch def
       3veritats exch get  %% treiem de l'array el comparatiu correlativament
       {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
       3Boctets ara1B hoES put
      }for
      3Boctets
      aload pop  %% desmuntem l'array
      and and  %% els 3 estan a true ?
      {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
       pop exit  %% ... sortim
      }
      {  %% com q encara no l'hem trobat ...
       %% enretirem 1 posicio cap a l'esquerra el paquet ...
       3Bytes 1 2 getinterval
       %% ... i escrivim el caracter sortint al buffer del repicat
       3Bytes 0 get iBuffer exch write
       %% recol·loquem l'enretirat
       /3Bytes 3 array def
       3Bytes exch 0 exch putinterval
      }ifelse
      3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
      Toctets 1 add /Toctets exch def  %% total d'octets llegits
      Toctets maxB gt {pop BaBeL 41 get print flush stop}if
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     }loop
     iBuffer closefile
    }
    {
    DuuLlesques
    {
     counttomark
     iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
     /ELdic << >> def
     /alDIC exch def
     alDIC 2 idiv {ELdic 3 1 roll put}repeat
     ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
     sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
     sEdAs2 (\012ID\012) writestring
     %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
     %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
     %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
     %%% llegimOctetAoctetXquadrar1patro.ps
     /Toctets 0 def  %% total d'octets llegits
     /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
     /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
     /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
     /3veritats
     [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
      [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
 %%      0  % Null
 %%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
       10  %% Line Feed
       12  %% Form Feed
       13  %% Carriage Return
 %%      32  % Space
      ]
      [
       69  %% caracter E
      ]
      [
       73  %% caracter I
      ]
     ] def
     %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
     %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
     /maxB 4 1024 mul def
     /maxIL maxB string def
     /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
     currentfile
     3
     {  %% posara els 3 primer bytes a l'array
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
       i3o 1 add /i3o exch def       
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     } repeat
     /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
     {  %% loop
      0 1 2
      {  %% for on muntem l'array d'avaluacio 3Boctets
       dup /ara1B exch def
       3veritats exch get  %% treiem de l'array el comparatiu correlativament
       {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
       3Boctets ara1B hoES put
      }for
      3Boctets
      aload pop  %% desmuntem l'array
      and and  %% els 3 estan a true ?
      {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
       pop exit  %% ... sortim
      }
      {  %% com q encara no l'hem trobat ...
       %% enretirem 1 posicio cap a l'esquerra el paquet ...
       3Bytes 1 2 getinterval
       %% ... i escrivim el caracter sortint al buffer del repicat
       3Bytes 0 get iBuffer exch write
       %% recol·loquem l'enretirat
       /3Bytes 3 array def
       3Bytes exch 0 exch putinterval
      }ifelse
      3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
      Toctets 1 add /Toctets exch def  %% total d'octets llegits
      Toctets maxB gt {pop BaBeL 41 get print flush stop}if
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     }loop
     iBuffer closefile
     %%3Bytes 3Boctets
     maxIL 0 Toctets getinterval
     %%% fi de llegimOctetAoctetXquadrar1patro.ps
     dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
     sEdAs2 exch writestring
     sEdAs2 (\015\012EI\015\012) writestring
%%     sEdAs2 (\012EI\012) writestring
     %%(EI\012) writestring sEdAs2 dup 1B
     %%write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador

     ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
     dup dup length 4 sub (.obj) putinterval  %% creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
     dup length faPathA add string dup
     /pAthA exch def 0 tEmp putinterval
     pAthA exch faPathA exch putinterval
     pAthA (w) file dup SiLi writestring closefile  %% utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
     pop  %% ens carreguem la mark
     %% desem sempre el path del raw de la inLine al dic ELdic
     ELdic /XIU pAthA put
     iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    }
    {  %% no duu llesques
     counttomark
     iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
     /ELdic << >> def
     /alDIC exch def
     alDIC 2 idiv {ELdic 3 1 roll put}repeat
%% aqui hem eliminat la part d'analisi d'XRay
     ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
     sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

     %% hem tret l'identificador d'inlines per l'opcio del repicat
     %%% posem davant ID el nom de la inLine (ARAxo) x poder-la identificar a l'hora d'escriure la separacio de colors
     %%sEdAs (\015) writestring
     %%sEdAs (/) writestring
     %%sEdAs ARAxo 128 string cvs writestring
     sEdAs (\012ID\012) writestring
     %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
     %% una altra solucio seria utilitzar, si s'escau, els mateixos filtres per desenflatar la imatge per calcular-ne
     %% la seva llargada en funcio de l'ample+alt+bitsxpixelxcanal

     %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
     %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
     %%% llegimOctetAoctetXquadrar1patro.ps
     /Toctets 0 def  %% total d'octets llegits
     /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
     /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
     /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
     /3veritats
     [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
      [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
       10  %% Line Feed
       12  %% Form Feed
       13  %% Carriage Return
%%      32  % Space
      ]
      [
       69  %% caracter E
      ]
      [
       73  %% caracter I
      ]
     ] def
     %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
     %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
     /maxB 4 1024 mul def
     /maxIL maxB string def
     /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
     currentfile
     3
     {  %% posara els 3 primer bytes a l'array
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
       i3o 1 add /i3o exch def       
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     } repeat
     /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
     {  %% loop
      0 1 2
      {  %% for on muntem l'array d'avaluacio 3Boctets
       dup /ara1B exch def
       3veritats exch get  %% treiem de l'array el comparatiu correlativament
       {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
       3Boctets ara1B hoES put
      }for
      3Boctets
      aload pop  %% desmuntem l'array
      and and  %% els 3 estan a true ?
      {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
       pop exit  %% ... sortim
      }
      {  %% com q encara no l'hem trobat ...
       %% enretirem 1 posicio cap a l'esquerra el paquet ...
       3Bytes 1 2 getinterval
       %% ... i escrivim el caracter sortint al buffer del repicat
       3Bytes 0 get iBuffer exch write
       %% recol·loquem l'enretirat
       /3Bytes 3 array def
       3Bytes exch 0 exch putinterval
      }ifelse
      3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
      Toctets 1 add /Toctets exch def  %% total d'octets llegits
      Toctets maxB gt {pop BaBeL 41 get print flush stop}if
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     }loop
     iBuffer closefile
     %%3Bytes 3Boctets
     maxIL 0 Toctets getinterval
     %%% fi de llegimOctetAoctetXquadrar1patro.ps
     dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
     sEdAs exch writestring sEdAs
     %%(EI\012\012\012\012)
     (\015\012EI\015\012EMC\012) writestring
%%     (\012EI\012EMC\012) writestring
     %% prevenim un aqui possible trepitjat de la Q de tancament en una segona interpretacio del codi (#6 i altres)?
    
     %%% ARA ELIMINEM L'ESCRIPTURA A SAC
     %%ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
     %%dup dup length 4 sub (.obj) putinterval  % creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
     %%dup length faPathA add string dup
     %% /pAthA exch def 0 tEmp putinterval
     %%pAthA exch faPathA exch putinterval
     %%pAthA
     %%(w) file dup SiLi writestring closefile  % utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
     %%%
    
     pop  %% ens carreguem la mark
     %% desem sempre el path del raw de la inLine al dic ELdic
     ELdic /XIU pAthA put
     iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    }ifelse
    }ifelse
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    %%%refetXinLine
    %% aqui considerem l'operador de les inLine com a fill sempre
    /Tfill 0 def  %% ara posem a l'inici de cada operador de pintat el gatell per saber si el valor de tinta es per fill (0) o stroke (1)
    %% ens arrisquem a considerar sempre el valor de TacaTintaF com a *diferent de zero*
    %% doncs no resultaria massa logic que algu fes una inLine a zero de tinta
    %% de tota manera x treballar al 100% l'hauriem de deduir d'interrogant el RAW?
    %% pero ho deixarem x + endavant si es dona el cas ...
    /TacaTintaF 1 def
    /XBJCT exch def  %% desem el nom de l'inLine
    /iTiNTeM false def  %% gatell x saber si llistem o no
    %% interroguem l'array de la tinta que toca x saber si llista la imatge ...
    XRay /EspaisDeColor get /TintesiValors get quinaTinta get
    {  %% forall
     dup XBJCT eq
     {
      pop /iTiNTeM true def exit
     }
     {  %% deixem de banda la consulta de si es un Form ...
      %%   FormsiXObjects XBJCT known
      %%   {  % si existeix aqui dins es que ho es
      %%    /noXBJCT exch def  % desem el nom que no s'ha igualat en el primer intent
      %%    FormsiXObjects XBJCT get
      %%    % explorant l'array mirem si es tracta d'una imatge XObject continguda dins el Form
      %%    {noXBJCT eq{/iTiNTeM true def exit}if}forall
      %%   }
      %%   {
      pop
      %%   }ifelse
      %%iTiNTeM (waiting for RedOnion) pstack quit
     }ifelse
    }forall
    %%(_____!______) == FotoCrom /Cyan get {== ==}forall (_____!______) == quit
    iTiNTeM
    {  %% es la tinta que toca ara ?
     sEdAs2 (BI\012) writestring
     XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get
     XBJCT get dup /CS /G put
     sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim el les dades de la inLine desades dins un dic
     sEdAs2 (\012ID\012) writestring
     FotoCrom quinaTinta get XBJCT get
     (r) file dup
     65535 string readstring
     pop exch closefile
     sEdAs2 exch writestring sEdAs2 (\012EI\012) writestring
     %%  cleartomark
     %% (_____!______) pstack quit
     %%  sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     %%  sEdAs2 32 write sEdAs2 (Do\015) writestring
    }
    {  %% si no es la tinta q toca cal consultar l'overprint!
     TacaTintaF 0 eq  %% hem pintat (aquest es el valor de tinta de la separacio) amb valor zero?
     {  %% si
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse   
      dup null eq
      {  %% l'Overprint no esta activat
       pop 
       %% si no es la tinta q toca doncs no cal pintar res!!
      }
      {    %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %% si no es la tinta q toca doncs no cal pintar res!!
        }
        {  %% l'Overprint es actiu
         %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
         %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
         sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %% si no es la tinta q toca doncs no cal pintar res!!
         }
         {  %% l'Overprint es actiu
          %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
          %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
          sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %% si no es la tinta q toca doncs no cal pintar res!!
         }
         {  %% l'Overprint es actiu
          %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
          %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
          sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }
     {  %% NO pintem amb valor zero ...
      %%% EP! amb valor de tinta diferent de zero capgirem la logica de l'overprint
      gsARA
      %%% aquest hauria de ser el tractament de l'array d'estats grafics arreu ...
      dup length 1 eq
      {
       0 get  %% mirem dins l'estat grafic que toca 
      }
      {  %% si te + d'1 element i el primer es un null (degut a 'q'), agafem el segon ...
       dup 0 get null eq
       {1 get}{0 get}ifelse
      }ifelse
      dup null eq
      {  %% l'Overprint no esta activat
       pop
       %%( Overprint NO actiu 0) ==
       %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
       %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
       sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
      }
      {    %% x filtrar Null
       XRay /EstatsGrafics get /Utilitzats get exch get
       Tfill 1 eq
       {  %% com que es OP llavors, cap problema
        Tfill get 0 get
        null eq
        {  %% l'Overprint no esta activat
         %%( Overprint NO actiu 1) ==
         %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
         %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
         sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
        }
        {  %% l'Overprint es actiu
         %%( Overprint Actiu 0) ==
         %% si no es la tinta q toca doncs no cal pintar res!!
        } ifelse
       }
       {  %% si es op cal assegurar-se que ...
        dup Tfill get 2 get  %% op es definit al gs actual ?
        null eq
        {  %% el gs actual NO te definit op
         1 get 0 get  %% llavor mirem el valor 0 de l'array d'OP, doncs en aquest cas manara
         null eq
         {  %% l'Overprint no esta activat
          %%( Overprint NO actiu 2) ==
          %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
          %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
          sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
         }
         {  %% l'Overprint es actiu
          %%( Overprint Actiu 1) ==
          %% si no es la tinta q toca doncs no cal pintar res!!
         } ifelse
        }
        {  %% el gs actual SI te definit op
         Tfill get 0 get
         null eq
         {  %% l'Overprint no esta activat
          %%( Overprint NO actiu 3) ==
          %% ara posem el rectangle de la imatge en blanc ... pero ens queda el dubte si caldra
          %% consultar el clipingpath abans de posar-lo o no (p.e. a 21_GG60.pdf es imprescindible¿?)
          sEdAs2 (q 0 0 0 0 k 0 0 m 0 1 l 1 1 l 1 0 l f Q\012) writestring
         }
         {  %% l'Overprint es actiu
          %%( Overprint Actiu 2) ==
          %% si no es la tinta q toca doncs no cal pintar res!!
         } ifelse
        }ifelse
       }ifelse
      } ifelse  %% x filtrar Null
     }ifelse  %% pintem o no amb valor zero?
    }ifelse  %% de la tinta que toca ara, apliquem les lleis de l'overprint
    %%%refetXinLine
    %%% temporalment l'eliminarem de forma fixa
    %%false {  % es la tinta que toca ara ?
    %%     counttomark
    %%     dup /RoLL exch def
    %%    {
    %%     RoLL -1 roll
    %%     dup type /nametype eq
    %%     {sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write}
    %%     {
    %%      dup type /arraytype eq
    %%      {
    %%       sEdAs2 ([ ) writestring
    %%       {
    %%        dup type /nametype eq
    %%        {sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write}
    %%        {64 string cvs sEdAs2 exch writestring sEdAs2 32 write} ifelse
    %%       } forall
    %%       sEdAs2 (] ) writestring
    %%      }
    %%      {
    %%       64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    %%      } ifelse
    %%     } ifelse
    %%     RoLL 1 sub /RoLL exch def
    %%    } repeat
    %%    sEdAs2 (\015ID\015) writestring
    %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
    %% una altra solucio seria utilitzar els mateixos filtres per la lectura
    %%currentfile 0 (EI) /SubFileDecode filter
    %%dup
    %%{
    %% 65535 string readstring
    %% {sEdAs2 exch writestring}{
    %%pop
    %% sEdAs2 exch writestring sEdAs2 (EI\015) writestring  %exit}ifelse
    %%}loop
    %%closefile  % tanquem el fitxer
    %%pop  % ens carreguem la mark
    %%}{
    cleartomark  %% ens polim totes les dades del dic inline
%%    currentfile 0 (\012EI) /SubFileDecode filter
%%    dup 65535 string readstring pop pop
%%    closefile  % ens polim les dades del raw

%%false{
    %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
    %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
    %%% llegimOctetAoctetXquadrar1patro.ps
    /Toctets 0 def  %% total d'octets llegits
    /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
    /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
    /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
    /3veritats
    [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
     [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
      10  %% Line Feed
      12  %% Form Feed
      13  %% Carriage Return
%%      32  % Space
     ]
     [
      69  %% caracter E
     ]
     [
      73  %% caracter I
     ]
    ] def
    %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
    %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
    /maxB 4 1024 mul def
    /maxIL maxB string def
    /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
    currentfile
    3
    {  %% posara els 3 primer bytes a l'array
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
      i3o 1 add /i3o exch def       
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    } repeat
    /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
    {  %% loop
     0 1 2
     {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
     }for
     3Boctets
     aload pop  %% desmuntem l'array
     and and  %% els 3 estan a true ?
     {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
      pop exit  %% ... sortim
     }
     {  %% com q encara no l'hem trobat ...
      %% enretirem 1 posicio cap a l'esquerra el paquet ...
      3Bytes 1 2 getinterval
      %% ... i escrivim el caracter sortint al buffer del repicat
      3Bytes 0 get iBuffer exch write
      %% recol·loquem l'enretirat
      /3Bytes 3 array def
      3Bytes exch 0 exch putinterval
     }ifelse
     3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
     Toctets 1 add /Toctets exch def  %% total d'octets llegits
     Toctets maxB gt {pop BaBeL 41 get print flush stop}if
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    }loop
    iBuffer closefile
    %%3Bytes 3Boctets
    maxIL 0 Toctets getinterval
    %%% fi de llegimOctetAoctetXquadrar1patro.ps
    dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
    sEdAs2 exch writestring
    sEdAs2 (\015\012EI\015\012) writestring
%%    sEdAs2 (\012EI\012) writestring
    %%(EI\012) writestring sEdAs2 dup 1B
    %%write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador

    %%}if
    %% }ifelse  % de la tinta que toca ara
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    {  % stopped
    counttomark
    iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
    /ELdic << >> def
    /alDIC exch def
    alDIC 2 idiv {ELdic 3 1 roll put}repeat
    ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
    sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
    /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
    sEdAs2 (\012ID\012) writestring
    %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
    %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
    %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
    %%% llegimOctetAoctetXquadrar1patro.ps
    /Toctets 0 def  %% total d'octets llegits
    /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
    /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
    /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
    /3veritats
    [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
     [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
      10  %% Line Feed
      12  %% Form Feed
      13  %% Carriage Return
%%      32  % Space
     ]
     [
      69  %% caracter E
     ]
     [
      73  %% caracter I
     ]
    ] def
    %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
    %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
    /maxB 4 1024 mul def
    /maxIL maxB string def
    /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
    currentfile
    3
    {  %% posara els 3 primer bytes a l'array
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
      i3o 1 add /i3o exch def       
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    } repeat
    /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
    {  %% loop
     0 1 2
     {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
     }for
     3Boctets
     aload pop  %% desmuntem l'array
     and and  %% els 3 estan a true ?
     {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
      pop exit  %% ... sortim
     }
     {  %% com q encara no l'hem trobat ...
      %% enretirem 1 posicio cap a l'esquerra el paquet ...
      3Bytes 1 2 getinterval
      %% ... i escrivim el caracter sortint al buffer del repicat
      3Bytes 0 get iBuffer exch write
      %% recol·loquem l'enretirat
      /3Bytes 3 array def
      3Bytes exch 0 exch putinterval
     }ifelse
     3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
     Toctets 1 add /Toctets exch def  %% total d'octets llegits
     Toctets maxB gt {pop BaBeL 41 get print flush stop}if
     dup read
     {
      /1B exch def
      3Bytes i3o 1B put
     }
     {
      pop BaBeL 42 get print flush stop  %%quit
     }ifelse
    }loop
    iBuffer closefile
    %%3Bytes 3Boctets
    maxIL 0 Toctets getinterval
    %%% fi de llegimOctetAoctetXquadrar1patro.ps
    dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
    sEdAs2 exch writestring
    sEdAs2 (\015\012EI\015\012) writestring
%%    sEdAs2 (\012EI\012) writestring
    %%(EI\012) writestring sEdAs2 dup 1B
    %%write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador

    ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
    dup dup length 4 sub (.obj) putinterval  %% creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
    dup length faPathA add string dup
    /pAthA exch def 0 tEmp putinterval
    pAthA exch faPathA exch putinterval
    pAthA (w) file dup SiLi writestring closefile  %% utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
    pop  %% ens carreguem la mark
    %% desem sempre el path del raw de la inLine al dic ELdic
    ELdic /XIU pAthA put
    iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    }stopped{( ... peta ID) pstack quit}if
   }
   {  %% 3 verificacio de PDF
    DuuLlesques
    {
     counttomark
     iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
     /ELdic << >> def
     /alDIC exch def
     alDIC 2 idiv {ELdic 3 1 roll put}repeat
     ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
     sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
     sEdAs2 (\012ID\012) writestring
     %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
     %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
     %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
     %%% llegimOctetAoctetXquadrar1patro.ps
     /Toctets 0 def  %% total d'octets llegits
     /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
     /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
     /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
     /3veritats
     [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
      [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
 %%      0  % Null
 %%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
       10  %% Line Feed
       12  %% Form Feed
       13  %% Carriage Return
 %%      32  % Space
      ]
      [
       69  %% caracter E
      ]
      [
       73  %% caracter I
      ]
     ] def
     %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
     %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
     /maxB 4 1024 mul def
     /maxIL maxB string def
     /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
     currentfile
     3
     {  %% posara els 3 primer bytes a l'array
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
       i3o 1 add /i3o exch def       
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     } repeat
     /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
     {  %% loop
      0 1 2
      {  %% for on muntem l'array d'avaluacio 3Boctets
       dup /ara1B exch def
       3veritats exch get  %% treiem de l'array el comparatiu correlativament
       {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
       3Boctets ara1B hoES put
      }for
      3Boctets
      aload pop  %% desmuntem l'array
      and and  %% els 3 estan a true ?
      {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
       pop exit  %% ... sortim
      }
      {  %% com q encara no l'hem trobat ...
       %% enretirem 1 posicio cap a l'esquerra el paquet ...
       3Bytes 1 2 getinterval
       %% ... i escrivim el caracter sortint al buffer del repicat
       3Bytes 0 get iBuffer exch write
       %% recol·loquem l'enretirat
       /3Bytes 3 array def
       3Bytes exch 0 exch putinterval
      }ifelse
      3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
      Toctets 1 add /Toctets exch def  %% total d'octets llegits
      Toctets maxB gt {pop BaBeL 41 get print flush stop}if
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     }loop
     iBuffer closefile
     %%3Bytes 3Boctets
     maxIL 0 Toctets getinterval
     %%% fi de llegimOctetAoctetXquadrar1patro.ps
     dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
     sEdAs2 exch writestring
     sEdAs2 (\015\012EI\015\012) writestring
%%     sEdAs2 (\012EI\012) writestring
     %%(EI\012) writestring sEdAs2 dup 1B
     %%write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador

     ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
     dup dup length 4 sub (.obj) putinterval  %% creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
     dup length faPathA add string dup
     /pAthA exch def 0 tEmp putinterval
     pAthA exch faPathA exch putinterval
     pAthA (w) file dup SiLi writestring closefile  %% utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
     pop  %% ens carreguem la mark
     %% desem sempre el path del raw de la inLine al dic ELdic
     ELdic /XIU pAthA put
     iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    }
    {  %% no duu llesques
     counttomark
     iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
     /ELdic << >> def
     /alDIC exch def
     alDIC 2 idiv {ELdic 3 1 roll put}repeat
%% aqui hem eliminat la part d'analisi d'XRay
     ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
     sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

     %% hem tret l'identificador d'inlines per l'opcio del repicat
     %%% posem davant ID el nom de la inLine (ARAxo) x poder-la identificar a l'hora d'escriure la separacio de colors
     %%sEdAs (\015) writestring
     %%sEdAs (/) writestring
     %%sEdAs ARAxo 128 string cvs writestring
     sEdAs (\012ID\012) writestring
     %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
     %% una altra solucio seria utilitzar, si s'escau, els mateixos filtres per desenflatar la imatge per calcular-ne
     %% la seva llargada en funcio de l'ample+alt+bitsxpixelxcanal

     %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
     %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
     %%% llegimOctetAoctetXquadrar1patro.ps
     /Toctets 0 def  %% total d'octets llegits
     /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
     /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
     /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
     /3veritats
     [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
      [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
%%      0  % Null
%%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
       10  %% Line Feed
       12  %% Form Feed
       13  %% Carriage Return
%%      32  % Space
      ]
      [
       69  %% caracter E
      ]
      [
       73  %% caracter I
      ]
     ] def
     %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
     %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
     /maxB 4 1024 mul def
     /maxIL maxB string def
     /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
     currentfile
     3
     {  %% posara els 3 primer bytes a l'array
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
       i3o 1 add /i3o exch def       
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     } repeat
     /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
     {  %% loop
      0 1 2
      {  %% for on muntem l'array d'avaluacio 3Boctets
       dup /ara1B exch def
       3veritats exch get  %% treiem de l'array el comparatiu correlativament
       {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
       3Boctets ara1B hoES put
      }for
      3Boctets
      aload pop  %% desmuntem l'array
      and and  %% els 3 estan a true ?
      {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
       pop exit  %% ... sortim
      }
      {  %% com q encara no l'hem trobat ...
       %% enretirem 1 posicio cap a l'esquerra el paquet ...
       3Bytes 1 2 getinterval
       %% ... i escrivim el caracter sortint al buffer del repicat
       3Bytes 0 get iBuffer exch write
       %% recol·loquem l'enretirat
       /3Bytes 3 array def
       3Bytes exch 0 exch putinterval
      }ifelse
      3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
      Toctets 1 add /Toctets exch def  %% total d'octets llegits
      Toctets maxB gt {pop BaBeL 41 get print flush stop}if
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     }loop
     iBuffer closefile
     %%3Bytes 3Boctets
     maxIL 0 Toctets getinterval
     %%% fi de llegimOctetAoctetXquadrar1patro.ps
     dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
     sEdAs exch writestring sEdAs
     %%(EI\012\012\012\012)
     (\015\012EI\015\012EMC\012) writestring
%%     (\012EI\012EMC\012) writestring
     %% prevenim un aqui possible trepitjat de la Q de tancament en una segona interpretacio del codi (#6 i altres)?
    
     %%% ARA ELIMINEM L'ESCRIPTURA A SAC
     %%ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
     %%dup dup length 4 sub (.obj) putinterval  % creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
     %%dup length faPathA add string dup
     %% /pAthA exch def 0 tEmp putinterval
     %%pAthA exch faPathA exch putinterval
     %%pAthA
     %%(w) file dup SiLi writestring closefile  % utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
     %%%
    
     pop  %% ens carreguem la mark
     %% desem sempre el path del raw de la inLine al dic ELdic
     ELdic /XIU pAthA put
     iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
    }ifelse
   }
   {  %% 4 restaurem continguts
    %% de moment no intervindrem!
    %%(*****i_ID*****)
    alFoc
    {
     cleartomark
     %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
     %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
     %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
     %%% llegimOctetAoctetXquadrar1patro.ps
     /Toctets 0 def  %% total d'octets llegits
     /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
     /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
     /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
     /3veritats
     [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
      [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
 %%      0  % Null
 %%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
       10  %% Line Feed
       12  %% Form Feed
       13  %% Carriage Return
 %%      32  % Space
      ]
      [
       69  %% caracter E
      ]
      [
       73  %% caracter I
      ]
     ] def
     %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
     %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
     /maxB 4 1024 mul def
     /maxIL maxB string def
     /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
     currentfile
     3
     {  %% posara els 3 primer bytes a l'array
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
       i3o 1 add /i3o exch def       
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     } repeat
     /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
     {  %% loop
      0 1 2
      {  %% for on muntem l'array d'avaluacio 3Boctets
       dup /ara1B exch def
       3veritats exch get  %% treiem de l'array el comparatiu correlativament
       {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
       3Boctets ara1B hoES put
      }for
      3Boctets
      aload pop  %% desmuntem l'array
      and and  %% els 3 estan a true ?
      {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
       pop exit  %% ... sortim
      }
      {  %% com q encara no l'hem trobat ...
       %% enretirem 1 posicio cap a l'esquerra el paquet ...
       3Bytes 1 2 getinterval
       %% ... i escrivim el caracter sortint al buffer del repicat
       3Bytes 0 get iBuffer exch write
       %% recol·loquem l'enretirat
       /3Bytes 3 array def
       3Bytes exch 0 exch putinterval
      }ifelse
      3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
      Toctets 1 add /Toctets exch def  %% total d'octets llegits
      Toctets maxB gt {pop BaBeL 41 get print flush stop}if
      dup read
      {
       /1B exch def
       3Bytes i3o 1B put
      }
      {
       pop BaBeL 42 get print flush stop  %%quit
      }ifelse
     }loop
     iBuffer closefile
    }
    {
     DuuLlesques
     {
      counttomark
      iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
      /ELdic << >> def
      /alDIC exch def
      alDIC 2 idiv {ELdic 3 1 roll put}repeat
      ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
      sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
      sEdAs2 (\012ID\012) writestring
      %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
      %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
      %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
      %%% llegimOctetAoctetXquadrar1patro.ps
      /Toctets 0 def  %% total d'octets llegits
      /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
      /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
      /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
      /3veritats
      [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
       [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
  %%      0  % Null
  %%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
        10  %% Line Feed
        12  %% Form Feed
        13  %% Carriage Return
  %%      32  % Space
       ]
       [
        69  %% caracter E
       ]
       [
        73  %% caracter I
       ]
      ] def
      %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
      %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
      /maxB 4 1024 mul def
      /maxIL maxB string def
      /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
      currentfile
      3
      {  %% posara els 3 primer bytes a l'array
       dup read
       {
        /1B exch def
        3Bytes i3o 1B put
        i3o 1 add /i3o exch def       
       }
       {
        pop BaBeL 42 get print flush stop  %%quit
       }ifelse
      } repeat
      /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
      {  %% loop
       0 1 2
       {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
       }for
       3Boctets
       aload pop  %% desmuntem l'array
       and and  %% els 3 estan a true ?
       {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
        pop exit  %% ... sortim
       }
       {  %% com q encara no l'hem trobat ...
        %% enretirem 1 posicio cap a l'esquerra el paquet ...
        3Bytes 1 2 getinterval
        %% ... i escrivim el caracter sortint al buffer del repicat
        3Bytes 0 get iBuffer exch write
        %% recol·loquem l'enretirat
        /3Bytes 3 array def
        3Bytes exch 0 exch putinterval
       }ifelse
       3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
       Toctets 1 add /Toctets exch def  %% total d'octets llegits
       Toctets maxB gt {pop BaBeL 41 get print flush stop}if
       dup read
       {
        /1B exch def
        3Bytes i3o 1B put
       }
       {
        pop BaBeL 42 get print flush stop  %%quit
       }ifelse
      }loop
      iBuffer closefile
      %%3Bytes 3Boctets
      maxIL 0 Toctets getinterval
      %%% fi de llegimOctetAoctetXquadrar1patro.ps
      dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
      sEdAs2 exch writestring
      sEdAs2 (\015\012EI\015\012) writestring
%%      sEdAs2 (\012EI\012) writestring
      %%(EI\012) writestring sEdAs2 dup 1B
      %%write (\012) writestring  % escrivim el darrer caracter xuclat just despres del separador d'EI: resol el cas de quan EI li segueix un espai en blanc i despres una Q o un altre operador

      ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
      dup dup length 4 sub (.obj) putinterval  %% creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
      dup length faPathA add string dup
      /pAthA exch def 0 tEmp putinterval
      pAthA exch faPathA exch putinterval
      pAthA (w) file dup SiLi writestring closefile  %% utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
      pop  %% ens carreguem la mark
      %% desem sempre el path del raw de la inLine al dic ELdic
      ELdic /XIU pAthA put
      iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
     }
     {  %% no duu llesques
      counttomark
      iiLine 6 string cvs dup length 6 add string dup dup 0 (inLine) putinterval 3 -1 roll 6 exch putinterval cvn /ARAxo exch def  %% desem el nom de la imatge inLine numerada
      /ELdic << >> def
      /alDIC exch def
      alDIC 2 idiv {ELdic 3 1 roll put}repeat
% % aqui hem eliminat la part d'analisi d'XRay
      ELdic  %% millorem el repicat del diccionari fent servir l'algorisme apropiat!
      sEdAs /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

      %% hem tret l'identificador d'inlines per l'opcio del repicat
      %%% posem davant ID el nom de la inLine (ARAxo) x poder-la identificar a l'hora d'escriure la separacio de colors
      %%sEdAs (\015) writestring
      %%sEdAs (/) writestring
      %%sEdAs ARAxo 128 string cvs writestring
      sEdAs (\012ID\012) writestring
      %% llegim les definicions d'imatge fins a mark i llegim el RAW fins al final (EI) 
      %% una altra solucio seria utilitzar, si s'escau, els mateixos filtres per desenflatar la imatge per calcular-ne
      %% la seva llargada en funcio de l'ample+alt+bitsxpixelxcanal

      %%% optem x solucionar el problema pescant correctament EI seguit dels possibles caracters en blanc permesos ...
      %%% ... de manera que no es pugui confondre amb dades d'imatge que tambe duguin EI entremig
      %%% llegimOctetAoctetXquadrar1patro.ps
      /Toctets 0 def  %% total d'octets llegits
      /3Bytes 3 array def  %% fa de magatzem intermig dels caracters llegits x currentfile i escrits a iBuffer
      /3Boctets 3 array def  %% aqui hi ha d'haver els boolens de l'analisi dels 3 bytes que hauran d'estar a true x considerar q ja som al final
      /i3o 0 def  %% index pel farcidor de l'array evaluador 3octets
      /3veritats
      [  %% taula de la veritat (patro a quadrar) per saber si som al final de la inLine (E+I+qualsevol caracter en blanc)
       [  %% caracters en blanc de separacio despres d'EI (veure 3.1.1 del PDF Reference --i tambe a PS--)
 %%      0  % Null
 %%      9  % Tab  % el matem xq hem detectat q incloure'l pot provocar equivocs en dades d'imatge
        10  %% Line Feed
        12  %% Form Feed
        13  %% Carriage Return
 %%      32  % Space
       ]
       [
        69  %% caracter E
       ]
       [
        73  %% caracter I
       ]
      ] def
      %% els 4Kb de maxim per a les dades d'imatge (descomprimides) d'una inLine ens serviran per avaluar a traves del buffer del
      %% NullEncode que ja ens hem passat el control de final de lectura (x error nostre o x error de construccio de la imatge)
      /maxB 4 1024 mul def
      /maxIL maxB string def
      /iBuffer maxIL /NullEncode filter def  %% buffer del repicat total de la inLine
      currentfile
      3
      {  %% posara els 3 primer bytes a l'array
       dup read
       {
        /1B exch def
        3Bytes i3o 1B put
        i3o 1 add /i3o exch def       
       }
       {
        pop BaBeL 42 get print flush stop  %%quit
       }ifelse
      } repeat
      /i3o 2 def  %% inicialitzem de forma fixa l'index pel farcidor de l'array evaluador 3octets 
      {  %% loop
       0 1 2
       {  %% for on muntem l'array d'avaluacio 3Boctets
        dup /ara1B exch def
        3veritats exch get  %% treiem de l'array el comparatiu correlativament
        {3Bytes ara1B get eq{/hoES true def exit}{/hoES false def}ifelse}forall
        3Boctets ara1B hoES put
       }for
       3Boctets
       aload pop  %% desmuntem l'array
       and and  %% els 3 estan a true ?
       {  %% si ja hem trobat la marca obligatoria de final de la inLine ...
        pop exit  %% ... sortim
       }
       {  %% com q encara no l'hem trobat ...
        %% enretirem 1 posicio cap a l'esquerra el paquet ...
        3Bytes 1 2 getinterval
        %% ... i escrivim el caracter sortint al buffer del repicat
        3Bytes 0 get iBuffer exch write
        %% recol·loquem l'enretirat
        /3Bytes 3 array def
        3Bytes exch 0 exch putinterval
       }ifelse
       3Bytes 2 1B put  %% posem el byte al darrer lloc de l'array enretirada
       Toctets 1 add /Toctets exch def  %% total d'octets llegits
       Toctets maxB gt {pop BaBeL 41 get print flush stop}if
       dup read
       {
        /1B exch def
        3Bytes i3o 1B put
       }
       {
        pop BaBeL 42 get print flush stop  %%quit
       }ifelse
      }loop
      iBuffer closefile
      %%3Bytes 3Boctets
      maxIL 0 Toctets getinterval
      %%% fi de llegimOctetAoctetXquadrar1patro.ps
      dup /SiLi exch def  %% ens quedem una copia de la cadena de la inLine x escriure-la a part en un fitxer
      sEdAs exch writestring sEdAs
      %%(EI\012\012\012\012)
      (\015\012EI\015\012EMC\012) writestring
%%      (\012EI\012EMC\012) writestring
      %% prevenim un aqui possible trepitjat de la Q de tancament en una segona interpretacio del codi (#6 i altres)?
   
      %%% ARA ELIMINEM L'ESCRIPTURA A SAC
      %%ARAxo 12 string cvs dup length 4 add string dup 3 -1 roll 0 exch putinterval
      %%dup dup length 4 sub (.obj) putinterval  % creem un fitxer amb el mateix nom intern de la inLine + l'extensio .obj
      %%dup length faPathA add string dup
      %% /pAthA exch def 0 tEmp putinterval
      %%pAthA exch faPathA exch putinterval
      %%pAthA
      %%(w) file dup SiLi writestring closefile  % utilitzat per l'applet per desar els streams de les inLine x si cal tractar-los x separacio de colors
      %%%

      pop  %% ens carreguem la mark
      %% desem sempre el path del raw de la inLine al dic ELdic
      ELdic /XIU pAthA put
      iiLine 1 add /iiLine exch def  %% numerador pels noms de les imatges InLine
     }ifelse
    }ifelse
   }
  ] i_ID get /ID exch bind def

  %% /EI {} bind def  % no cal definir-lo doncs ens el mengem amb la lectura anterior a ID

  %% (PDF Ref 1.7) 5.2 Text State Parameters and Operators
  %% (PDF Ref ?) 8.7.1.1 Character spacing
  [  %% Tc
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tc\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tc) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tc\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta Tc) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  %% stopped
    dup
    %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tc\012) writestring

    %%% KTCS
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /ecTc exch put
    /ecTc exch def  %% desem el valor afegit d'espaiat entre caracters (es suma a cada caracter)
    }stopped{( ... peta Tc) pstack quit}if
   }
  ] i_Tc get /Tc exch bind def

  %% 8.7.1.2 Word spacing
  [  %% Tw
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tw\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tw) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tw\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta Tw) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  %% stopped
    dup
    %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tw\012) writestring

    %%% KTCS
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /epTw exch put
    /epTw exch def  %% desem el valor afegit d'espaiat entre paraules (nomes suma si hi ha /space)
    }stopped{( ... peta Tw) pstack quit}if
   }
  ] i_Tw get /Tw exch bind def

  %% 8.7.1.3 Horizontal scaling
  [  %% Tz
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tz\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tz) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tz\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta Tz) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  %% stopped
    dup
    %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tz\012) writestring

    %%% KTCS
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /acTz exch put
    /acTz exch def  %% desem el valor del tant per cent d'ample del caracter
    %%CxTm mul 100 div  % apliquem l'escala horitzontal a tots els espaiats
    %% /CxTm exch def  % l'apliquem directament sobre l'X del caracter
    }stopped{( ... peta Tz) pstack quit}if
   }
  ] i_Tz get /Tz exch bind def

  %% 8.7.1.4 Leading
  [  %% TL
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop
     }
     {
      %%TiNTeM {  % es la tinta que toca ara ?
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (TL\012) writestring
      %%}{pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta TL) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificador de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (TL\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta TL) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  %% stopped
     dup
     %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (TL\012) writestring
     %% desem el valor pur (sense multiplicar per SyTm i cmSy) de l'interliniat Y a l'estat grafic actiu
     dup EstatGrafic iEG get exch /TLoTD exch put

     cmSy mul  %% multipliquem el valor provinent de cm
     SyTm mul  %% multipliquem el valor provinent de Tm
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /INTERli exch put
     /INTERli exch def  %% valor actual de l'interliniat (s'aplica amb T* " i ')
    }stopped{( ... peta TL) pstack quit}if
   }
  ] i_TL get /TL exch bind def

  %% 8.7.1.5 Text font and size
  [  %% Tf
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     exch sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tf\012) writestring
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tf) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificador de PDF)
    %%{  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    exch sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tf\012) writestring
    %%}{pop pop}ifelse  % de la tinta que toca ara
    %%}stopped{( ... peta Tf) == quit}if
   }
   {  %% 2 (dada variable)
    {  % stopped
    exch sEdAs2 (/) writestring
faDADAv
    {
     pop  %% eliminem la crida a la font PDF original per posar-hi la nostra clau de xifrat segur
     /fontB2  %% hi haurà d'anar un gatell per poder escollir a segonsF la variant des del menú
     128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    }
    {
     128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    }ifelse

    pop .90  %% substitutiu per reduir el cos

    128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tf\012) writestring
    }stopped{( ... peta Tf) == quit}if
   }
   {  %% 3 gatell 16 MASATS
    {  %% stopped
     2 copy
     %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     exch sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     128 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tf\012) writestring

     %%% KTCS
     dup /cos_ exch def  %% capturem el cos que multiplicara amb la matriu Tm (el desem en una altre variable per poder treballar quan a Tm hi han alteracions de l'eix de coordenades i llavors no actuen CxTm i CyTm
     dup
     %% cal tenir en compte abans l'escala x!
     EstatGrafic iEG get /SxTm get mul
     /CxTm exch def  %%% KTCS valor inicial del cos horitzontal de la lletra
     %% cal tenir en compte abans l'escala y!
     EstatGrafic iEG get /SyTm get mul
     /CyTm exch def  %%% KTCS valor inicial del cos vertical de la lletra
     Champollion
     exch dup /QuinaFONT exch def  %% nom PDF de la font actual

     %% desem a l'Estat Gràfic la font i cos cridats per Tf
     EstatGrafic dup iEG get dup dup /acTf get dup dup 0 QuinaFONT put 1 cos_ put /acTf exch put iEG exch put

     %% UiX
     exch araPlana get exch  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
     get dup type /nametype eq  %% capturem l'encoding per la decodificacio de l'string o executem aSia
     {
      cvx exec
     }
     {
      %% test per l'encoding GID
      %%pop COMdimoni /GIDEncoding get 391 array copy
      400 array copy
      /EncNETiPLANXAT exch def
     }ifelse
    }stopped{( ... peta Tf) pstack stop}if
   }
  ] i_Tf get /Tf exch bind def

  %% 8.7.1.7 Text rendering mode
  [  %% Tr
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     1 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tr\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Tr) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    1 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Tr\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta Tr) pstack quit}if
   }
  ] i_Tr get /Tr exch bind def

  %% 8.7.1.8 Text rise
  [  %% Ts
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Ts\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta Ts) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Ts\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta Ts) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  %% stopped
     dup
     %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Ts\012) writestring

     %%% KTCS
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TyTs exch put
     /TyTs exch def  %% desplacament vertical del text
    }stopped{( ... peta Ts) pstack quit}if
   }
  ] i_Ts get /Ts exch bind def

  %% (PDF Ref 1.7) 5.3.1 Text-Positioning Operators
  %% (PDF Ref ?) 8.7.3 Text positioning operators
  [  %% Td
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop pop
     }
     {
      %%TiNTeM {  % es la tinta que toca ara ?
      exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Td\012) writestring
      %%}{pop pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta Td) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Td\012) writestring
    %%}{pop pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta Td) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  % stopped

     %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %% /LleixaBuida false def
     2 copy
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (Td\012) writestring

     %% capturem les dades Td en estat pur
     2 copy /YpurTd exch def /XpurTd exch def

     SyTm mul  %% multipliquem el valor Y x l'escala actual de Tm
     /ilyTd exch def  %% inici Y de la propera linia des de l'inici Y de l'anterior
     SxTm mul /ilxTd exch def  %% idem per les X
     %% posem a la pila el valor de desplaçament x,y de Td x avaluar
     ilxTd ilyTd

     EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
     Aeix 0 eq  %% si l'eix no es rotat ...
     {  %% no cal q la normalitzem
      iTyTm add dup /iTyTm exch def  %% nou inici absolut de linia Y
      /TyTm exch def  %% posicio actual d'Y
      iTxTm add 

      CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTd no sigui zero ...
      ilyTd 0 ne and
      {  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
       0 ilyTd
       gsave
       [1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
       dup dup 1 Amentidera sin neg put 2 Amentidera sin put
       dup dup 0 Amentidera cos put 3 Amentidera cos put
       concat
       matrix currentmatrix  %% valor de la matriu rotada
       grestore
       transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
       itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
       pop add   %% valor X a corregir
      }if
      dup /iTxTm exch def  %% nou inici absolut de la linia X
      /TxTm exch def  %% posicio actual d'X
     }
     {  %% normalitzem
      %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm

      %%% hi manca?
      %%iTyTm add dup /iTyTm exch def  % nou inici absolut de linia Y
      %%dup /TyTm exch def  % posicio actual d'Y
      %%exch iTxTm add exch

      gsave
      aTm

      %% dup dup 2 get SyTm mul 2 exch put
      %% dup dup 1 get SxTm mul 1 exch put

      90NET
      {
       dup 1 get 0 lt
       {  %% rotacio negativa
        dup dup 1 -1 put 2 1 put
       }
       {  %% rotacio positiva
        dup dup 1 1 put 2 -1 put
        CursivaMentidera
        {
         %% eliminem els valors de generen la cursiva
         dup 3 0 put
         dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
         dup dup 5 get YpurTd add 5 exch put
         dup dup 4 get XpurTd add 4 exch put
        }
        {
         dup dup 5 iTyTm put 4 iTxTm put
        }ifelse
       }ifelse  %% sentit de la rotacio
      }
      {
       dup dup 5 iTyTm put 4 iTxTm put
      }ifelse
      concat
      matrix currentmatrix  %% valor de la matriu rotada
      grestore
      transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
      itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

      dup /iTyTm exch def  %% nou inici absolut de linia Y
      /TyTm exch def  %% posicio actual d'Y

      dup /iTxTm exch def  %% nou inici absolut de la linia X
      /TxTm exch def  %% posicio actual d'X
     }ifelse
     EstatGrafic iEG get dup dup dup
     /iTyTm iTyTm put
     /iTxTm iTxTm put
     /TyTm TyTm put
     /TxTm TxTm put

%% per activar el detector faTREUiFICA cal saber:
%% el dic de TREUiFICAfinal de la pàgina que som
TREUiFICAfinal araPlana 6 string cvs cvx exec get dup
TyTm  %% la Y de Tm definitiva ja computada per Td i emmagatzemada a EstatGrafic
cvi  %% EP!MASATS treballarem només amb l'enter
128 string cvs dup 3 -2 roll known  %% la posició Y del text és a TREUiFICAfinal?
%% fem una doble comprovació, doncs coordenades sense decimals p.e. 10 es desen com 10.0 i llavors no es troven al diccionari!
{  %% SI, hi és
 true
}
{  %% de debò que no hi és?
 (.) search
 {  %% o duu un decimal a zero #.0 povocat pel primer repicat?
  exch pop  %% ens carreguem el punt
  exch cvx exec 0 eq
  {  %% com que duu el decimal a zero, tornem a cercar
   2 copy known
   {  %% existeix!
    true
   }
   {  %% tampoc NO hi és
    false
   }ifelse
  }
  {  %% no duu el decimal a zero
   false
  }ifelse
 }
 {
  false
 }ifelse
}ifelse
{  %% és una Y d'un mot a treure
 get
%dup == (<<<< dades via Td)==
 /araTREUiFICA exch def  %% array de dades a utilitzar pels operador de composició Tj TJ ' "
 /faTREUiFICA true def  %% gatell x saber si hem de treure i ficar text als operadors Tj TJ ' "
}
{  %% no és cap Y de mot a treure
 pop pop  %% esborrem la clau Y i el diccionari de la pàgina de TREUiFICAfinal
 /faTREUiFICA false def  %% gatell x saber si hem de treure i ficar text als operadors Tj TJ ' "
}ifelse

     %% estratègia a TD i Td per tal d'afegir un separador null
     %% entre paraules en cas que la Y de la línia que estem tractant ja existeixi, per tal d'afegir
     %% l'espai separador, amb un null, i evitar s'enganxin paraules diferents. Si ja existeix, o sigui
     %% que hi havia text abans, pot ser per dos motius: o som a final de línia (és el darrer mot) o som
     %% davant d'un cas on s'enganxarien dues paraules per manca d'aquest control a TD i Td
     yRENGS araPlana get dup dup
     %% aquí és on comprovem si existeix la Y del reng en aquesta pàgina
     TyTm
cvi  %% EP!MASATS treballarem només amb l'enter
 128 string cvs dup dup 3 index exch known
     {
      3 -1 roll exch get  %% posem a l'stack
      /araRENG exch def
      %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
      null
      araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
      %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
      null
      araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
      %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
      null
      araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
      %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
      null
      araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
      araRENG put  %% desem al diccionari de la plana
      yRENGS exch araPlana exch put  %% desem al diccionari dels rengs
     }
     {
      %% (NOHIES!)==
      %% araRENG ==
      pop pop pop pop pop
     }ifelse
    }stopped{( ... peta Td)pstack quit}if
   }
  ] i_Td get /Td exch bind def

  [  %% TD
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (TD\012) writestring
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta TD) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (TD\012) writestring
    %%}{pop pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta TD) == quit}if
   }
   {  %% 2 gatell 2 MASATS
    {  % stopped
     %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %% /LleixaBuida false def
     2 copy
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (TD\012) writestring

     %% desem el valor pur (sense multiplicar per SyTm i cmSy) de l'interliniat Y a l'estat grafic actiu
     dup EstatGrafic iEG get exch neg  %% cal negativar-lo xq treballi correctament
     /TLoTD exch put

     %% capturem les dades TD en estat pur
     2 copy /YpurTD exch def /XpurTD exch def

     SyTm mul  %% multipliquem el valor provinent de Tm
     dup neg
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /INTERli exch put
     /INTERli exch def  %% valor actual de l'interliniat (aqui es comporta negativat!)
     /ilyTD exch def  %% inici Y de la propera linia des de l'inici Y de l'anterior
     SxTm mul  %% multipliquem el valor provinent de Tm
     /ilxTD exch def  %% inici X de la propera linia des de l'inici X de l'anterior

     ilxTD ilyTD

     EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
     Aeix 0 eq  %% si l'eix no es rotat ...
     {  %% no cal q normalitzem
      iTyTm add
      /TyTm exch def  %% rectifiquem la posicio absoluta de les Y
      %% cal que desem el valor de la coordenada d'inici de cadena, nomes utilitzada pels operadors ' i "
      TyTm /iTyTm exch def
      iTxTm add
      CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTD no sigui zero ...
      ilyTD 0 ne and
      {  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
       0 ilyTD
       gsave
       [1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
       dup dup 1 Amentidera sin neg put 2 Amentidera sin put
       dup dup 0 Amentidera cos put 3 Amentidera cos put
       concat
       matrix currentmatrix  %% valor de la matriu rotada
       grestore
       transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
       itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
       pop add   %% valor X a corregir
      }if
      dup
      /iTxTm exch def  %% rectifiquem la posicio absoluta de les X
      %% cal que desem el valor de la coordenada d'inici de cadena, nomes utilitzada pels operadors ' i "
      %% TxTm
      /TxTm exch def
     }
     {  %% normalitzem
      %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm
      gsave
      aTm
      %% dup dup 2 get SyTm mul 2 exch put
      %% dup dup 1 get SxTm mul 1 exch put
      90NET
      {
       dup 1 get 0 lt
       {  %% rotacio negativa
        dup dup 1 -1 put 2 1 put
       }
       {  %% rotacio positiva
        dup dup 1 1 put 2 -1 put
        CursivaMentidera
        {
         %% eliminem els valors de generen la cursiva
         dup 3 0 put
         dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
         dup dup 5 get YpurTD add 5 exch put
         dup dup 4 get XpurTD add 4 exch put
        }
        {
         dup dup 5 iTyTm put 4 iTxTm put
        }ifelse
       }ifelse
      }
      {
       dup dup 5 iTyTm put 4 iTxTm put
      }ifelse

      concat
      matrix currentmatrix  %% valor de la matriu rotada
      grestore
      transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
      itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
      dup /iTyTm exch def  %% nou inici absolut de linia Y
      /TyTm exch def  %% posicio actual d'Y
      dup /iTxTm exch def  %% nou inici absolut de la linia X
      /TxTm exch def  %% posicio actual d'X
     }ifelse
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /TyTm TyTm put
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /iTyTm TyTm put
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /TxTm TxTm put
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /iTxTm TxTm put

%% per activar el detector faTREUiFICA cal saber:
%% el dic de TREUiFICAfinal de la pàgina que som
TREUiFICAfinal araPlana 6 string cvs cvx exec get dup
TyTm  %% la Y de Tm definitiva ja computada per TD i emmagatzemada a EstatGrafic
cvi  %% EP!MASATS treballarem només amb l'enter
128 string cvs dup 3 -2 roll known  %% la posició Y del text és a TREUiFICAfinal?
%% fem una doble comprovació, doncs coordenades sense decimals p.e. 10 es desen com 10.0 i llavors no es troven al diccionari!
{  %% SI, hi és
 true
}
{  %% de debò que no hi és?
 (.) search
 {  %% o duu un decimal a zero #.0 povocat pel primer repicat?
  exch pop  %% ens carreguem el punt
  exch cvx exec 0 eq
  {  %% com que duu el decimal a zero, tornem a cercar
   2 copy known
   {  %% existeix!
    true
   }
   {  %% tampoc NO hi és
    false
   }ifelse
  }
  {  %% no duu el decimal a zero
   false
  }ifelse
 }
 {
  false
 }ifelse
}ifelse
{  %% és una Y d'un mot a treure
 get
%dup == (<<<< dades via Td)==
 /araTREUiFICA exch def  %% array de dades a utilitzar pels operador de composició Tj TJ ' "
 /faTREUiFICA true def  %% gatell x saber si hem de treure i ficar text als operadors Tj TJ ' "
}
{  %% no és cap Y de mot a treure
 pop pop  %% esborrem la clau Y i el diccionari de la pàgina de TREUiFICAfinal
 /faTREUiFICA false def  %% gatell x saber si hem de treure i ficar text als operadors Tj TJ ' "
}ifelse

     %% estratègia a TD i Td per tal d'afegir un separador null
     %% entre paraules en cas que la Y de la línia que estem tractant ja existeixi, per tal d'afegir
     %% l'espai separador, amb un null, i evitar s'enganxin paraules diferents. Si ja existeix, o sigui
     %% que hi havia text abans, pot ser per dos motius: o som a final de línia (és el darrer mot) o som
     %% davant d'un cas on s'enganxarien dues paraules per manca d'aquest control a TD i Td
     yRENGS araPlana get dup dup
     %% aquí és on comprovem si existeix la Y del reng en aquesta pàgina
     TyTm
cvi  %% EP!MASATS treballarem només amb l'enter
 128 string cvs dup dup 3 index exch known
     {
      3 -1 roll exch get  %% posem a l'stack
      /araRENG exch def
      %% ampliem el primer array d'araRENG, de posicions X, amb un null per la dreta ...
      null
      araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
      %% ampliem el segon array d'araRENG, de noms de signes, amb un null per la dreta ...
      null
      araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
      %% ampliem el tercer array d'araRENG, de tipus, amb un null per la dreta ...
      null
      araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
      %% ampliem el quart array d'araRENG, de cossos, amb un null per la dreta ...
      null
      araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
      0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
      araRENG put  %% desem al diccionari de la plana
      yRENGS exch araPlana exch put  %% desem al diccionari dels rengs
     }
     {
      %% (NOHIES!)==
      %% araRENG ==
      pop pop pop pop pop
     }ifelse
    }stopped{( ... peta TD) pstack quit}if
   }
  ] i_TD get /TD exch bind def

  [  %% Tm
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop pop pop pop pop pop
     }
     {
      %%TiNTeM {  % es la tinta que toca ara ?
      6 /RoLL 6 def
      {
       RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       RoLL 1 sub /RoLL exch def
      }repeat
      sEdAs2 (Tm\012) writestring
      %%}{6{pop}repeat}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta Tm) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificador de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    6 /RoLL 6 def
    {
     RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     RoLL 1 sub /RoLL exch def
    } repeat
    sEdAs2 (Tm\012) writestring
    %%}{6{pop}repeat}ifelse  % de la tinta que toca ara
    }stopped{( ... peta Tm) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  %% stopped
     6 copy
     6 /RoLL 6 def
     {
      RoLL -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      RoLL 1 sub /RoLL exch def
     } repeat
     sEdAs2 (Tm\012) writestring
     EstatGrafic iEG get
     /girNOcontrolat get
     {  %% si cm duu un gir no controlat encara en aquesta implementacio, pleguem
      ( ... cm ... duu un gir NO controlat ... PLEGUEM!)== stop  %%quit
     }if
     /CursivaMentidera false def  %% gatell per la falsa italica
     6 copy
     %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     %% /LleixaBuida false def
     %% eliminem l'escriptura a disc, doncs aqui no ens serveix per a res!
     6 array astore /aTm exch def  %% desem l'array de la Tm
     /eixTmGirat false def
     /suaraTm true def  %% x saber si es la primera vegada q executem un operador de text despres d'executar Tm
     cmSy mul  %% multipliquem el valor provinent de cm
     cmPy add  %% hi sumem el valor provinent de cm
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TyTm exch put
%%En aquest punt, un cop corregit el valor amb cmPy, és on cal comprovar la coordenada Y de Tm 
%% a quin índex de pàgina som?
TREUiFICAfinal araPlana 6 string cvs cvx exec get
%% la posició Y del text és a TREUiFICAfinal?
dup 2 index
cvi  %% EP!MASATS treballarem només amb l'enter
128 string cvs dup 3 -2 roll known
%% fem una doble comprovació, doncs coordenades sense decimals p.e. 10 es desen com 10.0 i llavors no es troven al diccionari!
{  %% SI, hi és
 true
}
{  %% de debò que no hi és?
 (.) search
 {  %% o duu un decimal a zero #.0 povocat pel primer repicat?
  exch pop  %% ens carreguem el punt
  exch cvx exec 0 eq
  {  %% com que duu el decimal a zero, tornem a cercar
   2 copy known
   {  %% existeix!
    true
   }
   {  %% tampoc NO hi és
    false
   }ifelse
  }
  {  %% no duu el decimal a zero
   length 2 add  %% +2 ens donarà el rang fins al primer decimal significatiu que necessitem extraure per comparar
   2 index 128 string cvs exch 0 exch getinterval

%exch {== ==}forall (eeeeeeeee)== quit

   2 copy known
   {  %% n'hi ha prou que coincideixi el primer decimal significatiu
    true
   }
   {
    false
   }ifelse
  }ifelse
 }
 {
  false
 }ifelse
}ifelse
{  %% és una Y d'un mot a treure
 get
%%dup == (<<< dades via Tm)==
 /araTREUiFICA exch def  %% array de dades a utilitzar pels operador de composició Tj TJ ' "
 /faTREUiFICA true def  %% gatell x saber si hem de treure i ficar text als operadors Tj TJ ' "
}
{  %% no és cap Y de mot a treure
 pop pop  %% esborrem la clau Y i el diccionari de la pàgina de TREUiFICAfinal
 /faTREUiFICA false def  %% gatell x saber si hem de treure i ficar text als operadors Tj TJ ' "
}ifelse

     /TyTm exch def  %% valor absolut de posicio Y del text
     cmSx mul  %% multipliquem el valor provinent de cm
     cmPx add  %% hi sumem el valor provinent de cm
     %% copiem aquest valor al dic de l'estat grafic actiu
     dup EstatGrafic iEG get exch /TxTm exch put
     /TxTm exch def  %% valor absolut de posicio X del text
     cmSy mul  %% multipliquem el valor provinent de cm
     dup cos_ mul /CyTm exch def  %% valor del cos vertical de la lletra
     %% multiplicador d'escala Y del cos del text (seria el que al manual s'anomena com a 'text space unit')
     /iSyTm exch def  %% valor inicial que ratificarem + endavant
     /tanBsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un cursivat
     /tanAsin exch def  %% valor de la tangent o del sinus de l'angle segons sigui una rotacio o un cursivat
     cmSx mul  %% multipliquem el valor provinent de cm
     dup cos_ mul /CxTm exch def  %% valor del cos horitzontal de la lletra
     %% multiplicador d'escala X del cos del text (seria el que al manual s'anomena com a 'text space unit')
     /iSxTm exch def  %% valor inicial que ratificarem + endavant
     EstatGrafic iEG get /A_Tm 0 put  %% valor x defecte al dic de l'estat grafic actiu
     %% si algun dels dos valors (2 i 3 de l'array) es diferent de zero llavors actua el cos definit per Tf
     tanBsin abs tanAsin abs add 0 ne
     {  %% l'eix Tm es aparentment rotat (podria no ser-ho degut a les falses cursives!)
      %% esbrinem si duu falses cursives ...
      tanAsin 0 eq
      {
       %% eliminem els missatges idèntics que ja hem emès a la primera execució
       %% (\n ... cursiva mentidera de ... )print flush
       %% tanBsin iSyTm atan dup /Amentidera exch def
       tanBsin iSyTm atan /Amentidera exch def
       %% 128 string cvs print flush ( ... graus\n)print flush
       %% llistem el nom PS del tipus de lletra que la duu?
       %% hauríem de polir millor aquesta crida ...
       CalaixDeTipus araPlana get QuinaFONT get 0 get ==  %% (:-?)pstack quit
       %% si l'eix Tm no es rotat llavors ...
       %% copiem aquest valor al dic de l'estat grafic actiu
       EstatGrafic iEG get /SyTm iSyTm put
       %% ratifiquem ... iSyTm ... com a ... SyTm
       /SyTm iSyTm def
       %% copiem aquest valor al dic de l'estat grafic actiu
       EstatGrafic iEG get /SxTm iSxTm put
       %% ratifiquem ... iSxTm ... com a ... SxTm
       /SxTm iSxTm def
       /CursivaMentidera true def  %% gatell per la falsa italica
      }
      {
       /CursivaMentidera false def  %% gatell per la falsa italica
       %% esbrinem si es una rotacio neta a 90 graus ...
      %% de la mateixa manera que en condicions normals d'escriptura (linia de base en horitzontal)
      %% el cos del tipus es multiplicat pel cosinus d'aquest angle (0 graus = 1) doncs quan la linia de base
      %% es vertical el sinus (90 graus = 1) pot multiplicar tambe el cos del tipus i donar aquestes dues dades
      iSxTm iSyTm add 0 eq  %% si es true llavors tanBsin i tanAsin son valors del cos
      {  %% es una rotacio neta a 90 graus!
       tanBsin cmSy mul  %% multipliquem el valor provinent de cm
       dup abs dup /SyTm exch def  %% nou valor d'escala Tm establert pel sinus
       EstatGrafic iEG get exch /SyTm exch put  %% desen al dic de l'estat grafic
       cos_ mul abs /CyTm exch def  %% (valor absolut!) redefinim el valor del cos vertical de la lletra
       tanAsin cmSx mul  %% multipliquem el valor provinent de cm
       dup abs dup /SxTm exch def  %% nou valor d'escala Tm establert pel sinus
       EstatGrafic iEG get exch /SxTm exch put  %% desen al dic de l'estat grafic
       cos_ mul abs /CxTm exch def  %% (valor absolut!) redefinim el valor del cos horitzontal de la lletra
       %% gatell x detectar girs nets de 90 graus pel sinus
       /90NET true def
       %% esbrinem el signe de l'angle i desem el valor
       EstatGrafic iEG get /A_Tm 90 tanAsin 0 lt
       {
        neg dup /A_Tm exch def
       }
       {
        dup /A_Tm exch def
       }ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa
       /eixTmGirat true def
      }
      {  %% ha de ser una rotacio d'un altre valor
       %% llavors l'escala pren altra cop puntualment el valor d'1 (no cal desar-ho a l'estat grafic?)
       /SxTm 1 def  %% nou valor d'escala Tm per les X
       /SyTm 1 def  %% nou valor d'escala Tm per les Y
       %% restablim els valors d'escala desats a l'anterior Tm
       %%EstatGrafic iEG get dup /SxTm get /SxTm exch def /SyTm get /SyTm exch def
       %% gatell x detectar girs nets de 90 graus pel sinus
       /90NET false def
       cos_ cmSx mul /CxTm exch def cos_ cmSy mul /CyTm exch def
       %% eliminem els missatges idèntics que ja hem emès a la primera execució
       %% (EP: text Tm rotat o falses cursives!) ==
       %% discriminem el tipus de rotacio o esbiaixat ...
       aTm 0 4 getinterval aload pop  %% extraiem els quatre primers valors que ens interessen
       4 1 roll add 0 eq
       { %% es una rotacio normal (sinus contraposats)?
        %% o pot ser tambe una falsa cursiva rotada ...
        0 eq
        {
         /CursivaMentidera true def  %% gatell per la falsa italica
         %% eliminem els missatges idèntics que ja hem emès a la primera execució
         %% (\n ... cursiva mentidera de ... )print flush
         %% tanBsin abs atan dup /Amentidera exch def
         tanBsin abs atan /Amentidera exch def
         %% 128 string cvs print flush ( ... graus\n)print flush
         %% llistem el nom PS del tipus de lletra que la duu?
         %% hauríem de polir millor aquesta crida ...
         CalaixDeTipus araPlana get QuinaFONT get 0 get ==  %% (:-?)pstack quit
         %% es una rotacio neta a 90 graus!
         tanBsin cmSy mul  %% multipliquem el valor provinent de cm
         dup abs dup /SyTm exch def  %% nou valor d'escala Tm establert pel sinus
         EstatGrafic iEG get exch /SyTm exch put  %% desen al dic de l'estat grafic
         cos_ mul abs /CyTm exch def  %% (valor absolut!) redefinim el valor del cos vertical de la lletra
         tanAsin cmSx mul  %% multipliquem el valor provinent de cm
         dup abs dup /SxTm exch def  %% nou valor d'escala Tm establert pel sinus
         EstatGrafic iEG get exch /SxTm exch put  %% desen al dic de l'estat grafic
         cos_ mul abs /CxTm exch def  %% (valor absolut!) redefinim el valor del cos horitzontal de la lletra
         %% gatell x detectar girs nets de 90 graus pel sinus
         /90NET true def
         %% esbrinem el signe de l'angle i desem el valor
         EstatGrafic iEG get /A_Tm 90 tanAsin 0 lt
         {
          neg dup /A_Tm exch def
         }
         {
          dup /A_Tm exch def
         }ifelse put  %% el desem al dic de l'estat grafic actiu i a la variable activa
         /eixTmGirat true def
         /NOescairat false def  %% gatell x saber si cal cercar l'angle de rotacio
        }
        {
         /CursivaMentidera false def  %% gatell per la falsa italica
         /NOescairat true def  %% gatell x saber si cal cercar l'angle de rotacio
         pop
         %% eliminem els missatges idèntics que ja hem emès a la primera execució
         % ( ... es una rotacio normal) ==
        }ifelse
       }
       {
        add 0 eq
        {  %% es una imatge mirall (cosinus contraposats)
         ( ... es una rotacio d'espill ... PLEGUEM!)pstack stop  %%quit
        }
        {  %% aqui tenim una falsa cursiva en rotacio NO escairada
         %%( ... es un esbiaixat de l'eix NO controlat ... PLEGUEM!)
         %% eliminem els missatges idèntics que ja hem emès a la primera execució
         %% (\n ... cursiva mentidera rotada i no escairada ... \n\n)print flush
         %%% DEDUCCIONS X FER
         %% podem deduir l'angle de la linia de base restant 90 graus positius, fent ...
         aTm 0 2 getinterval aload pop atan 90 exch sub
         %% podem deduir l'angle vertical de les cursives (comptant des de la linia de base) fent ...
         %% aTm 2 2 getinterval aload pop atan ==
         %% fi de DEDUCCIONS
         %% aquest valor d'atan s'en deduiex el segon i tercer valor d'aTm
         %% aTm 3 get tanBsin abs atan
         %% tanBsin iSyTm atan pstack stop %quit
         /NOescairat false def  %% desactivem el gatell x saber si cal cercar l'angle de rotacio
         dup /anglES exch def /A_Tm exch def
         EstatGrafic iEG get /A_Tm A_Tm put  %% el desem al dic de l'estat grafic actiu
         /CursivaMentidera true def  %% gatell per la falsa italica
        }ifelse
       }ifelse
       NOescairat  %% cal cercar l'angle de rotacio?
       {  %% CANVIEM L'ESTRATEGIA DEL CALCUL PER L'OPERADOR atan
        /eixTmGirat true def
        %% aqui fem el calcul de l'angle de rotacio (graus i signe!)
        aTm
        dup 1 get /Asinus exch def  %% si el sinus es positiu: l'angle sera positiu (direccio contrarellotge)
        0 get /Acosinus exch def  %% pesquem el cosinus
        %% /anglES null def  % no fos q no el trobem
        %% /Acrement .001 def  % suficient per q la precisio d'angle no hagi d'iterar + d'1 cop?
        %% {  % loop
        Asinus 0 lt  %% si l'angle es negatiu (ho controlem amb l'index 1 de l'array Tm o cm)
        {
         %% -360 Acrement 0  
         Asinus Acosinus atan neg /anglES exch def
        }
        {
         %% 0 Acrement 360
         Asinus Acosinus atan /anglES exch def
        }ifelse
        %% {  % for
        %% dup dup sin 10000 mul truncate 10000 div Asinus 10000 mul truncate 10000 div eq
        %% exch cos 10000 mul truncate 10000 div Acosinus 10000 mul truncate 10000 div eq
        %% and
        %% {  % donat que l'error es mil·limetric, donem x bo el primer angle q compleixi la condicio
        %% % (pero n'hi poden haver +!)
        %% /anglES exch def exit
        %% }
        %% {
        %% pop
        %% }ifelse
        %% }for
        %% anglES null eq  % iterem?
        %% {  % si la precisio no es suficient li afegim 1 decimal!
        %% Acrement 10 div /Acrement exch def
        %% (no es prou acurat ... TORNEM-HI!) ==
        %% }
        %% {  % donem x bo el primer angle q compleixi la condicio (pero n'hi poden haver +!)
        anglES /A_Tm exch def
        EstatGrafic iEG get /A_Tm A_Tm put  %% el desem al dic de l'estat grafic actiu
        %% exit
        %% }ifelse
        %% }loop
       }if  %% cal cercar l'angle de rotacio?
      }ifelse  %% es una rotacio neta a 90 graus o una altre?
     }ifelse  %% cursiva mentidera?
    }
    {  %% si l'eix Tm no es rotat llavors ...
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /SyTm iSyTm put
     %% ratifiquem ... iSyTm ... com a ... SyTm
     /SyTm iSyTm def
     %% copiem aquest valor al dic de l'estat grafic actiu
     EstatGrafic iEG get /SxTm iSxTm put
     %% ratifiquem ... iSxTm ... com a ... SxTm
     /SxTm iSxTm def
    }ifelse
    %% cal que desem els valors de la coordenada d'inici de cadena, nomes utilitzades pels operadors ' " T* Td
    TxTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTxTm exch put
    /iTxTm exch def
    TyTm
    %% copiem aquest valor al dic de l'estat grafic actiu
    dup EstatGrafic iEG get exch /iTyTm exch put
    /iTyTm exch def

    %% aqui es on controlem l'herencia dels valors de rotacio de cm
    %% primer interroguem si cm duu cap tipus de rotacio
    A_cm 0 ne
    {  %% si la duu, llavors ho sumem a A_Tm i en calculem el cos i el sin
     A_cm A_Tm add dup /A_TOT exch def
     %% el calcul del sin/cos cal fer-lo amb el valor absolut de l'angle
     abs dup dup cos /A_cosTOT exch def sin /A_sinTOT exch def
     %% modifiquem, si cal, la variable 90NET
     truncate  %% desestimem els decimals?
     abs 90 eq {/90NET true def}{/90NET false def}ifelse
     %% modifiquem els cosinus la matriu de treball de Tm
     aTm dup dup dup 0 A_cosTOT put 3 A_cosTOT put
     %% modifiquem el sinus de la matriu Tm tenint en compte el sentit de l'angle
     A_TOT 0 lt {1 A_sinTOT neg put 2 A_sinTOT put}{1 A_sinTOT put 2 A_sinTOT neg put}ifelse
    }if

    %% reactualitzem l'interliniat (TL o TD q podria haver estat definit abans) ...
    EstatGrafic iEG get
    dup /TLoTD get  %% ... a partir del valor pur de l'interliniat desat a l'estat grafic actiu
    cmSy mul SyTm mul dup /INTERli exch def /INTERli exch put
    }stopped{( ... peta Tm) pstack quit}if
    %%% test
    %% CxTm CyTm
    %% [SxTm tanAsin tanBsin SyTm TxTm TyTm]
    %% aTm
    %% A_cm A_Tm(:::)pstack quit  % cos i paquet comparatiu
    %% /isiGne 0 def
   }
  ] i_Tm get /Tm exch bind def

  [  %% T*
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs2 (T*\012) writestring
     %%}if  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta T*) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs2 (T*\012) writestring
    %%}if  % de la tinta que toca ara
    }stopped{( ... peta T*) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  % stopped
     %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs2 (T*\012) writestring

     INTERli 0 eq  %% tret que l'interliniat sigui zero
     {  %% TxTm agafa el valor de iTxTm
      %% cada cop que es crida /T* cal reinicialitzar el valor de TxTm pel de iTxTm i idem x Y
      EstatGrafic iEG get dup /iTxTm get dup /TxTm exch def /TxTm exch put
      EstatGrafic iEG get dup /iTyTm get dup /TyTm exch def /TyTm exch put
     }
     {
      EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
      Aeix 0 eq  %% si l'eix no es rotat ...
      {  %% no cal q la normalitzem
       %% posem a la pila el valor de desplaçament (interliniat) y definit per TD x redefinir
       iTyTm INTERli sub
       dup /iTyTm exch def  %% nou inici absolut de linia Y
       /TyTm exch def  %% posicio actual d'Y

       CursivaMentidera  %% si es cursiva mentidera i sempre que ilYTd no sigui zero ...
       {  %% ... hem de reposicionar X en funcio del valor de l'angle negatiu de distorsio d'Y
        0
        INTERli neg
        gsave
        [1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
        dup dup 1 Amentidera sin neg put 2 Amentidera sin put
        dup dup 0 Amentidera cos put 3 Amentidera cos put
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

        pop iTxTm add   %% valor X a corregir
        dup /iTxTm exch def  %% nou inici absolut de la linia X
        /TxTm exch def  %% l'inici absolut de la linia X
       }
       {
        %% cada cop que es crida /T* cal reinicialitzar el valor de TxTm pel de iTxTm i idem x Y
        EstatGrafic iEG get dup /iTxTm get dup /TxTm exch def /TxTm exch put
        EstatGrafic iEG get dup  %%dup dup /iTxTm iTxTm put /TxTm iTxTm put
        /TyTm iTyTm put /iTyTm iTyTm put
       }ifelse
      }
      {  %% normalitzem
       0 INTERli neg
       %% redefinim la matriu d l'eix amb la rotacio, escala la translacio q ens interessa x Tm
       gsave
       aTm
       %%    dup dup 2 get tanBsin add 2 exch put
       %%    dup dup 1 get SxTm mul 1 exch put

       90NET
       {
        dup 1 get 0 lt
        {  %% rotacio negativa
         dup dup 1 -1 put 2 1 put
        }
        {  %% rotacio positiva
         dup dup 1 1 put 2 -1 put
        }ifelse

        CursivaMentidera
        {
         %% eliminem els valors de generen la cursiva
         dup 3 0 put
         dup 0 0 put  %% malgrat el zero altera l'eix X (i aixo no es propiament una cursiva)
         %%dup dup 5 get YpurTd add 5 exch put
         %%dup dup 4 get XpurTd add 4 exch put
        }if
       }if
       dup dup 5 iTyTm put 4 iTxTm put
       concat
       matrix currentmatrix  %% valor de la matriu rotada
       grestore
       transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
       itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

       CursivaMentidera
       {
        0
        INTERli neg
        gsave
        [1 0 0 1 0 0]  %% definim la matriu amb la rotacio de Amentidera
        dup dup 1 Amentidera sin neg put 2 Amentidera sin put
        dup dup 0 Amentidera cos put 3 Amentidera cos put
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

        pop  %% la distorsio angular X de la falsa cursiva aplicada a la posicio i l'angle Aeix
        0
        gsave
        [1 0 0 1 0 0]  %% definim la matriu amb la rotacio d'Aeix al punt q toca
        dup 5 -1 roll 5 exch put
        dup 5 -1 roll 4 exch put
        dup dup 1 Aeix sin put 2 Aeix sin neg put
        dup dup 0 Aeix cos put 3 Aeix cos put

        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics

        dup /iTyTm exch def  %% nou inici absolut de la linia Y
        /TyTm exch def  %% l'inici absolut de la linia Y
        dup /iTxTm exch def  %% nou inici absolut de la linia X
        /TxTm exch def  %% l'inici absolut de la linia X
       }
       {
        dup /iTyTm exch def  %% nou inici absolut de linia Y
        /TyTm exch def  %% posicio actual d'Y
        dup /iTxTm exch def  %% nou inici absolut de la linia X
        /TxTm exch def  %% posicio actual d'X
       }ifelse
      }ifelse
     }ifelse  %% tret que l'interliniat sigui zero
     %% TyTm iTyTm (:-l)pstack quit
    }stopped{( ... peta T*) pstack quit}if
   }
  ] i_T* get /T* exch bind def

  %% (PDF Ref 1.7) 5.3.2 Text-Showing Operators
  %% (PDF Ref ?) 8.7.5 Text string operators
  [  %% Tj
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop
     }
     {
      %%TiNTeM {  % es la tinta que toca ara ?
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %% posem els caracters ( ... ) com a cadena
      dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
      dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
      %%% fi de salvaparent2.ps
      sEdAs2 exch writestring
      sEdAs2 32 write sEdAs2 (Tj\012) writestring
      %%}{pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta Tj) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs2 exch writestring
    sEdAs2 32 write sEdAs2 (Tj\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta Tj) == quit}if
   }
   {  %% 2 dada variable
    faDADAv
    {
     pop  %% eliminem l'actual string de text
     DADAmestre iDADAv get  %% extraiem l'array de dades que es correspon a la pàgina segons líndex
     diDADAv nomDADAclau get get  %% extraiem la nova string amb la dada variable que toca
%% buffer de reescriptura de la cadena
dup length string dup /novaDADAv exch def /NullEncode filter /reescriuDADA exch def
%% reescrivim tots els caràcters en funció del xifrat utilitzat per la tipografia del PDF
%% aquí podrem comprovar també si el joc de caràcters és sencer
{  %% forall per tots els caràcters
 %% pressuposem que el TXT s'ha escrit en WinAnsi
 userdict /WinAnsiEncoding get exch get /crctr exch def  %% extraiem el nom del caràcter
 %% pel número de pàgina extraiem el nom PDF de tipografia utilitzada segons nomDADAclau
 tipusDADAv araPlana get nomDADAclau get
 %% extraiem l'encoding normalitzat corresponent a la tipografia i la pàgina dins de Champollion
 Champollion araPlana get exch get
 /mancasigne true def  %% gatell per saber si el signe que rexifrem existeix a la tipografia
 %% bastim el for per cercar el codi del caràcter segons l'encoding del tipus utilitzat
 dup /xfrt exch def length 0 exch 1 exch
 {
  dup xfrt exch get crctr eq
  {  %% és el caràcter
   reescriuDADA exch write  %% reescrivim el caràcter a la nova cadena
   /mancasigne false def
   exit
  }
  {  %% no ho és
   pop
  }ifelse 
 }for
 mancasigne  %% existeix?
 {
  crctr == ( ... caràcter INEXISTENT en aquesta tipografia ... pleguem!\n\n)print flush stop
 }
 {  %% inicialitzem pel caràcter següent
  /mancasigne true def
 }ifelse
 
}forall
reescriuDADA closefile

novaDADAv

%(:-5)pstack quit

% calfer: activar %20bis per 05, al final de %23 comprovarem que hem muntat el diccionari tipusDADAv on hi haura la clau del núm de pàgina i de valor un diccionari on la clau serà nomDADAclau i el valor el nom PDF de la tipografia, per muntar el diccionari tipusDADAv haurem de fer un maxmix de la versió per 04 (amb el que hem fet a QueLiFEmFer2) dels operadors Tf BDC EMC i tots els operadors de text: Tj TJ ' "
     ( ... Tj HO ESTEM FENT ... )==  %%pstack quit
     %%{  % stopped
     %%% salvaparent2.ps
     %%% de com reescriure una string x solucionar el problema de no deixar-nos
     %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
     %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
     /fora
     [  %% paquet de caracters a cercar
      (\134)  %% \ backslash
      (\050)  %% ( left parenthesis
      (\051)  %% ) right parenthesis
      (\012)  %% \n line feed (LF)
      (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
      (\011)  %% \t horizontal tab
      (\010)  %% \b backspace
      (\014)  %% \f form feed (FF)
     ] def
     /FAfora fora length def  %% pestell de sortida del loop
     /foraX
     [  %% paquet de substitucio de caracter
      (\\\\)  %% backslash
      (\\\()  %% left parenthesis
      (\\\))  %% right parenthesis
      (\\n)  %% line feed (LF)
      (\\r)  %% carriage return (CR)
      (\\t)  %% horizontal tab
      (\\b)  %% backspace
      (\\f)  %% form feed (FF)
     ] def
     /ifora 0 def  %% index de fora
     %%% aqui la cadena a reescriure correctament
     %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
     mark exch
     {  %% loop general
      {  %% loop cerca/subs de caracters
       fora ifora get search
       {
        exch pop
        dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
        dup 3 -1 roll 0 exch putinterval
       }
       {
        exit
       }ifelse
       exch
      } loop
      %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
      counttomark 1 gt
      {
       counttomark /atura't exch def
       /ici 2 def
       {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
       {  %% loop empalmador de les cadenes trobades en 1 sola
        dup length dup 3 index length add string dup 4 -1 roll
        0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
        counttomark 1 eq {exit} if
       } loop
      } if
      ifora 1 add /ifora exch def
      FAfora ifora eq {exit}if
     } loop
     exch pop  %% ens carreguem mark
     %% posem els caracters ( ... ) com a cadena
     dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
     dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
     %%% fi de salvaparent2.ps
     sEdAs2 exch writestring
     sEdAs2 32 write sEdAs2 (Tj\012) writestring
     %%}stopped{( ... peta Tj) == quit}if
    }
    {  %% reescrivim l'string de text de forma intacte
     %%{  % stopped
     %%% salvaparent2.ps
     %%% de com reescriure una string x solucionar el problema de no deixar-nos
     %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
     %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
     /fora
     [  %% paquet de caracters a cercar
      (\134)  %% \ backslash
      (\050)  %% ( left parenthesis
      (\051)  %% ) right parenthesis
      (\012)  %% \n line feed (LF)
      (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
      (\011)  %% \t horizontal tab
      (\010)  %% \b backspace
      (\014)  %% \f form feed (FF)
     ] def
     /FAfora fora length def  %% pestell de sortida del loop
     /foraX
     [  %% paquet de substitucio de caracter
      (\\\\)  %% backslash
      (\\\()  %% left parenthesis
      (\\\))  %% right parenthesis
      (\\n)  %% line feed (LF)
      (\\r)  %% carriage return (CR)
      (\\t)  %% horizontal tab
      (\\b)  %% backspace
      (\\f)  %% form feed (FF)
     ] def
     /ifora 0 def  %% index de fora
     %%% aqui la cadena a reescriure correctament
     %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
     mark exch
     {  %% loop general
      {  %% loop cerca/subs de caracters
       fora ifora get search
       {
        exch pop
        dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
        dup 3 -1 roll 0 exch putinterval
       }
       {
        exit
       }ifelse
       exch
      } loop
      %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
      counttomark 1 gt
      {
       counttomark /atura't exch def
       /ici 2 def
       {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
       {  %% loop empalmador de les cadenes trobades en 1 sola
        dup length dup 3 index length add string dup 4 -1 roll
        0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
        counttomark 1 eq {exit} if
       } loop
      } if
      ifora 1 add /ifora exch def
      FAfora ifora eq {exit}if
     } loop
     exch pop  %% ens carreguem mark
     %% posem els caracters ( ... ) com a cadena
     dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
     dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
     %%% fi de salvaparent2.ps
     sEdAs2 exch writestring
     sEdAs2 32 write sEdAs2 (Tj\012) writestring
     %%}stopped{( ... peta Tj) == quit}if
    }ifelse

   }
   {  %% 3 gatell 16 MASATS (adaptat de dada variable)
    {  % stopped
     %% dup (\000T\0001) eq{EstatGrafic iEG get /TyTm get faTREUiFICA (!!!!)pstack quit}if
     faTREUiFICA
     {  %% possiblement aquesta string l'hem de reescriure amb text a ficar
      araTREUiFICA
      %% per detectar el mot correcte en cas n'hi hagi múltiples compartint Y, hi hauria un mètode precís a implementar
      %% i més senzill que no pas decodificar altra cop la cadena, que seria desar a la darrera posició de cadascuna de les
      %% arrays de araTREUiFICA la coordenada X real (un cop computats escales i desplaçaments varis)
      %% doncs aquesta feina ja s'ha fet a la 1a interpretació

      %% ens cal llegir el gatell del doble octet!
      /esUnicode CalaixDeTipus araPlana get QuinaFONT get 3 get def

      %% NO cal (doncs també hi poden haver cadenes a 8 bits que duguin el xifrat alterat)
      %% primer detectem si la cadena ve amb doble octet, doncs només en aquest cas ens obligarà a decodificar-la de nou
      %% per saber si és el mot correcte en cas n'hi hagi múltiples compartint Y a dins d'araTREUiFICA

      1 index

      %% inici de la decodificació de la cadena Tj
      %% computem el valor del Ts (text rise)
      TyTs SyTm mul TyTm add
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TyTm exch put
      dup /TyTm exch def
      %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia la coordenada
      %% y i l'angle, de forma que els dos hauran de coincidir xq siguin considerats dins el mateix reng
      %% eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
      EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
      {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
       %% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat
       90NET
       {  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
        256 string cvs
        EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
        TxTm 256 string cvs  %% ara lliguem la X en ves de l'angle
        1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
        6 -1 roll 0 exch putinterval
        UndeR (_) putinterval
        UndeR 1 add 4 -1 roll putinterval
       }
       {
        256 string cvs
        EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
        1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
        6 -1 roll 0 exch putinterval
        UndeR (_) putinterval
        UndeR 1 add 4 -1 roll putinterval
       }ifelse
      }
      {
       /Aeix 0 def
       %% 128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
      }ifelse
      pop
      %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
      %% yRENGS araPlana get dup 2 index known
      %% pop {== ==}forall(MMMMMM)pstack quit
      %% {  %% existeix
      %% exch get /araRENG exch def  %% capturem l'array amb els elements del reng
      %% /HiHaY true def  %% el reng ja existeix
      %% }
      %% {  %% l'hem de crear
      %% exch
      [  %% array d'elements pel reng, on tots el seus index coincidiran!
       []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
       %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
       %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
       %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
       %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
       []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
       %% correctament on, si hi hagues una separacio (espai o no), contindria un null
       []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
       []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
       Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
       {
        null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
       }
       {
        Aeix  %% valor de l'angle
       }ifelse
      ]
      %% dup
      /araRENG exch def
      %% put  %% la desem al dic de la pagina
      %% /HiHaY false def  %% el reng NO existeix
      %% valors inicials de la translacio Tm de control signe a signe x concat
      /transX TxTm def
      /transY TyTm def
      %% }ifelse
      %% array de caracter amb les posicions:
      %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
      %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
      %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
      /iXfX 6 array def  %% ara de 6 posicions!

      dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
      /iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)

      {  %% loop per cada un dels caracters de la cadena de text Tj
       maxLoop 0 eq
       {
        pop exit
       }if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
       dup
       %% la captura en doble octet s'haurà de revisar quan tractem documents on sigui necessari treballar +enllà del 256
       iU esUnicode
       {
        2 getinterval 1 get
       }
       {
        1 getinterval 0 get
       }ifelse
       %% aquí tenim el codi del caràcter de la cadena
       /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
       %%  posicio x,y d'inici de caracter
       TxTm
       %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
       Aeix 0 eq
       {
        dup iXfX exch 0 exch put  %% x JBC
       }
       {
        dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
        {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
         pop
        }
        {
         div
        }ifelse
        iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
       }ifelse
       Aeix 0 eq  %% si l'eix no es rotat ...
       {  %% no cal q la normalitzem
        iXfX exch 2 exch put  % coordenada X d'inici del signe
        iXfX 3 TyTm put  %% coordenada Y d'inici del signe
       }
       {  %% normalitzem
        %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
        gsave
        aTm
        %% si es un angle net de 90 graus, hem de treballar a escala 1
        90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
        %% la translacio q ens interessa es la del x,y d'origen del signe
        dup 3 -1 roll 4 exch put  %% posicio X d'inici
        dup 5 TyTm put  %% posicio Y d'inici
        %% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
        0 exch 0 exch
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
        /transY exch def  %% desem pel proper concat?
        /transX exch def  %% desem pel proper concat?
        iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
        iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
       }ifelse

       %%(\n)print flush
       %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
       %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush
       %% treiem l'ample (Width metrics) de cada caracter ...

       CalaixDeTipus
       araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
       QuinaFONT get
       esUnicode
       {
%%Aquí hi ha un problema: treballant a 1 byte no ajustem l'índex pel valor de FirstChar!
        1 index exch
       }
       {
        dup 1 get 2 index exch sub exch
       }ifelse
       2 get exch  %get

%%Com pot ser que li arribi un valor d'índex en negatiu?
       abs  %% té lògica?
       %% dup 0 lt{(valor IMAGINARI!)pstack quit}if
%%L'altra problema és que l'encoding de Widths no té tot el rang a 256 (tot i ser Identity-H) doncs la font està escapçada
%%Si al descendantFont hi ha /DW llavors podriem posar-hi aquest valor?
%%Tirem pel dret: mirem si sortim de rang a l'encoding de Widths i si és així apliquem el valor de l'índex 4 de la font a CalaixDeTipus
       2 copy exch length ge
       {  %% el codi del caràcter és fora de rang de l'encoding de Widths
        pop pop
        CalaixDeTipus
        araPlana get
        QuinaFONT get 4 get  %% ara fem servir el valor mitjà de mètrica calculat
       }
       { 
        get
       }ifelse

       %% multipliquem l'ample de la metrica pel cos i dividim x1000+TxTm x saber la posicio del signe seguent
       CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       mul 1000 div
       %% es suma a cada caracter el valor definit per Tc
       ecTc
       SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
       %% aquest factor definit per Tc sempre va multiplicat pel multiplicador d'escala X del cos del text
       mul add
       dup /aS exch def  %% nomes l'ample del signe
       Aeix 0 eq
       {
        TxTm add  %% sumem el valor anterior ara
       }
       {
        dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
        %% desem la posicio X final del signe de la linia de base x si hem de fer la correccio d'espai
        /XfLB exch def
        TxTm add  %% sumem el valor anterior ara
       }ifelse
       %% copiem aquest valor al dic de l'estat grafic actiu
       dup EstatGrafic iEG get exch /TxTm exch put
       /TxTm exch def
       EncNETiPLANXAT exch get
       dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
       {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
        epTw
        SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
        mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos de text
        Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
        {
         dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
         dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
        }if
        TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
        %% copiem aquest valor al dic de l'estat grafic actiu
        dup EstatGrafic iEG get exch /TxTm exch put
        /TxTm exch def
       }if

       Aeix 0 eq  %% si l'eix no es rotat ...
       {  %% no cal q la normalitzem
        %% posicio x,y de final de caracter
        TxTm
        dup iXfX exch 1 exch put
        iXfX exch 4 exch put  %% coordenada X de final del signe
        TyTm
        iXfX exch 5 exch put  %% coordenada Y de final del signe
       }
       {  %% normalitzem
        %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
        gsave
        %% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
        aS abs  %% hem d'anul.lar el signe de l'amplada xq la coordenada corregida es calculi correctament
        0
        aTm
        %% si es un angle net de 90 graus, hem de treballar a escala 1
        90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
        %% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
        concat
        matrix currentmatrix  %% valor de la matriu rotada
        grestore
        transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
        itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
        dup /transY exch def  %% desem pel proper concat?
        /TyTm exch def  %% nova posisico Y d'inici pel proper signe
        dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
        /transX exch def  %% desem pel proper concat?
        iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
        iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
        %% desem la coordenada X de final de caracter mesurada en horitzontal
        Aeix 0 ne
        {  %% si es rotada
         iXfX 1 XfLB put
        }
        {  %% sense rotar
         iXfX 1 TxTm put
        }ifelse
       }ifelse

       %%iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
       %%iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
       %%(Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush

       /nullExtra false def

       %% ampliem el primer array d'araRENG, de posicions X, 1+ x la dreta ...
       iXfX dup length array copy  %% x profilaxi!
       araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
       %% ampliem el segon array d'araRENG, de noms de signes, 1+ x la dreta ...
       araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
       %% ampliem el tercer array d'araRENG, de tipus, 1+ x la dreta ...
       QuinaFONT
       araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
       %% ampliem el quart array d'araRENG, de cossos, 1+ x la dreta ...
       CyTm
       araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
       0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
       %% test
       %%isiGne 1 add /isiGne exch def


       iU esUnicode{2}{1}ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
       iU maxLoop ge
       {
        esUnicode{length 2 idiv /faCadena exch def}{length/faCadena exch def}ifelse
        %%pop
        exit
       }if  %% hem llegit tota la cadena?
      }loop  %% x cada un dels caracters del la cadena de dins TJ

      %% deixaNull
      %% {
      nullExtra
      %% }
      %% {
      %% false
      %% }ifelse

      {  %% si aquest gatell és actiu voldrà dir que haurem inserit text entremig d'una cadena
       %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
       %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
       %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
       %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

       %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
       araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
       getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
       sub getinterval putinterval araRENG exch 0 exch put

       %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
       araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
       faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
       faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
       baUla exch putinterval araRENG exch 0 exch put

       %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
       araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
       getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
       sub getinterval putinterval araRENG exch 1 exch put

       %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
       araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
       faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
       faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
       baUla exch putinterval araRENG exch 1 exch put

       %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
       araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
       getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
       sub getinterval putinterval araRENG exch 2 exch put

       %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
       araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
       faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
       faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
       baUla exch putinterval araRENG exch 2 exch put

       %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
       araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
       getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
       sub getinterval putinterval araRENG exch 3 exch put

       %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
       araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
       faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
       faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
       baUla exch putinterval araRENG exch 3 exch put
      }if

      araRENG 1 get  %% anem a pescar l'array amb els literals decodificats a WinAnsi
      dup length string /crWA exch def  %% màxima capacitat de la cadena repicada a WinAnsi
      crWA /NullEncode filter /FcrWA exch def  %% fitxer d'escriptura
      {  %% forall de l'array de literals decodificats a WinAnsi
       d_WAE exch get  %% anem a pescar el codi WinAnsi del literal
       dup null eq
       {  %% eliminem nulls
        pop
       }
       {
        dup /space eq
        {  %% eliminem espais en blanc
         pop
        }
        {
         FcrWA exch write  %% escrivim el codi WinAnsi del literal
        }ifelse
       }ifelse
      }forall
      FcrWA dup flushfile closefile
      crWA (\000) search  %% purguem, si n'hi han, els caràcters zero (\000) sobrants del buffer
      {
       exch pop exch pop
      }if
      %% final de la decodificació de la cadena Tj

      %% aquí hi haurà d'arribar la cadena repicada en WinAnsi
      /SaT exch def  %% cercarem si és l'string a treure
      /iSaT 0 def  %% aquest índex ens dirà el mot correcte en cas n'hi hagi múltiples compartint Y
      /araSaT false def  %% gatell per saber si és l'string a treure
      {  %% forall
       0 get SaT eq
       {
        /araSaT true def
        exit
       }
       {
        iSaT 1 add /iSaT exch def
       }ifelse
      }forall

      araSaT
      {  %% és l'string a treure
       araTREUiFICA iSaT get 3 get
       {  %% HI HA risc de trobar d'altres mots a la mateixa línia
        (\n >>> HI HA risc de cavalcar amb d'altres mots a la mateixa línia!\n)print flush
        %% (\n ... cal ponderar el risc de col·lisió d'X!\n\n)print flush
       }if
       true
      }
      {  %% NO és l'string a treure
       false
      }ifelse
     }
     {  %% segur que no
      false
     }ifelse

     {
      pop  %% la cadena de text original aquí sobra
      %% és una de les arrays emmagatzemada a TREUiFICAfinal, que s'estructura:
      %% índex 0 cadena de text a treure
      %% índex 1 cadena de text a ficar
      %% índex 2 justificat del text a ficar
      %% índex 3 risc de trobar d'altres mots a la mateixa línia? (llavors hauríem de treballar les X?) true=si false=no
      %% índex 4 nom PDF de la font (original o forastera)
      %% índex 5 font original o forastera? true=original false=forastera 
      araTREUiFICA iSaT get 5 get /ESoriginal exch def
      %% índex 6 doble octet? true=si false=no

      %% pop  %% eliminem l'actual string de text
      araTREUiFICA iSaT get 1 get  %% i hi posem la cadena de text a ficar

      ESoriginal
      {  %% treballarà amb una font original
       araTREUiFICA iSaT get 6 get  %% doble octet?
       {  %% doble octet
        /esUnicode true def
        dup length 2 mul
       }
       {  %% simple
        /esUnicode false def
        dup length
       }ifelse
      }
      {  %% treballarà amb una font forastera incrustada
       %% si n'incrustem una forastera treballarà inicialment sempre en WinAnsi
       dup length
       /esUnicode false def
       %% redefinim la font forastera incrustada...
       sEdAs2 (/) writestring sEdAs2 araTREUiFICA iSaT get 4 get 128 string cvs writestring
       sEdAs2 32 write
       sEdAs2 EstatGrafic iEG get /acTf get 1 get 128 string cvs writestring  %% ...i el cos amb l'operador Tf
       sEdAs2 ( Tf\012) writestring
      }ifelse

      %% buffer de reescriptura de la cadena
      string dup /hiFICA exch def /NullEncode filter /reescriuAficar exch def
      %% reescrivim tots els caràcters en funció del xifrat utilitzat per la tipografia del PDF
      %% aquí podrem comprovar també si el joc de caràcters és sencer
      {  %% forall per tots els caràcters
       %% pressuposem que el TXT s'ha escrit en WinAnsi
       userdict /WinAnsiEncoding get exch get /crctr exch def  %% extraiem el nom del caràcter

       ESoriginal
       {  %% NO podem anar a pescar una tipografia forastera a Champollion...
        araTREUiFICA iSaT get 4 get  %% nom PDF de tipografia utilitzada
        %% extraiem l'encoding normalitzat corresponent a la tipografia i la pàgina dins de Champollion
        Champollion araPlana get exch get
       }
       {  %% si és forastera, sempre treballarem en WinANsi
        userdict /WinAnsiEncoding get
       }ifelse

       /mancasigne true def  %% gatell per saber si el signe que rexifrem existeix a la tipografia
       %% bastim el for per cercar el codi del caràcter segons l'encoding particular /xfrt del tipus utilitzat
       dup /xfrt exch def length 1 sub 0 exch 1 exch
       {  %% for
        dup xfrt exch get crctr eq
        {  %% és el caràcter
         esUnicode
         {
          /pHexa (<0000>) def  %% patró hexa en doble octet per fer la conversió a decimal a doble octet
          /maxU 16 string def  %% buffer màxim per representar el codi del caràcter en hexa
          16 maxU cvrs  %% convertim el codi decimal a hexa
          dup length 5 exch sub exch pHexa 3 1 roll putinterval  %% farcim el patró hexa
          reescriuAficar pHexa cvx exec writestring  %% escrivim el buffer de la cadena de text a ficar
         }
         {
          reescriuAficar exch write  %% reescrivim el caràcter a la nova cadena
         }ifelse
         /mancasigne false def
         exit
        }
        {  %% no ho és
         pop
        }ifelse 
       }for
       mancasigne  %% existeix?
       {
        crctr ==
        araTREUiFICA iSaT get 4 get dup ==  %% nom PDF de tipografia utilitzada
        CalaixDeTipus araPlana get exch get 0 get ==  %% nom PS de la tipografia utilitzada
        ( ... caràcter INEXISTENT en aquesta tipografia ... pleguem!\n\n)print flush stop
       }
       {  %% inicialitzem pel caràcter següent
        /mancasigne true def
       }ifelse 
      }forall
      reescriuAficar closefile

      hiFICA

      ( ... ficant el nou text via Tj)==  %%pstack quit
      %% salvaparent2.ps
      %% de com reescriure una string x solucionar el problema de no deixar-nos
      %% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %% aqui la cadena a reescriure correctament
      %% (el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       }loop
       %% aquest loop capgira tots els elements trobats a l'stack mentre n'hi hagi mes d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {
         ici -1 roll ici 1 add /ici exch def ici atura't gt
         {
          exit
         }if
        }loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq
         {
          exit
         }if
        }loop
       }if
       ifora 1 add /ifora exch def
       FAfora ifora eq
       {
        exit
       }if
      }loop
      exch pop  %% ens carreguem mark

      %% Justificat?
      %% si no és caixa a l'esquerra, o sigui: si va centrat o caixa a la dreta ara utilitzem el recurs de treballar amb TJ
      araTREUiFICA iSaT get 2 get dup 0 eq
      {  %% treballem amb Tj perquè és caixa a l'esquerra
       pop
       %% posem els caracters ( ... ) com a cadena
       dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
       dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
       %% fi de salvaparent2.ps
       sEdAs2 exch writestring
       sEdAs2 32 write sEdAs2 (Tj\012) writestring
      }
      {  %% treballem amb TJ perquè: o és centrat o és caixa a la dreta
       /centratOdreta exch def
       %% segons si la font és original o forastera via el nom PDF de la font anirem a buscar la mètrica per poder justificar
       %% gràcies al recurs de rectificar el valor de iK (kern) i ajustar la posició horitzontal amb precisió
       %% 0 només si és original anirem a pescar la mètrica particular i mirarem si va a doble octet
       ESoriginal
       { %% 1 anem a pescar l'array de la mètrica particular associada
        araTREUiFICA iSaT get 4 get CalaixDeTipus araPlana get exch get
        dup dup 1 get /FCh exch def  %% FirstChar
        2 get /araARRAYmetrica exch def
        3 get  %% és doble octet?
        {
         /nOctets 2 def
        }
        {
         /nOctets 1 def
        }ifelse

        %% cadena de text a ficar
        /cAllegir exch def
        /metricaMOT 0 def

%%Aquest algorisme de lectura Unicode s'hauria de replicar en punts diversos de CaLi2CoPi on es necessita
        %% l'algorisme desglossatBinari.ps serveix per llegir cadenes de text escrites amb la lògica d'Unicode:
        %% trobar el valor decimal (índex), caràcter a caràcter, d'una cadena de text que duu els caràcters definits en n octets
        0 nOctets cAllegir length 1 sub
        {  %% for que extrau en substrings cada caràcter d'n octets dins cAllegir
         %% regenerem per cada caràcter
         /mascaraRadix  %% fem la màscara del radix number en funció d'nOctets
         nOctets 8 mul  %% 8 bits per byte
         2 add  %% pel cap 2# de la màscara del radix number
         string  %% buffer d'escriptura
         def
         %% fitxer d'escriptura de la mascaraRadix
         mascaraRadix /NullEncode filter /FCbinari exch def
         %% cap del radix number
         FCbinari (2#) writestring
         %% fi del regenerat
         cAllegir exch nOctets getinterval /caracterDnOctets exch def  %% la cadena del caràcter
         /iBit 2 def  %% índex inicial del farcidor de 0 i 1
         0 1 nOctets 1 sub
         {  %% for per farcir la mascaraRadix
          caracterDnOctets exch get 2 8 string cvrs  %% conversió del caràcter decimal a cadena binària
          dup length 8 exch sub
          {  %% farcim de zeros a l'esquerra, si en manquen
           FCbinari 48 write  %% escriu 0
          }repeat
          FCbinari exch writestring  %% escriu la cadena significativa de l'octet
         }for
         %% llistem
         FCbinari dup flushfile closefile  %% fluxió el buffer i tanquem el fitxer d'escriptura
         mascaraRadix  %% valor binari dins la cadena
         %% dup ==
         cvx exec %% passat a decimal executant el radix number
         %% 2 calculem la mètrica total de la cadena a ficar
         araARRAYmetrica exch FCh sub  %% és clau restar-hi el FirstChar!
         get metricaMOT add /metricaMOT exch def
        }for
       }
       {  %% 1 anem a pescar el diccionari de la mètrica estàndard que correspon a alguna de les 14 Core Fonts o els seus clònics
        araTREUiFICA iSaT get 4 get objectStandard14Fonts exch get /BaseFont get 14PDFcoreFonts exch get /araDICmetrica exch def
        %% aTJatreure iK get
        dup /cAllegir exch def  %% la cadena de text a ficar
        /metricaMOT 0 def
        {  %% 2 calculem la mètrica total de la cadena a ficar
         WinAnsiEncoding exch get araDICmetrica exch get metricaMOT add /metricaMOT exch def
        }forall
       }ifelse

       centratOdreta 2 eq
       {  %% 3 només si va centrat, la dividim per dos
        metricaMOT 2 div /metricaMOT exch def
       }if

%%Aquí és on componem amb l'operador TJ
       sEdAs2 ([) writestring
       sEdAs2 metricaMOT 256 string cvs writestring
       sEdAs2 (\() writestring
       %% (aquiESonPLORAlaCRIATURA)pstack quit
       sEdAs2 cAllegir writestring
       sEdAs2 (\)]TJ\012) writestring
      }ifelse

      %% dup (\000T\0001) eq {(MITELA)pstack quit}if

      ESoriginal not
      %%(:-16)pstack quit
      { %% restablim la font original un cop utilitzada la forastera?
       sEdAs2 (/) writestring
       sEdAs2 EstatGrafic iEG get /acTf get 0 get 128 string cvs writestring  %% el nom PDF de la font per l'operador Tf
       sEdAs2 32 write
       sEdAs2 EstatGrafic iEG get /acTf get 1 get 128 string cvs writestring  %% ...i el cos amb l'operador Tf
       sEdAs2 ( Tf\012) writestring
      }if
     }
     {  %% reescrivim l'string de text de forma intacte
      %% salvaparent2.ps
      %% de com reescriure una string x solucionar el problema de no deixar-nos
      %% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ]def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ]def
      /ifora 0 def  %% index de fora
      %% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       }loop
       %% aquest loop capgira tots els elements trobats a l'stack mentre n'hi hagi més d'un
       counttomark 1 gt
       {
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        }loop
       }if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      }loop
      exch pop  %% ens carreguem mark
      %% posem els caracters ( ... ) com a cadena
      dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
      dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
      %% fi de salvaparent2.ps
      sEdAs2 exch writestring
      sEdAs2 32 write sEdAs2 (Tj\012) writestring
     }ifelse
    }stopped
    {
     ( ... peta Tj) pstack stop
    }if
   }
  ] i_Tj get /Tj exch bind def

  [  %% '
   {  %% 0 eliminem continguts
    {  % stopped
     alFoc
     {
      pop
     }
     {
    %%TiNTeM {  % es la tinta que toca ara ?
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs2 exch writestring
    sEdAs2 32 write sEdAs2 ('\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
     }ifelse
    }stopped{( ... peta ') == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs2 exch writestring
    sEdAs2 32 write sEdAs2 ('\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta ') == quit}if
   }
   {  %% 2 dada variable
    {  % stopped
    faDADAv
    {
     ( ' ... pendent d'adaptar! ... )pstack quit
    }
    {
     %%{  % stopped
     %%% salvaparent2.ps
     %%% de com reescriure una string x solucionar el problema de no deixar-nos
     %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
     %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
     /fora
     [  %% paquet de caracters a cercar
      (\134)  %% \ backslash
      (\050)  %% ( left parenthesis
      (\051)  %% ) right parenthesis
      (\012)  %% \n line feed (LF)
      (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
      (\011)  %% \t horizontal tab
      (\010)  %% \b backspace
      (\014)  %% \f form feed (FF)
     ] def
     /FAfora fora length def  %% pestell de sortida del loop
     /foraX
     [  %% paquet de substitucio de caracter
      (\\\\)  %% backslash
      (\\\()  %% left parenthesis
      (\\\))  %% right parenthesis
      (\\n)  %% line feed (LF)
      (\\r)  %% carriage return (CR)
      (\\t)  %% horizontal tab
      (\\b)  %% backspace
      (\\f)  %% form feed (FF)
     ] def
     /ifora 0 def  %% index de fora
     %%% aqui la cadena a reescriure correctament
     %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
     mark exch
     {  %% loop general
      {  %% loop cerca/subs de caracters
       fora ifora get search
       {
        exch pop
        dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
        dup 3 -1 roll 0 exch putinterval
       }
       {
        exit
       }ifelse
       exch
      } loop
      %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
      counttomark 1 gt
      {
       counttomark /atura't exch def
       /ici 2 def
       {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
       {  %% loop empalmador de les cadenes trobades en 1 sola
        dup length dup 3 index length add string dup 4 -1 roll
        0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
        counttomark 1 eq {exit} if
       } loop
      } if
      ifora 1 add /ifora exch def
      FAfora ifora eq {exit}if
     } loop
     exch pop  %% ens carreguem mark
     %% posem els caracters ( ... ) com a cadena
     dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
     dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
     %%% fi de salvaparent2.ps
     sEdAs2 exch writestring
     sEdAs2 32 write sEdAs2 ('\012) writestring
     %%}stopped{( ... peta ') == quit}if
    }ifelse
    }stopped{( ... peta ') == quit}if
   }
   {  %% 3 gatell 16 MASATS
    ( ' ... pendent d'adaptar! seguint el model Tj ... )pstack quit
   }
  ] i_' get /' exch bind def

  [  %% "
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop pop
    }
    {
    %%TiNTeM {  % es la tinta que toca ara ?
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    %%    sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs2 exch writestring
    sEdAs2 32 write sEdAs2 ("\012) writestring
    %%}{pop pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta ") == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    %%{  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    %%    sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
    %%% salvaparent2.ps
    %%% de com reescriure una string x solucionar el problema de no deixar-nos
    %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
    %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
    /fora
    [  %% paquet de caracters a cercar
     (\134)  %% \ backslash
     (\050)  %% ( left parenthesis
     (\051)  %% ) right parenthesis
     (\012)  %% \n line feed (LF)
     (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
     (\011)  %% \t horizontal tab
     (\010)  %% \b backspace
     (\014)  %% \f form feed (FF)
    ] def
    /FAfora fora length def  %% pestell de sortida del loop
    /foraX
    [  %% paquet de substitucio de caracter
     (\\\\)  %% backslash
     (\\\()  %% left parenthesis
     (\\\))  %% right parenthesis
     (\\n)  %% line feed (LF)
     (\\r)  %% carriage return (CR)
     (\\t)  %% horizontal tab
     (\\b)  %% backspace
     (\\f)  %% form feed (FF)
    ] def
    /ifora 0 def  %% index de fora
    %%% aqui la cadena a reescriure correctament
    %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
    mark exch
    {  %% loop general
     {  %% loop cerca/subs de caracters
      fora ifora get search
      {
       exch pop
       dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
       dup 3 -1 roll 0 exch putinterval
      }
      {
       exit
      }ifelse
      exch
     } loop
     %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
     counttomark 1 gt
     {
      counttomark /atura't exch def
      /ici 2 def
      {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
      {  %% loop empalmador de les cadenes trobades en 1 sola
       dup length dup 3 index length add string dup 4 -1 roll
       0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
       counttomark 1 eq {exit} if
      } loop
     } if
     ifora 1 add /ifora exch def
     FAfora ifora eq {exit}if
    } loop
    exch pop  %% ens carreguem mark
    %% posem els caracters ( ... ) com a cadena
    dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
    dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
    %%% fi de salvaparent2.ps
    sEdAs2 exch writestring
    sEdAs2 32 write sEdAs2 ("\012) writestring
    %%}{pop pop pop}ifelse  % de la tinta que toca ara
    %%}stopped{( ... peta ") == quit}if
   }
   {  %% 2 dada variable
    {  % stopped
    faDADAv
    {
     ( " ... pendent d'adaptar! ... )pstack quit
    }
    {
     %%{  % stopped
     3 -1 roll 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     %%    sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
     %%% salvaparent2.ps
     %%% de com reescriure una string x solucionar el problema de no deixar-nos
     %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
     %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
     /fora
     [  %% paquet de caracters a cercar
      (\134)  %% \ backslash
      (\050)  %% ( left parenthesis
      (\051)  %% ) right parenthesis
      (\012)  %% \n line feed (LF)
      (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
      (\011)  %% \t horizontal tab
      (\010)  %% \b backspace
      (\014)  %% \f form feed (FF)
     ] def
     /FAfora fora length def  %% pestell de sortida del loop
     /foraX
     [  %% paquet de substitucio de caracter
      (\\\\)  %% backslash
      (\\\()  %% left parenthesis
      (\\\))  %% right parenthesis
      (\\n)  %% line feed (LF)
      (\\r)  %% carriage return (CR)
      (\\t)  %% horizontal tab
      (\\b)  %% backspace
      (\\f)  %% form feed (FF)
     ] def
     /ifora 0 def  %% index de fora
     %%% aqui la cadena a reescriure correctament
     %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
     mark exch
     {  %% loop general
      {  %% loop cerca/subs de caracters
       fora ifora get search
       {
        exch pop
        dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
        dup 3 -1 roll 0 exch putinterval
       }
       {
        exit
       }ifelse
       exch
      } loop
      %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
      counttomark 1 gt
      {
       counttomark /atura't exch def
       /ici 2 def
       {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
       {  %% loop empalmador de les cadenes trobades en 1 sola
        dup length dup 3 index length add string dup 4 -1 roll
        0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
        counttomark 1 eq {exit} if
       } loop
      } if
      ifora 1 add /ifora exch def
      FAfora ifora eq {exit}if
     } loop
     exch pop  %% ens carreguem mark
     %% posem els caracters ( ... ) com a cadena
     dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
     dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
     %%% fi de salvaparent2.ps
     sEdAs2 exch writestring
     sEdAs2 32 write sEdAs2 ("\012) writestring
     %%}stopped{( ... peta ") == quit}if
    }ifelse
    }stopped{( ... peta ") == quit}if
   }
   {  %% 3 gatell 16 MASATS
    ( " ... pendent d'adaptar! seguint el model Tj ... )pstack quit
   }
  ] i_" get /" exch bind def

  %% nou algorisme TJ molt optimitzat, vegeu fa__tj.ps
  %% reordena els caracters en tots els casos de forma molt acurada
  [  %% TJ
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs2 ([ ) writestring
    {  %% forall
     dup type /stringtype eq
     {  %%sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {  %% loop
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %% posem els caracters ( ... ) com a cadena
      dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
      dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
      %%% fi de salvaparent2.ps
      sEdAs2 exch writestring
      sEdAs2 32 write
     }
     {
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     } ifelse
    } forall
    sEdAs2 (] TJ\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta TJ) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    %%{  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs2 ([ ) writestring
    {  %% forall
     dup type /stringtype eq
     {  %%sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
      %%% salvaparent2.ps
      %%% de com reescriure una string x solucionar el problema de no deixar-nos
      %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
      %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
      /fora
      [  %% paquet de caracters a cercar
       (\134)  %% \ backslash
       (\050)  %% ( left parenthesis
       (\051)  %% ) right parenthesis
       (\012)  %% \n line feed (LF)
       (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
       (\011)  %% \t horizontal tab
       (\010)  %% \b backspace
       (\014)  %% \f form feed (FF)
      ] def
      /FAfora fora length def  %% pestell de sortida del loop
      /foraX
      [  %% paquet de substitucio de caracter
       (\\\\)  %% backslash
       (\\\()  %% left parenthesis
       (\\\))  %% right parenthesis
       (\\n)  %% line feed (LF)
       (\\r)  %% carriage return (CR)
       (\\t)  %% horizontal tab
       (\\b)  %% backspace
       (\\f)  %% form feed (FF)
      ] def
      /ifora 0 def  %% index de fora
      %%% aqui la cadena a reescriure correctament
      %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
      mark exch
      {  %% loop general
       {  %% loop cerca/subs de caracters
        fora ifora get search
        {
         exch pop
         dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
         dup 3 -1 roll 0 exch putinterval
        }
        {
         exit
        }ifelse
        exch
       } loop
       %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
       counttomark 1 gt
       {  %% loop
        counttomark /atura't exch def
        /ici 2 def
        {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
        {  %% loop empalmador de les cadenes trobades en 1 sola
         dup length dup 3 index length add string dup 4 -1 roll
         0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
         counttomark 1 eq {exit} if
        } loop
       } if
       ifora 1 add /ifora exch def
       FAfora ifora eq {exit}if
      } loop
      exch pop  %% ens carreguem mark
      %% posem els caracters ( ... ) com a cadena
      dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
      dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
      %%% fi de salvaparent2.ps
      sEdAs2 exch writestring
      sEdAs2 32 write
     }
     {
      10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     } ifelse
    } forall
    sEdAs2 (] TJ\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    %%}stopped{( ... peta TJ) == quit}if
   }
   {  %% 2 dada variable
    {  % stopped
    faDADAv
    {
     ( TJ ... pendent d'adaptar! ... )pstack quit
    }
    {
     %%{  % stopped
     sEdAs2 ([ ) writestring
     {  %% forall
      dup type /stringtype eq
      {  %%sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
       %%% salvaparent2.ps
       %%% de com reescriure una string x solucionar el problema de no deixar-nos
       %%% el backslash \ i els parentesi () sense el \ que els marca com a caracters
       %%% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
       /fora
       [  %% paquet de caracters a cercar
        (\134)  %% \ backslash
        (\050)  %% ( left parenthesis
        (\051)  %% ) right parenthesis
        (\012)  %% \n line feed (LF)
        (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
        (\011)  %% \t horizontal tab
        (\010)  %% \b backspace
        (\014)  %% \f form feed (FF)
       ] def
       /FAfora fora length def  %% pestell de sortida del loop
       /foraX
       [  %% paquet de substitucio de caracter
        (\\\\)  %% backslash
        (\\\()  %% left parenthesis
        (\\\))  %% right parenthesis
        (\\n)  %% line feed (LF)
        (\\r)  %% carriage return (CR)
        (\\t)  %% horizontal tab
        (\\b)  %% backspace
        (\\f)  %% form feed (FF)
       ] def
       /ifora 0 def  %% index de fora
       %%% aqui la cadena a reescriure correctament
       %%(el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
       mark exch
       {  %% loop general
        {  %% loop cerca/subs de caracters
         fora ifora get search
         {
          exch pop
          dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
          dup 3 -1 roll 0 exch putinterval
         }
         {
          exit
         }ifelse
         exch
        } loop
        %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA mentre n'hi hagi mes d'un
        counttomark 1 gt
        {  %% loop
         counttomark /atura't exch def
         /ici 2 def
         {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
         {  %% loop empalmador de les cadenes trobades en 1 sola
          dup length dup 3 index length add string dup 4 -1 roll
          0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
          counttomark 1 eq {exit} if
         } loop
        } if
        ifora 1 add /ifora exch def
        FAfora ifora eq {exit}if
       } loop
       exch pop  %% ens carreguem mark
       %% posem els caracters ( ... ) com a cadena
       dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
       dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
       %%% fi de salvaparent2.ps
       sEdAs2 exch writestring
       sEdAs2 32 write
      }
      {
       10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
      } ifelse
     } forall
     sEdAs2 (] TJ\012) writestring
     %%}stopped{( ... peta TJ) == quit}if
    }ifelse
    }stopped{( ... peta TJ) == quit}if
   }
   {  %% 3 gatell 16 MASATS
    {  %% stopped
     faTREUiFICA
     {  %% possiblement aquesta string l'hem de reescriure amb text a ficar
      araTREUiFICA 1 index
      %% inici de la decodificació de cadascuna de les cadenes de l'array TJ
      %% aprofitem parcialment el codi utilitzat a la primera interpretació de TJ per muntar l'array de yRENGS
      %% ens cal transformar l'array TJ en un nou array on l'organització de cadenes de text i dígits de prosa pot ser ben diferent

      %% ens cal llegir el gatell del doble octet!
      /esUnicode CalaixDeTipus araPlana get QuinaFONT get 3 get def

      %% computem el valor del Ts (text rise)
      TyTs SyTm mul TyTm add
      %% copiem aquest valor al dic de l'estat grafic actiu
      dup EstatGrafic iEG get exch /TyTm exch put
      dup /TyTm exch def
      %% si la linia duu una rotacio, llavors farem servir com a detector del reng la coincidencia la coordenada
      %% y i l'angle, de forma que els dos hauran de coincidir xq siguin considerats dins el mateix reng
      %% eixTmGirat eixcmGirat or  % si qualsevol dels dos es cert
      EstatGrafic iEG get dup /A_cm get exch /A_Tm get add 0 ne
      {  %% si no es zero, malgrat eixTmGirat o eixcmGirat estiguin activats
       %% utilitzarem aquesta marca x tancar tot el que tingui relacio amb el text girat
       90NET
       {  %% les linies escairades les identifiquem amb la coordenada y i x (en ves de l'angle)
        256 string cvs
        EstatGrafic iEG get dup /A_cm get exch /A_Tm get add /Aeix exch def
        TxTm 256 string cvs  %% ara lliguem la X en ves de l'angle
        1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
        6 -1 roll 0 exch putinterval
        UndeR (_) putinterval
        UndeR 1 add 4 -1 roll putinterval
       }
       {
        256 string cvs
        EstatGrafic iEG get dup /A_cm get exch /A_Tm get add dup /Aeix exch def  256 string cvs
        1 index length dup /UndeR exch def 1 index length add 1 add string dup dup dup
        6 -1 roll 0 exch putinterval
        UndeR (_) putinterval
        UndeR 1 add 4 -1 roll putinterval
       }ifelse
      }
      {
       /Aeix 0 def
       %% 128 string cvs  %% convertim a cadena xq esdevingui clau del diccionari
      }ifelse
      pop
      %% aqui es on comprovem si existeix la Y del reng en aquesta pagina
      %% yRENGS araPlana get dup 2 index known
      %% pop {== ==}forall(MMMMMM)pstack quit
      %% {  %% existeix
      %% exch get /araRENG exch def  %% capturem l'array amb els elements del reng
      %% /HiHaY true def  %% el reng ja existeix
      %% }
      %% {  %% l'hem de crear
      %% exch
      [  %% array d'elements pel reng, on tots el seus index coincidiran!
       []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
       %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
       %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
       %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
       %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
       %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
       []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
       %% correctament on, si hi hagues una separacio (espai o no), contindria un null
       []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
       []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
       Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
       {
        null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
       }
       {
        Aeix  %% valor de l'angle
       }ifelse
      ]
      %% dup
      /araRENG exch def
      %% put  %% la desem al dic de la pagina
      %% /HiHaY false def  %% el reng NO existeix
      %% valors inicials de la translacio Tm de control signe a signe x concat
      /transX TxTm def
      /transY TyTm def
      %% }ifelse

      %% array de caracter amb les posicions:
      %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
      %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
      %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
      %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
      /iXfX 6 array def  %% ara de 6 posicions!

      %% fem una array de la mateixa capacitat per desar-hi la primera decodificació amb literals
      dup length array /idemTJliterals exch def
      %% punter dels elements TJ originals
      /iidemTJ 0 def

      {  %% forall del paquet
       dup type /stringtype eq
       {  %% es la cadena de text (analisi idem Tj)
        %% dup (\000\013\000?) eq {/@--`-,-- true def}{/@--`-,-- false def}ifelse
        %% @--`-,-- {esUnicode(o)pstack quit}if
        %% {  % forall de la cadena de text

        dup length /maxLoop exch def  %% sortirem del loop quan haguem llegit tota la cadena
        /iU 0 def  %% index d'inici del text unicode (ara sense el 2 caracters de la marca d'inici)

        {  %% loop per cada un dels caracters de la cadena de text dins TJ
         maxLoop 0 eq {pop exit}if  %% sortim si la cadena es a zero (pot passar quan p.e. s'ailla el guio de final de linia en una sola string)
         dup
         %% la captura en doble octet s'haurà de revisar quan tractem documents on sigui necessari treballar +enllà del 256
         iU esUnicode{2 getinterval 1 get}{1 getinterval 0 get}ifelse

         %% aquí tenim el codi del caràcter de la cadena

         %% false{
         /aS 0 def  %% nomes l'ample del signe, pero el primer valor val zero
         %%  posicio x,y d'inici de caracter
         TxTm
         %% la distacia X de la linia de base, si es rotat, sera la coordenada X dividit pel cosinus de l'angle
         Aeix 0 eq
         {
          dup iXfX exch 0 exch put  %% x JBC
         }
         {
          dup Aeix cos dup 0 eq  %% si el cosinus es 0 evitem l'undefinedresult de dividir x zero ...
          {  %% ... i en aquest cas el valor de la distancia sera el valor de Y
           pop
          }
          {
           div
          }ifelse
          iXfX exch 0 exch put  %% calcul de la distancia X de la linia de base
         }ifelse

         Aeix 0 eq  %% si l'eix no es rotat ...
         {  %% no cal q la normalitzem
          iXfX exch 2 exch put  % coordenada X d'inici del signe
          iXfX 3 TyTm put  %% coordenada Y d'inici del signe
         }
         {  %% normalitzem
          %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
          gsave
          aTm
          %% si es un angle net de 90 graus, hem de treballar a escala 1
          90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
          %% la translacio q ens interessa es la del x,y d'origen del signe
          dup 3 -1 roll 4 exch put  %% posicio X d'inici
          dup 5 TyTm put  %% posicio Y d'inici
          %% posem a la pila els valors x,y a zero x avaluar-los en el mateix punt de translacio q hem posat a Tm
          0 exch 0 exch
          concat
          matrix currentmatrix  %% valor de la matriu rotada
          grestore
          transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
          itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
          /transY exch def  %% desem pel proper concat?
          /transX exch def  %% desem pel proper concat?
          iXfX 2 transX put  %% desem la coordenada X d'inici del signe normalitzada al paquet de 6 posicions
          iXfX 3 transY put  %% desem la coordenada Y d'inici del signe normalitzada al paquet de 6 posicions
         }ifelse
         %% }if

         %%(\n)print flush
         %%iXfX 2 get 256 string cvs print flush ( ... origen X\n) print flush
         %%iXfX 3 get 256 string cvs print flush ( ... origen Y\n) print flush
         %% treiem l'ample (Width metrics) de cada caracter ...

         CalaixDeTipus
         araPlana get  %% podem pescar la plana sense interrogar-la doncs s'ha creat interrogant Resources
         QuinaFONT get

         esUnicode
         {
%%Aquí hi ha un problema: treballant a 1 byte no ajustem l'índex pel valor de FirstChar!
          1 index exch
         }
         {
          dup 1 get 2 index exch sub exch
         }ifelse

         2 get exch  %% get

%%Com pot ser que li arribi un valor d'índex en negatiu?
         abs  %% té lògica?
%dup 0 lt{(valor IMAGINARI!)pstack quit}if
%%L'altra problema és que l'encoding de Widths no té tot el rang a 256 (tot i ser Identity-H) doncs la font està escapçada
%%Si al descendantFont hi ha /DW llavors podriem posar-hi aquest valor?
%%Tirem pel dret: mirem si sortim de rang a l'encoding de Widths i si és així apliquem el valor de l'índex 4 de la font a CalaixDeTipus
         2 copy exch length ge
         {  %% el codi del caràcter és fora de rang de l'encoding de Widths
          pop pop
          CalaixDeTipus
          araPlana get
          QuinaFONT get 4 get  %% ara fem servir el valor mitjà de mètrica calculat
         }
         { 
          get
         }ifelse

         %% multipliquem l'ample de la metrica pel cos i dividim x1000+TxTm x saber la posicio del signe seguent
         CxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
         mul 1000 div
         %% es suma a cada caracter el valor definit per Tc
         ecTc
         SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
         %% aquest factor definit per Tc sempre va multiplicat pel multiplicador d'escala X del cos del text
         mul add
         dup /aS exch def  %% nomes l'ample del signe
         Aeix 0 eq
         {
          TxTm add  %% sumem el valor anterior ara
         }
         {
          dup iXfX 0 get add  %% hi sumem la distacia de la posicio X d'inici rotada
          %% desem la posicio X final del signe de la linia de base x si hem de fer la correccio d'espai
          /XfLB exch def
          TxTm add  %% sumem el valor anterior ara
         }ifelse
         %% copiem aquest valor al dic de l'estat grafic actiu
         dup EstatGrafic iEG get exch /TxTm exch put
         /TxTm exch def
         EncNETiPLANXAT exch get
         dup /space eq  %% un espai en blanc ... i oju q aixo no vol dir q sigui un 32!
         {  %% si es un espai en blanc hem de tenir en compte l'operador Tw
          epTw
          SxTm acTz mul 100 div  %% apliquem l'escala horitzontal al valor del cos horitzontal de la lletra
          mul  %% aquest factor definit per Tw sempre va multiplicat pel multiplicador d'escala X del cos de text
          Aeix 0 ne  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
          {
           dup aS add /aS exch def  %% corregim el valor de nomes l'ample del signe?
           dup XfLB add /XfLB exch def  %% corregim la posicio X del final del signe de la linia de base
          }if
          TxTm add  %% sumem el valor d'espaiat entre paraules a la posicio X del text
          %% copiem aquest valor al dic de l'estat grafic actiu
          dup EstatGrafic iEG get exch /TxTm exch put
          /TxTm exch def
         }if

         Aeix 0 eq  %% si l'eix no es rotat ...
         {  %% no cal q la normalitzem
          %% posicio x,y de final de caracter
          TxTm
          dup iXfX exch 1 exch put
          iXfX exch 4 exch put  %% coordenada X de final del signe
          TyTm
          iXfX exch 5 exch put  %% coordenada Y de final del signe
         }
         {  %% normalitzem
          %% redefinim la matriu d l'eix Tm amb la translacio q ens interessa avaluar
          gsave
          %% posem a la pila els valors: X com a aS (ample del signe) i Y a zero x avaluar-los
          aS abs  %% hem d'anul.lar el signe de l'amplada xq la coordenada corregida es calculi correctament
          0
          aTm
          %% si es un angle net de 90 graus, hem de treballar a escala 1
          90NET{dup 1 get 0 lt{dup dup 1 -1 put 2 1 put}{dup dup 1 1 put 2 -1 put}ifelse}if
          %% la translacio q ens interessa es identica al aTm anterior tret q sigui un angle net a 90
          concat
          matrix currentmatrix  %% valor de la matriu rotada
          grestore
          transform  %% dona coordenades del punt (eix normal) en unitats del dispositiu d sortida (device pixels)
          itransform  %% ens dona les coordenades del punt (amb l'eix normal) en punts tipografics
          dup /transY exch def  %% desem pel proper concat?
          /TyTm exch def  %% nova posisico Y d'inici pel proper signe
          dup /TxTm exch def  %% nova posicio X d'inici pel proper signe
          /transX exch def  %% desem pel proper concat?
          iXfX 4 transX put  %% desem la coordenada X de final del signe normalitzada al paquet de 6 posicions
          iXfX 5 transY put  %% desem la coordenada Y de final del signe normalitzada al paquet de 6 posicions
          %% desem la coordenada X de final de caracter mesurada en horitzontal
          Aeix 0 ne
          {  %% si es rotada
           iXfX 1 XfLB put
          }
          {  %% sense rotar
           iXfX 1 TxTm put
          }ifelse
         }ifelse

         %%iXfX 4 get 256 string cvs print flush ( ... final X\n) print flush
         %%iXfX 5 get 256 string cvs print flush ( ... final Y\n) print flush
         %%(Signe ... )print flush dup 128 string cvs print flush (\n\n)print flush

         /nullExtra false def

         %% ampliem el primer array d'araRENG, de posicions X, 1+ x la dreta ...
         iXfX dup length array copy  %% x profilaxi!
         araRENG 0 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
         0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 0 exch put
         %% ampliem el segon array d'araRENG, de noms de signes, 1+ x la dreta ...
         araRENG 1 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
         0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 1 exch put
         %% ampliem el tercer array d'araRENG, de tipus, 1+ x la dreta ...
         QuinaFONT
         araRENG 2 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
         0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 2 exch put
         %% ampliem el quart array d'araRENG, de cossos, 1+ x la dreta ...
         CyTm
         araRENG 3 get dup length dup /baUla exch def 1 add array dup 3 -1 roll
         0 exch putinterval dup 3 -1 roll baUla exch put araRENG exch 3 exch put
         %% test
         %%isiGne 1 add /isiGne exch def

         iU esUnicode
         {
          2
         }
         {
          1
         }ifelse add /iU exch def  %% saltem d'1 en 1 o de dos en dos
         iU maxLoop ge
         {
          esUnicode
          {
           length 2 idiv /faCadena exch def
          }
          {
           length/faCadena exch def
          }ifelse
          %% pop
          exit
         }if  %% hem llegit tota la cadena?
        }loop  %% x cada un dels caracters del la cadena de dins TJ

        %% deixaNull
        %% {
        nullExtra
        %% }
        %% {
        %% false
        %% }ifelse
        {  %% si aquest gatell és actiu voldrà dir que haurem inserit text entremig d'una cadena
         %% llavors, afegirem sempre un null extra just després de l'índex EnRETIRA
         %% que ens hauria de marcar la posició del darrer caràcter de la cadena que hem tractat
         %% aquest null és preventiu, doncs és per evitar amb tota provabilitat que mots diferents
         %% quedin enganxats al ser extrets: un null o més equival a una (1) sola separació entre mots

         %% ampliem el primer array d'araRENG, de posicions X, amb un null a EnRETIRA+1 per inserir-hi
         araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
         getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
         sub getinterval putinterval araRENG exch 0 exch put

         %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
         araRENG 0 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
         faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
         faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
         baUla exch putinterval araRENG exch 0 exch put

         %% ampliem el segon array d'araRENG, de noms de signes, amb un null a EnRETIRA+1 per inserir-hi
         araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
         getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
         sub getinterval putinterval araRENG exch 1 exch put

         %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
         araRENG 1 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
         faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
         faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
         baUla exch putinterval araRENG exch 1 exch put
         %%(:-u) pstack quit

         %% ampliem el tercer array d'araRENG, de tipus, amb un null a EnRETIRA+1 per inserir-hi
         araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
         getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
         sub getinterval putinterval araRENG exch 2 exch put

         %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
         araRENG 2 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
         faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
         faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
         baUla exch putinterval araRENG exch 2 exch put

         %% ampliem el quart array d'araRENG, de cossos, amb un null a EnRETIRA+1 per inserir-hi
         araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
         getinterval 0 exch putinterval dup EnRETIRA 2 add 4 -1 roll EnRETIRA 1 add baUla EnRETIRA 1 add
         sub getinterval putinterval araRENG exch 3 exch put

         %% afegim un null de seguretat per l'esquerra de la cadena que hem inserit
         araRENG 3 get dup dup length dup /baUla exch def 1 add array dup 3 -1 roll 0 EnRETIRA 1 add
         faCadena sub dup 0 le {pop 0}if getinterval 0 exch putinterval dup 3 -1 roll EnRETIRA 1 add
         faCadena sub dup 0 le {pop 0}if dup baUla exch sub 1 index 1 add /baUla exch def getinterval
         baUla exch putinterval araRENG exch 3 exch put
        }if
        %% }forall  % de la cadena de text

        %% fiquem la cadena de text amb literals al seu lloc
        idemTJliterals iidemTJ araRENG 1 get put

        [  %% array d'elements pel reng, on tots el seus index coincidiran!
         []  %% 0: el primer, una array que contindra una array per a cada caracter amb les posicions:
         %% index 0: coordenada X d'inici del caracter (mesurada en horitzontal)
         %% index 1: coordenada X de final del caracter: el seu Width sumat (mesurada en horitzontal)
         %% index 2: coordenada real X d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
         %% index 3: coordenada real Y d'inici del caracter (punt de linia de base corregit a l'eix no rotat)
         %% index 4: coordenada real X de final del caracter (punt de linia de base corregit a l'eix no rotat)
         %% index 5: coordenada real Y de final del caracter (punt de linia de base corregit a l'eix no rotat)
         %% ... si hi ha una separacio (espai o no) en comptes d'array contindra un null
         []  %% 1: el segon, una array on hi hauran els noms literals dels signes ordenats
         %% correctament on, si hi hagues una separacio (espai o no), contindria un null
         []  %% 2: el tercer, una array amb el nom PDF del tipus (QuinaFONT) utilitzat a cada signe
         []  %% 3: el quart, una array amb el cos real (CyTm) utilitzat en cada signe
         Aeix 0 eq  %% malgrat eixTmGirat o eixcmGirat estiguin activats podrien donar un valor zero
         {
          null  %% 4: el cinque, ens indica si la linia es rotada (null=NO)
         }
         {
          Aeix  %% valor de l'angle
         }ifelse
        ]
        %% dup
        /araRENG exch def
       }
       {  %% es la prosa (kern)
        %% fiquem el valor de la prosa al seu lloc
        idemTJliterals iidemTJ 3 -1 roll put
       }ifelse
       iidemTJ 1 add /iidemTJ exch def
      }forall  %% del paquet
      %% final de la decodificació de cadascuna de les cadenes de l'array TJ

      %% aquí és on refem l'array TJ per reescriure en base a quines strings de TJ s'han de mantenir i quines s'han de fusionar
      %% en aquest diccionari desarem com a clau les cadenes del /motAtreure lligades amb l'array de /rangDextraccio
      /dicTJatreure <<>> def
      %% en aquesta array temporal jugarem amb nulls per situar correctament els possibles elements fusionats
      %% en relació a la resta que es mantindran intactes
      /aTJatreure 2 index length array def  %% de capacitat idèntica a array original TJ 
      /1nouMot true def  %% gatell per poder enganxar trams de text que pertanyen a un mateix mot
      /darrerKern null def  %% valor inicial per filtrar arrays TJ sense numèrics kern
      {  %% forall sobre l'array araTREUiFICA
       0 get dup /motAtreure exch def  %% capturem l'string del mot a treure
       length /MAXmotAtreure exch def  %% ens dirà on ens parem en la comparació amb el punter /iLit dins l'array de literals
       /rangDextraccio [] def  %% array temporal on s'emmagatzemen els índex processats en la comparació del /motAtreure
       0 1 idemTJliterals length 1 sub
       {  %% for de cadascun dels elements de l'array TJ passada a literal
        dup /ARAiRANG exch def
        idemTJliterals exch get
        dup type /arraytype eq
        {  %% és la cadena de TJ
         1nouMot
         {  %% només inicialitzem si comencem un nou mot (un mot pot estar trencat en n cadenes)
          /iLit 0 def  %% índex de posició de cadascun dels caràcters a quadrar dins /motAtreure
         }if
         {  %% forall per a cadascun dels literals a cercar dins de /motAtreure
          %% aquí no caldrà interrogar si el caràcter existeix doncs ja ha passat aquest filtre al primer repicat
          dup /space eq
          {  %% l'espai en blanc és l'únic caràcter que filtrem per ometre
           pop
          }
          {  %% aquí és on hem d'avaluar que el codi existeix a /motAtreure
           %% i saber si el grup de literals quadra total o parcialment amb l'string:
           iLit 1 add MAXmotAtreure  %% cal interrogar si iLit iguala a MAXmotAtreure !
           eq
           {
            pop
            %% com que hi ha un canvi d'índex llegint l'array original de TJ (aTJatreure)
            darrerKern ARAiRANG 1 sub eq  %% l'índex anterior era un valor de Kern?
            {  %% si és així, també l'hem de desar
             rangDextraccio length dup /araVa exch def 1 add array dup dup
             0 rangDextraccio putinterval araVa darrerKern put /rangDextraccio exch def
            }if
            rangDextraccio length dup /araVa exch def 1 add array dup dup
            0 rangDextraccio putinterval araVa ARAiRANG put /rangDextraccio exch def
            %% sortim
            %% /QUAdra true def
            /1nouMot true def  %% gatell per poder enganxar trams de text que pertanyen a un mateix mot

            dicTJatreure motAtreure rangDextraccio put
            %% dicTJatreure{== ==}forall
            %% rangDextraccio MAXmotAtreure(QUEfemARA?)pstack quit
            /rangDextraccio [] def  %% array temporal on s'emmagatzemen els índex processats en la comparació del /motAtreure
            exit
           }
           {
            d_WAE exch get
            motAtreure iLit get eq  %% els codis del literal decodificat i la cadena del motAtreure quadren?
            {
             iLit 1 add /iLit exch def
             /1nouMot false def  %% gatell per poder enganxar trams de text que pertanyen a un mateix mot
            }
            {  %% sortim si cap dels codis del literal decodificat i la cadena del motAtreure no quadren
             %% /QUAdra false def
             /1nouMot true def  %% gatell per poder enganxar trams de text que pertanyen a un mateix mot
             /rangDextraccio [] def  %% array temporal on s'emmagatzemen els índex processats en la comparació del /motAtreure
             exit
            }ifelse
           }ifelse
          }ifelse
         }forall  %% per a cadascun dels literals a cercar dins de /motAtreure
        }
        {  %% com que és un valor de kern desem el seu índex a rangDextraccio
         pop rangDextraccio length dup /araVa exch def 1 add array dup dup
         0 rangDextraccio putinterval araVa ARAiRANG put /rangDextraccio exch def
         /darrerKern ARAiRANG def  %% índex del darrer valor de kern computat (l'haurem de desar si la cadena que segueix quadra)
        }ifelse

        %% aquí és on hauríem de desar el /rangDextraccio amb el /motAtreure dins el diccionari /dicTJatreure ???
        %% QUAdra
        %% {  %% només s'hi quadra
        %% dicTJatreure motAtreure rangDextraccio dup length array copy put
        %% }if
       }for  %% de cadascun dels elements de l'array TJ passada a literal

       %% rangDextraccio ==
      }forall  %% sobre l'array araTREUiFICA

      /TJoriginal exch def  %% desem l'array TJ original

      %% l'anàlisi d'aquest diccionari ens dirà:
      %% si ha trobat res i quin rang de valors ha de modificar a l'array TJ
      dicTJatreure length 0 ne
      {  %% si el diccionari NO és buit, voldrà dir que ens cal modificar l'array TJ amb les noves cadenes de text a ficar
       ( ... ficant el nou text via TJ)==  %% s'escau aquest missatge?
       %% l'array aTJatreure, si s'escau, contindrà els nous elements a ficar
       %% i ens servirà per reescriure l'array de cadenes de text codificades tal com necessiti TJ (encoding original o WinAnsi)
       dicTJatreure
       {  %% forall..
        %% ...per farcir a true tots els índex d'aTJatreure que vagin d'inici a final del /rangDextraccio dels /motAtreure
        dup 0 get 1 index length 1 sub 2 index exch get 1 exch
        {
         aTJatreure exch true put
        }for
        %% ...per farcir el mot a ficar (precedit del valor del kern o no), amb la codificació necessària (encoding original o WinAnsi)
        /motPerdut true def  %% gatell per filtrar l'improvable possibilitat de no localitzar aquí el mot a treure!
        0 get dup /iK exch def  %% primer avaluem que l'índex inicial sigui un valor de kern
        TJoriginal exch get dup type /stringtype eq
        {  %% és un text
         (TEXT)==
         pop
         /motSenseKern true def  %% gatell per saber si la cadena de text a treure duu originalment kern o no
        }
        {  %% és un valor de kern
         /motSenseKern false def
         aTJatreure exch iK exch put  %% farcim el valor de kern al seu índex...
         %% a l'índex següent és on hi ha d'anar el nou text a ficar amb la codificació necessària (encoding original o WinAnsi)
         /iK iK 1 add def
         (KERN)==
        }ifelse

        /iSaT 0 def  %% índex de l'array de dades del mot a treure dins araTREUiFICA
        araTREUiFICA
        {  %% forall
         dup 0 get 2 index eq  %% és l'array de dades del mot a treure?
         {  %% si HO ÉS...
          /motPerdut false def  %% desactivem el gatell d'alerta
          dup 1 get  %% pesquem el mot a ficar (aquí sempre xifrat en WinAnsi) 
          1 index 5 get  %% avaluem si el xifrat és l'original o WinAnsi
          {  %% la font és l'original, per tant l'encoding haurà de ser l'original
           /ESoriginal true def  %% gatell per redefinir o no la font forastera incrustada
           1 index 4 get  %% anem a pescar el xifrat original a Champollion via el nom PDF de la font
           Champollion araPlana get exch get /XInal exch def
           1 index 6 get /aDO exch def  %% treballem a doble octet?
           dup length
           aDO
           {
            2 mul
           }if
           string /cTaF exch def  %% cadena de text a ficar recodificada amb l'encoding original
           cTaF /NullEncode filter /FcTaF exch def  %% fitxer d'escriptura de la cadena de text a ficar
           {  %% forall per repicar cadascun dels caràcters a ficar que ara tenim a la pila amb l'encoding original /XInal...
            userdict /WinAnsiEncoding get exch get /cLit exch def  %% capturem el literal en relació al seu codi WinAnsi
            0 1 XInal length 1 sub
            {  %% for per capturar quin codi li correspon al caràcter que volem escriure segons l'encoding original
             dup XInal exch get  %% pentinem tots els literals per ordre
             cLit eq
             {  %% aquest serà el codi corresponent al caràcter que hem d'escriure segon el seu xifrat original
              aDO
              {  %% si va a doble octet, li precedeix un zero (això ho haurem de revisar quan contemplem plenament l'Unicode)
               FcTaF 0 write
              }if
              FcTaF exch write
              exit  %% i ja podem sortir del for
             }
             {
              pop
             }ifelse
            }for
           }forall  %% per repicar cadascun dels caràcters a ficar que ara tenim a la pila amb l'encoding original /XInal
           FcTaF dup flushfile closefile
           aTJatreure iK cTaF put  %% farcim el text a ficar al seu índex...
           %% ...cercant primer el nom via WinAnsi
           (original) ==  %pstack quit
           %% /foraStera false def  %% gatell per saber si treballarem amb fonts originals o forasteres
          }
          {  %% la font es forastera, per tant l'encoding serà WinAnsi segur
           /ESoriginal false def  %% gatell per redefinir o no la font forastera incrustada
           (forastera)==
           %% /foraStera true def  %% gatell per saber si treballarem amb fonts originals o forasteres
           aTJatreure exch iK exch put  %% farcim el text a ficar al seu índex...
          }ifelse
          %% farcim el mot a ficar a l'índex següent del valor de kern
          %% gatell de justificat 0 = caixa esquerra 1 = caixa dreta 2 = centrat, des de l'orígen del mot a trobar
          dup 2 get dup 0 eq
          {  %% caixa a l'esquerra
           pop pop  %% no cal fer res
          }
          {  %% o centrat o caixa a la dreta
           /centratOdreta exch def
           %% segons si la font és original o forastera via el nom PDF de la font anirem a buscar la mètrica per poder justificar
           %% gràcies al recurs de rectificar el valor de iK (kern) a aTJatreure i ajustar la posició horitzontal amb precisió
           %% 0 només si és original anirem a pescar la mètrica particular i mirarem si va a doble octet
           ESoriginal
           { %% 1 anem a pescar l'array de la mètrica particular associada
            4 get CalaixDeTipus araPlana get exch get
            dup dup 1 get /FCh exch def  %% FirstChar
            2 get /araARRAYmetrica exch def
            3 get  %% és doble octet?
            {
             /nOctets 2 def
            }
            {
             /nOctets 1 def
            }ifelse

            aTJatreure iK get  %% cadena de text a ficar
            dup /cAllegir exch def
            /metricaMOT 0 def

%%Aquest algorisme de lectura Unicode s'hauria de replicar en punts diversos de CaLi2CoPi on es necessita
            %% l'algorisme desglossatBinari.ps serveix per llegir cadenes de text escrites amb la lògica d'Unicode:
            %% trobar el valor decimal (índex), caràcter a caràcter, d'una cadena de text amb els caràcters definits en n octets
            0 nOctets cAllegir length 1 sub
            {  %% for que extrau en substrings cada caràcter d'n octets dins cAllegir
             %% regenerem per cada caràcter
             /mascaraRadix  %% fem la màscara del radix number en funció d'nOctets
             nOctets 8 mul  %% 8 bits per byte
             2 add  %% pel cap 2# de la màscara del radix number
             string  %% buffer d'escriptura
             def
             %% fitxer d'escriptura de la mascaraRadix
             mascaraRadix /NullEncode filter /FCbinari exch def
             %% cap del radix number
             FCbinari (2#) writestring
             %% fi del regenerat

             cAllegir exch nOctets getinterval /caracterDnOctets exch def  %% la cadena del caràcter
             /iBit 2 def  %% índex inicial del farcidor de 0 i 1
             0 1 nOctets 1 sub
             {  %% for per farcir la mascaraRadix
              caracterDnOctets exch get 2 8 string cvrs  %% conversió del caràcter decimal a cadena binària
              dup length 8 exch sub
              {  %% farcim de zeros a l'esquerra, si en manquen
               FCbinari 48 write  %% escriu 0
              }repeat
              FCbinari exch writestring  %% escriu la cadena significativa de l'octet
             }for

             %% llistem
             FCbinari dup flushfile closefile  %% fluxió el buffer i tanquem el fitxer d'escriptura
             mascaraRadix  %% valor binari dins la cadena
             %% dup ==
             cvx exec %% passat a decimal executant el radix number
             %% 2 calculem la mètrica total de la cadena a ficar
             araARRAYmetrica exch FCh sub  %% és clau restar-hi el FirstChar!
             get metricaMOT add /metricaMOT exch def
            }for
           }
           {  %% 1 anem a pescar el diccionari de la mètrica estàndard que correspon a alguna de les 14 Core Fonts o els seus clònics
            4 get objectStandard14Fonts exch get /BaseFont get 14PDFcoreFonts exch get /araDICmetrica exch def
            aTJatreure iK get  %% cadena de text a ficar
            /metricaMOT 0 def
            {  %% 2 calculem la mètrica total de la cadena a ficar
             WinAnsiEncoding exch get araDICmetrica exch get metricaMOT add /metricaMOT exch def
            }forall
           }ifelse
           centratOdreta 2 eq
           {  %% 3 només si va centrat, la dividim per dos
            metricaMOT 2 div /metricaMOT exch def
           }if

           motSenseKern
           {  %% 4 si no duu kern ens obliga abans a ampliar l'array aTJatreure amb un nou element a la posició iK
            %% de com ampliar una array a la posició d'un index determinat
            %% sempre que el valor d'aquest no excedeixi el seu length
            /Aindex iK def  %% índex determinat on ampliarem l'array (la posició quedarà a null)
            %% la nova sempre serà 1 element més gran
            aTJatreure length 1 add array /novArray exch def
            %% farcim pel davant
            novArray 0 aTJatreure 0 Aindex getinterval putinterval
            %% farcim pel darrera
            novArray aTJatreure dup length Aindex sub Aindex exch getinterval Aindex 1 add exch putinterval
            novArray dup length array copy /aTJatreure exch def  %% cal profilaxi?
            aTJatreure iK metricaMOT put  %% 5 el posem al seu lloc dins /aTJatreure
           }
           {  %% si duu kern, l'anem a pescar a iK - 1
            aTJatreure iK 1 sub get
            %% 4 li sumem el total de la mètrica de la cadena a ficar
            metricaMOT add
            %% 5 el tornem al seu lloc dins /aTJatreure
            aTJatreure exch iK 1 sub exch put
           }ifelse
          }ifelse

          araTREUiFICA iSaT get 3 get
          {  %% HI HA risc de trobar d'altres mots a la mateixa línia
           (\n >>> HI HA risc de cavalcar amb d'altres mots a la mateixa línia!\n)print flush
           %% (\n ... cal ponderar el risc de col·lisió d'X!\n\n)print flush
          }if
          pop exit  %% sortim, doncs les paraules a treure/ficar només hi són 1 vegada
         }
         { %% si NO ho és...
          pop  %% ens carreguem l'array i continuem cercant 
         }ifelse
         iSaT 1 add /iSaT exch def  %% índex de l'array de dades del mot a treure dins araTREUiFICA
        }forall  %% dins araTREUiFICA

        motPerdut
        {  %% de debò es pot donar el cas?
         (\n\n >>> NO HEM localitzat a /araTREUiFICA el mot a treure de l'array TJ ...pleguem!\n\n) print flush quit
        }if
       }forall  %% dins dicTJatreure
      }if
     }
     {  %% segur que no
      /ESoriginal true def
      /aTJatreure exch def
     }ifelse

     %% algorisme TJatreureTJaficar.ps
     %% fusiona l'array temporal de composició final /aTJatreure amb l'array d'orígen /TJoriginal per crear un nou contenidor
     %% general de composició fet d'n arrays en base a si la font a utlitzar és l'original del PDF o una de les 14 estàndard
     %% forasteres i en base a si el mot a ficar ha eliminat elements de la paraula substituïda que eren trencats pels valors
     %% del Kern, doncs ara el nou mot no duu encara tractament de la prosa en parells de caràcters
     %% sintaxi:
     %% els índex de /aTJatreure i /TJoriginal sempre han de quadrar abans de començar
     %% els índex de /aTJatreure a null substitueixen els seus equivalents a /TJoriginal i trenquen l'array si canvien de valor
     %% els índex de /aTJatreure a true eliminen els seus equivalents a /TJoriginal
     %% el format d'array que contemplarà tots els casos de reescriptura té aquesta estructura:
     %% [  %% contenidor general de composició
     %% [  %% cadascuna de les vegades que s'ha d'executar l'algorisme de reescriptura
     %% [() # () #()]  %% array TJ
     %% #  %% gatell per saber si redefinim o no amb font forastera
     %% ]
     %% ]

     /iaTJ 0 def  %% índex de seguiment
     /primerNULL null def  %% índex d'inici del rang de nulls
     /primerNOtrue null def  %% índex d'inici del rang de dades ja escrites a /aTJatreure

     /cgcTJ
     [  %% contenidor general de composició
     ] def

     aTJatreure

     %% sobre aquest array és on haurem d'aplicar finalment el justificat a TJ ??
     %% considerem el cas pitjor: dos mots o + a substituir que són a la mateixa línia

     {  %% forall
      dup null eq
      {
       pop primerNULL null eq
       {
        /primerNULL iaTJ def  %% som a l'inici d'un rang de nulls
        primerNOtrue null ne
        {  %% voldrà dir que som al final d'un rang de dades
         aTJatreure primerNOtrue iaTJ primerNOtrue sub getinterval
         %% com que només hi poden haver trues entre les dades (fruit de mots sencers trencats pel kern)
         mark exch
         {
          dup true eq
          {  %% els eliminem de l'array
           pop
          }if
         }forall
         ]
         %% ==  %% de moment llistem el rang de dades
         mark exch ESoriginal ]  %% fem l'array amb el gatell i el farcim al contenidor general de composició cgcTJ
         cgcTJ length dup /araVa exch def 1 add array dup 0 cgcTJ putinterval dup araVa 4 -1 roll put /cgcTJ exch def
         /primerNOtrue null def  %% inicialitzem
        }if
       }if
       %% xafem amb el seu equivalent a /TJoriginal
       aTJatreure iaTJ TJoriginal iaTJ get put
      }
      {
       primerNULL null ne
       {  %% voldrà dir que som al final d'un rang de nulls
        aTJatreure primerNULL iaTJ primerNULL sub getinterval
        %% ==  %% de moment llistem e rang de nulls
        mark exch true ]  %% fem l'array amb el gatell aquí sempre a true i el farcim al contenidor general de composició cgcTJ
        cgcTJ length dup /araVa exch def 1 add array dup 0 cgcTJ putinterval dup araVa 4 -1 roll put /cgcTJ exch def
        /primerNULL null def  %% inicialitzem
       }if
       true ne
       {
        primerNOtrue null eq
        {  %% som a l'inici d'un rang de dades
         /primerNOtrue iaTJ def
        }if
       }if
      }ifelse
      iaTJ 1 add /iaTJ exch def
     }forall

     primerNULL null ne
     {  %% voldrà dir que ha quedat a la cua un rang de nulls a extraure
      aTJatreure primerNULL iaTJ primerNULL sub getinterval
      %% ==  %% si hi és llistem el darrer rang de nulls
      mark exch true ]  %% fem l'array amb el gatell aquí sempre a true i el farcim al contenidor general de composició cgcTJ
      cgcTJ length dup /araVa exch def 1 add array dup 0 cgcTJ putinterval dup araVa 4 -1 roll put /cgcTJ exch def
     }if

     primerNOtrue null ne
     {  %% voldrà dir que ha quedat a la cua un rang de dades a extraure
      aTJatreure primerNOtrue iaTJ primerNOtrue sub getinterval
      %% com que només hi poden haver trues entre les dades (fruit de mots sencers trencats pel kern)
      mark exch
      {
       dup true eq
       {  %% els eliminem de l'array
        pop
       }if
      }forall
      ]
      %% ==  %% si hi és llistem el darrer rang de dades
      mark exch ESoriginal ]  %% fem l'array amb el gatell i el farcim al contenidor general de composició cgcTJ
      cgcTJ length dup /araVa exch def 1 add array dup 0 cgcTJ putinterval dup araVa 4 -1 roll put /cgcTJ exch def
     }if

     %% TJoriginal aTJatreure

     cgcTJ
     {  %% forall de reescriptura sobre el contenidor general de composició
      %% repicat de Tf si treballem amb fonts forasteres?.
      dup 1 get not dup
      /cfo exch def  %% restablirem la font original?
      { %% cridem la font forastera incrustada?
       sEdAs2 (/) writestring sEdAs2 araTREUiFICA iSaT get 4 get 128 string cvs writestring
       sEdAs2 32 write
       sEdAs2 EstatGrafic iEG get /acTf get 1 get 128 string cvs writestring  %% ...i el cos amb l'operador Tf
       sEdAs2 ( Tf\012) writestring
      }if

      0 get  %% cridem l'array de composició a escriure

      sEdAs2 ([ ) writestring
      {  %% forall
       dup type /stringtype eq
       {  %% sEdAs2 40 write sEdAs2 exch writestring sEdAs2 41 write
        %% salvaparent2.ps
        %% de com reescriure una string x solucionar el problema de no deixar-nos
        %% el backslash \ i els parentesi () sense el \ que els marca com a caracters
        %% adaptat de l'algorisme NRMLTZDR2.ps del cercador de palindroms TURURUT2
        /fora
        [  %% paquet de caracters a cercar
         (\134)  %% \ backslash
         (\050)  %% ( left parenthesis
         (\051)  %% ) right parenthesis
         (\012)  %% \n line feed (LF)
         (\015)  %% \r carriage return (CR) ... exemples com misterioses_Y_rb82fc.pdf i rb82fc.pdf ens han obligat a filtrar aquests caracters d'escape
         (\011)  %% \t horizontal tab
         (\010)  %% \b backspace
         (\014)  %% \f form feed (FF)
        ] def
        /FAfora fora length def  %% pestell de sortida del loop
        /foraX
        [  %% paquet de substitucio de caracter
         (\\\\)  %% backslash
         (\\\()  %% left parenthesis
         (\\\))  %% right parenthesis
         (\\n)  %% line feed (LF)
         (\\r)  %% carriage return (CR)
         (\\t)  %% horizontal tab
         (\\b)  %% backspace
         (\\f)  %% form feed (FF)
        ] def
        /ifora 0 def  %% index de fora
        %% aqui la cadena a reescriure correctament
        %% (el primer \\\)el segon\\\( el tercer \)\(el quart i el cinque\(\))
        mark exch
        {  %% loop general
         {  %% loop cerca/subs de caracters
          fora ifora get search
          {
           exch pop
           dup length dup 2 add string dup 3 -1 roll foraX ifora get putinterval
           dup 3 -1 roll 0 exch putinterval
          }
          {
           exit
          }ifelse
          exch
         }loop
         %% aquest loop capgira tots els elements trobats a l'stack mentre n'hi hagi més d'un
         counttomark 1 gt
         {  %% loop
          counttomark /atura't exch def
          /ici 2 def
          {
           ici -1 roll ici 1 add /ici exch def ici atura't gt
           {
            exit
           }if
          }loop
          {  %% loop empalmador de les cadenes trobades en 1 sola
           dup length dup 3 index length add string dup 4 -1 roll
           0 exch putinterval dup 3 -1 roll 4 -1 roll putinterval
           counttomark 1 eq
           {
            exit
           }if
          }loop
         }if
         ifora 1 add /ifora exch def
         FAfora ifora eq {exit}if
        }loop
        exch pop  %% ens carreguem mark
        %% posem els caracters ( ... ) com a cadena
        dup length dup /lAstC exch def 2 add string dup 0 (\() putinterval
        dup 3 -1 roll 1 exch putinterval dup lAstC 1 add (\)) putinterval
        %% fi de salvaparent2.ps
        sEdAs2 exch writestring
        sEdAs2 32 write
       }
       {
        10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
       }ifelse
      }forall
      sEdAs2 (] TJ\012) writestring

      cfo  %% restablim la font original?
      { %% restablim la font forastera incrustada?
       sEdAs2 (/) writestring
       sEdAs2 EstatGrafic iEG get /acTf get 0 get 128 string cvs writestring  %% el nom PDF de la font per l'operador Tf
       sEdAs2 32 write
       sEdAs2 EstatGrafic iEG get /acTf get 1 get 128 string cvs writestring  %% ...i el cos amb l'operador Tf
       sEdAs2 ( Tf\012) writestring
      }if
     }forall  %% de reescriptura sobre el contenidor general de composició
    }stopped
    {
     ( ... peta TJ) pstack stop
    }if
   }
  ] i_TJ get /TJ exch bind def

  %% Text object
  %% (PDF Ref ?) 8.7.2 Text Object operators
  [  %% BT
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (BT\012) writestring
     }
     {
      %% anellem la llesca sense destriar, de moment, els Forms
      sEdAs2 dup dup (/OC ) writestring
      llesques 5 get dup 0 true put  %% marquem el text com actiu
      1 get writestring ( BDC\012) writestring
      sEdAs2 (BT\012) writestring
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions + relligat d'imatges)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs2 (BT\012) writestring
    %%}if  % de la tinta que toca ara
    }stopped{( ... peta BT) == quit}if
   }
   {  %% 2 verificador de PDF
    DuuLlesques
    {
     sEdAs2 (BT\012) writestring
    }
    {
     %% anellem la llesca sense destriar, de moment, els Forms
     sEdAs2 dup dup (/OC ) writestring
     llesques 5 get dup 0 true put  %% marquem el text com actiu
     1 get writestring ( BDC\012) writestring
     sEdAs2 (BT\012) writestring
    }ifelse
   }
   {  %% 3 gatell 16 MASATS
    {  %% stopped
     %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     /CursivaMentidera false def  %% gatell per la falsa italica
     sEdAs2 (BT\012) writestring
   
     %%% KTCS inicialitzem les variables de text ara i les posem a l'estat grafic actiu
     %% valors inicials de les variables de posicio absoluta del carater definit per Tm
     EstatGrafic iEG get /TxTm 0 cmPx add 2 copy def put
     EstatGrafic iEG get /TyTm 0 cmPy add 2 copy def put
     %%% CAL VEURE SI S'INICIALITZEN LA RESTA DE VALORS I QUE NO PASSI COM INTERLi
     %% valor inicial d'espaiat entre paraules (nomes s'aplica quan troba un /space) definit per Tw
     EstatGrafic iEG get /epTw 0 2 copy def put
     %% valor inicial d'espaiat entre caracters (s'aplica a cada caracter) definit per Tc
     EstatGrafic iEG get /ecTc 0 2 copy def put
     %% valor inicial del % d'escala horitzontal definit per Tz
     EstatGrafic iEG get /acTz 100 2 copy def put
     %% valor inicial del multiplicador d'escala X del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
     EstatGrafic iEG get /SxTm 1 2 copy def put
     %% valor inicial del multiplicador d'escala Y del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
     EstatGrafic iEG get /SyTm 1 2 copy def put
     %% valor per defecte del desplacament vertical del text
     EstatGrafic iEG get /TyTs 0 2 copy def put
     %% NO S'INICIALITZA! valor inicial de l'interliniat (s'aplica amb T* " i ')
     %%EstatGrafic iEG get /INTERli 0 2 copy def put
     %% valors inicials de les coordenades d'inici de cadena, nomes utilitzades pels operadors ' i "
     EstatGrafic iEG get /iTxTm 0 2 copy def put
     EstatGrafic iEG get /iTyTm 0 2 copy def put
    }stopped{( ... peta BT) pstack quit}if
   }
  ] i_BT get /BT exch bind def

  [  %% ET
   {  %% 0 eliminem continguts
    alFoc
    {
    }
    {
     DuuLlesques
     {
      sEdAs2 (ET\012) writestring
     }
     {
      sEdAs2 (ET\012EMC\012) writestring
     }ifelse
    }ifelse
   }
   {  %% 1 (separacions + relligat d'imatges)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs2 (ET\012) writestring
    %%}if  % de la tinta que toca ara
    }stopped{( ... peta ET) == quit}if
   }
   {  %% 2 verificador de PDF
    DuuLlesques
    {
     sEdAs2 (ET\012) writestring
    }
    {
     sEdAs2 (ET\012EMC\012) writestring
    }ifelse
   }
   {  %% 3 gatell 16 MASATS
    {  %% stopped
     %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     sEdAs2 (ET\012) writestring

     %%% KTCS
     %% inicialitzem els valors de les variables de text a l'estat grafic actiu
     %% valors inicials de les variables de posicio absoluta del carater definit per Tm
     EstatGrafic iEG get /TxTm 0 put
     EstatGrafic iEG get /TyTm 0 put
     %% valor inicial d'espaiat entre paraules (nomes s'aplica quan troba un /space) definit per Tw
     EstatGrafic iEG get /epTw 0 put
     %% valor inicial d'espaiat entre caracters (s'aplica a cada caracter) definit per Tc
     EstatGrafic iEG get /ecTc 0 put
     %% valor inicial del % d'escala horitzontal definit per Tz
     EstatGrafic iEG get /acTz 100 put
     %% valor inicial del multiplicador d'escala X del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
     EstatGrafic iEG get /SxTm 1 put
     %% valor inicial del multiplicador d'escala Y del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
     EstatGrafic iEG get /SyTm 1 put
     %% valor per defecte del desplacament vertical del text
     EstatGrafic iEG get /TyTs 0 put
     %% NO S'INICIALITZA! valor inicial de l'interliniat (s'aplica amb T* " i ')
     %%EstatGrafic iEG get /INTERli 0 put
     %% valors inicials de les coordenades d'inici de cadena, nomes utilitzades pels operadors ' i "
     EstatGrafic iEG get /iTxTm 0 put
     EstatGrafic iEG get /iTyTm 0 put

     %% test
     %% yRENGS /1 get
     %% {pop ==}forall
     %% /502.747 get 1 get
     %% /483.545
     %% /493.146 get 1 get

    }stopped{( ... peta ET) pstack quit}if
   }
  ] i_ET get /ET exch bind def

  %% Type 3 fonts
  %% (PDF Ref ?) 8.10.1 Type 3 font operators
  [  %% d0
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (d0\012) writestring
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta d0) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
    10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (d0\012) writestring
    %%}{pop pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta d0) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  % stopped
     %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     exch 10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write
     10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write sEdAs2 (d0\012) writestring
    }stopped{( ... peta d0) pstack quit}if
   }
  ] i_d0 get /d0 exch bind def

  [  %% d1
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop pop pop pop pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
     sEdAs2 (d1\012) writestring
     %%}{6{pop}repeat}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta d1) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
    sEdAs2 (d1\012) writestring
    %%}{6{pop}repeat}ifelse  % de la tinta que toca ara
    }stopped{( ... peta d1) == quit}if
   }
   {  %% 2 gatell 16 MASATS
    {  % stopped
     %% /LleixaBuida false def  %% gatell x detectar lleixes absolutament buides (sense cap tipus d'operador PDF entre BDC i EMC)
     6 array astore {10000 mul truncate 10000 div 64 string cvs sEdAs2 exch writestring sEdAs2 32 write}forall
     sEdAs2 (d1\012) writestring
    }stopped{( ... peta d1) pstack quit}if
   }
  ] i_d1 get /d1 exch bind def

  %% (PDF Ref 1.7) 10.5 Marked Content
  %% (PDF Ref ?) 8.10.3 Marked Content operators
  [  %% MP
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 32 write sEdAs2 (MP\012) writestring
     %%}{pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta MP) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
    sEdAs2 32 write sEdAs2 (MP\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
    }stopped{( ... peta MP) pstack quit}if
   }
  ] i_MP get /MP exch bind def

  [  %% DP
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop pop
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     exch sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     dup type /nametype eq
     {
      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     }
     {
      sEdAs2 (<<) writestring
      sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
      sEdAs2 (>> DP\012) writestring
     } ifelse
     %%}{pop pop}ifelse  % de la tinta que toca ara
    }ifelse
    %%}stopped{( ... peta DP) == quit}if
   }
   {  %% 1 (separacions + relligat d'imatges + verificacio de PDF)
    {  % stopped
    %%TiNTeM {  % es la tinta que toca ara ?
    exch sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    dup type /nametype eq
    {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    }
    {
     sEdAs2 (<<) writestring

     sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
     sEdAs2 (>> DP\012) writestring
    } ifelse
    }stopped{( ... peta DP) pstack quit}if
   }
  ] i_DP get /DP exch bind def

  [  %% BMC
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {
     pop
    }
    {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
     sEdAs2 32 write sEdAs2 (BMC\012) writestring
    }ifelse
    %%}stopped{( ... peta BMC) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    /esUNAlayer false def  %% necessari doncs combina amb EMC
    %%TiNTeM {  % es la tinta que toca ara ?
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
    sEdAs2 32 write sEdAs2 (BMC\012) writestring
    %%}{pop}ifelse  % de la tinta que toca ara
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    {  % stopped
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
    sEdAs2 32 write sEdAs2 (BMC\012) writestring
    }stopped{( ... peta BMC) pstack quit}if
   }
  ] i_BMC get /BMC exch bind def

  [  %% BDC
   {  %% 0 eliminem continguts
    %%{  % stopped
    dEliminar 1 index known
    {  %% gatell per activar l'eliminat de continguts
     /alFoc true def
     pop pop
    }
    {
     /alFoc false def
    %% detector de les nostres llesques ...
    dup 128 string cvs (MRCT_ll) search
    {
     pop pop pop
     /DuuLlesques true def  %% obrim el gatell x saber com escriure o reescriure llesques
    }
    {
     pop
    }ifelse
    
    HiHaForms
    {
     dup /MRCT_llXObject eq
     {
      /QuiSapSiFXO true def  %% gatell de sospita x saber, quan executem Do, si es un Form XObject o no
      pop pop  %% ens carreguem les dades de la llesca, doncs les escriura Do
      false  %% hem d'escriure les dades d'aquesta llesca?
     }
     {
      /QuiSapSiFXO false def
      true  %% hem d'escriure les dades d'aquesta llesca?
     }ifelse
    }
    {
     /QuiSapSiFXO false def
     true  %% hem d'escriure les dades d'aquesta llesca?
    }ifelse  %% hi ha Forms XObjects ?
    
    {  %% hem d'escriure les dades d'aquesta llesca?
     exch
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     dup type /nametype eq
     {
      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
      sEdAs2 ( BDC\012) writestring
     }
     {
      sEdAs2 (<<) writestring
      sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
      sEdAs2 (>> BDC\012) writestring
     } ifelse
    }if  %% hem d'escriure les dades d'aquesta llesca?
    }ifelse
    %%} stopped{( ... peta BDC) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    exch
    %%% eliminem l'estructura de Layers (no pas el seu contingut!)
    dup /OC eq
    {
     /esUNAlayer true def  %% gatell per EMC i saber si cal eliminar-lo si es una Layer
     pop pop
    }
    {
     /esUNAlayer false def
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     dup type /nametype eq
     {
      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
      sEdAs2 (BDC\012) writestring
     }
     {
      sEdAs2 (<<) writestring

      sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic

%%      {  % forall
%%       exch dup type /nametype eq
%%       {
%%        sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
%%       }
%%       {
%%        dup type /stringtype eq
%%        {
%%         sEdAs2 exch writestring sEdAs2 32 write
%%        }
%%        {
%%         dup type /arraytype eq
%%         {
%%          sEdAs2 ([ ) writestring
%%          {  % forall
%%           dup type /nametype eq
%%           {
%%            sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
%%           }
%%           {
%%            64 string cvs sEdAs2 exch writestring sEdAs2 32 write
%%           } ifelse
%%          } forall
%%          sEdAs2 (] ) writestring
%%         }
%%         {
%%          64 string cvs sEdAs2 exch writestring sEdAs2 32 write
%%         } ifelse
%%        } ifelse
%%       } ifelse
%%       dup type /nametype eq
%%       {
%%        sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
%%       }
%%       {
%%        dup type /stringtype eq
%%        {
%%         sEdAs2 exch writestring sEdAs2 32 write
%%        }
%%        {
%%         dup type /arraytype eq
%%         {
%%          sEdAs2 ([ ) writestring
%%          {  % forall
%%           dup type /nametype eq
%%           {
%%            sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
%%           }
%%           {
%%            64 string cvs sEdAs2 exch writestring sEdAs2 32 write
%%           } ifelse
%%          } forall
%%          sEdAs2 (] ) writestring
%%         }
%%         {
%%          64 string cvs sEdAs2 exch writestring sEdAs2 32 write
%%         } ifelse
%%        } ifelse
%%       } ifelse
%%      } forall
      sEdAs2 (>> BDC\012) writestring
     } ifelse
     %%}{pop pop}ifelse  % de la tinta que toca ara
    } ifelse  %% x eliminar l'estructura de Layers (no pas el seu contingut!)
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny
    %%{  % stopped
    exch
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    dup type /nametype eq
    {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     sEdAs2 (BDC\012) writestring
    }
    {
     sEdAs2 (<<) writestring
     sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
     sEdAs2 (>> BDC\012) writestring
    } ifelse
    %%} stopped{( ... peta BDC) == quit}if
   }
   {  %% 3 verificacio de PDF
    %%{  % stopped
    %% detector de les nostres llesques ...
    dup 128 string cvs (MRCT_ll) search
    {
     pop pop pop
     /DuuLlesques true def  %% obrim el gatell x saber com escriure o reescriure llesques
    }
    {
     pop
    }ifelse
    
    HiHaForms
    {
     dup /MRCT_llXObject eq
     {
      /QuiSapSiFXO true def  %% gatell de sospita x saber, quan executem Do, si es un Form XObject o no
      pop pop  %% ens carreguem les dades de la llesca, doncs les escriura Do
      false  %% hem d'escriure les dades d'aquesta llesca?
     }
     {
      /QuiSapSiFXO false def
      true  %% hem d'escriure les dades d'aquesta llesca?
     }ifelse
    }
    {
     /QuiSapSiFXO false def
     true  %% hem d'escriure les dades d'aquesta llesca?
    }ifelse  %% hi ha Forms XObjects ?
    
    {  %% hem d'escriure les dades d'aquesta llesca?
     exch
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     dup type /nametype eq
     {
      sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring
      sEdAs2 ( BDC\012) writestring
     }
     {
      sEdAs2 (<<) writestring
      sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
      /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
      sEdAs2 (>> BDC\012) writestring
     } ifelse
    }if  %% hem d'escriure les dades d'aquesta llesca?
    %%} stopped{( ... peta BDC) == quit}if
   }
   {  %% 4 dada variable
    {  % stopped
    %% el literal inicial que duu BDC és el que ens dirà si és el nostre artefacte de dada variable
    %% o es tracta d'un altre tipus de container aliè a la nostra llibreria
    1 index /nomDADAclau exch def  %% desem el nom clau de la dada variable
    /esDADAv false def  %% esquer
    aDADAv
    {  %% forall
     nomDADAclau eq
     {
      /esDADAv true def
      exit
     }if
    }forall
    esDADAv
    {
     %% reescrivim de nou el BDC de forma intacte doncs ara els streams no es regeneren
     %% amb la clonació que fem a %39 i %57
     /faDADAv true def
     ( ... BDC HO ESTEM FENT! ... )==  %%pstack quit
    }if
    exch
    sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
    dup type /nametype eq
    {
     sEdAs2 (/) writestring 128 string cvs sEdAs2 exch writestring sEdAs2 32 write
     sEdAs2 (BDC\012) writestring
    }
    {
     sEdAs2 (<<) writestring
     sEdAs2 /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2
     /salva'l save def espiadic_fura2 salva'l restore  %% reescrivim les dades del dic
     sEdAs2 (>> BDC\012) writestring
    } ifelse
    } stopped{( ... peta BDC) pstack quit}if
   }
  ] i_BDC get /BDC exch bind def

  [  %% EMC
   {  %% 0 eliminem continguts
    %%{  % stopped
    alFoc
    {  %% gatell per aturar l'eliminat de continguts
     /alFoc false def
    }
    {
     sEdAs2 (EMC\012) writestring
     DuuLlesques {/DuuLlesques false def} if  %% tanquem el gatell x saber com escriure o reescriure llesques
    }ifelse
    %%}stopped{( ... peta EMC) == quit}if
   }
   {  %% 1 (separacions) redefinicio generada pel projecte WebProof
    esUNAlayer
    {
    }
    {
     %%TiNTeM {  % es la tinta que toca ara ?
     sEdAs2 (EMC\012) writestring
     %%}if  % de la tinta que toca ara
    } ifelse  %% x eliminar l'estructura de Layers (no pas el seu contingut!)
   }
   {  %% 2 (relligat d'imatges) redefinicio generada pel projecte A3copiseny + verificacio de PDF
    %%{  % stopped
    sEdAs2 (EMC\012) writestring
    DuuLlesques {/DuuLlesques false def} if  %% tanquem el gatell x saber com escriure o reescriure llesques
    %%}stopped{( ... peta EMC) == quit}if
   }
   {  %% 3 dada variable
    {  % stopped
    faDADAv
    {  %% només si correspon a continguts de dada variable
     /faDADAv false def
     ( ... EMC HO ESTEM FENT! ... )==  %%pstack quit
     %% reescrivim de nou el EMC de forma intacte doncs ara els streams no es regeneren
     %% amb la clonació que fem a %39 i %57
     sEdAs2 (EMC\012) writestring
    }if
    }stopped{( ... peta EMC) pstack quit}if
   }
   {  %% 4 repicat idem
    {  % stopped
     sEdAs2 (EMC\012) writestring
    }stopped{( ... peta EMC) pstack quit}if
   }
  ] i_EMC get /EMC exch bind def

  >> def  %% fi del OpContents_QueLiFemFer2
  %%% fi de diccionari
 } if
 %/16 cerca i substitució de text
 %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
 %/13 eliminem continguts de pàgina
 %/12 arbre jeràrquic
 %/10 PREFLIGHT AMB CAPES
 %/06 COSIT D'IMATGES
 %/05 dada variable
 %/01 SEPARACIÓ DE TINTES

 %% creiem que els signes << i >> interfereixen a l'anellador del vi % per blocar { ... } 
 %%% som a cal Quedelemi
 %%XRay /ObjectesX get /1 get /Utilitzats get
 %%JectesX {== ==}forall
 %% totalRSRCS (%!!!%)pstack quit
 QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
 {
  %%XRay /Patterns&Shadings get /Utilitzats get
  %%JectesPS
  %%XRay /EspaisDeColor get /Utilitzats get
  %% /CS1 get
  %%{== ==}forall (uuuuu) == quit

  %#%41% separem Patterns&Shadings
  (%#%41%)==
  %% diccionari on desarem com a clau el nom de cada tinta a separar i com a valor hi haura
  %% un dic amb d'entrada els parells nom del Pattern/path de l'stream separat
  /FotoCromPS 2 dict def
  /DarrersRange 2 dict def  %% aqui desarem les claus dels objectes de funcio (ara sembla q nomes de T3) on cal eliminar /Range per evitar l'Error de visualitzacio a l'Acrobat (aquest Range sera eliminat dins el loop de repicat de les tintes %48bis)
  /sepPS true def  %% gatell x indicar als operador cs/CS que son executats per reinterpretar l'stream d'un Pattern&Shading
  /esUnPS false def  %% valor inical del flag x saber si es un Pattern&Shading
  %% separem Patterns&Shadings?
  XRay /Patterns&Shadings get /Utilitzats get length 0 ne
  {
   BaBeL 36 get print flush  %% treiem per la pantalleta que separem Patterns&Shadings
   /BeSSo2  %% aquesta darrera funcio executa directament el fitxer de continguts aLLeGiR
   {
    OpContents_QueLiFemFer2 begin  %% activem el diccionari amb les redefinicions dels operadors PDF
    aLLeGiR cvx exec end  %% executem el fitxer de l'stream dels /Contents i sortim del diccionari
    sEdAs2 flushfile
   } bind def
   1 /iNousStreams exch def  %% index per assignar noms als nous streams repicats
   %% redefinicio dels path i els index pel repicat dels nou streams de Patterns&Shadings
   (1__________.nps) dup length faPath add string dup /pAthXiU exch def
   0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
   pAthXiU /nousStreamsPS exch def  %% utilitzat per l'applet per desar els nous streams dels Patterns&Shadings redefinits al disc
   nousStreamsPS length 15 sub /posNum exch def  %% posicio d'inici fix del numerador d'streams
   XRay /EspaisDeColor get /TintesiValors get
   {  %% forall de la generacio de separacions dels streams de Patterns&Shadings x Tinta
    pop  %% l'array de valors no ens interessa per a res
    /quinaTinta exch def  %% desem el literal de la tinta que llesquem
    %% inicialitzem les funcions dels valors actuals de ...
    /csARA [/Black] def  %% valor inicial de l'Espai de Color actual per fill
    /CSARA [/Black] def  %% valor inicial de l'Espai de Color actual per stroke
    /gsARA [null] def  %% Estat Grafic actual
    /tintARA [1] def  %% valor inicial de Tinta actual
    /Tfill 0 def  %% valor inical del gatell (suposem que no afecta) per saber si el valor de tinta es per fill (0) o stroke (1)
    /Tzero false def  %% valor inicial del gatell x saber si hem pintat amb tinta zero (blanc)
    /TiNTeMF true def  %% gatell de si Tintem x Fill
    /TiNTeMS true def  %% gatell de si Tintem x Stroke
    /TacaTintaF 1 def  %% valor x defecte de la Tinta per Fill
    /TacaTintaS 1 def  %% valor x defecte de la Tinta per Stroke
    /LaQtocaF true def  %% gatell x compensar el comportament Nexus/Backstage x Fill
    /LaQtocaS true def  %% gatell x compensar el comportament Nexus/Backstage x Stroke
    %% valors inicials dels gatells x control de l'overprint
    /NomesUn true def  %% valor inicial del gatell x saber si nomes treballem amb un espai de color d'1 sol component
    /OPactua false def
    /opactua false def
    /es4c false def  %% es CMYK ?
    %% ... abans dins el dic d'OpContents
    %% definim el fitxer on reescriurem l'stream del Pattern
    l'objectenet3 (w) file  %%  repicats a traves de les redefinicions d'OpContents_QueLiFemFer#
    /sEdAs2 exch def
    %% algun dels Patterns desats a /Patterns&Shadings es un Colored Pattern?
    XRay /Patterns&Shadings get /Utilitzats get
    {  %% forall on filtrem els Tiling Patterns (/PatternType 1) Colored (/PaintType 1) i ...
     1 index /mem exch def 0 index /MiM exch def
     dup 2 get  %% comprovem que la tinta que volem separar existeix al Pattern, doncs si no no fem res
     dup type /arraytype eq
     {
      /HiEs false def
      {quinaTinta eq {/HiEs true def exit}if}forall
      HiEs  %% la tinta que volem separar existeix al Pattern?    
     }
     {  %% ha de ser un nom d'una Separation o un literal directe DeviceCMYK o PureCMYK ...
      dup quinaTinta
      eq
      {  %% es tracta del nom del canal d'una Separation
       pop true
      }
      {
       dup null eq
       {pop true}  %% si es un null hi deixem tambe un true, i es deu tractar d'un Uncolored Pattern que es pinta amb Shadings
       {
        dup
        <</DeviceCMYK null /PureCMYK null>> exch known  %% en tenim prou sabent si l'espai es CMYK
        {
         pop
         <</Cyan null /Magenta null /Yellow null /Black null>>
         quinaTinta known  %% la tinta que volem separar existeix al Pattern?
        }
        {  %% seria un extrany error ...
         <</Cyan null /Magenta null /Yellow null /Black null>>
         exch known
         {true}
         {
          %%mug@
          %%(\n\n---1959 8\n\n) print flush %stop
          false  %%% PROVISIONAL
         }ifelse
        }ifelse
       } ifelse
      } ifelse
     }ifelse

     {  %% ifelse de si la tinta que volem separar existeix al Pattern ...
      dup 0 get 1 eq
      {  %% si es un Tiling Pattern ...
       1 get 1 eq
       {  %% si es un Colored Pattern ens obliga a reinterpretar el seu stream de dades x deduir-ne l'espai de color i les Tintes
        %% #0#% tret que estigui a la llista dels Patterns que duen un Shading al seu stream
        %% llavors no cal que anem a reinterpretar res doncs l'espai de color que cerquem el dura el Shading ...
        dup ColPatSha exch
        known
        {
         pop
        }
        {
         dup /nomDtp exch def  %% ens desem el nom del Tiling Pattern
         %% anem a Resources a cercar el dic Pattern
         RSRCS araPlana get /Pattern get exch get
         /aCercar exch def
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         } loop  %% d'interrogacio dels dicts de COMdimoni
         dup /Filter known
         { %% fitxer stream amb algun tipus de filtre
          dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
          dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
          dup /DecodeParms known exch /DP known 2 copy or
          {
           {pop/DP get}{pop/DecodeParms get}ifelse dup type
           /dicttype eq
           {
            [ exch [ exch filtresstream ] ] /filtresstream exch def
           }
           {  %% es una array
            %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
            dup length filtresstream length ne
            {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
             (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
            }if
            /iDPF 0 def
            [ exch
             {  %% forall
              dup null eq
              {
               pop [filtresstream iDPF get]
               iDPF 1 add/iDPF exch def
              }
              {
               [exch filtresstream iDPF get]
	       iDPF 1 add/iDPF exch def
              }ifelse
             }forall
            ]
            /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
           }ifelse
          }
          {
           pop pop  %% ens carreguem els logics
           pop  %% ens carreguem el dic
           %% avaluem filtresstream per redefinir-lo com cal per /filtRa
           filtresstream type /arraytype eq
           {
            [filtresstream] /filtresstream exch def
           }
           {
            [[filtresstream]] /filtresstream exch def
           }ifelse
          }ifelse
          dadesstream
          %% comprovem si l'stream es un path dins una array o una string de dades directe
          type /arraytype eq
          {
           dadesstream 0 get (r) file  %% convertim a fitxer des del path sense dexifrar
          }
          {  %% convertim a fitxer de la cadena sense dexifrar
           dadesstream 0 () /SubFileDecode filter
          } ifelse
          filtresstream
          (F8) ==
          filtRa  %% dexifrem el fitxer stream
          %% preparem el fitxer de lectura que a l'estar filtrat el repiquem al disc
          repiCa (w) file /REPIcA exch def
          {  %% loop
           dup
           65535 string readstring
           {
            REPIcA exch writestring
           }
           {
            REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit
           }ifelse
          }loop
          repiCa dup
          status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
          (r) file /aLLeGiR exch def
         }
         {  %% fitxer stream sense filtres
          /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
          dadesstream  %% tibem el fitxer stream sense dexifrar
          %% comprovem si l'stream es un path dins una array o una string de dades directe
          type /arraytype eq
          {
           dadesstream 0 get
           dup
           status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
           (r) file /aLLeGiR exch def
          }
          {  %% convertim a fitxer de la cadena sense dexifrar
           dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
           0 () /SubFileDecode filter /aLLeGiR exch def
          }ifelse
         }ifelse
         %% repicat idem en ascii de l'stream del Colored Pattern
         BeSSo2
         %% traslladem i renombrem l'stream x posar-lo al dic FotoCromPS
         l'objectenet3 /aRePiCaR exch def
         %% genererem el nom del fitxer on hi ha l'stream ...
         nousStreamsPS dup posNum iNousStreams 10 string cvs putinterval
         %% el repiquem
         (w) file /trAsllAt exch def 
         aRePiCaR (r) file
         {  %% loop
          dup 65535 string readstring
          {
           trAsllAt exch writestring
          }
          {
           trAsllAt exch writestring
           closefile exit
          }ifelse
         }loop
         trAsllAt closefile
         %% desem a FotoCromPS i a la Tinta que toca el nom del Pattern ...
         FotoCromPS quinaTinta known
         {  %% si ja hi es ...
          FotoCromPS quinaTinta get
          nomDtp nousStreamsPS dup length string copy  %% en fem una copia no contaminada
          put  %% afegim el Pattern/path al dic que li correspon
         }
         {  %% si NO hi es ...
          FotoCromPS quinaTinta
          <<
            nomDtp nousStreamsPS dup length string copy  %% en fem una copia no contaminada
          >>
          put  %% donem d'alta el Pattern/string del path de l'stream separat com a valor
         }ifelse
        }ifelse  %% es a la llista dels Patterns que duen Shading?
       }
       {  %% si es un Uncolored Pattern no fem res
        pop
       }ifelse
      }
      {  %% SON Shading Patterns ...
       pop
       /nomDsp exch def  %% capturem el nom del Shading Pattern
       JectesPS nomDsp known
       {
        JectesPS nomDsp get
        dup type /nametype eq
        {
         /aCercar exch def  %% nom amb la ref ind del dic Resources
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         }loop  %% d'interrogacio dels dicts de COMdimoni
        }if
        /Shading get
       }
       {  %% si no es al dic JectesPS haura d'estar aqui ...
        elsAltresShadings nomDsp get
       }ifelse
       dup type /nametype eq
       {
        /aCercar exch def  %% nom amb la ref ind del dic Resources
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        }loop  %% d'interrogacio dels dicts de COMdimoni
       }if
       /Function get  %% anem a pescar el dic de la funcio (directe o indirecte)
       dup type /nametype eq
       {
        /aCercar exch def  %% nom amb la ref ind
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        }loop  %% d'interrogacio dels dicts de COMdimoni
       }if
       dup /FunctionType get
       [
        {	%% Tipus 0 ... NO implementada encara
        }
        {	%% Tipus 1 ... inexistents
        }
        {	%% Tipus 2
         dup /C0 known  %% quan nomes treballa amb 1 sol valor pot prescindir de C0/C1
         {
          2 array /ft2C0C1 exch def  %% desarem aqui els paquets C0 C1
          dup /C0 get dup length array copy  %% fem una copia descontaminada x rellegir C0 sense alteracions
          ft2C0C1 exch 0 exch put
          /C1 get dup length array copy  %% fem una copia descontaminada x rellegir C1 sense alteracions
          ft2C0C1 exch 1 exch put
         }
         {
          pop  %% ens carreguem el dic de la Function
          /ft2C0C1 [ null null ] def  %% desem l'array amb 2 null x detectar la inexistencia de C0/C1 a %43bis%
         }ifelse
         %% desem a FotoCromPS i a la Tinta que toca el nom del Pattern ...
         FotoCromPS quinaTinta known
         {  %% si ja hi es ...
          FotoCromPS quinaTinta get
          nomDsp ft2C0C1 put  %% afegim el Pattern/array
         }
         {  %% si NO hi es ...
          FotoCromPS quinaTinta
          <<
            nomDsp ft2C0C1
          >>
          put  %% donem d'alta el Pattern/array
         }ifelse
        }
        {	%% Tipus 3
         %% provem de carregar-nos aqui el /Range
         dup /Range undef  %% possiblement aqui no s'elimini i es torni a regenerar (si es una ref ind)
         DarrersRange aCercar null put  %% posem la ref ind del dic a eliminar Range de nou
         %% per aqui passen totes les Tipus 3 ?
         /dicSFT3 2 dict def  %% dic on desarem les dades de cadascuna de les funcions de tipus 2 contingudes a la 3
         dup /Functions get
         {  %% forall x anar a pescar els objectes de cadascuna de les funcions que formen el sargit ...
          dup type /nametype eq
          {
           /aCercar exch def  %% nom amb la ref ind del dic Resources
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
          }if
          %% ... i comprovar que aquestes siguin de tipus 2
          dup /FunctionType get 2 eq
          {
           %%(COAC ... 0) ==
           dup /C0 known  %% quan nomes treballa amb 1 sol valor pot prescindir de C0/C1
           {
            2 array /ft2C0C1 exch def  %% desarem aqui els paquets C0 C1
            dup /C0 get
            dup length array /nVa exch def  %% fem una copia descontaminada x rellegir C0 sense alteracions
            0 /inVa exch def
            {  %% forall, invertim el color ?
             %%1 exch sub
             nVa exch inVa exch put
             inVa 1 add /inVa exch def
            }forall
            nVa  %% array amb el color invertit
            ft2C0C1 exch 0 exch put
            /C1 get
            dup length array /nVa exch def  %% fem una copia descontaminada x rellegir C0 sense alteracions
            0 /inVa exch def
            {  %% forall, invertim el color ?
             %%1 exch sub
             nVa exch inVa exch put
             inVa 1 add /inVa exch def
            }forall
            nVa  %% array amb el color invertit
            ft2C0C1 exch 1 exch put
           }
           {
            pop  %% ens carreguem el dic de la Function
            /ft2C0C1 [ null null ] def  %% desem l'array amb 2 null x detectar la inexistencia de C0/C1 a %43bis%
           }ifelse
           dicSFT3 aCercar ft2C0C1 put  %% desem al dic de funcions de tipus 2 el parell ref ind/array C0/C1
          }
          {  %% si la tipus 3 no conte una tipus 2 donarem error ...
           (\n\nMRCT1959 11\n\n) print flush stop  %%quit
          }ifelse
         }forall
         %% desem a FotoCromPS i a la Tinta que toca el nom del Pattern ...
         FotoCromPS quinaTinta known
         {  %% si ja hi es ...
          FotoCromPS quinaTinta get
          nomDsp dicSFT3 put  %% afegim el Pattern/array
         }
         {  %% si NO hi es ...
          FotoCromPS quinaTinta
          <<
            nomDsp dicSFT3
          >>
          put  %% donem d'alta el Pattern/array
         } ifelse
         %%FotoCromPS quinaTinta get nomDsp get {== ==} forall
         %%(\n\nMRCT1959 2004\n\n) print flush stop  % error Temporal
        }
        {	%% Tipus 4 ... NO implementada encara
        }
       ]      
       exch get cvx exec
       %%pstack (nmgdfs) == quit
      }ifelse
      iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
     }
     {
      pop pop
     }ifelse  %% ifelse de si la tinta que volem separar existeix al Pattern ...
    }forall  %% forall on filtrem els Tiling Patterns (/PatternType 1) Colored (/PaintType 1) i ...
   }forall  %% forall de la generacio de separacions dels streams de Patterns&Shadings x Tinta
  }if  %% separem Patterns&Shadings?
  %% clonem els dics del dic FotoCromPS !
  %% /CLONfcps 2 dict def
  %%FotoCromPS dup length dict copy {
  %%                                 dup length dict copy /clonL1 exch def
  %%                                 clonL1
  %%                                 {
  %%                                  dup length dict copy
  %%                                  clonL1 3 1 roll put
  %%                                 }forall
  %%                                 clonL1 CLONfcps 3 1 roll put
  %%                                }forall
  %%FotoCromPS {{{== ==}forall ==}forall pop}forall
  %%XRay /EspaisDeColor get /Utilitzats get /NoName9 get {== ==}forall
  %%XRay /Patterns&Shadings get /Utilitzats get {== ==}forall
  %%XRay /EspaisDeColor get /TintesiValors get
  %%XRay /ObjectesX get /Utilitzats get
  %% /inLine0 get {== ==}forall
  %%(sssssssss) pstack quit
  %%%test
  %%clear
  /sepPS false def  %% gatell x indicar als operador cs/CS que son executats per reinterpretar l'stream d'un Pattern&Shading

  %#%42% fem la separació de colors de totes les imatges
  (%#%42%)==
  %% treiem per la pantalleta que separem imatges XObject?
  XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
  /Utilitzats get length 0 ne {BaBeL 34 get print flush}if
  %%% avui dilluns
  %%% per procedir a la separacio de color de les imatges fem ...
  %%is1% localitzem el dict del XObject/inLine i dexifrem el raw
  %%is2% splitarem el raw en tants fitxers etiquetats com canals (nomes 1 i 4?)
  %% veure rawCMYK2Sep8b_2.PS i caldra estar al cas del Decode (si el duu) del dict per invertir o no ...
  %%is3% al dic de la imatge modifiquem x cada Tinta a separar ...
  %% /Filter (/F), /Decode [0 1], /Length i /ColorSpace (/CS) i per mitja del dic FotoCrom relacionem cada tinta amb
  %% les imatges que en tenen un canal i el path que li correspon al raw separat x
  %% incrustar-lo a l'array de la variable /XIU
  %%4% quan implementem els Forms haurem de filtrar tambe l'entrada /Subtype

  %% diccionari on desarem com a clau el nom de cada tinta a separar i com a valor hi haura
  %% un dic amb el nom de la imatge (XObject/inLine) i el path del raw de la separacio
  /FotoCrom 2 dict def

  %% filtrem que no hi hagi imatges que tot i tenint nom diferent comparteixin el mateix
  %% objecte (/Subtype /Image), llavors x evitar errors les eliminarem tant d'un clonic de
  %% JectesX com d'XRay/ObjectesX/Utilitzats (d'entrada es igual quines esborrem) ...
  %% vegeu el cas de 22-AJ64_nexus.pdf

  /XObjectsAesborrar 2 dict def  %% aqui desarem NomImatge/NumObjImatge que cal esborrar d'XRay/ObjectesX/Utilitzats
  JectesX dup null eq
  {  %% ens assegurem que no sigui un null
   /JectesXclon exch def
  }
  {
   dup length dict copy  %% clonem JectesX xq no quedin afectats els Resources al generar els PDF
   dup /JectesXclon exch def
   {  %% forall de plana x plana
    exch /araPlana exch def
    {  %% forall, esborra aleatoriament de JectesX els elements que tenen el valor repetit i els desa a XObjectsAesborrar
     /Xval exch def
     /Xclau exch def
     JectesXclon araPlana get
     {  %% forall
      Xval eq
      {
       dup Xclau eq
       {
        pop
       }
       {
        dup XObjectsAesborrar araPlana get exch Xval put JectesXclon araPlana get exch undef
       }ifelse
      }
      {
       pop
      }ifelse
     }forall
    }forall
   }forall  %% de plana x plana
   %% esborrem d'XRay/ObjectesX/Utilitzats els elements que ja hem donat de baixa de JectesXclon
   XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
   /Utilitzats get /eXOXU exch def
   XObjectsAesborrar araPlana get
   {
    pop eXOXU exch undef
   }forall
  }ifelse

  %% com a excepcio esborrem de JectesXclon tots els Form existents
  %% aixo lliga amb 270206 doncs cal saber xq no s'escriuen B ara els streams del Form
  FormsQhiHa
  {
   JectesXclon {exch pop exch undef}forall  %% tenim en compte el paginat
  }forall
  %%test
  %%{  % stopped
  XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
  /Utilitzats get
  {  %% forall de tots els XObjects utilitzats
   dup
   type /arraytype eq
   {  %% si el valor es una array es tracta d'un XObject
    %% Form o image XObject ?
    dup 0 get type /arraytype eq
    {  %% Form
     %%   (suARA)pstack quit
     pop pop
    }
    {  %% image
     2 get /bAUlA exch def  %% la baula perduda que ens duu a l'array veritable dels canals de color utilitzats
     JectesX araPlana get exch dup /iaSep exch def  %% nom intern de la imatge a separar
     get  %% anem a pescar el diccionari de la imatge per mitja del dic XObject de Resources
     dup type /nametype eq
     {  %% si es una ref ind l'anem a cercar ...
      /aCercar exch def  %% nom amb la ref ind del dic Resources
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     %%is1% tenim a la pila el diccionari de la imatge i ara ens assegurem que tindrem el raw dexifrat a BRoSSa
     dup /XIU known  %% te stream?
     {
      dup /XIU get /strEAm exch def  %% capturem l'array o string del fitxer stream
      dup /XIU undef  %% la donem de baixa abans d'escriure
      %%%***%%% afegit per generar streams sense comprimir
      strEAm /dadesstream exch def  %% definim l'adreca de l'stream per despres
      dup /Filter known  %% duu filtres ??
      {
       dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
       dup /Filter undef
       dup /DecodeParms known exch /DP known 2 copy or
       {
        {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
        {
         [ exch [ exch filtresstream ] ] /filtresstream exch def
        }
        {  %% es una array
         %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
         dup length filtresstream length ne
         {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
          (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
         }if
         /iDPF 0 def
         [ exch
          {  %% forall
           dup null eq
           {
            pop [filtresstream iDPF get]
            iDPF 1 add/iDPF exch def
           }
           {
            [exch filtresstream iDPF get]
            iDPF 1 add/iDPF exch def
           }ifelse
          }forall
         ]
         /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
        }ifelse
       }
       {
        pop pop  %% ens carreguem els logics
        pop  %% ens carreguem el dic
        %% avaluem filtresstream per redefinir-lo com cal per /filtRa
        filtresstream type /arraytype eq
        {
         [filtresstream] /filtresstream exch def
        }
        {
         [[filtresstream]] /filtresstream exch def
        }ifelse
       }ifelse 
       dadesstream
       %% comprovem si l'stream es un path dins una array o una string de dades directe
       type /arraytype eq
       {
        dadesstream 0 get (r) file  %% convertim a fitxer des del path
        filtresstream
        (F9) ==
        filtRa  %% dexifrem el fitxer stream
        %%% a l'estar filtrat el repiquem al disc
        BRoSSa (w) file /REPIcA exch def
        {  %% loop
         dup
         65535 string readstring
         {
          REPIcA exch writestring
         }
         {
          REPIcA exch writestring REPIcA closefile closefile exit
         }ifelse
        }loop
        %%BRoSSa status {pop pop /Lfa exch def pop} if  % bytes totals del fitxer pel Length del dic
        %%BRoSSa 1 array astore /strEAm exch def  % redefinim l'array
       }
       {  %% traspassem les cadenes com a fitxers doncs poden inflar-se moltissim
        dadesstream 0 () /SubFileDecode filter  %% convertim a fitxer des del path
        %% repiquem la cadena a fixter i dexifrem a partir d'aqui x evitar ioerrors
        %%BRoSSa2 (w) file dup 3 -1 roll writestring closefile flush
        %%BRoSSa2 (r) file  % convertim a fitxer des del path
        filtresstream
        (F10) ==
        filtRa  %% dexifrem el fitxer stream
        %%% a l'estar filtrat el repiquem al disc
        BRoSSa (w) file /REPIcA exch def
        {  %% loop
         dup
         65535 string readstring
         {
          REPIcA exch writestring
         }
         {
          REPIcA exch writestring REPIcA closefile closefile exit
         }ifelse
        }loop
        %%BRoSSa status {pop pop /Lfa exch def pop} if  % bytes totals del fitxer pel Length del dic
        %%BRoSSa 1 array astore /strEAm exch def  % capturem com una array, doncs sempre sera un fitxer
       }ifelse
       %%dup /Length Lfa put  % incrustem a sac (ignorant el possible objecte indirecte) la llargada de l'stream
      }
      {  %% si no duu filtres ...
       dadesstream type /stringtype eq
       {  %% i es una cadena de dades
        %% la traspassem com a fitxer
        dadesstream 0 () /SubFileDecode filter  %% convertim a fitxer des del path
        %% el repiquem al disc
        BRoSSa (w) file /REPIcA exch def
        {  %% loop
         dup
         65535 string readstring
         {
          REPIcA exch writestring
         }
         {
          REPIcA exch writestring REPIcA closefile closefile exit
         }ifelse
        }loop
       }
       {  %% i encara que sigui a fitxer el traspassem a BRoSSa per unificar criteris
        dadesstream 0 get (r) file  %% convertim a fitxer des del path
        %% el repiquem novament a disc
        BRoSSa (w) file /REPIcA exch def
        {  %% loop
         dup
         65535 string readstring
         {
          REPIcA exch writestring
         }
         {
          REPIcA exch writestring REPIcA closefile closefile exit
         }ifelse
        }loop
       }ifelse
      }ifelse
      %%is2% anem a separar el raw x canals d'escala de gris
      %% cal saber quants canals separem i com es diuen
      %% posem un detector pel Decode x no tenir sorpreses amb les imatges en negatiu al separar-les
      dup /Decode known
      {
       dup /Decode get 0 get 0 eq
       {
        dup /ColorSpace get
        dup type /nametype eq 1 index length 16 eq
        {
         1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
        }
        {
         false
        }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
        and
        {  %% els dos han de ser certs (o sigui una ref ind segur), doncs llavors n'anirem a treure el literal que amaga
         /aCercar exch def
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         }loop  %% d'interrogacio dels dicts de COMdimoni
        }if
        /DeviceGray eq
        {  %% si es escala de grisos definim el Decode x no invertir els pixels ...
         /DeCoDe01 false def
        }
        {
         /DeCoDe01 true def
        }ifelse
       }
       {
        /DeCoDe01 false def
       }ifelse
      }
      {
       dup /ColorSpace get
       dup type /nametype eq 1 index length 16 eq
       {
        1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
       }
       {
        false
       }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
       and
       {  %% els dos han de ser certs (o sigui una ref ind segur), doncs llavors n'anirem a treure el literal que amaga
        /aCercar exch def
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        }loop  %% d'interrogacio dels dicts de COMdimoni
       }if
       /DeviceGray eq
       {  %% si es escala de grisos definim el Decode x no invertir els pixels ...
        /DeCoDe01 false def
       }
       {
        /DeCoDe01 true def
       }ifelse
      }ifelse
      %% tambe filtrem els BitsPerComponent, doncs de moment no tractarem les imatges a 1 bit o imagemasks
      dup /BitsPerComponent known
      {
       /BitsPerComponent get 8 ne
       {(\n\nMRCT1959 5\n\n) print flush stop}if  %% per filtrar imatges a 1bit o imagemask
      }
      {  %% o es una imagemask o es una JPEG2000
       pop (\n\nMRCT1959 5\n\n) print flush stop  %%quit
      }ifelse
      XRay /EspaisDeColor get /Utilitzats get
      %%{{== ==} forall == (*#*) ==} forall quit
      %% un altre metode + fiable d'extraure els canals
      bAUlA
      dup type /nametype eq 1 index length 16 eq
      {
       1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
      }
      {
       false
      }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
      and
      {  %% els dos han de ser certs (o sigui una ref ind segur), doncs llavors n'anirem a treure el literal que amaga
       /aCercar exch def
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
      }if
      dup /DeviceCMYK eq
      {
       pop /NoName9 get
       %%% aquí es on plora la criatura ...
       %% segur ha de ser un dic
       /NomExtern get  %%dup ==
      }
      {
       dup type /arraytype eq
       {  %% es l'array directe de color amb els canals!
        exch pop
        %%( ... imatge sense nom extern) ==
       }
       {  %% mentre no sigui l'array directe de color amb els canals ...
        get
        /NomExtern get    %%dup ==
       }ifelse
      }ifelse
      %%{  % esbrinem quin espai de color fa servir iaSep
      %% dup /Paleta get iaSep known {
      %%                              /NomExtern get  % aqui tibem l'array amb els canals o el literal /PureCMYK o el nom de la Separation
      %%                              exch pop exit
      %%                             }{pop pop}ifelse
      %%}forall
      %% aqui o: hi ha l'array amb els canals o el literal /PureCMYK o el literal amb el nom de la Separation
      dup type /arraytype eq
      {  %% posem un detector que (de moment) nomes admeti 1 o 4 canals
       dup length dup 1 eq exch 4 eq or
       {
        dup length 1 eq
        {  %% si hi ha un sol canal no cal fer la separacio pero necessitem reescriure els bytes segons el Decode
         %%(1solCanalenArray) ==
         %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
         0 /iXiC exch def  [/NaL1] /vaCanals exch def
         {  %% forall
          dup  %% x FotoCrom
          dup length iaSep length add 1 add string dup /XiC exch def
          /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
          3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
          /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
          pAthXiU vaCanals iXiC get exch def
          FotoCrom 1 index known
          {  %% si ja hi ha aquesta tinta ...
           FotoCrom exch get
           %%dup
           iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
          }
          {  %% si la tinta no hi es ...
           FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
          }ifelse
          iXiC 1 add /iXiC exch def  %% actualitzem l'index
         }forall
         /_NaL1 NaL1 (w) file def
         BRoSSa (r) file  %% el raw a separar
         DeCoDe01  %% segons el Decode restem de 255 o no ...
         {
          {  %% loop de captura de canals
           dup read
           {
            _NaL1 exch 255 exch sub write
           }
           {
            pop exit
           }ifelse
          }loop
          _NaL1 closefile
         }
         {  %% seria x Decode 1 0
          {  %% loop de captura de canals
           dup read
           {
            _NaL1 exch write
           }
           {
            pop exit
           }ifelse
          }loop
          _NaL1 closefile
         }ifelse
         %%BRoSSa NaL1 renamefile  % ens limitem a renombrar el fitxer brossa.obj
         %%pstack (mmm) == quit
        }
        {  %% quatre canals ...
         %%(4canals) ==
         %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
         0 /iXiC exch def  [/NaL1 /NaL2 /NaL3 /NaL4] /vaCanals exch def
         {
          dup %% x FotoCrom
          dup length iaSep length add 1 add string dup /XiC exch def
          /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
          3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
          /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
          pAthXiU vaCanals iXiC get exch def
          FotoCrom 1 index known
          {  %% si ja hi ha aquesta tinta ...
           FotoCrom exch get
           %%dup
           iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
          }
          {  %% si la tinta no hi es ...
           FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
          }ifelse
          iXiC 1 add /iXiC exch def  %% actualitzem l'index
         }forall
         /_NaL1 NaL1 (w) file def
         /_NaL2 NaL2 (w) file def
         /_NaL3 NaL3 (w) file def
         /_NaL4 NaL4 (w) file def
         BRoSSa (r) file  %% el raw a separar
         DeCoDe01  %% segons el Decode restem de 255 o no ...
         {
          {  %% loop de captura de canals
           dup read
           {
            _NaL1 exch 255 exch sub write
            dup read
            {
             _NaL2 exch 255 exch sub write
             dup read
             {
              _NaL3 exch 255 exch sub write
              dup read
              {
               _NaL4 exch 255 exch sub write
              }
              {
               pop exit
              }ifelse
             }
             {
              pop exit
             }ifelse
            }
            {
             pop exit
            }ifelse
           }
           {
            pop exit
           }ifelse
          }loop
          _NaL1 closefile _NaL2 closefile _NaL3 closefile _NaL4 closefile  %% tanquem
         }
         {  %% seria x Decode 1 0
          {  %% loop de captura de canals
           dup read
           {
            _NaL1 exch write
            dup read
            {
             _NaL2 exch write
             dup read
             {
              _NaL3 exch write
              dup read
              {
               _NaL4 exch write
              }
              {
               pop exit
              }ifelse
             }
             {
              pop exit
             }ifelse
            }
            {
             pop exit
            }ifelse
           }
           {
            pop exit
           }ifelse
          }loop
          _NaL1 closefile _NaL2 closefile _NaL3 closefile _NaL4 closefile  %% tanquem
         }ifelse
         %%pstack () == stop
        }ifelse
       }
       {  %% si no te 1 o 4 canals activem l'algorisme dinamic llescacanals x separar qualsevol nombre
        %%(N canals) ==
        dup length  %%== (WeirdCanals) == (\n\nMRCT1959 4\n\n) print flush stop
        /QuantesLlesques exch def  %% el nombre de canals de la imatge (qualsevol)
        %% farcim l'array ...
        /iNals 1 def  %% comptador de canals
        mark
        QuantesLlesques
        {
         iNals 4 string cvs dup length 3 add  %% el que fa NaL
         string dup /elNaL exch def
         /NullEncode filter dup dup (NaL) writestring 3 -1 roll writestring closefile
         elNaL cvn iNals 1 add /iNals exch def
        }repeat
        counttomark array astore /vaCanals exch def pop  %% desem el paquet i ens carreguem la mark
        %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
        0 /iXiC exch def
        {
         dup  %% x FotoCrom
         dup length iaSep length add 1 add string dup /XiC exch def
         /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
         3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
         /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
         pAthXiU vaCanals iXiC get exch def
         FotoCrom 1 index known
         {  %% si ja hi ha aquesta tinta ...
          FotoCrom exch get
          %%dup
          iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
         }
         {  %% si la tinta no hi es ...
          FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
         }ifelse
         iXiC 1 add /iXiC exch def  %% actualitzem l'index
        }forall
        %% generem els fitxers d'excriptura tants com canals
        mark
        vaCanals
        {
         dup dup length 1 add string
         dup /elNaL exch def
         /NullEncode filter dup dup (_) writestring 3 -1 roll 12 string cvs writestring closefile
         elNaL cvn dup 3 -1 roll
         cvx exec (w) file def
        }forall
        counttomark array astore /canelobre exch def pop  %% desem el paquet i ens carreguem la mark
        BRoSSa (r) file  %% el raw a separar
        DeCoDe01  %% segons el Decode restem de 255 o no ...
        {
         /pleguem false def  %% gatell de sortida del loop
         {  %% loop dinamic de captura de canals
          canelobre
          {
           cvx exec 1 index read {255 exch sub write}{pop /pleguem true def exit} ifelse
          } forall
          pleguem {pop exit}if
         }loop
         canelobre {cvx exec closefile} forall  %% tanquem
        }
        {  %% seria x Decode 1 0
         /pleguem false def  %% gatell de sortida del loop
         {  %% loop dinamic de captura de canals
          canelobre
          {
           cvx exec 1 index read {write}{pop /pleguem true def exit} ifelse
          }forall
          pleguem {pop exit}if
         }loop
         canelobre {cvx exec closefile} forall  %% tanquem
        }ifelse
       }ifelse  %% 1 o 4 canals o qualsevol nombre ?
      }
      {  %% o es una Separation d'1 sol canal o es un /PureCMYK ...
       dup /PureCMYK eq
       {  %% quatre canals classics
        %%(4cromia) ==
        pop [/Cyan /Magenta /Yellow /Black]  %% ens carreguem el literal i deixem l'array amb els noms classics de la quadricromia
        %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
        0 /iXiC exch def  [/NaL1 /NaL2 /NaL3 /NaL4] /vaCanals exch def
        {  %% forall
         dup  %% x FotoCrom
         dup length iaSep length add 1 add string dup /XiC exch def
         /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
         3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
         /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
         pAthXiU vaCanals iXiC get exch def
         FotoCrom 1 index known
         {  %% si ja hi ha aquesta tinta ...
          FotoCrom exch get
          %%dup
          iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
         }
         {  %% si la tinta no hi es ...
          FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
         }ifelse
         iXiC 1 add /iXiC exch def  %% actualitzem l'index
        }forall
        /_NaL1 NaL1 (w) file def
        /_NaL2 NaL2 (w) file def
        /_NaL3 NaL3 (w) file def
        /_NaL4 NaL4 (w) file def
        BRoSSa (r) file  %% el raw a separar
        DeCoDe01  %% segons el Decode restem de 255 o no ...
        {
         {  %% loop de captura de canals
          dup read
          {
           _NaL1 exch 255 exch sub write
           dup read
           {
            _NaL2 exch 255 exch sub write
            dup read
            {
             _NaL3 exch 255 exch sub write
             dup read
             {
              _NaL4 exch 255 exch sub write
             }
             {
              pop exit
             }ifelse
            }
            {
             pop exit
            }ifelse
           }
           {
            pop exit
           }ifelse
          }
          {
           pop exit
          }ifelse
         }loop
         _NaL1 closefile _NaL2 closefile _NaL3 closefile _NaL4 closefile  %% tanquem
        }
        {  %% seria x Decode 1 0
         {  %% loop de captura de canals
          dup read
          {
           _NaL1 exch write
           dup read
           {
            _NaL2 exch write
            dup read
            {
             _NaL3 exch write
             dup read
             {
              _NaL4 exch write
             }
             {
              pop exit
             }ifelse
            }
            {
             pop exit
            }ifelse
           }
           {
            pop exit
           }ifelse
          }
          {
           pop exit
          }ifelse
         }loop
         _NaL1 closefile _NaL2 closefile _NaL3 closefile _NaL4 closefile  %% tanquem
        }ifelse
       }
       {  %% si hi ha un sol canal no cal fer la separacio pero necessitem reescriure els bytes segons el Decode
        %%(1solCanal) ==
        1 array dup 3 -1 roll 0 exch put  %% l'incrustem dins una array x no modificar els algorismes que segueixen ...
        %%pstack (aaa) == quit
        %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
        0 /iXiC exch def  [/NaL1] /vaCanals exch def
        {
         dup  %% x FotoCrom
         dup length iaSep length add 1 add string dup /XiC exch def
         /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
         3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
         /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
         pAthXiU vaCanals iXiC get exch def
         FotoCrom 1 index known
         {  %% si ja hi ha aquesta tinta ...
          FotoCrom exch get
          %%dup
          iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
         }
         {  %% si la tinta no hi es ...
          FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
         }ifelse
         iXiC 1 add /iXiC exch def  %% actualitzem l'index
        }forall
        /_NaL1 NaL1 (w) file def
        BRoSSa (r) file  %% el raw a separar
        DeCoDe01  %% segons el Decode restem de 255 o no ...
        {
         {  %% loop de captura de canals
          dup read
          {
           _NaL1 exch 255 exch sub write
          }
          {
           pop exit
          }ifelse
         }loop
         _NaL1 closefile
        }
        {  %% seria x Decode 1 0 (o com si ho fos en cas de les imatges DeviceGray doncs llavors no cal tocar res al raw)
         {  %% loop de captura de canals
          dup read
          {
           _NaL1 exch write
          }
          {
           pop exit
          }ifelse
         }loop
         _NaL1 closefile
        }ifelse
       }ifelse
      }ifelse
     }
     {  %% si no tingues stream donariem un nou error MRCT
      BaBeL 35 get print flush stop  %%quit
%%UBpliegOMaker
     }ifelse
     %%%***%%% fi d'afegit x generar streams sense comprimir
    }ifelse  %% Form o image XObject ?
   }
   {  %% i si es un dict, es una inLine amb el seu dic!
    %%%nouXinLine
    dup /CS get  %% interroguem l'espai de color
    /bAUlA exch def  %% la baula perduda que ens duu al literal o l'array veritable dels canals de color utilitzats
    exch /iaSep exch def  %% nom intern de la imatge inLine a separar
    %%is1% tenim a la pila el diccionari de la imatge i ara ens assegurem que tindrem el raw dexifrat a BRoSSa
    %% donem x fet q sempre tindrem l'entrada /XIU amb l'stream de dades de l'inLine a disc
    dup /XIU get /strEAm exch def  %% capturem l'array o string del fitxer stream
    dup /XIU undef  %% la donem de baixa abans d'escriure
    %%%***%%% afegit per generar streams sense comprimir
    strEAm /dadesstream exch def  %% definim l'adreca de l'stream per despres
    %%%refetXinLine
    dup /F known  %% duu filtres ??
    {
     dup dup /F get /filtresstream exch def  %% definim l'array dels filtres per despres
     dup /F undef
     /DP known
     {
      dup /DP get exch /DP undef
      dup type /dicttype eq
      {
       [ exch [ exch filtresstream ] ] /filtresstream exch def
      }
      {  %% es una array
       %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
       dup length filtresstream length ne
       {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
        (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
       }if
       /iDPF 0 def
       [ exch
        {  %% forall
         dup null eq
         {
          pop [filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }
         {
	  [exch filtresstream iDPF get]
	  iDPF 1 add/iDPF exch def
         }ifelse
        }forall
       ]
       /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
      }ifelse
     }
     {
      pop pop  %% ens carreguem els logics
      pop  %% ens carreguem el dic
      %% avaluem filtresstream per redefinir-lo com cal per /filtRa
      filtresstream type /arraytype eq
      {
       [filtresstream] /filtresstream exch def
      }
      {
       [[filtresstream]] /filtresstream exch def
      }ifelse
     }ifelse
     (____cal revisar el comportament de les inLine____) pstack stop  %%quit
     dadesstream (r) file  %% convertim a fitxer des del path
     filtresstream type /arraytype eq
     {  %% recomposem el seu nom original dins l'array
      [
       filtresstream
       {  %% forall
        <<
          /AHx /ASCIIHexDecode
          /A85 /ASCII85Decode
          /LZW /LZWDecode
          /Fl /FlateDecode
          /RL /RunLengthDecode
          /CCF /CCITTFaxDecode
          /DCT /DCTDecode
        >>
        exch get
       }forall
      ]
     }
     {  %% recomposem el seu nom original
      <<
        /AHx /ASCIIHexDecode
        /A85 /ASCII85Decode
        /LZW /LZWDecode
        /Fl /FlateDecode
        /RL /RunLengthDecode
        /CCF /CCITTFaxDecode
        /DCT /DCTDecode
      >>
      filtresstream get
     }ifelse
     (F11) ==
     filtRa  %% dexifrem el fitxer stream
     %%% a l'estar filtrat el repiquem al disc
     BRoSSa (w) file /REPIcA exch def
     {  %% loop
      dup
      65535 string readstring
      {
       REPIcA exch writestring
      }
      {
       REPIcA exch writestring REPIcA closefile closefile exit
      }ifelse
     }loop
     %%BRoSSa status {pop pop /Lfa exch def pop} if  % bytes totals del fitxer pel Length del dic
     %%BRoSSa 1 array astore /strEAm exch def  % redefinim l'array
    }
    {  %% si no duu filtres ...
     dadesstream (r) file  %% convertim a fitxer des del path
     %% el repiquem novament a disc
     BRoSSa (w) file /REPIcA exch def
     {  %% loop
      dup
      65535 string readstring
      {
       REPIcA exch writestring
      }
      {
       REPIcA exch writestring REPIcA closefile closefile exit
      }ifelse
     }loop
    }ifelse
    %%is2% anem a separar el raw x canals d'escala de gris
    %% cal saber quants canals separem i com es diuen
    %% posem un detector pel Decode x no tenir sorpreses amb les imatges en negatiu al separar-les
    %%%refetXinLine
    dup /D known
    {
     dup /D get 0 get 0 eq
     {
      %%%refetXinLine
      dup /CS get
      dup type /nametype eq 1 index length 16 eq
      {
       1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
      }
      {
       false
      }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
      and
      {  %% els dos han de ser certs (o sigui una ref ind segur), doncs llavors n'anirem a treure el literal que amaga
       /aCercar exch def
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
      }if
      %%%refetXinLine
      /G eq
      {  %% si es escala de grisos definim el Decode x no invertir els pixels ...
       /DeCoDe01 false def
      }
      {
       /DeCoDe01 true def
      }ifelse
     }
     {
      /DeCoDe01 false def
     }ifelse
    }
    {  %% no duu Decode ...
     %%%refetXinLine
     dup /CS get
     dup type /nametype eq 1 index length 16 eq
     {
      1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
     }
     {
      false
     }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
     and
     {  %% els dos han de ser certs (o sigui una ref ind segur), doncs llavors n'anirem a treure el literal que amaga
      /aCercar exch def
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     %%%refetXinLine
     /G eq
     {  %% si es escala de grisos definim el Decode x no invertir els pixels ...
      /DeCoDe01 false def
     }
     {
      /DeCoDe01 true def
     }ifelse
    }ifelse
    %% tambe filtrem els BitsPerComponent, doncs de moment no tractarem les imatges a 1 bit o imagemasks
    %%%refetXinLine
    dup /BPC known
    {
     /BPC get 8 ne
     {(\n\nMRCT1959 5\n\n) print flush stop}if  %% per filtrar imatges a 1bit o imagemask
    }
    {  %% o es una imagemask o es una JPEG2000
     pop (\n\nMRCT1959 5\n\n) print flush stop  %%quit
    }ifelse
    XRay /EspaisDeColor get /Utilitzats get
    %%{{== ==} forall == (*#*) ==} forall quit
    %% un altre metode + fiable d'extraure els canals
    bAUlA
    dup type /nametype eq 1 index length 16 eq
    {
     1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
    }
    {
     false
    }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
    and
    {  %% els dos han de ser certs (o sigui una ref ind segur), doncs llavors n'anirem a treure el literal que amaga
     /aCercar exch def
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop  %% d'interrogacio dels dicts de COMdimoni
    }if
    %%%refetXinLine
    dup /CMYK eq
    {  %% es quadricromia ...
     pop /NoName9 get
     %%% aquí es on plora la criatura ...
     %% segur ha de ser un dic
     %% aqui no hauriem de posar el mot inLine ????
     /NomExtern get  %%dup ==
     %%iaSep ==  % llistem el nom intern que li hem donat
    }
    {  %% no es espai CMYK, pot ser DeviceGray ...
     %%% aqui es on cal implementar x les inLine /G !!!!
     %%pop /DeviceGray get {== ==}forall ( ... aqui tambe plora la criatura!) pstack quit
     dup /G eq
     {
      pop /DeviceGray get
      /NomExtern get  %%dup ==
      %%iaSep ==  % llistem el nom intern que li hem donat
     }
     {  %% no es DeviceGray, pot ser DeviceN o Separation ...
      2 copy known
      {
       get
      }
      {
       (\n\nMRCT1959 21\n\n) == stop  %%quit  % sortim si el literal de l'espai de color referenciat a l'inLine no es en aquest diccionari
      }ifelse
      dup type /arraytype eq
      {  %% es l'array directe de color amb els canals!
       exch pop
       %%iaSep ==  % llistem el nom intern que li hem donat
      }
      {  %% mentre no sigui l'array directe de color amb els canals ...
       /NomExtern get  %%dup ==
       %%iaSep ==  % llistem el nom intern que li hem donat
      }ifelse
     }ifelse
    }ifelse
    %%{  % esbrinem quin espai de color fa servir iaSep
    %% dup /Paleta get iaSep known {
    %%                              /NomExtern get  % aqui tibem l'array amb els canals o el literal /PureCMYK o el nom de la Separation
    %%                              exch pop exit
    %%                             }{pop pop}ifelse
    %%}forall
    %% aqui o: hi ha l'array amb els canals o el literal /PureCMYK o el literal amb el nom de la Separation
    dup type /arraytype eq
    {  %% posem un detector que (de moment) nomes admeti 1 o 4 canals
     dup length dup 1 eq exch 4 eq or
     {
      dup length 1 eq
      {  %% si hi ha un sol canal no cal fer la separacio pero necessitem reescriure els bytes segons el Decode
       %%(1solCanalenArray) ==
       %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
       0 /iXiC exch def  [/NaL1] /vaCanals exch def
       {  %% forall
        dup  %% x FotoCrom
        dup length iaSep length add 1 add string dup /XiC exch def
        /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
        3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
        /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
        pAthXiU vaCanals iXiC get exch def
        FotoCrom 1 index known
        {  %% si ja hi ha aquesta tinta ...
         FotoCrom exch get
         %%dup
         iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
        }
        {  %% si la tinta no hi es ...
         FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
        }ifelse
        iXiC 1 add /iXiC exch def  %% actualitzem l'index
       }forall
       /_NaL1 NaL1 (w) file def
       BRoSSa (r) file  %% el raw a separar
       DeCoDe01  %% segons el Decode restem de 255 o no ...
       {
        {  %% loop de captura de canals
         dup read
         {
          _NaL1 exch 255 exch sub write
         }
         {
          pop exit
         }ifelse
        }loop
        _NaL1 closefile
       }
       {  %% seria x Decode 1 0
        {  %% loop de captura de canals
         dup read
         {
          _NaL1 exch write
         }
         {
          pop exit
         }ifelse
        }loop
        _NaL1 closefile
       }ifelse
       %%BRoSSa NaL1 renamefile  % ens limitem a renombrar el fitxer brossa.obj
       %%pstack (mmm) == quit
      }
      {  %% quatre canals ...
       %%(4canals) ==
       %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
       0 /iXiC exch def  [/NaL1 /NaL2 /NaL3 /NaL4] /vaCanals exch def
       {  %% forall
        dup %% x FotoCrom
        dup length iaSep length add 1 add string dup /XiC exch def
        /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
        3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
        /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
        pAthXiU vaCanals iXiC get exch def
        FotoCrom 1 index known
        {  %% si ja hi ha aquesta tinta ...
         FotoCrom exch get
         %%dup
         iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
        }
        {  %% si la tinta no hi es ...
         FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
        }ifelse
        iXiC 1 add /iXiC exch def  %% actualitzem l'index
       }forall
       /_NaL1 NaL1 (w) file def
       /_NaL2 NaL2 (w) file def
       /_NaL3 NaL3 (w) file def
       /_NaL4 NaL4 (w) file def
       BRoSSa (r) file  %% el raw a separar
       DeCoDe01  %% segons el Decode restem de 255 o no ...
       {
        {  %% loop de captura de canals
         dup read
         {
          _NaL1 exch 255 exch sub write
          dup read
          {
           _NaL2 exch 255 exch sub write
           dup read
           {
            _NaL3 exch 255 exch sub write
            dup read
            {
             _NaL4 exch 255 exch sub write
            }
            {
             pop exit
            }ifelse
           }
           {
            pop exit
           }ifelse
          }
          {
           pop exit
          }ifelse
         }
         {
          pop exit
         }ifelse
        }loop
        _NaL1 closefile _NaL2 closefile _NaL3 closefile _NaL4 closefile  %% tanquem
       }
       {  %% seria x Decode 1 0
        {  %% loop de captura de canals
         dup read
         {
          _NaL1 exch write
          dup read
          {
           _NaL2 exch write
           dup read
           {
            _NaL3 exch write
            dup read
            {
             _NaL4 exch write
            }
            {
             pop exit
            }ifelse
           }
           {
            pop exit
           }ifelse
          }
          {
           pop exit
          }ifelse
         }
         {
          pop exit
         }ifelse
        }loop
        _NaL1 closefile _NaL2 closefile _NaL3 closefile _NaL4 closefile  %% tanquem
       }ifelse
       %%pstack () == stop
      }ifelse
     }
     {  %% si no te 1 o 4 canals activem l'algorisme dinamic llescacanals x separar qualsevol nombre
      %%(N canals) ==
      dup length  %%== (WeirdCanals) == (\n\nMRCT1959 4\n\n) print flush stop
      /QuantesLlesques exch def  %% el nombre de canals de la imatge (qualsevol)
      %% farcim l'array ...
      /iNals 1 def  %% comptador de canals
      mark
      QuantesLlesques
      {
       iNals 4 string cvs dup length 3 add  %% el que fa NaL
       string dup /elNaL exch def
       /NullEncode filter dup dup (NaL) writestring 3 -1 roll writestring closefile
       elNaL cvn iNals 1 add /iNals exch def
      }repeat
      counttomark array astore /vaCanals exch def pop  %% desem el paquet i ens carreguem la mark
      %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
      0 /iXiC exch def
      {  %% forall
       dup  %% x FotoCrom
       dup length iaSep length add 1 add string dup /XiC exch def
       /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
       3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
       /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
       pAthXiU vaCanals iXiC get exch def
       FotoCrom 1 index known
       {  %% si ja hi ha aquesta tinta ...
        FotoCrom exch get
        %%dup
        iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
       }
       {  %% si la tinta no hi es ...
        FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
       }ifelse
       iXiC 1 add /iXiC exch def  %% actualitzem l'index
      }forall
      %% generem els fitxers d'excriptura tants com canals
      mark
      vaCanals
      {  %% forall
       dup dup length 1 add string
       dup /elNaL exch def
       /NullEncode filter dup dup (_) writestring 3 -1 roll 12 string cvs writestring closefile
       elNaL cvn dup 3 -1 roll
       cvx exec (w) file def
      }forall
      counttomark array astore /canelobre exch def pop  %% desem el paquet i ens carreguem la mark
      BRoSSa (r) file  %% el raw a separar
      DeCoDe01  %% segons el Decode restem de 255 o no ...
      {
       /pleguem false def  %% gatell de sortida del loop
       {  %% loop dinamic de captura de canals
        canelobre
        {
         cvx exec 1 index read {255 exch sub write}{pop /pleguem true def exit} ifelse
        } forall
        pleguem {pop exit}if
       }loop
       canelobre {cvx exec closefile} forall  %% tanquem
      }
      {  %% seria x Decode 1 0
       /pleguem false def  %% gatell de sortida del loop
       {  %% loop dinamic de captura de canals
        canelobre
        {  %% forall
         cvx exec 1 index read {write}{pop /pleguem true def exit} ifelse
        } forall
        pleguem {pop exit}if
       }loop
       canelobre {cvx exec closefile} forall  %% tanquem
      }ifelse
     }ifelse  %% 1 o 4 canals o qualsevol nombre ?
    }
    {  %% o es una Separation d'1 sol canal o es un /PureCMYK ...
     dup /PureCMYK eq
     {  %% quatre canals classics
      %%%refetXinLine
      %%(4cromia) ==
      pop [/Cyan /Magenta /Yellow /Black]  %% ens carreguem el literal i deixem l'array amb els noms classics de la quadricromia
      %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
      0 /iXiC exch def  [/NaL1 /NaL2 /NaL3 /NaL4] /vaCanals exch def
      {  %% forall
       dup  %% x FotoCrom
       dup length iaSep length add 1 add string dup /XiC exch def
       /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
       3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
       /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
       pAthXiU vaCanals iXiC get exch def
       FotoCrom 1 index known
       {  %% si ja hi ha aquesta tinta ...
        FotoCrom exch get
        %%dup
        iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
       }
       {  %% si la tinta no hi es ...
        FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec
        put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
       }ifelse
       iXiC 1 add /iXiC exch def  %% actualitzem l'index
      }forall
      /_NaL1 NaL1 (w) file def
      /_NaL2 NaL2 (w) file def
      /_NaL3 NaL3 (w) file def
      /_NaL4 NaL4 (w) file def
      BRoSSa (r) file  %% el raw a separar
      DeCoDe01  %% segons el Decode restem de 255 o no ...
      {
       {  %% loop de captura de canals
        dup read
        {
         _NaL1 exch 255 exch sub write
         dup read
         {
          _NaL2 exch 255 exch sub write
          dup read
          {
           _NaL3 exch 255 exch sub write
           dup read
           {
            _NaL4 exch 255 exch sub write
           }
           {
            pop exit
           }ifelse
          }
          {
           pop exit
          }ifelse
         }
         {
          pop exit
         }ifelse
        }
        {
         pop exit
        }ifelse
       }loop
       _NaL1 closefile _NaL2 closefile _NaL3 closefile _NaL4 closefile  %% tanquem
      }
      {  %% seria x Decode 1 0
       {  %% loop de captura de canals
        dup read
        {
         _NaL1 exch write
         dup read
         {
          _NaL2 exch write
          dup read
          {
           _NaL3 exch write
           dup read
           {
            _NaL4 exch write
           }
           {
            pop exit
           }ifelse
          }
          {
           pop exit
          }ifelse
         }
         {
          pop exit
         }ifelse
        }
        {
         pop exit
        }ifelse
       }loop
       _NaL1 closefile _NaL2 closefile _NaL3 closefile _NaL4 closefile  %% tanquem
      }ifelse
     }
     {  %% si hi ha un sol canal no cal fer la separacio pero necessitem reescriure els bytes segons el Decode
      %%(1solCanal) ==
      1 array dup 3 -1 roll 0 exch put  %% l'incrustem dins una array x no modificar els algorismes que segueixen ...
      %%pstack (aaa) == quit
      %% cal generar un fitxer de sortida per canal anomenat NomXObject_NomCanal
      0 /iXiC exch def  [/NaL1] /vaCanals exch def
      {  %% forall
       dup %% x FotoCrom
       dup length iaSep length add 1 add string dup /XiC exch def
       /NullEncode filter dup dup dup iaSep 128 string cvs writestring (_) writestring
       3 -1 roll 128 string cvs writestring closefile XiC dup length faPath add string dup
       /pAthXiU exch def 0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
       pAthXiU vaCanals iXiC get exch def
       FotoCrom 1 index known
       {  %% si ja hi ha aquesta tinta ...
        FotoCrom exch get
        %%dup
        iaSep vaCanals iXiC get cvx exec put  %% incrustem a FotoCrom el nom de la Tinta i afegim al dic la nova imatge i el path del seu raw relacionat
       }
       {  %% si la tinta no hi es ...
        FotoCrom exch 2 dict dup iaSep vaCanals iXiC get cvx exec put put  %% incrustem a FotoCrom el nom de la Tinta i un dic amb la imatge i el path del seu raw relacionat
       }ifelse
       iXiC 1 add /iXiC exch def  %% actualitzem l'index
      }forall
      /_NaL1 NaL1 (w) file def
      BRoSSa (r) file  %% el raw a separar
      DeCoDe01  %% segons el Decode restem de 255 o no ...
      {
       {  %% loop de captura de canals
        dup read
        {
         _NaL1 exch 255 exch sub write
        }
        {
         pop exit
        }ifelse
       }loop
       _NaL1 closefile
      }
      {  %% seria x Decode 1 0 (o com si ho fos en cas de les imatges DeviceGray doncs llavors no cal tocar res al raw)
       {  %% loop de captura de canals
        dup read
        {
         _NaL1 exch write
        }
        {
         pop exit
        }ifelse
       }loop
       _NaL1 closefile
      }ifelse
     }ifelse
    }ifelse
    %%%***%%% fi d'afegit x generar streams sense comprimir
    %%%nouXinLine
   }ifelse
  }forall   %% de tots els XObjects utilitzats
  %%test
  %%}stopped{pop length ==}if
  %%% fi de la separacio de colors de totes les imatges

  %#%42bis% esborrem a cada tinta de FotoCrom els noms de les imatges que ja hem donat de baixa d'JectesXclon
  (%#%42bis%)==
  XObjectsAesborrar
  {
   pop /NomXdBaixa exch def
   FotoCrom {NomXdBaixa undef pop} forall
  }forall
  %%% EP! ara hi posem un clear x tirar pel dret, pero hauriem de veure d'on salta aquest dict!!!
  clear
  0 /iPrev exch def  %% index per tenir controlats les repeticions dels Previews
  %% treiem x pantalleta el missatge que s'inicien les separacions
  BaBeL 37 get print flush

  %#%42bis2% generem un paquet per renombrar parcialment el(s) PDF(s) i afegir al Subject
  %# segons la quantitat de fitxers PDF que haguem de reescriure (opcions 01 i 05)
  %# on si fem (01) separarem les tintes per un determinat ordre ...
  %# ... de moment ens interessa ordenar primer les tintes que duen Shadings pel davant
  %# de les que no en duen, doncs aixó afecta a l'estabilitat de modificació dels diccionaris
  %# dels Shadings, funcions de tipus 3 i tipus 2. Paràmetres com ColorSpace, C0/C1 i Range
  %# es veuen afectats per l'odre en que se'n modifica el contingut
  (%#%42bis2%)==
  /TNTSxORDRE [] def
  FotoCromPS  %% desem als primers llocs de l'array TNTSxORDRE els noms de les tintes que duen Shadings
  {
   pop
   %% fiquem aVeure dins TNTSxORDRE ampliant cada vegada aquest array
   /aVeure exch def
   TNTSxORDRE
   dup length 1 add dup 1 sub /Dmes exch def
   array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
   /TNTSxORDRE exch def  %% redesem el paquet ampliat dels Resources particulars dels Pattern
  }forall
  %% desem la resta de noms de tintes a la cua de TNTSxORDRE
  XRay /EspaisDeColor get /TintesiValors get
  {  %% forall
   pop
   FotoCromPS 1 index known
   {pop}
   {
    %% fiquem aVeure dins TNTSxORDRE ampliant cada vegada aquest array
    /aVeure exch def
    TNTSxORDRE
    dup length 1 add dup 1 sub /Dmes exch def
    array dup dup 4 -1 roll 0 exch putinterval Dmes aVeure put
    /TNTSxORDRE exch def  %% redesem el paquet ampliat dels Resources particulars dels Pattern 
   }ifelse
  }forall
  %% fi de generacio del paquet de les tintes x ordre
 }  %/01 SEPARACIÓ DE TINTES
 {  %% aqui NO FEM la separacio de colors
  clear
  %% concretem /TNTSxORDRE segons /QueLiFemFer doncs ens descriu part del nom del fitxer de sortida el Subject del DocInfo
  [
   [
    [/iDeM]  %% 0
    [/iDeM]
   ]
   [
    null  %% 1
    null
   ]
   [
    [/TaLL]  %% 2
    [/MaRKS]
   ]
   [
    [/CoRReCToR]  %% 3
    [/CoRReCToR]
   ]
   [
    [/TeXTuaL]  %% 4
    [/TeXTuaL]
   ]
   [
    null  %% 5
    null
   ]
   [
    [/CoSiT]  %% 6
    [/uNSTiTCH]
   ]
   [
    [/ReiNSeReiX]  %% 7
    [/ReiNSeRT]
   ]
   torsimany
   {
    [
     [/TRaDuiT]
     [/TRaNSLaTioN]
    ]
   }
   {
    [
     [/eTiQueTa]
     [/TaGGiNG]
    ]
   }ifelse  %% 8 amb l'ambivalència de treballar per JBC o pel traductor
   [
    [/eXTRau]  %% 9
    [/eXTRaCTiNG]
   ]
   [
    [/PReFLiGHT]  %% 10
    [/PReFLiGHT]
   ]
   [
    null  %% 11 trosimany 4+8
    null
   ]
   [
    [/PolyBookmarks]  %% 12
    [/PolyBookmarks]
   ]
   [
    [/eliminaContents]  %% 13
    [/eraseContents]
   ]
   [
    [/restauraContents]  %% 14
    [/reloadContents]
   ]
   [
    [/eliminaLlesques]  %% 15
    [/eraseLayers]
   ]
   [
    [/MASATStreuificaText]  %% 16
    [/MASATSswapText]
   ]
   [
    [/MASATSencavalcaContinguts]  %% 17 %%MASATSencvlct
    [/MASATSoverlapsContents]
   ]
  ]
  QueLiFemFer get
  lleNguatge get  %% per idioma 
  dup null eq
  {
   %:05 dada variable
   %#%42bis3% bastim /TNTSxORDRE amb tots els noms únics per reescriure els PDF de dada variable
   %# i generem el paquet DADAmestre amb tots els continguts de dada variable per reincrustar
   (%#%42bis3%)==
   pop QueLiFemFer 5 eq
   {
    %# índex per llegir l'array DADAmestre contenint una array de dades per fitxer a reescriure
    /iDADAv 0 def  %% aquest index sumador s'utilitza dins el forall generador %43
    /DADAmestre [] def  %% paquet de dada variable mestre amb tots els continguts per reincrustar on hi ha una array per fitxer a reescriure
    /Pfa 0 def aDADAv {null ne{Pfa 1 add /Pfa exch def}if}forall Pfa array  %% el fem a mida
    /DADAxlinia exch def  %% paquet de dada variable mestre amb els continguts d'una sola línia
    %% muntem un diccionari amb els índex per ordre (DADAxlinia) com a valor dels noms clau de dada variable
    /iDADA 0 def
    /diDADAv 2 dict def  %% aquest diccionari també serà utilizat pels operadors Tj ' " TJ
    aDADAv
    {  %% forall per l'array del patró dels noms clau
     dup null eq
     {
      pop
     }
     {  %% desem el nom clau de dada variable amb el seu index dins a DADAxlinia
      diDADAv exch iDADA put
      iDADA 1 add /iDADA exch def 
     }ifelse
    }forall

%% controlem l'excepció<1> on ens cal enpalmar 3 artefactes idèntics seguits al darrer de tots
%% de forma que primer localitzem on comença l'índex del nom idèntic iIDEM i on acaba fIDEM
false{
/araArtfct 0 def  %% valors inicials pel comparatiu
/iIDEM null def
aDADAv length 1 sub 0 exch 1 exch
{  %% for
 aDADAv
 exch dup /araIDEM exch def
 get dup araArtfct eq
 {
  araArtfct 0 ne
  {
   /araArtfct exch def
   iIDEM null eq {araIDEM 1 sub /iIDEM exch def}if
  }
  {
   /araArtfct exch def
  }ifelse
 }
 {
  iIDEM null ne
  {
   pop araIDEM 1 sub /fIDEM exch def exit
  }
  {
   /araArtfct exch def
  }ifelse
 }ifelse
}for
}if

    pathDADAv (r) file  %% lectura de la dada variable
    {  %% loop
     dup 65535 string readline
     /soRtim exch def

%% l'excepció<1>
%% en aquest punt és on si cal empalmem les cadenes que tenen el mateix nom d'artefacte al CSV
%% de manera que des l'index iIDEM fins l'índex fIDEM les afegim separades per un espai
%% i les reintroduïm a l'index fIDEM altra cop (doncs és el que actuarà)
false{
dup
/araArtfct () def
/capArtfct 0 def
iIDEM null ne
{  %% ha trobat artefactes amb nom idèntic
 0 1 fIDEM
 {  %% for
  exch sDADA search
  {
   exch pop
   3 -1 roll iIDEM ge
   {
    dup length dup dup /lastArtfct exch def capArtfct add /capArtfct exch def
    araArtfct length dup /araVA exch def add string dup 0 araArtfct putinterval
    dup araVA 4 -1 roll putinterval dup length dup /araVA exch def 1 add string dup 3 -1 roll
    0 exch putinterval dup araVA 32 put  %% afegim l'espai en blanc separador
    /araArtfct exch def
   }
   {
    length capArtfct add /capArtfct exch def
   }ifelse
  }
  {
%(+++++)pstack quit
   exch /capArtfct exch def /lastArtfct 0 def /fIDEM 0 def
  }ifelse
 }for
 /cuaArtfct exch def
 fIDEM 0 ne
 {
  %% inserim la cadena amb les dades dels tres artefactes sumats on toca
  0 capArtfct lastArtfct sub fIDEM add getinterval dup length dup /araVA exch def
  araArtfct length add string dup 3 -1 roll 0 exch putinterval dup araVA araArtfct putinterval
  dup dup length 1 sub sDADA putinterval dup length dup /araVA exch def cuaArtfct length add string
  dup 3 -1 roll 0 exch putinterval dup araVA cuaArtfct putinterval
 }if
}if
}if

     aDADAv  %% array pel patró dels índex clau per cada línia de dada variable llegida
     {  %% forall
      dup null eq
      {  %% ignorem la dada
       pop
       sDADA  %% string amb el caràcter separador dels registres a les línies de dada variable
       search
       {  %% ok
        pop pop
       }
       {  %% teniu un error?
        %%pstack
        %%(\n\n ... teniu un error al fitxer de dada variable?\n\n)print flush
       }ifelse
      }
      {  %% desem la dada al seu index mestre
       diDADAv exch get  %% pesquem l'índex que li correspon dins DADAxlinia
       /iDADA exch def
       sDADA  %% string amb el caràcter separador dels registres a les línies de dada variable
%DADAxlinia
%(+++++)pstack quit
       search
       {  %% ok
        exch pop  %% eliminem el separador
%%(xavierDsarrio)pstack quit
        %% despullem el text de cometes?
        %% amolla un(s) nou(s) caracter en lloc d'un(s) altre(s)
        () /amolla exch def  %% text despullat
        (") /cErquEm exch def  %% cadena que cerquem
        () /HiPosem exch def  %% cadena que hi posem
        1024 string cvs  %% la cadena on apliquem l'algorisme de filtrat
        {  %% loop
         cErquEm search
         {
          dup length
          amolla length dup /afG exch def
          add dup /aON2 exch def HiPosem length add string dup
          0 amolla putinterval dup afG 4 -1 roll putinterval
          dup aON2 HiPosem putinterval /amolla exch def
          pop
         }
         {
          dup length
          amolla length dup /afG exch def
          add string dup
          0 amolla putinterval dup afG 4 -1 roll putinterval
          /amolla exch def
          exit
         }ifelse
        }loop
        DADAxlinia iDADA amolla put  %% desem
       }
       {  %% teniu un error?
        %%pstack
        %%(\n\n ... teniu un error al fitxer de dada variable?\n\n)print flush
       }ifelse
      }ifelse
     }forall
     %% desem i ampliem l'array
     DADAmestre dup length dup /afG exch def 1 add array dup 3 -1 roll 0 exch putinterval dup
     afG DADAxlinia dup length array copy  %% descontaminem
     put /DADAmestre exch def
     pop  %% eliminem la cadena residual del search
     soRtim not {closefile exit}if  %% sortim?
    }loop
   }
   {  %% error incomprensible :-(
    (\n\n:-\( ... error esotèric\n\n)print flush stop
   }ifelse
   %% generem TNTSxORDRE
   /TNTSxORDRE [] def
   /NMrDR 0 def  %% numerador simple per reescriure el nom del fitxer
   DADAmestre
%(+++++)pstack quit
   {
    pop  %% s'hauria d'eliminar si utilitzessim l'index de dada única de més avall
    TNTSxORDRE dup length dup /afG exch def 1 add array dup 3 -1 roll 0 exch
    putinterval dup afG
    %% això podria substituir el numerador normal i estar al menú de capçalera?
    %% 4 -1 roll 2 get  %% index de la dada única per reescriure el nom del fitxer
    NMrDR 1 add dup /NMrDR exch def 7 string cvs  %% numerador normal
    cvn put /TNTSxORDRE exch def
   }forall
%% DADAmestre(:-5)pstack quit
   %/05 dada variable
  }
  {  %% no pot ser ni la 1 ni la 5
   /TNTSxORDRE exch def
  }ifelse
  0 /iPrev exch def  %% index per tenir controlats les repeticions dels Previews
 }ifelse  %% tret q fem la separacio de colors

 %:00 REESCRIPTURA IDEM
 %:01 SEPARACIÓ DE TINTES
 %:02 MARQUES DE TALL
 %:03 CORRECTOR TIPOGRÀFIC
 %:05 dada variable
 %:06 COSIT D'IMATGES
 %:07 REINSEREIX IMATGES JPEG
 %:08 ETIQUETA TEXT
 %:10 PREFLIGHT AMB CAPES
 %:12 arbre jeràrquic
 %:13 eliminem continguts de pàgina
 %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
 %:15 ELIMINA LLESQUES
 %:16 cerca i substitució de text
 %:17 ENCAVALCA CONTINGUTS

 %#%43% reescriptura de fitxers
 %# separació de tintes: un PDF de sortida per a cada una de les Tintes
 %# dada variable: un PDF de sortida per cada registre de dada variable
 %# la resta d'opcions només generen un sol fitxer de sortida
 (%#%43%)==
 0 /iNousCoOb exch def  %% index per assignar noms als nous streams repicats
 nousCoOb length 15 sub /posNum exch def  %% posicio d'inici fixa del numerador d'streams
 1 /iNousStreams exch def  %% index per assignar noms als nous streams repicats
 QueLiFemFer 1 eq
 {
  TNTSxORDRE  %% generem les separacions x l'ordre establert en aquest paquet
  %% ARA invertim l'array (els colors que duen Shadings aniran ara a la cua!)
  %%dup ==
  aload pop  %% desfem el paquet de colors
  /tWist 1 def  %% valor que fa rodar els elements de la pila
  count {tWist -1 roll tWist 1 add /tWist exch def} repeat
  count array astore  %% refem el paquet
 }
 {  %% no cal que capgirem els elements de l'array si no fem la separació de tintes
  TNTSxORDRE
 }ifelse


 {  %% forall de la generacio de PDF (per Tinta, per Dada Variable, reescriptura normal del PDF o cerca i substitució de text)
%/17 ENCAVALCA CONTINGUTS
%/16 cerca i substitució de text
%/15 ELIMINA LLESQUES
%/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%/13 eliminem continguts de pàgina
%/12 arbre jeràrquic
%/10 PREFLIGHT AMB CAPES
%/08 ETIQUETA TEXT
%/07 REINSEREIX IMATGES JPEG
%/06 COSIT D'IMATGES
%/05 dada variable
%/03 CORRECTOR TIPOGRÀFIC
%/02 MARQUES DE TALL
%/01 SEPARACIÓ DE TINTES
%/00 REESCRIPTURA IDEM

  QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
  {
   dup  % deixem una copia del nom a la pila
   XRay /EspaisDeColor get /TintesiValors get
   exch get  %% anem a pescar pel nom de la tinta l'array de valors
   %%is3% per mitja de l'array de valors podem saber si a la Tinta que llistem li correspon

   %#%43bis% hi ha alguna imatge? (XObject o inLine), doncs en aquest punt és on n'hem de modificar
   %# el diccionari /Filter /XIU /Decode[0 1] /Length i /ColorSpace per activar la seva separació
   (%#%43bis%)==
   {  %% forall de l'array de valors
    dup type /nametype eq
    {
     %% malgrat sigui un nom ens assegurem que existeix al dic clonic d'XObjects (o aquest existeixi i no sigui un null), doncs podria ser un Shading Pattern
     JectesXclon null eq {false}{JectesXclon araPlana get 1 index known}ifelse
     {
      FotoCrom
      2 index get  %% extraiem el dic de la tinta que toca
      JectesXclon araPlana get  %% dic clonic dels XObjects a Resources un cop ens hem polit les imatges que tot i tenir nom diferent comparteixen objecte
      2 index
      get  %% anem a pescar el dic de la imatge a separar
      dup type /nametype eq
      {
       /aCercar exch def  %% nom amb la ref ind del dic Resources
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
      }if
      %% al dic de la imatge ...
      dup /Filter undef  %% li rematem /Filter
      dup /ColorSpace /DeviceGray put  %% li redefinim l'espai de color a escala de grisos
      dup /Decode [0 1] put  %% redefinim la polaritat de la imatge positiu/negatiu
      3 1 roll
      %%% aqui tenim el problema, doncs xq no hi ha la imatge amb el path en aquesta tinta que en comparteix dues????
      %%  dup {== ==}forall (?¿) == % quit
      exch
      get  %% anem a pescar el path de la separacio de la imatge que toca x incrustar-lo a l'array de /XIU
      1 array dup 3 -1 roll 0 exch
      %% interroguem els bytes del fitxer per modificar /Length
      dup status pop pop pop /FaFtxr exch def pop  %% bytes totals del fitxer
      put  %% incrustem el path dins un array x indicar que es un stream de dades a disc
      1 index /Length FaFtxr put  %% redefinim els bytes del stream d'imatge
      /XIU exch put  %% redefinim /XIU
      %%pstack ($$$) == quit
     }
     {
      pop  %% ens carreguem el nom del Sahding Pattern doncs ara no toca
     }ifelse
    }
    {
     pop
    }ifelse
   }forall
   %%1%% QUAN L'OBJECTE DEL SHADING ES TROBI AQUI ... elsAltresShadings ... CALDRA ANAR A RENOVAR L'ELEMENT (posicio 2 a Patterns&Shadings utilitzats) QUE DUU ELS COMPONENTS DE L'ESPAI DE COLOR
   %% doncs ara no sabem xq no coincideixen (o poden no coincidir) amb l'array emmagatzemat aqui elsAltresShadings
   %%FotoCromPS /PANTONE#20Process#20Cyan#20C get /P1 get {== ==}forall (ummmm) == quit
   %% /P2995 get /P5 get
   %%elsAltresShadings
   %%JectesPS
   %%XRay /Patterns&Shadings get /Utilitzats get
   %%2%% quan 2 shadings comparteixen color amb la mateixa funcio de tipus 2 (i de tipus 3?) llavors tenim un problema al haver actualitzat el dic
   %% aqui desarem les referencies indirectes de totes les crides a Shadings i funcions
   %% de tipus 2 i 3 que tractem a cada passada de color per tal d'evitar intents de
   %% modificacio de funcions que ja han estat modificades dins la mateixa passada de color
   /RiFT 2 dict def
   /DeSCoNeGuDa true def  %% valor inicial del gatell que ens ha de dir si ja hem modificat una determinat objecte

   %#%43bis2% aquí és on modificarem l'stream dels dics dels Patterns&Shadings x separar la Tinta que llistem
   (%#%43bis2%)==
   FotoCromPS length 0 ne  %% si te algun element es que hem separat alguna mena de Pattern&Shading
   {
    dup FotoCromPS exch known
    {  %% ens assegurem que sigui una tinta utilitzada en una separacio de Patterns&Shadings!
     dup FotoCromPS exch get  %% extraiem el dic de la Tinta on hi ha tots els Patterns&Shadings que cal separar
     {  %% forall x cada Pattern&Shading
      dup type /arraytype eq
      1 index type /dicttype eq
      or
      {  %% si es un array o un dict es que es tracta d'un Shading Pattern
       dup type /arraytype eq
       {  %% es una array
        dup 0 get /_C0 exch def 1 get /_C1 exch def
        dup /eSP exch def  %% pel nom del Shading Pattern anem a buscar l'espai de color amb q treballa
        XRay /Patterns&Shadings get /Utilitzats get exch get
        2 get dup type /nametype eq
        {  %% si es un literal nomes es pot tractar d'un CMYK o d'un nom d'un canal d'una Separation
         dup /DeviceCMYK eq
         {
          pop
          JectesPS eSP known
          {
           JectesPS eSP get
           dup type /nametype eq
           {
            %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
            %% RiFT 1 index known
            %% {/DeSCoNeGuDa false def}
            %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
            %%dup == (1) ==
            aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }if
           /Shading get
          }
          {  %% si no es al dic JectesPS haura d'estar aqui ...
           elsAltresShadings eSP get
           %%(M·A·T·A·M·A·L·A) ==
          }ifelse
          dup type /nametype eq
          {
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           %% RiFT 1 index known
           %% {/DeSCoNeGuDa false def}
           %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
           %%dup == (2) ==
           /aCercar exch def
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
          }if
          dup /ColorSpace /DeviceGray put  %% li repiquem l'espai de color x la separacio al dic del Shading Pattern
          %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
          dup /Range undef
          /Function get  %% anem a pescar el dic de la funcio (directe o indirecte)
          dup type /nametype eq
          {
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           RiFT 1 index known
           1 index /QuinObDuFD exch def  %% ref ind de l'objecte que duu funcions directes
           {
            /DeSCoNeGuDa false def
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }
           {
            dup  %%RiFT 1 index null
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
            %% dup length dict copy
            %% tractarem els composite objects com a fitxers a disc
            iNousCoOb 1 add /iNousCoOb exch def  %% comptador de nous fitxers composite object
            nousCoOb dup posNum iNousCoOb 10 string cvs putinterval  %% nou fitxer+path
            dup length string copy dup /nousCoOb exch def
            (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2 i /espiapaq_fura3
            %% ho tanquem dins un dict
            Objected'Ara (<<) writestring
            espiadic_fura2
            %% ho tanquem dins un dict
            Objected'Ara dup (>>) writestring closefile
            nousCoOb
            RiFT 3 1 roll put /DeSCoNeGuDa true def
            nousCoOb (r) file cvx exec
            %% repiquem el dic reescrit al seu objecte ref ind original
            currentdict iDimoni 4 string cvs cvn get 1 index QuinObDuFD exch put
           }ifelse
           %%dup ==
           %%(3) ==
          }if
          %%(aviamFT0) ==
          dup /FunctionType get
          [
           {	%% 0 NO implementada encara
           }
           {	%% 1 inexistents
           }
           {	%% 2
            %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
            dup /Range undef
            DeSCoNeGuDa  %% ja l'hem tractat?
            {
             <</Cyan 0 /Magenta 1 /Yellow 2 /Black 3>>
             2 index get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
             %% 1 index /Range known
             %% {
             %% 1 index dup /Range get
             %% iC0C1 2 mul 2 getinterval /Range exch put
             %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
             %%pstack _C0 == _C1 == quit XQ es confon un array [/Magenta/Yellow/Black] per un CMYK?
             dup _C0 exch get
             1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
             1 array astore  %% preparem l'array x reescriure C0
             2 index exch /C0 exch put  %% redefinim C0
             _C1 exch get
             1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
             1 array astore  %% preparem l'array x reescriure C1
             /C1 exch put  %% redefinim C1
            }
            {
             pop
            }ifelse
           }
           {  %% 3
            %%mug@
            %%(\n\n---1959 2005v026bis2\n\n) print flush % error Temporal
            %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
            dup /Range undef
            DeSCoNeGuDa  %% ja l'hem tractada?
            {
             <</Cyan 0 /Magenta 1 /Yellow 2 /Black 3>>
             paTina get /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
             %%% SI LA TIPUS 3 DUU ELS DICS DE L'ARRAY FUNCTIONS DIRECTES NO ELS TENIM REFERENCIATS AL DIC DES D'ON MODIFIQUEM
             %%% LLAVORS CAL FER LA MODIFICACIO (EN FUNCIO DE LA TINTA) AQUI MATEIX
             %%mug@
             %%(\n\n---1959 2005bis\n\n) print flush        
             dup /Functions get  %% tibem l'array obligatori amb les funcions ...
             {  %% forall x saber si son directes o indirectes?
              dup type /dicttype eq
              {  %% com que son directes les hem de retocar ara i aqui
               %%(funcions directes!) ==
               dup /FunctionType get 2 eq
               {
                %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
                dup /Range undef
                <</Cyan 0 /Magenta 1 /Yellow 2 /Black 3>>
                paTina get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
                %% al ser dics directes no necessitem per a res les variables _C0 _C1              
                1 index /C0 get exch get              
                1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
                1 array astore  %% preparem l'array x reescriure C0
                1 index exch /C0 exch put  %% redefinim C0
                dup /C1 get iC0C1 get 1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
                1 array astore  %% preparem l'array x reescriure C1
                /C1 exch put  %% redefinim C1
               }
               {  %% si una 3 no esta formada x tipus 2, ara donem error ...
                (\n\nMRCT1959 2008bis\n\n) print flush stop  %%quit
               }ifelse
              }
              {  %% si son indirectes no fem res doncs ja estaran referenciades
               %%(COAC ... 1) ==
               pop
              }ifelse
             }forall
            }
            {
             pop
            }ifelse
           }
           {  %% 4 NO implementada encara
           }
          ]      
          exch get cvx exec
         }
         {  %% sera un nom d'un canal d'una Separation
          pop
          JectesPS eSP known
          {
           JectesPS eSP get
           dup type /nametype eq
           {
            %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
            %% RiFT 1 index known
            %% {/DeSCoNeGuDa false def}
            %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
            %%dup == (4) ==                              
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }if
           /Shading get
          }
          {  %% si no es al dic JectesPS haura d'estar aqui ...
           elsAltresShadings eSP get
           %%(G·U·S·A·R·A·P·A) ==
          }ifelse 
          dup type /nametype eq
          {
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           %% RiFT 1 index known
           %% {/DeSCoNeGuDa false def}
           %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
           %%dup == (5) ==                              
           /aCercar exch def
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
          }if
          _C0 null ne
          {   %% si es null es que la funcio no duu C0/C1 i llavors no cal fer res ...
           dup /ColorSpace /DeviceGray put  %% li repiquem l'espai de color x la separacio al dic del Shading Pattern
          }if
          %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
          dup /Range undef
          /Function get  %% anem a pescar el dic de la funcio (directe o indirecte)
          dup type /nametype eq
          {
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           RiFT 1 index known
           1 index /QuinObDuFD exch def  %% ref ind de l'objecte que duu funcions directes
           {
            /DeSCoNeGuDa false def
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }
           {
            dup  %%RiFT 1 index null
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
            %%dup length dict copy
            %% tractarem els composite objects com a fitxers a disc
            iNousCoOb 1 add /iNousCoOb exch def  %% comptador de nous fitxers composite object
            nousCoOb dup posNum iNousCoOb 10 string cvs putinterval  %% nou fitxer+path
            dup length string copy dup /nousCoOb exch def
            (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2 i /espiapaq_fura3
            %% ho tanquem dins un dict
            Objected'Ara (<<) writestring
            espiadic_fura2
            %% ho tanquem dins un dict
            Objected'Ara dup (>>) writestring closefile
            nousCoOb
            RiFT 3 1 roll put /DeSCoNeGuDa true def
            nousCoOb (r) file cvx exec
            %% repiquem el dic reescrit al seu objecte ref ind original
            currentdict iDimoni 4 string cvs cvn get 1 index QuinObDuFD exch put
           }ifelse
           %%(6) ==                              
          }if
          %%(aviamFT1) ==
          dup /FunctionType get
          [
           {	%% 0 NO implementada encara
           }
           {	%% 1 inexistents
           }
           {	%% 2
            %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
            dup /Range undef
            DeSCoNeGuDa  %% ja l'hem tractat?
            {
             %% dup /Range known
             %% {  % es segur 1 sol element
             %% dup dup /Range get
             %% 0 2 mul 2 getinterval /Range exch put
             %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
             _C0 null eq
             {  %% si es null es que la funcio no duu C0/C1 i llavors cal aplicar els valors x defecte /C0 [0] /C1 [1]
              dup  %% invertim els valors x defecte ...
              /C0 [1] put
              /C1 [0] put
             }
             {
              0  %% es segur 1 sol element
              dup _C0 exch get
              1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
              1 array astore  %% preparem l'array x reescriure C0
              2 index exch /C0 exch put  %% redefinim C0
              _C1 exch get
              1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
              1 array astore  %% preparem l'array x reescriure C1
              /C1 exch put  %% redefinim C1
             }ifelse
            }
            {
             pop
            }ifelse
           }
           {  %% 3
            %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
            dup /Range undef
            DeSCoNeGuDa  %% ja l'hem tractat?
            {
             %%% SI LA TIPUS 3 DUU ELS DICS DE L'ARRAY FUNCIONS DIRECTES NO ELS TENIM REFERENCIATS AL DIC DES D'ON MODIFIQUEM
             %%% LLAVORS CAL FER LA MODIFICACIO (EN FUNCIO DE LA TINTA) AQUI MATEIX
             %%mug@
             %%(\n\n---1959 2005_d\n\n) print flush        
             dup /Functions get  %% tibem l'array obligatori amb les funcions ...
             {  %% forall x saber si son directes o indirectes?
              dup type /dicttype eq
              {  %% com que son directes les hem de retocar ara i aqui
               %%(funcions directes!!) ==
               dup /FunctionType get 2 eq
               {
                %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
                dup /Range undef
                0  %% es segur 1 sol element
                dup 2 index /C0 get exch get
                1 exch sub  %% xq al treballar amb DeviceGray NO hem d'invertir el valor de color?
                1 array astore  %% preparem l'array x reescriure C0
                2 index exch /C0 exch put  %% redefinim C0
                1 index /C1 get exch get
                1 exch sub  %% xq al treballar amb DeviceGray NO hem d'invertir el valor de color?
                1 array astore  %% preparem l'array x reescriure C1
                /C1 exch put  %% redefinim C1
               }
               {  %% si una 3 no esta formada x tipus 2, ara donem error ...
                (\n\nMRCT1959 2008\n\n) print flush stop  %%quit
               }ifelse
              }
              {  %% si son indirectes no fem res doncs ja estaran referenciades
               %%(COAC ... 2) ==
               pop
              }ifelse
             }forall
            }
            {
             pop
            }ifelse
           }
           {	%% 4 NO implementada encara
           }
          ]
          exch get cvx exec
          %%(\n\nMRCT1959 2006\n\n) print flush stop  % error Temporal
          %%% X OMPLIR
         }ifelse
        }
        {  %% sera una array d'un DeviceN
         /AindexarCanals exch def  %% desem l'array dels canals de color x fer-ne + endavant un dic amb els index
         JectesPS eSP known
         {
          JectesPS eSP get
          dup type /nametype eq
          {
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           %% RiFT 1 index known
           %% {/DeSCoNeGuDa false def}
           %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
           %%dup == (7) ==                              
           /aCercar exch def  %% nom amb la ref ind del dic Resources
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
          }if
          /Shading get
         }
         {  %% si no es al dic JectesPS haura d'estar aqui ...
          elsAltresShadings eSP get
          %%(A·F·R·I·C·A·D·A) ==
          %% actualitzem el valor de C0 i C1 ...
          %%% no sabem si es del tot correcte aquesta supressio
          %%       ft2C0C1 dup 0 get /_C0 exch def 1 get /_C1 exch def  % doncs si no, podria no coincidir amb els definits fins ara
         }ifelse
         dup type /nametype eq
         {
          %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
          %% RiFT 1 index known
          %% {/DeSCoNeGuDa false def}
          %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
          %%dup == (8) ==                              
          /aCercar exch def  %% nom amb la ref ind del dic Resources
          /iDimoni 0 def
          {  %% loop d'interrogacio dels dicts de COMdimoni
           currentdict iDimoni 4 string cvs cvn get
           %% el diccionari de l'objecte
           dup aCercar known {aCercar get exit}{pop}ifelse
           iDimoni 1 add /iDimoni exch def
           iDimoni MaxDimoni eq {exit} if
          }loop  %% d'interrogacio dels dicts de COMdimoni
         }if
         dup /ColorSpace /DeviceGray put  %% li repiquem l'espai de color x la separacio al dic del Shading Pattern
         %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
         dup /Range undef
         /Function get  %% anem a pescar el dic de la funcio (directe o indirecte)
         dup type /nametype eq
         {
          %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           RiFT 1 index known
          1 index /QuinObDuFD exch def  %% ref ind de l'objecte que duu funcions directes
          {
           /DeSCoNeGuDa false def
           /aCercar exch def  %% nom amb la ref ind del dic Resources
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
          }
          {
           dup %%RiFT 1 index null
           /aCercar exch def  %% nom amb la ref ind del dic Resources
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
           %%dup length dict copy
           %% tractarem els composite objects com a fitxers a disc
           iNousCoOb 1 add /iNousCoOb exch def  %% comptador de nous fitxers composite object
           nousCoOb dup posNum iNousCoOb 10 string cvs putinterval  %% nou fitxer+path
           dup length string copy dup /nousCoOb exch def
           (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2 i /espiapaq_fura3
           %% ho tanquem dins un dict
           Objected'Ara (<<) writestring
           espiadic_fura2
           %% ho tanquem dins un dict
           Objected'Ara dup (>>) writestring closefile
           nousCoOb
           RiFT 3 1 roll put /DeSCoNeGuDa true def
           nousCoOb (r) file cvx exec
           %% repiquem el dic reescrit al seu objecte ref ind original
           currentdict iDimoni 4 string cvs cvn get 1 index QuinObDuFD exch put
          }ifelse
          %%(9) ==                              
         }if
         %%(aviamFT2) ==
         dup /FunctionType get
         [
          {	%% 0 NO implementada encara
          }
          {	%% 1 inexistents
          }
          {	%% 2
           %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
           dup /Range undef
           DeSCoNeGuDa  %% ja l'hem tractat?
           {
            _C0 null eq
            {  %% si es null es que la funcio no duu C0/C1 i llavors cal aplicar els valors x defecte /C0 [0] /C1 [1]
             dup  %% invertim els valors x defecte ...
             /C0 [1] put
             /C1 [0] put
             %% dup  % invertim els valors x defecte ...
             %% /C0 AindexarCanals length {1}repeat  % tants 'uns' com canals
             %% AindexarCanals length array astore put
             %% /C1 AindexarCanals length {0}repeat  % tants 'zeros' com canals
             %% AindexarCanals length array astore put
             %% (\n\nMRCT1959 10\n\n) print flush stop
            }
            {
             AindexarCanals
             /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
             /deXcanal 2 dict def  %% diccionari amb els index x canal de color
             {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
             deXcanal
             2 index get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
             %% 1 index /Range known
             %% {
             %% 1 index dup /Range get
             %% iC0C1 2 mul 2 getinterval /Range exch put
             %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
             dup _C0 exch get
             1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
             1 array astore  %% preparem l'array x reescriure C0
             2 index exch /C0 exch put  %% redefinim C0
             _C1 exch get
             1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
             1 array astore  %% preparem l'array x reescriure C1
             /C1 exch put  %% redefinim C1
            }ifelse
           }
           {
            pop
           }ifelse
          }
          {  %% 3
           %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
           dup /Range undef
           DeSCoNeGuDa  %% ja l'hem tractada?
           {
            AindexarCanals
            /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
            /deXcanal 2 dict def  %% diccionari amb els index x canal de color
            {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
            deXcanal
            paTina get /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
            %% dup /Range known
            %% {
            %% dup dup /Range get
            %% iC0C1 2 mul 2 getinterval /Range exch put
            %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
            %%% SI LA TIPUS 3 DUU ELS DICS DE L'ARRAY FUNCTIONS DIRECTES NO ELS TENIM REFERENCIATS AL DIC DES D'ON MODIFIQUEM
            %%% LLAVORS CAL FER LA MODIFICACIO (EN FUNCIO DE LA TINTA) AQUI MATEIX
            %%mug@
            %%(\n\n---1959 2005bis\n\n) print flush        
            dup /Functions get  %% tibem l'array obligatori amb les funcions ...
            {  %% forall x a cada una de les stitching i saber si son directes o indirectes?
             dup type /dicttype eq
             {  %% com que son directes les hem de retocar ara i aqui
              %%(funcions directes!) ==
              dup /FunctionType get 2 eq
              {
               %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
               dup /Range undef
               %% Desactivat ... si tinguessim una funcio de tipus 2 sense C0/C1 seria un cas no controlat que aboquem a un error a solucionar quan surti
               %%_C0 null eq {(\n\nMRCT1959 10\n\n) print flush stop}if
               AindexarCanals
               /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
               /deXcanal 2 dict def  %% diccionari amb els index x canal de color
               {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
               deXcanal
               paTina get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
               %% 1 index /Range known
               %% {
               %% 1 index dup /Range get
               %% iC0C1 2 mul 2 getinterval /Range exch put
               %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
               %% al ser dics directes no necessitem per a res les variables _C0 _C1              
               1 index /C0 get exch get              
               1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
               1 array astore  %% preparem l'array x reescriure C0
               1 index exch /C0 exch put  %% redefinim C0
               dup /C1 get iC0C1 get 1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
               1 array astore  %% preparem l'array x reescriure C1
               /C1 exch put  %% redefinim C1
              }
              {  %% si una 3 no esta formada x tipus 2, ara donem error ...
               (\n\nMRCT1959 2008\n\n) print flush stop  %%quit
              }ifelse
             }
             {  %% si son indirectes no fem res doncs ja estaran referenciades
              %%(COAC ... 3) ==
              pop
             }ifelse
            }forall
           }
           {
            pop
           }ifelse
          }
          {	%% 4 NO implementada encara
          }
         ]      
         exch get cvx exec
         %%(\n\nMRCT1959 2007\n\n) print flush stop  % error Temporal
        }ifelse
       }
       {  %% es un diccionari que ens diu que es tracta d'un Shading amb una funcio de tipus ?
        exch /eSP exch def  %% pel nom del Shading Pattern anem a buscar l'espai de color amb q treballa
        exch /paTina exch def  %% desem la tinta
        {  %% forall x cada ref ind + array      
         exch /Fsargit exch def  %% ara desem la ref ind que actua com a clau x modificar-ne l'objecte funcio que forma part del sargit de la tipus 3
         dup 0 get /_C0 exch def 1 get /_C1 exch def
         XRay /Patterns&Shadings get /Utilitzats get eSP get
         2 get dup type /nametype eq
         {  %% si es un literal nomes es pot tractar d'un CMYK o d'un nom d'un canal d'una Separation
          dup /DeviceCMYK eq
          {
           pop
           JectesPS eSP known
           {
            JectesPS eSP get
            dup type /nametype eq
            {
             %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
             %% RiFT 1 index known
             %% {/DeSCoNeGuDa false def}
             %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
             %%dup == (10) ==
             /aCercar exch def  %% nom amb la ref ind del dic Resources
             /iDimoni 0 def
             {  %% loop d'interrogacio dels dicts de COMdimoni
              currentdict iDimoni 4 string cvs cvn get
              %% el diccionari de l'objecte
              dup aCercar known {aCercar get exit}{pop}ifelse
              iDimoni 1 add /iDimoni exch def
              iDimoni MaxDimoni eq {exit} if
             } loop  %% d'interrogacio dels dicts de COMdimoni
            }if
            /Shading get
           }
           {  %% si no es al dic JectesPS haura d'estar aqui ...
            elsAltresShadings eSP get
            %%(F·R·E·T·U·R·A) ==
           }ifelse
           dup type /nametype eq
           {
            %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
            %% RiFT 1 index known
            %% {/DeSCoNeGuDa false def}
            %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
            %%dup == (11) ==
            /aCercar exch def
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }if
           %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
           dup /Range undef
           /ColorSpace /DeviceGray put  %% li repiquem l'espai de color x la separacio al dic del Shading Pattern
           Fsargit
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           RiFT 1 index known
           1 index /QuinObDuFD exch def  %% ref ind de l'objecte que duu funcions directes
           {
            /DeSCoNeGuDa false def
            /aCercar exch def  %% nom amb la ref ind
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }
           {
            dup  %%RiFT 1 index null
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
            %%dup length dict copy
            %% tractarem els composite objects com a fitxers a disc
            iNousCoOb 1 add /iNousCoOb exch def  %% comptador de nous fitxers composite object
            nousCoOb dup posNum iNousCoOb 10 string cvs putinterval  %% nou fitxer+path
            dup length string copy dup /nousCoOb exch def
            (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2 i /espiapaq_fura3
            %% ho tanquem dins un dict
            Objected'Ara (<<) writestring
            espiadic_fura2
            %% ho tanquem dins un dict
            Objected'Ara dup (>>) writestring closefile
            nousCoOb
            RiFT 3 1 roll put /DeSCoNeGuDa true def
            nousCoOb (r) file cvx exec
            %% repiquem el dic reescrit al seu objecte ref ind original
            currentdict iDimoni 4 string cvs cvn get 1 index QuinObDuFD exch put
           }ifelse
           %%(12) ==
           %%(aviamFT3) ==
           dup /FunctionType known
           {  %% es una Function
            dup /FunctionType get
           }
           {  %% es un objecte Shading encara
            /Function get
            dup type /nametype eq
            {                            
             /aCercar exch def
             /iDimoni 0 def
             {  %% loop d'interrogacio dels dicts de COMdimoni
              currentdict iDimoni 4 string cvs cvn get
              %% el diccionari de l'objecte
              dup aCercar known {aCercar get exit}{pop}ifelse
              iDimoni 1 add /iDimoni exch def
              iDimoni MaxDimoni eq {exit} if
             }loop  %% d'interrogacio dels dicts de COMdimoni
            }if
            dup /FunctionType get
           }ifelse  %% no entenem encara xq aqui hi pode arribar tan funcions com Shadings ... la pista pot estar a Fsargit
           [
            {	%% 0 NO implementada encara
            }
            {	%% 1 inexistents
            }
            {	%% 2
             %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
             dup /Range undef
             DeSCoNeGuDa  %% ja l'hem tractat?
             {
              <</Cyan 0 /Magenta 1 /Yellow 2 /Black 3>>
              paTina get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
              %% 1 index /Range known
              %% {
              %% 1 index dup /Range get
              %% iC0C1 2 mul 2 getinterval /Range exch put
              %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
              dup _C0 exch get
              1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
              1 array astore  %% preparem l'array x reescriure C0
              2 index exch /C0 exch put  %% redefinim C0
              _C1 exch get
              1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
              1 array astore  %% preparem l'array x reescriure C1
              /C1 exch put  %% redefinim C1
             }
             {
              pop
             }ifelse
            }
            {  %% 3
             %%mug@
             %%(\n\n---1959 2005v026bis2\n\n) print flush % error Temporal
             %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
             dup /Range undef
             DeSCoNeGuDa  %% ja l'hem tractada?
             {
              <</Cyan 0 /Magenta 1 /Yellow 2 /Black 3>>
              paTina get /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
              %% dup /Range known
              %% {
              %% dup dup /Range get
              %% iC0C1 2 mul 2 getinterval /Range exch put
              %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
              %%% SI LA TIPUS 3 DUU ELS DICS DE L'ARRAY FUNCTIONS DIRECTES NO ELS TENIM REFERENCIATS AL DIC DES D'ON MODIFIQUEM
              %%% LLAVORS CAL FER LA MODIFICACIO (EN FUNCIO DE LA TINTA) AQUI MATEIX
              %%mug@
              %%(\n\n---1959 2005bis\n\n) print flush        
              dup /Functions get  %% tibem l'array obligatori amb les funcions ...
              {  %% forall x saber si son directes o indirectes?
               dup type /dicttype eq
               {  %% com que son directes les hem de retocar ara i aqui
                %%(funcions directes!) ==
                dup /FunctionType get 2 eq
                {
                 %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
                 dup /Range undef
                 %% Desactivat ... si tinguessim una funcio de tipus 2 sense C0/C1 seria un cas no controlat que aboquem a un error a solucionar quan surti
                 %%_C0 null eq {(\n\nMRCT1959 10\n\n) print flush stop}if
                 <</Cyan 0 /Magenta 1 /Yellow 2 /Black 3>>
                 paTina get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
                 %% 1 index /Range known
                 %% {
                 %% 1 index dup /Range get
                 %% iC0C1 2 mul 2 getinterval /Range exch put
                 %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
                 %% aquest metode no rutlla amb dics directes
                 %% dup _C0 exch get
                 %% 1 exch sub  % al treballar amb DeviceGray hem d'invertir el valor de color
                 %% 1 array astore  % preparem l'array x reescriure C0
                 %% 2 index exch /C0 exch put  % redefinim C0
                 %% _C1 exch get
                 %% 1 exch sub  % al treballar amb DeviceGray hem d'invertir el valor de color
                 %% 1 array astore  % preparem l'array x reescriure C1
                 %% /C1 exch put  % redefinim C1
                 %% al ser dics directes no necessitem per a res les variables _C0 _C1              
                 1 index /C0 get exch get              
                 1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
                 1 array astore  %% preparem l'array x reescriure C0
                 1 index exch /C0 exch put  %% redefinim C0
                 dup /C1 get iC0C1 get 1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
                 1 array astore  %% preparem l'array x reescriure C1
                 /C1 exch put  %% redefinim C1
                }
                {  %% si una 3 no esta formada x tipus 2, ara donem error ...
                 (\n\nMRCT1959 2008bis\n\n) print flush stop  %%quit
                }ifelse
               }
               {  %% si son indirectes no fem res doncs ja estaran referenciades
                %%(COAC ... 4) ==
                pop
               }ifelse
              }forall
             }
             {
              pop
             }ifelse
            }
            {	%% 4 NO implementada encara
            }
           ]      
           exch get cvx exec
          }
          {  %% sera un nom d'un canal d'una Separation
           pop
           JectesPS eSP known
           {
            JectesPS eSP get
            dup type /nametype eq
            {
             %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
             %% RiFT 1 index known
             %% {/DeSCoNeGuDa false def}
             %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
             %%dup == (13) ==
             /aCercar exch def  %% nom amb la ref ind del dic Resources
             /iDimoni 0 def
             {  %% loop d'interrogacio dels dicts de COMdimoni
              currentdict iDimoni 4 string cvs cvn get
              %% el diccionari de l'objecte
              dup aCercar known {aCercar get exit}{pop}ifelse
              iDimoni 1 add /iDimoni exch def
              iDimoni MaxDimoni eq {exit} if
             }loop  %% d'interrogacio dels dicts de COMdimoni
            }if
            /Shading get
           }
           {  %% si no es al dic JectesPS haura d'estar aqui ...
            elsAltresShadings eSP get
            %%(S·U·A·R·A) ==
           }ifelse 
           dup type /nametype eq
           {
            %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
            %% RiFT 1 index known
            %% {/DeSCoNeGuDa false def}
            %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
            %%dup == (14) ==
            /aCercar exch def
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }if
           %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
           dup /Range undef
           %% si existeix canviem l'espai de color del dic ...
           dup /ColorSpace known
           {
            /ColorSpace /DeviceGray put  %% li repiquem l'espai de color x la separacio al dic del Shading Pattern
           }
           {
            pop
           }ifelse
           Fsargit  %% anem a pescar el dic de la funcio sargida (segurament una tipus 2)
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           RiFT 1 index known
           1 index /QuinObDuFD exch def  %% ref ind de l'objecte que duu funcions directes
           {
            /DeSCoNeGuDa false def
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }
           {
            dup  %%RiFT 1 index null
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
            %%dup length dict copy
            %% tractarem els composite objects com a fitxers a disc
            iNousCoOb 1 add /iNousCoOb exch def  %% comptador de nous fitxers composite object
            nousCoOb dup posNum iNousCoOb 10 string cvs putinterval  %% nou fitxer+path
            dup length string copy dup /nousCoOb exch def
            (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2 i /espiapaq_fura3
            %% ho tanquem dins un dict
            Objected'Ara (<<) writestring
            espiadic_fura2
            %% ho tanquem dins un dict
            Objected'Ara dup (>>) writestring closefile
            nousCoOb
            RiFT 3 1 roll put /DeSCoNeGuDa true def
            nousCoOb (r) file cvx exec
            %% repiquem el dic reescrit al seu objecte ref ind original
            currentdict iDimoni 4 string cvs cvn get 1 index QuinObDuFD exch put
           }ifelse
           %%(15) ==
           %%(aviamFT4) ==
           dup /FunctionType known  %% hi es?
           {
            dup /FunctionType get
            [
             {	%% 0 NO implementada encara
             }
             {	%% 1 inexistents
             }
             {	%% 2
              %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
              dup /Range undef
              DeSCoNeGuDa  %% ja l'hem tractat?
              {
               %% dup /Range known
               %% {  % es segur 1 sol element
               %% dup dup /Range get
               %% 0 2 mul 2 getinterval /Range exch put
               %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
               _C0 null eq
               {  %% si es null es que la funcio no duu C0/C1 i llavors cal aplicar els valors x defecte /C0 [0] /C1 [1]
                dup  %% invertim els valors x defecte ...
                /C0 [1] put
                /C1 [0] put
               }
               {
                %%(F2 FT4?) ==
                0  %% es segur 1 sol element
                dup _C0 exch get
                1 exch sub  %% desactivem lla inversio del valor de color?
                1 array astore  %% preparem l'array x reescriure C0
                2 index exch /C0 exch put  %% redefinim C0
                _C1 exch get
                1 exch sub  %% desactivem lla inversio del valor de color?
                1 array astore  %% preparem l'array x reescriure C1
                /C1 exch put  %% redefinim C1
               }ifelse
              }
              {
               pop
              }ifelse
             }
             {  %% 3
              %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
              dup /Range undef
              DeSCoNeGuDa  %% ja l'hem tractat?
              {
               %%% SI LA TIPUS 3 DUU ELS DICS DE L'ARRAY FUNCIONS DIRECTES NO ELS TENIM REFERENCIATS AL DIC DES D'ON MODIFIQUEM
               %%% LLAVORS CAL FER LA MODIFICACIO (EN FUNCIO DE LA TINTA) AQUI MATEIX
               %%mug@
               %%(\n\n---1959 2005_c\n\n) print flush        
               dup /Functions get  %% tibem l'array obligatori amb les funcions ...
               {  %% forall x saber si son directes o indirectes?
                dup type /dicttype eq
                {  %% com que son directes les hem de retocar ara i aqui
                 %%(funcions directes!!) ==
                 dup /FunctionType get 2 eq
                 {
                  %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
                  dup /Range undef
                  0  %% es segur 1 sol element
                  dup 2 index /C0 get exch get
                  1 exch sub  %% xq al treballar amb DeviceGray NO hem d'invertir el valor de color?
                  1 array astore  %% preparem l'array x reescriure C0
                  2 index exch /C0 exch put  %% redefinim C0
                  1 index /C1 get exch get
                  1 exch sub  %% xq al treballar amb DeviceGray NO hem d'invertir el valor de color?
                  1 array astore  %% preparem l'array x reescriure C1
                  /C1 exch put  %% redefinim C1
                 }
                 {  %% si una 3 no esta formada x tipus 2, ara donem error ...
                  (\n\nMRCT1959 2008\n\n) print flush stop  %%quit
                 }ifelse
                }
                {  %% si son indirectes no fem res doncs ja estaran referenciades
                 %%(COAC ... 5) ==
                 pop
                }ifelse
               }forall
              }
              {
               pop
              }ifelse
             }
             {	%% 4 NO implementada encara
             }
            ]      
            exch get cvx exec
           }
           {  %% si no hi es, es que es tracta del dic del Shading ...
            dup /ColorSpace /DeviceGray put  %% li repiquem l'espai de color x la separacio al dic del Shading Pattern
            %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
            dup /Range undef
            /Function get  %% anem a pescar el dic de la funcio (directe o indirecte)
            dup type /nametype eq
            {
             %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
             RiFT 1 index known
             1 index /QuinObDuFD exch def  %% ref ind de l'objecte que duu funcions directes
             {
              /DeSCoNeGuDa false def
              /aCercar exch def  %% nom amb la ref ind del dic Resources
              /iDimoni 0 def
              {  %% loop d'interrogacio dels dicts de COMdimoni
               currentdict iDimoni 4 string cvs cvn get
               %% el diccionari de l'objecte
               dup aCercar known {aCercar get exit}{pop}ifelse
               iDimoni 1 add /iDimoni exch def
               iDimoni MaxDimoni eq {exit} if
              }loop  %% d'interrogacio dels dicts de COMdimoni
             }
             {
              dup  %%RiFT 1 index null
              /aCercar exch def  %% nom amb la ref ind del dic Resources
              /iDimoni 0 def
              {  %% loop d'interrogacio dels dicts de COMdimoni
               currentdict iDimoni 4 string cvs cvn get
               %% el diccionari de l'objecte
               dup aCercar known {aCercar get exit}{pop}ifelse
               iDimoni 1 add /iDimoni exch def
               iDimoni MaxDimoni eq {exit} if
              }loop  %% d'interrogacio dels dicts de COMdimoni
              %%dup length dict copy
              %% tractarem els composite objects com a fitxers a disc
              iNousCoOb 1 add /iNousCoOb exch def  %% comptador de nous fitxers composite object
              nousCoOb dup posNum iNousCoOb 10 string cvs putinterval  %% nou fitxer+path
              dup length string copy dup /nousCoOb exch def
              (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2 i /espiapaq_fura3
              %% ho tanquem dins un dict
              Objected'Ara (<<) writestring
              espiadic_fura2
              %% ho tanquem dins un dict
              Objected'Ara dup (>>) writestring closefile
              nousCoOb
              RiFT 3 1 roll put /DeSCoNeGuDa true def
              nousCoOb (r) file cvx exec
              %% repiquem el dic reescrit al seu objecte ref ind original
              currentdict iDimoni 4 string cvs cvn get 1 index QuinObDuFD exch put
             }ifelse
             %%(16) ==
            }if
            dup /FunctionType get
            [
             {	%% Tipus 0 NO implementada encara
             }
             {	%% Tipus 1 inexistents
             }
             {	%% Tipus 2
              %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
              dup /Range undef
              DeSCoNeGuDa  %% ja l'hem tractat?
              {
               %% dup /Range known
               %% {  % es segur 1 sol element
               %% dup dup /Range get
               %% 0 2 mul 2 getinterval /Range exch put
               %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
               _C0 null eq
               {  %% si es null es que la funcio no duu C0/C1 i llavors cal aplicar els valors x defecte /C0 [0] /C1 [1]
                dup  %% invertim els valors x defecte ...
                /C0 [1] put
                /C1 [0] put
               }
               {
                0  %% es segur 1 sol element
                dup _C0 exch get
                1 exch sub  %% xq desactivem la inversio del valor de color?
                1 array astore  %% preparem l'array x reescriure C0
                2 index exch /C0 exch put  %% redefinim C0
                _C1 exch get
                1 exch sub  %% xq desactivem la inversio del valor de color?
                1 array astore  %% preparem l'array x reescriure C1
                /C1 exch put  %% redefinim C1
               }ifelse
              }
              {
               pop
              }ifelse
             }
             {	%% Tipus 3
              %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
              dup /Range undef
              DeSCoNeGuDa  %% ja l'hem tractat?
              {
               %% dup /Range known
               %% {  % es segur 1 sol element
               %% dup dup /Range get
               %% 0 2 mul 2 getinterval /Range exch put
               %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
               %%% SI LA TIPUS 3 DUU ELS DICS DE L'ARRAY FUNCIONS DIRECTES NO ELS TENIM REFERENCIATS AL DIC DES D'ON MODIFIQUEM
               %%% LLAVORS CAL FER LA MODIFICACIO (EN FUNCIO DE LA TINTA) AQUI MATEIX
               %%mug@
               %%(\n\n---1959 2005_b\n\n) print flush
               dup /Functions get  %% tibem l'array obligatori amb les funcions ...
               {  %% forall x saber si son directes o indirectes?
                dup type /dicttype eq
                {  %% com que son directes les hem de retocar ara i aqui
                 %% (funcions directes!) ==
                 dup /FunctionType get 2 eq
                 {
                  %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
                  dup /Range undef
                  %% dup /Range known
                  %% {  % es segur 1 sol element
                  %% dup dup /Range get
                  %% 0 2 mul 2 getinterval /Range exch put
                  %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
                  %% Desactivat ... si tinguessim una funcio de tipus 2 sense C0/C1 seria un cas no controlat que aboquem a un error a solucionar quan surti
                  %%_C0 null eq {(\n\nMRCT1959 10\n\n) print flush stop}if
                  0  %% es segur 1 sol element
                  dup 2 index /C0 get exch get
                  1 exch sub  %% xq al treballar amb DeviceGray NO hem d'invertir el valor de color?
                  1 array astore  %% preparem l'array x reescriure C0
                  2 index exch /C0 exch put  %% redefinim C0
                  1 index /C1 get exch get
                  1 exch sub  %% xq al treballar amb DeviceGray NO hem d'invertir el valor de color?
                  1 array astore  %% preparem l'array x reescriure C1
                  /C1 exch put  %% redefinim C1
                 }
                 {  %% si una 3 no esta formada x tipus 2, ara donem error ...
                  (\n\nMRCT1959 2008\n\n) print flush stop  %%quit
                 }ifelse
                }
                {  %% si son indirectes no fem res doncs ja estaran referenciades
                 %%(COAC ... 6) ==
                 pop
                }ifelse
               }forall
              }
              {
               pop
              }ifelse
             }
             {	%% 4 NO implementada encara
             }
            ]      
            exch get cvx exec
           }ifelse
          }ifelse
         }
         {  %% sera una array d'un DeviceN      
          /AindexarCanals exch def  %% desem l'array dels canals de color x fer-ne + endavant un dic amb els index
          JectesPS eSP known
          {
           JectesPS eSP get
           dup type /nametype eq
           {
            %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
            %% RiFT 1 index known
            %% {/DeSCoNeGuDa false def}
            %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
            %%dup == (17) ==
            /aCercar exch def  %% nom amb la ref ind del dic Resources
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
           }if
           /Shading get
          }
          {  %% si no es al dic JectesPS haura d'estar aqui ...
           elsAltresShadings eSP get
           %%(C·A·M·P·O·R·E·L·L·S) ==
          }ifelse
          dup type /nametype eq
          {
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           %% RiFT 1 index known
           %% {/DeSCoNeGuDa false def}
           %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
           %%dup == (18) ==
           /aCercar exch def  %% nom amb la ref ind del dic Resources
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
          }if
          dup /ColorSpace /DeviceGray put  %% li repiquem l'espai de color x la separacio al dic del Shading Pattern
          %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
          dup /Range undef
          /Function get  %% anem a pescar el dic de la funcio (directe o indirecte)
          dup type /nametype eq
          {
           %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
           %% RiFT 1 index known
           %% {/DeSCoNeGuDa false def}
           %% {RiFT 1 index null put /DeSCoNeGuDa true def}ifelse
           %%dup == %(19) ==
           /aCercar exch def  %% nom amb la ref ind del dic Resources
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
          }if
          %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
          /Range undef
          %% DeSCoNeGuDa  % ja l'hem tractada?
          %% {
          %% AindexarCanals
          %% /iXc 0 def  % donara els index xcanal cara a gestionar els valors de C0/C1
          %% /deXcanal 2 dict def  % diccionari amb els index x canal de color
          %% {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
          %% deXcanal
          %% paTina get /iC0C1 exch def  % anem a pescar l'index del valor C0/C1 que reescriurem ...
          %% dup /Range known
          %% {
          %% dup /Range get
          %% iC0C1 2 mul 2 getinterval /Range exch put
          %% }{pop}ifelse  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
          %% }{pop}ifelse
          %% fi de redefinicio de Range a la funcio de tipus 3
          Fsargit
          %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
          RiFT 1 index known
          1 index /QuinObDuFD exch def  %% ref ind de l'objecte que duu funcions directes
          {
           /DeSCoNeGuDa false def
           /aCercar exch def  %% nom amb la ref ind del dic Resources
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni        
          }
          {
           dup  %%RiFT 1 index null
           /aCercar exch def  %% nom amb la ref ind del dic Resources
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
           %%dup length dict copy
           %% tractarem els composite objects com a fitxers a disc
           iNousCoOb 1 add /iNousCoOb exch def  %% comptador de nous fitxers composite object
           nousCoOb dup posNum iNousCoOb 10 string cvs putinterval  %% nou fitxer+path
           dup length string copy dup /nousCoOb exch def
           (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2 i /espiapaq_fura3
           %% ho tanquem dins un dict
           Objected'Ara (<<) writestring
           espiadic_fura2
           %% ho tanquem dins un dict
           Objected'Ara dup (>>) writestring closefile
           nousCoOb
           RiFT 3 1 roll put /DeSCoNeGuDa true def
           nousCoOb (r) file cvx exec
           %% repiquem el dic reescrit al seu objecte ref ind original
           currentdict iDimoni 4 string cvs cvn get 1 index QuinObDuFD exch put
          }ifelse
          %%(19bis) ==
          %%(aviamFT5) ==
          dup /FunctionType known  %% com es que hi ha casos en que no HI ES ????
          {
           dup /FunctionType get
           [
            {	%% Tipus 0 NO implementada encara
            }
            {	%% Tipus 1 inexistents
            }
            {	%% Tipus 2
             %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
             dup /Range undef
             DeSCoNeGuDa  %% ja l'hem tractada?
             {
              %%(F2 FT5?) ==
              %% si tinguessim una funcio de tipus 2 sense C0/C1 seria un cas no controlat que aboquem a un error a solucionar quan surti
              _C0 null eq
              {  %% si es null es que la funcio no duu C0/C1 i llavors cal aplicar els valors x defecte /C0 [0] /C1 [1]
               %%(\n\nMRCT1959 10\n\n) print flush stop
               dup  %% invertim els valors x defecte ...
               /C0 [1] put
               /C1 [0] put
               %% dup  % invertim els valors x defecte ...
               %% /C0 AindexarCanals length {1}repeat  % tants 'uns' com canals
               %% AindexarCanals length array astore put
               %% /C1 AindexarCanals length {0}repeat  % tants 'zeros' com canals
               %% AindexarCanals length array astore put
              }
              {
               AindexarCanals
               /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
               /deXcanal 2 dict def  %% diccionari amb els index x canal de color
               {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
               deXcanal
               paTina get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
               %% 1 index /Range known
               %% {
               %% 1 index dup /Range get
               %% iC0C1 2 mul 2 getinterval /Range exch put
               %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
               dup _C0 exch get
               1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
               1 array astore  %% preparem l'array x reescriure C0
               2 index exch /C0 exch put  %% redefinim C0
               _C1 exch get
               1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
               1 array astore  %% preparem l'array x reescriure C1
               /C1 exch put  %% redefinim C1
              }ifelse
             }
             {
              pop
             }ifelse
            }
            {  %% Tipus 3
             %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
             dup /Range undef
             DeSCoNeGuDa  %% ja l'hem tractada?
             {
              AindexarCanals
              /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
              /deXcanal 2 dict def  %% diccionari amb els index x canal de color
              {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
              deXcanal
              paTina get /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
              %% dup /Range known
              %% {
              %% dup dup /Range get
              %% iC0C1 2 mul 2 getinterval /Range exch put
              %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
              %%% SI LA TIPUS 3 DUU ELS DICS DE L'ARRAY FUNCTIONS DIRECTES NO ELS TENIM REFERENCIATS AL DIC DES D'ON MODIFIQUEM
              %%% LLAVORS CAL FER LA MODIFICACIO (EN FUNCIO DE LA TINTA) AQUI MATEIX
              %%mug@
              %%(\n\n---1959 2005bis\n\n) print flush
              dup /Functions get  %% tibem l'array obligatori amb les funcions ...
              {  %% forall x a cada una de les stitching i saber si son directes o indirectes?
               dup type /dicttype eq
               {  %% com que son directes les hem de retocar ara i aqui
                %%(funcions directes!) ==
                dup /FunctionType get 2 eq
                {
                 %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
                 dup /Range undef
                 %% Desactivat ... si tinguessim una funcio de tipus 2 sense C0/C1 seria un cas no controlat que aboquem a un error a solucionar quan surti
                 %%_C0 null eq {(\n\nMRCT1959 10\n\n) print flush stop}if
                 AindexarCanals
                 /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
                 /deXcanal 2 dict def  %% diccionari amb els index x canal de color
                 {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
                 deXcanal
                 paTina get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
                 %% 1 index /Range known
                 %% {
                 %% 1 index dup /Range get
                 %% iC0C1 2 mul 2 getinterval /Range exch put
                 %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
                 %% al ser dics directes no necessitem per a res les variables _C0 _C1              
                 1 index /C0 get exch get              
                 1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
                 1 array astore  %% preparem l'array x reescriure C0
                 1 index exch /C0 exch put  %% redefinim C0
                 dup /C1 get iC0C1 get 1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
                 1 array astore  %% preparem l'array x reescriure C1
                 /C1 exch put  %% redefinim C1
                }
                {  %% si una 3 no esta formada x tipus 2, ara donem error ...
                 (\n\nMRCT1959 2008\n\n) print flush stop  %%quit
                }ifelse
               }
               {  %% si son indirectes no fem res doncs ja estaran referenciades
                %%(COAC ... 7) ==
                pop
               }ifelse
              }forall
             }
             {
              pop
             }ifelse
            }
            {	%% Tipus 4 NO implementada encara
            }
           ]
           exch get cvx exec
          }
          {  %% si no hi es, es que es tracta del dic del Shading ...
           dup /ColorSpace /DeviceGray put  %% li repiquem l'espai de color x la separacio al dic del Shading Pattern
           %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
           dup /Range undef
           /Function get  %% anem a pescar el dic de la funcio (directe o indirecte)
           dup type /nametype eq
           {
            %% x evitar intents de modificacio doble a funcions de tipus 2 i 3
            RiFT 1 index known
            1 index /QuinObDuFD exch def  %% ref ind de l'objecte que duu funcions directes
            {
             /DeSCoNeGuDa false def
             /aCercar exch def  %% nom amb la ref ind del dic Resources
             /iDimoni 0 def
             {  %% loop d'interrogacio dels dicts de COMdimoni
              currentdict iDimoni 4 string cvs cvn get
              %% el diccionari de l'objecte
              dup aCercar known {aCercar get exit}{pop}ifelse
              iDimoni 1 add /iDimoni exch def
              iDimoni MaxDimoni eq {exit} if
             }loop  %% d'interrogacio dels dicts de COMdimoni
            }
            {
             dup  %%RiFT 1 index null
             /aCercar exch def  %% nom amb la ref ind del dic Resources
             /iDimoni 0 def
             {  %% loop d'interrogacio dels dicts de COMdimoni
              currentdict iDimoni 4 string cvs cvn get
              %% el diccionari de l'objecte
              dup aCercar known {aCercar get exit}{pop}ifelse
              iDimoni 1 add /iDimoni exch def
              iDimoni MaxDimoni eq {exit} if
             }loop  %% d'interrogacio dels dicts de COMdimoni
             %%dup length dict copy
             %% tractarem els composite objects com a fitxers a disc
             iNousCoOb 1 add /iNousCoOb exch def  %% comptador de nous fitxers composite object
             nousCoOb dup posNum iNousCoOb 10 string cvs putinterval  %% nou fitxer+path
             dup length string copy dup /nousCoOb exch def
             (w) file /Objected'Ara exch def  %% desem el fitxer d'escriptura a la variable q fa servir /espiadic_fura2 i /espiapaq_fura3
             %% ho tanquem dins un dict
             Objected'Ara (<<) writestring
             espiadic_fura2
             %% ho tanquem dins un dict
             Objected'Ara dup (>>) writestring closefile
             nousCoOb
             RiFT 3 1 roll put /DeSCoNeGuDa true def
             nousCoOb (r) file cvx exec
             %% repiquem el dic reescrit al seu objecte ref ind original
             currentdict iDimoni 4 string cvs cvn get 1 index QuinObDuFD exch put
            }ifelse
            %%(20) ==
           }if
           dup /FunctionType get
           [
            {	%% Tipus 0 NO implementada encara
            }
            {	%% Tipus 1 inexistents
            }
            {	%% Tipus 2
             %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
             dup /Range undef
             DeSCoNeGuDa  %% ja l'hem tractada?
             {
              AindexarCanals
              /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
              /deXcanal 2 dict def  %% diccionari amb els index x canal de color
              {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
              deXcanal
              paTina get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
              %% 1 index /Range known
              %% {
              %% 1 index dup /Range get
              %% iC0C1 2 mul 2 getinterval /Range exch put
              %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
              _C0 null eq
              {  %% si es null es que la funcio no duu C0/C1 i llavors cal aplicar els valors x defecte /C0 [0] /C1 [1]
               dup  %% invertim els valors x defecte ...
               /C0 [1] put
               /C1 [0] put
               %% pop
               %% dup  % invertim els valors x defecte ...
               %% /C0 AindexarCanals length {1}repeat  % tants 'uns' com canals
               %% AindexarCanals length array astore put
               %% /C1 AindexarCanals length {0}repeat  % tants 'zeros' com canals
               %% AindexarCanals length array astore put
              }
              {
               dup _C0 exch get
               1 exch sub  %% desactivem lla inversio del valor de color?
               1 array astore  %% preparem l'array x reescriure C0
               2 index exch /C0 exch put  %% redefinim C0
               _C1 exch get
               1 exch sub  %% desactivem la inversio del valor de color?
               1 array astore  %% preparem l'array x reescriure C1
               /C1 exch put  %% redefinim C1
              }ifelse
             }
             {
              pop
             }ifelse
            }
            {  %% Tipus 3
             %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
             dup /Range undef
             DeSCoNeGuDa  %% ja l'hem tractada?
             {
              AindexarCanals
              /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
              /deXcanal 2 dict def  %% diccionari amb els index x canal de color
              {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
              deXcanal
              paTina get /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
              %% dup /Range known
              %% {
              %% dup dup /Range get
              %% iC0C1 2 mul 2 getinterval /Range exch put
              %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
              %%% SI LA TIPUS 3 DUU ELS DICS DE L'ARRAY FUNCIONS DIRECTES NO ELS TENIM REFERENCIATS AL DIC DES D'ON MODIFIQUEM
              %%% LLAVORS CAL FER LA MODIFICACIO (EN FUNCIO DE LA TINTA) AQUI MATEIX
              %%mug@
              %%(\n\n---1959 2005_a\n\n) print flush
              dup /Functions get  %% tibem l'array obligatori amb les funcions ...
              {  %% forall x saber si son directes o indirectes?
               dup type /dicttype eq
               {  %% com que son directes les hem de retocar ara i aqui
                %%RiFT QuinObDuFD get (r) file cvx exec {== ==}forall ( ... ) pstack quit
                %%(funcions directes!) ==
                dup /FunctionType get 2 eq
                {
                 %%RiFT
                 %% /8______________0 get /Function get /Functions get 0 get
                 %%{== ==}forall (:::) == quit             
                 %% com que hem vist que /Range nomes es obligatori x les funcions de tipus 0 i 4 llavors l'eliminem arreu (F2 i F3)
                 dup /Range undef
                 %% Desactivat ... si tinguessim una funcio de tipus 2 sense C0/C1 seria un cas no controlat que aboquem a un error a solucionar quan surti
                 %%_C0 null eq {(\n\nMRCT1959 10\n\n) print flush stop}if
                 AindexarCanals
                 /iXc 0 def  %% donara els index xcanal cara a gestionar els valors de C0/C1
                 /deXcanal 2 dict def  %% diccionari amb els index x canal de color
                 {deXcanal exch iXc put iXc 1 add /iXc exch def}forall
                 deXcanal
                 paTina get dup /iC0C1 exch def  %% anem a pescar l'index del valor C0/C1 que reescriurem ...
                 %% 1 index /Range known
                 %% {
                 %% 1 index dup /Range get
                 %% iC0C1 2 mul 2 getinterval /Range exch put
                 %% }if  % si hi ha Range ens assegurem de redefinir-lo amb el parell de l'index que toqui
                 %% aquest metode no rutlla amb funcions directes
                 %% dup _C0 exch get
                 %% 1 exch sub  % al treballar amb DeviceGray hem d'invertir el valor de color
                 %% 1 array astore  % preparem l'array x reescriure C0
                 %% 2 index exch /C0 exch put  % redefinim C0
                 %% _C1 exch get
                 %% 1 exch sub  % al treballar amb DeviceGray hem d'invertir el valor de color
                 %% 1 array astore  % preparem l'array x reescriure C1
                 %% /C1 exch put  % redefinim C1
                 %% al ser dics directes no necessitem per a res les variables _C0 _C1              
                 1 index /C0 get exch get              
                 1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
                 1 array astore  %% preparem l'array x reescriure C0
                 1 index exch /C0 exch put  %% redefinim C0
                 dup /C1 get iC0C1
                 get 1 exch sub  %% al treballar amb DeviceGray hem d'invertir el valor de color
                 1 array astore  %% preparem l'array x reescriure C1
                 /C1 exch put  %% redefinim C1
                }
                {  %% si una 3 no esta formada x tipus 2, ara donem error ...
                 (\n\nMRCT1959 2009\n\n) print flush stop  %%quit
                }ifelse
               }
               {  %% si son indirectes no fem res doncs ja estaran referenciades
                %%(COAC ... 8) ==
                pop
               }ifelse
              }forall
             }
             {
              pop
             }ifelse
            }
            {	%% 4 NO implementada encara
            }
           ]
           exch get cvx exec
          }ifelse
         }ifelse
        }forall  %% x cada ref ind + array     
        paTina  %% tornem a deixar al Tinta a la pila !!!
       }ifelse  %% es un array o un dic ?    
      }
      {  %% si no, sera una string que ens dira que es tracta d'un Tiling Colored Pattern
       /pathPSsep exch def  %% desem el path amb la separacio corresponent de l'stream
       JectesPS exch get  %% extraiem la ref ind del Colored Pattern a modificar-ne el dic
       /aCercar exch def  %% nom amb la ref ind de l'objecte Colored Pattern
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
       %% al dic del Colored Pattern ...
       dup /Filter undef  %% li rematem /Filter de forma fixa
       %% el path de la separacio del Colored Pattern l'incrustem a l'array de /XIU
       dup 1 array dup 0 pathPSsep put /XIU exch put  %% redefinim /XIU
       %% no cal xq la redefinicio de /stream ja es prou completa
       %%     % interroguem els bytes del fitxer per modificar /Length
       %%     pathPSsep status pop pop pop /FaFtxr exch def pop  % bytes totals del fitxer
       %%     /Length FaFtxr put  % redefinim els bytes del stream del Colored Pattern
      }ifelse
     }forall  %% x cada Pattern&Shading
    }if
   }if  %% modificarem l'stream dels dics dels Patterns&Shadings
  }if %/01 SEPARACIÓ DE TINTES

%:00 REESCRIPTURA IDEM
%:01 SEPARACIÓ DE TINTES
%:02 MARQUES DE TALL
%:03 CORRECTOR TIPOGRÀFIC
%:05 dada variable
%:06 COSIT D'IMATGES
%:07 REINSEREIX IMATGES JPEG
%:08 ETIQUETA TEXT
%:10 PREFLIGHT AMB CAPES
%:12 arbre jeràrquic
%:13 eliminem continguts de pàgina
%:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%:15 ELIMINA LLESQUES
%:17 ENCAVALCA CONTINGUTS

  %% x si queden dics indesitjables q hauriem de polir de l'if de + amunt
  count 1 sub {exch pop}repeat
  %%(*******FINS*******) == RiFT {== ==} forall
  %%(*******ARA*******) pstack quit

  %#%44% filtrem el nom de: el PDF a reescriure o la Tinta a separar
  (%#%44%)==
  %% amolla un(s) nou(s) caracter en lloc d'un(s) altre(s)
  () /amolla exch def
  (#20) /cErquEm exch def  %% cadena que cerquem (ara en tenim prou filtrant #20 com a espai per guiobaix)
  (_) /HiPosem exch def  %% cadena que hi posem
  dup /quinaTinta exch def  %% desem el literal de la tinta que llesquem
  128 string cvs  %% la cadena on apliquem l'algorisme de filtrat p.e. (PANTONE#20117#20CVC)
  {  %% loop
   cErquEm search
   {
    dup length
    amolla length dup /afG exch def
    add dup /aON2 exch def HiPosem length add string dup
    0 amolla putinterval dup afG 4 -1 roll putinterval
    dup aON2 HiPosem putinterval /amolla exch def
    pop
   }
   {
    dup length
    amolla length dup /afG exch def
    add string dup
    0 amolla putinterval dup afG 4 -1 roll putinterval
    /amolla exch def
    exit
   }ifelse
  }loop
  %% ara al nom del PDF de sortida li afegim el nom de cada Tinta a separar
  amolla length
  nomFITX length dup /VaS exch def add 1 add string dup 0 nomFITX
  putinterval dup VaS (_) putinterval
  dup VaS 1 add amolla putinterval
  QueLiFemFer 1 eq
  {
   %%% treiem per la pantalleta el nom de la Tinta que llesquem
   (\nTint ... ) print flush
  }  %/01 SEPARACIÓ DE TINTES
  {
   %%% treiem per la pantalleta el nom diferencial del PDF que reescrivim
   BaBeL 51 get print flush
  }ifelse
  amolla
  print flush
  (\n) print flush

  %#%45% posem el farcidor de _ per als caràcters indesitjables
  (%#%45%)==
  /idena 0 def
  /dena exch def
  /Mai  %% (*? .:,;/\\) eren els q filtravem abans
  ( .,;:?*#!§$%&/\(\){}<>=`´|\\'") def  %% els caracters indesitjables (els fem quadrar amb filtrat d'executal.php)
  %% aquí podriem aplicar la sintaxi de les regular expressions?
  dena
  {  %% forall
   /SiMai false def
   /A_ exch def Mai {A_ eq {/SiMai true def exit}if}forall
   SiMai {dena idena 95 put}if
   idena 1 add /idena exch def
  }forall
  %% llistem el nom de la layer Xtest
  %%dena == quit
  %%% ALERTA
  %%save /Salva'm exch def

  %#%46% redefinició dels path i els índex pel repicat dels nous streams
  (%#%46%)==
  %%% !!!!!!!!!!
  (1__________.nou) dup length faPath add string dup /pAthXiU exch def
  0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
  pAthXiU /nousStreams exch def  %% utilitzat per l'applet per desar els nous streams redefinits al disc
  %% EP! el posem fora de la roda ...
  %%1 /iNousStreams exch def  % index per assignar noms als nous streams repicats
  nousStreams length 15 sub /posNum exch def  %% posicio d'inici fixa del numerador d'streams

  %#%47% tanquem fitxers per profilaxi (és necessari?)
  (%#%47%)==
  sEdAs status
  {  %%(sEdAs) ==
   sEdAs closefile
  }if
  %% REPIcA status {
  %%               (REPIcA) ==
  %%                REPIcA closefile
  %%               REPIcA status {(REPIcA2) ==}if
  %%               }if
  %% bociStream status { %(bociStream) ==
  %%                    bociStream closefile
  %%                   }if
  wFitxerXRay status
  {  %%(wFitxerXRay) ==
   wFitxerXRay closefile
  }if
  %% (r) de lectura ...
  aLLeGiR status
  {  %%(aLLeGiR) ==
   aLLeGiR closefile
  }if
  %% totStream status { %(totStream) ==
  %%                   totStream closefile
  %%                  }if

  %#%48% donem de baixa l'única entrada que no és un objecte
  (%#%48%)==
  /iDimoni 0 def
  {  %% loop de descarrega de definicions pels dic creats
   currentdict iDimoni 4 string cvs cvn get
   /tauXref undef
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  }loop  %% de descarrega

%/17 ENCAVALCA CONTINGUTS
%/15 ELIMINA LLESQUES
%/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%/13 eliminem continguts de pàgina
%/12 arbre jeràrquic
%/10 PREFLIGHT AMB CAPES
%/08 ETIQUETA TEXT
%/07 REINSEREIX IMATGES JPEG
%/06 COSIT D'IMATGES
%/05 dada variable
%/03 CORRECTOR TIPOGRÀFIC
%/02 MARQUES DE TALL
%/01 SEPARACIÓ DE TINTES
%/00 REESCRIPTURA IDEM

  QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
  {
   %#%48bis# aquí donem de baixa l'entrada /Range a uns objectes, que si hi són, no hi havia manera d'esborrar-la abans
   (%#%48bis%)==
   currentdict /DarrersRange known
   {
    DarrersRange
    {  %% forall
     pop
     /aCercar exch def  %% nom amb la ref ind de l'objecte Colored Pattern
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get /Range undef exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop  %% d'interrogacio dels dicts de COMdimoni
    }forall
   }if
  }if  %/01 SEPARACIÓ DE TINTES

%:00 REESCRIPTURA IDEM
%:01 SEPARACIÓ DE TINTES
%:02 MARQUES DE TALL
%:03 CORRECTOR TIPOGRÀFIC
%:05 dada variable
%:06 COSIT D'IMATGES
%:07 REINSEREIX IMATGES JPEG
%:08 ETIQUETA TEXT
%:10 PREFLIGHT AMB CAPES
%:12 arbre jeràrquic
%:13 eliminem continguts de pàgina
%:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%:15 ELMINA LLESQUES
%:17 ENCAVALCA CONTINGUTS

  %#%49% busquem el número del darrer objecte actiu (QuiEsAra) i del primer (elPrimer)
  (%#%49%)==
  /elPrimer 100000 def
  /QuiEsAra 0 def
  /iDimoni 0 def
  {  %% loop
   currentdict iDimoni 4 string cvs get
   {  %% forall
    pop
    16 string cvs (_) search pop cvi dup QuiEsAra gt
    {
     dup
     /QuiEsAra exch def
     dup elPrimer lt {/elPrimer exch def}{pop}ifelse
    }
    {
     dup elPrimer lt {/elPrimer exch def}{pop}ifelse
    }ifelse pop pop
   }forall
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  }loop
  %% es un error utilitzar el num real del primer objecte com a index
  %% per generar l'xref, llavors desarem elPrimer en una altre variable
  %% i a elPrimer li donarem sempre valor 1, doncs en PDFs que el primer objecte
  %% no es l'1 hem vist que l'xref era erroni en la descripcio dels primers objectes f
  elPrimer /elPrimerARA exch def
  /elPrimer 1 def

%%QuiEsAra(********)pstack quit

  %#%49bis% tractem el Subject + Title + Author + Creator + CreationDate/ModDate de l'Info ...
  (%#%49bis%)==
  TAUxREF xref+nova 10 string cvs cvn get  %% el dic Trailer x tractar Info
  %% repiquem el Subject al dic Info i si no existeix Info el creem? ...
  %% ara al nom del PDF de sortida li afegim el nom de la clau /quinaTinta
  %% (distintiu genèric, cada Tinta a separar o cada PDF amb dada variable)

  %#%49bis2% definim el contingut del Subject del DocInfo
  (%#%49bis2%)==
  [
   [
    (Reescriptura )  %% 0
    (rewriting )
   ]
   [
    (Separació de Tintes )  %% 1
    (color separation )
   ]
   [
    (Creus de Tall ) %% 2
    (trim marks )
   ]
   [
    (Corrector Tipogràfic )  %% 3
    (typographic correction )
   ]
   [
    (Analisi Textual )  %% 4
    (textual analysis )
   ]
   [
    (Dada Variable )  %% 5
    (variable data )
   ]
   [
    (Cosit d'Imatges )  %% 6
    (image unstitch )
   ]
   [
    (Reinsereix Imatges JPEG )  %% 7
    (reinserts JPEG images )
   ]
   [
    (Etiqueta Text )  %% 8
    (tagging text )
   ]
   [
    (Extrau Imatges JPEG )  %% 9
    (extracts JPEG images )
   ]
   [
    (Espècimens digitals amb Capes )  %% 10
    (layers per data specimens )
   ]
   [
    null  %% 11 (torsimany 4+8)
    null
   ]
   [
    (Arbre Jeràrquic )  %% 12
    (hierarchical tree )
   ]
   [
    (Elimina Continguts )  %% 13
    (cleaning contents )
   ]
   [
    (Restaura Continguts )  %% 14
    (restoring contents )
   ]
   [
    (Elimina Continguts de Capes )  %% 15
    (debugging layers with contents )
   ]
   [
    (Treu i Fica Text )  %% 16
    (swapping text )
   ]
   [
    (Encavalca Continguts )  %% 17 %%MASATSencvlct
    (overlaps contents )
   ]
  ]
  QueLiFemFer get  %% text del Subject
  lleNguatge get  %% per idioma
  /genericSubject exch def  %% nom generic pel principi del Subject
  /araCDstring (D:) def  %% cadena d'inici per la Creation Date
  elDicInfo null eq
  {  %% si no hi ha Info el creem
   /Info << >>
   dup /Producer
   %% (GNU AGPL FemFum CaLi2CoPi ¸.·´¯`·.¸.·´¨«~)  %% WinAnsi no es veu bé als nous Viewers
   %% en Unicode per tal que funcioni bé amb tots els sistemes
   <feff0047004e00550020004100470050004c002000460065006d00460075006d002000430061004c006900320043006f00500069002000b8002e00b700b400af006000b7002e00b8002e00b700b400a800ab007e>
   put  %% afegim Producer
   dup
   quinaTinta 128 string cvs dup /amolla exch def length
   genericSubject length dup /VaS exch def add string dup 0 genericSubject
   putinterval dup VaS amolla putinterval
   /Subject exch put  %% afegim Subject
   dup /Title dena put  %% afegim Title
   dup /Author   %% (¸.·´¯`·.¸.·´¨«~)  %% en WinAnsi no es veu bé als nous Viewers
   %% en Unicode per tal que funcioni bé amb tots els sistemes
   <feff00b8002e00b700b400af006000b7002e00b8002e00b700b400a800ab007e>
   put  %% afegim Author
   dup /Creator  %% (¸.·´¯`·.¸.·´¨«~)  %% en WinAnsi no es veu bé als nous Viewers
   %% en Unicode per tal que funcioni bé amb tots els sistemes
   <feff00b8002e00b700b400af006000b7002e00b8002e00b700b400a800ab007e>
   put  %% afegim Creator
   %% Detecta si l'interpret PS duu el recurs %Calendar% (p.e. GS)
   %% si el duu llavors farceix una cadena segons la sintaxi del Creation Date d'AcrobatPDF
   (%Calendar%) /IODevice resourcestatus  %% existeix el recurs del calendari+rellotge?
   {  %% existeix! (probablement siguem dins GS)
    pop pop  %% ens carreguem les altres dues respostes del query
    %% /araCDstring (D:) def  %% cadena d'inici per la Creation Date
    (%Calendar%) currentdevparams  %%{== ==}forall quit
    dup /Running get
    {  %% suposem q per refiar-nos del calendari aquesta entrada ha d'estar a true
     dup /Year get
     4 string cvs dup length araCDstring length dup /afegit exch def add string dup
     0 araCDstring putinterval dup afegit 4 -1 roll putinterval /araCDstring exch def
     dup /Month get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
     dup /Day get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
     dup /Hour get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
     dup /Minute get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
     /Second get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
    }
    {  %% si Running es a false deixem un missatge d'avis, pero no fem res ...
     pop
     (\n ... >>> Hi ha %Calendar% pero Running es a false :-\( \n) print flush
    }ifelse
    dup /CreationDate araCDstring put  %% afegim CreationDate
    dup /ModDate araCDstring put  %% afegim ModDate
   }if
   %% si NO existeix ... probablement siguem a Distiller
   put  %% afegim Info
  }
  {  %% si hi es, modifiquem Subject, Author, Title i CreationDate/ModDate
    %% tret q fem l'opcio 8 de JBC on nomes modifiquem el CreationDate/ModDate
   /Info get
   dup type /nametype eq
   {
    /laBranca exch def
    %% pesquem la branca ...
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup laBranca known {laBranca get exit}{pop}ifelse 
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% d'interrogacio dels dicts de COMdimoni
   }if

%/17 ENCAVALCA CONTINGUTS
%/15 ELIMINA LLESQUES
%/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%/13 eliminem continguts de pàgina
%/12 arbre jeràrquic
%/10 PREFLIGHT AMB CAPES
%/08 ETIQUETA TEXT
%/07 REINSEREIX IMATGES JPEG
%/06 COSIT D'IMATGES
%/05 dada variable
%/03 CORRECTOR TIPOGRÀFIC
%/02 MARQUES DE TALL
%/01 SEPARACIÓ DE TINTES
%/00 REESCRIPTURA IDEM

%:00 REESCRIPTURA IDEM
%:01 SEPARACIÓ DE TINTES
%:02 MARQUES DE TALL
%:03 CORRECTOR TIPOGRÀFIC
%:05 dada variable
%:06 COSIT D'IMATGES
%:07 REINSEREIX IMATGES JPEG
%:10 PREFLIGHT AMB CAPES
%:12 arbre jeràrquic
%:13 eliminem continguts de pàgina
%:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%:15 ELIMINA LLESQUES
%:17 ENCAVALCA CONTINGUTS
   QueLiFemFer 8 ne
   {  %% ho modifiquem mentre no fem l'opcio 8 per a JBC
    dup
    quinaTinta 128 string cvs dup /amolla exch def length
    genericSubject length dup /VaS exch def add string dup 0 genericSubject
    putinterval dup VaS amolla putinterval
    /Subject exch put  %% afegim Subject
    dup /Title dena put  %% afegim Title
    dup /Author  %%(¸.·´¯`·.¸.·´¨«~)  %% en WinAnsi no es veu bé als nous Viewers
    %% en Unicode per tal que funcioni bé amb tots els sistemes
    <feff00b8002e00b700b400af006000b7002e00b8002e00b700b400a800ab007e>
    put  %% afegim Author
   }if
%/17 ENCAVALCA CONTINGUTS
%/15 ELIMINA LLESQUES
%/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%/13 eliminem continguts de pàgina
%/12 arbre jeràrquic
%/10 PREFLIGHT AMB CAPES
%/07 REINSEREIX IMATGES JPEG
%/06 COSIT D'IMATGES
%/05 dada variable
%/03 CORRECTOR TIPOGRÀFIC
%/02 MARQUES DE TALL
%/01 SEPARACIÓ DE TINTES
%/00 REESCRIPTURA IDEM

%:00 REESCRIPTURA IDEM
%:01 SEPARACIÓ DE TINTES
%:02 MARQUES DE TALL
%:03 CORRECTOR TIPOGRÀFIC
%:05 dada variable
%:06 COSIT D'IMATGES
%:07 REINSEREIX IMATGES JPEG
%:08 ETIQUETA TEXT
%:10 PREFLIGHT AMB CAPES
%:12 arbre jeràrquic
%:13 eliminem continguts de pàgina
%:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%:15 ELIMINA LLESQUES
%:17 ENCAVALCA CONTINGUTS

   %%(***************)pstack quit
   %% Detecta si l'interpret PS duu el recurs %Calendar% (p.e. GS)
   %% si el duu llavors farceix una cadena segons la sintaxi del Creation Date d'AcrobatPDF
   (%Calendar%) /IODevice resourcestatus  %% existeix el recurs del calendari+rellotge?
   {  %% existeix! (probablement siguem dins GS)
    pop pop  %% ens carreguem les altres dues respostes del query
    %% /araCDstring (D:) def  %% cadena d'inici per la Creation Date
    (%Calendar%) currentdevparams  %%{== ==}forall quit
    dup /Running get
    {  %% suposem q per refiar-nos del calendari aquesta entrada ha d'estar a true
     dup /Year get
     4 string cvs dup length araCDstring length dup /afegit exch def add string dup
     0 araCDstring putinterval dup afegit 4 -1 roll putinterval /araCDstring exch def
     dup /Month get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
     dup /Day get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
     dup /Hour get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
     dup /Minute get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
     /Second get
     2 string cvs dup length dup 2 ne {1 add exch (00) dup 3 -1 roll 1 exch putinterval exch}if
     araCDstring length dup /afegit exch def add string dup 0 araCDstring putinterval
     dup afegit 4 -1 roll putinterval /araCDstring exch def
    }
    {  %% si Running es a false deixem un missatge d'avis, pero no fem res ...
     pop
     (\n ... >>> Hi ha %Calendar% pero Running es a false :-\( \n) print flush
    }ifelse
    dup /CreationDate araCDstring put  %% afegim CreationDate
    /ModDate araCDstring put  %% afegim ModDate
   }
   {
    pop
   }ifelse
   %% si NO existeix ... probablement siguem a Distiller
  }ifelse

  %#%49bis3% generem o redefinim PieceInfo per segellar l'ús de CaLi2CoPi
  (%#%49bis3%)==
  %% aquí és on posem el PieceInfo amb les dades privades d'execució per cadascuna de les execucions
  %% i variants de CaLi2CoPi que han actuat sobre el fitxer i amb control del CreationDate
  CtLgViu /PieceInfo known  %% ja existeix aquest diccionari?
  {
   CtLgViu /PieceInfo get
   %% tret que sigui una referència indirecta
   dup type /nametype eq
   {
    /laBranca exch def
    %% pesquem la branca ...
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup laBranca known {laBranca get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% d'interrogacio dels dicts de COMdimoni
   }if
   dup /MRCT_CaLi2CoPi known
   {  %% ja l'hem tractat amb CaLi2CoPi
    dup dup /MRCT_CaLi2CoPi get dup dup dup
    /LastModified araCDstring put  %% idem que CreationDate
    /Private get dup length dup /vaP exch def 1 add array dup 3 -1 roll 0 exch putinterval
    dup vaP QueLiFemFer put /Private exch put  %% afegim el nou gatell al paquet d'executats
    /MRCT_CaLi2CoPi exch put  %% repiquem la nostra entrada al PieceInfo original
   }
   {  %% no ha estat mai tractat
    dup
    /MRCT_CaLi2CoPi
    <<
      /LastModified araCDstring  %% idem que CreationDate
      /Private [QueLiFemFer]  %% paquet de gatells executats
    >> put
   }ifelse
  }
  {  %% no ha estat mai tractat
   <<
     /MRCT_CaLi2CoPi
     <<
       /LastModified araCDstring  %% idem que CreationDate
       /Private [QueLiFemFer]  %% paquet de gatells executats
     >>
   >>
  }ifelse
  CtLgViu exch /PieceInfo exch put  %% repiquem a Catalog

  %% QuiEsAra ==
  %%% test som aqui corregint la cagada de l'xref
  %% elPrimer == quit
  %%     (busquem el num del darrer objecte actiu) ==
  %%% EN AQUEST PUNT ES PODEN DONAR D'ALTA OBJECTES NOUS
  %% aqui hi havia (v27 i anteriors) ...
  %%%CALi2COPi%%% donarem d'alta els nous dics clonics dels GS amb les ref ind a /Resources /GStates i com a objectes directes
  %% NO CAL tenir cura que aquesta alta nomes la fem la primera vegada
  %%% FI DE DONAR D'ALTA OBJECTES NOUS
  %% llistem el dict Xtest
  %%Fenix {== ==} forall

%/17 ENCAVALCA CONTINGUTS
%/15 ELIMINA LLESQUES
%/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%/13 eliminem continguts de pàgina
%/12 arbre jeràrquic
%/10 PREFLIGHT AMB CAPES
%/08 ETIQUETA TEXT
%/07 REINSEREIX IMATGES JPEG
%/06 COSIT D'IMATGES
%/05 dada variable
%/03 CORRECTOR TIPOGRÀFIC
%/02 MARQUES DE TALL
%/01 SEPARACIÓ DE TINTES
%/00 REESCRIPTURA IDEM

  QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
  {  %% creació dels nous objectes XObject per restaurar la capa d'imatge de cada pàgina
   %% generarem i afegirem els nous objectes XObject al dic del darrer tros de PDF
   MaxDimoni 1 sub 4 string cvs userdict exch get /darrerDic exch def
   /iJPEGsXObject 0 def
   JPEGsXObject
   {  %% forall
    dup null eq
    {
     pop
    }
    {
     quinaPlana iJPEGsXObject 1 add 4 string cvs get  %% desem el literal del num d'obj /Page
     /actGina exch def
     %% pesquem la branca ...
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup actGina known {actGina get exit}{pop}ifelse 
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop  %% d'interrogacio dels dicts de COMdimoni
     %% 05.03.09 aquesta solucio de la cerca recursiva del dic Resources considerant el null i el diccionari buit cal implementar-la arreu on calgui!
     %% anem cercant cap enrera els Parent en cas de no trobar Resources dins la mateixa pagina
     {  %% loop
      dup /Resources known  %% hi ha Resources?
      {  %% Resources es a /Page o /Pages ?
       %% descartem la possibilitat de que la ref indirecte sigui un null o un dict buit
       %% pel que llavors tindria els Resources heretats i continuariem el loop enrera ...
       /Resources get dup type /nametype eq
       {
        /aCercar exch def  %% nom amb la ref ind del dic Resources
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dics de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        }loop  %% d'interrogacio dels dicts de COMdimoni
        dup length 0 eq
        {  %% pagina amb Resources heretats i continuem el loop enrera
         pop
        }
        {
         %% /riResources aCercar def  %% la ref ind del diccionari Resources
         exit  %% sortim del loop amb el dic Resources a l'stack
        }ifelse
       }
       {
        dup null eq
        {  %% pagina amb Resources heretats i continuem el loop enrera
         pop
        }
        {  %% no pot ser altra cosa que un dic directe
         dup length 0 eq
         {  %% pagina amb Resources heretats i continuem el loop enrera
          pop
         }
         {
          exit  %% sortim del loop amb el dic Resources a l'stack
         }ifelse
        }ifelse
       }ifelse
      }
      {  %% Resources podria estar a /Pages!
       dup /Parent known
       {
        dup /Parent get
        /aCercar exch def
        %% pesquem la branca ...
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup aCercar known {aCercar get exit}{pop}ifelse 
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        }loop  %% d'interrogacio dels dicts de COMdimoni
       }
       {  %% aquesta pagina no te Resources!
        BaBeL 33 get print flush
actGina == (4)==
        %% informem dels fitxers del tmp
        BaBeL 50 get print flush
        clear stop  %%quit
%%UBpliegOMaker
       }ifelse
      }ifelse
     }loop
     %% aquí tenim el diccionari Resources de la plana que explorem ara, l'interroguem si existeix
     %% el diccionari /XObject, doncs en cas que no hi fos voldria dir que en aquesta pàgina només
     %% hi havia inLines i per tant haurem d'inlore-hi un Do de forma expressa, doncs
     %% si no, no podrem restaurar la capa d'imatge amb el JPEG corresponent
     dup /XObject known not
     {  %% missatge provisional abans no implementem aquest cas
      (\n >>> a la pàgina ... )print flush iJPEGsXObject 1 add 4 string cvs print flush
      ( ... no podrem restaurar la capa d'imatge! \(abans eren tot inLines\)) print flush
     }if
     /dicDrecursos exch def
     dup  %% exraiem el nom del fitxer com a literal intern de l'XObject (Do i Resources)
     {
      bUsca search
      {pop pop}{exit}ifelse
     }loop /nomXObj exch def
     %% generem un nou objecte
     QuiEsAra 1 add /QuiEsAra exch def
     %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
     (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
     %% podem xafar tranquil·lament el nou diccionari /XObject amb la ref ind de l'objecte XObject
     %% desem el nom i la ref ind de l'XObject dins el nou diccionari XObject per Resources
     dup nomXObj exch << 3 1 roll >> /XObject exch dicDrecursos 3 1 roll put
     %% afegirem l'objecte XObject al diccionari d'objectes de PDF
     darrerDic exch << 4 -1 roll dup
     %% l'algorisme paral·lel a %#%19bis4%
     /elJPEGteproblemes false def
     mark exch
     {  %%d'stopped
      %% captura de dades del JPEG i comprovacio de consistència ...
      dup status
      {
       pop pop
       %% el fitxer fa ...
       /FiFtxr exch def pop
       dup /elD'ara exch def  %% path+Nom del fitxer que processem
       (r) file /tesela exch def  %% fitxer de lectura
       %% mirem el cap i els peus (marcadors d'inici i final) del fitxer aviam si son normatius ...
       tesela FiFtxr 2 sub setfileposition
       tesela 2 string readstring pop <FFD9> eq
       {
        %%(PEUS OK) ==
        tesela dup 0 setfileposition
        2 string readstring pop <FFD8> eq
        {
         %%(CAP OK) ==
         /SoRTiM false def  %% pestell de sortida
         %% explorem el fitxer per localitzar els marcadors significatius que duen les dades d'imatge (qualsevol d'ells es valid)
         {  %% loop
          tesela 2 string readstring  %% llegim el segment
          {
           /SeGMeNT exch def
           0 1 6
           {  %% for
            [<FFC0> <FFC1> <FFC2> <FFC3> <FFC5> <FFC6> <FFC7>]  %% marcadors significatius
            exch get SeGMeNT eq
            {
             %%(JA EL TINC !!!) ==
             tesela 10 string readstring pop
             %% captura del valor de files (y)
             dup dup 3 get 256 mul exch 4 get add (\n ... Files (Y) ... ) print flush dup ==
             /_B exch def  %% (Y) FILES D'IMATGE
             %% captura del valor de columnes (x)
             dup dup 5 get 256 mul exch 6 get add ( ... Columnes (X) ... ) print flush dup ==
             /_A exch def  %% (X) COLUMNES D'IMATGE
             %% captura dels components de color (1, 3 o 4 canals)
             dup dup 7 get ( ... Components de Color ... ) print flush dup ==
             /CNL exch def
             %% bits per component de color (o per pixel)
             dup dup 2 get ( ... Bits x Comp ... ) print flush dup == elD'ara print flush (\n) print flush
             /bXp exch def
             /SoRTiM true def
            }if
           } for
           SoRTiM not
           {
            tesela 2 string readstring
            {  %% llegim la llargada del segment per saltar al seguent ...
             dup 0 get 256 mul exch 1 get add
             2 sub string tesela exch readstring {pop}{pop tesela closefile exit}ifelse
            }
            {
             pop tesela closefile exit
            }ifelse
           }if
          }
          {
           pop tesela closefile exit
          }ifelse
          SoRTiM {tesela closefile exit} if
         } loop
         SoRTiM not
	 {
	  (\n\n <<<< NO podem llegir correctament les dades d'aquest JPEG\n\n) print flush
	  /elJPEGteproblemes true def  %% n'hi ha
	 } if
         %% aquí hi havia la construcció de la imatge
        }
        {
         %%(CAP KAPPUT)==
	 /elJPEGteproblemes true def  %% n'hi ha
        }ifelse
       }
       {  %% desactivem x TEST
        %%(PEUS KAPPUT)==
	/elJPEGteproblemes true def  %% n'hi ha
       }ifelse
      }
      {
       %%(NO HI ES ...) == tesela closefile quit
       /elJPEGteproblemes true def  %% n'hi ha
      }ifelse
     }stopped 
     {
      %% clear ( ... PETADA !!\n\n) print flush
      /elJPEGteproblemes true def  %% n'hi ha
     }if
     %%% fi del lector de jpeg
     elJPEGteproblemes
     {  %% algun dels gatells clau peta
      cleartomark cleartomark pop pop
      ( <<< el JPEG a restaurar a la plana ... )print flush
      iJPEGsXObject 1 add 4 string cvs print flush
      ( ... duu dades erronies\n >>> continuem!\n) print flush
      %% stop  %%quit
     }
     {
      cleartomark
      %% aquí construim el diccionari d'imatge
      /XIU exch 1 array astore  %% podrem repicar mantenint el JPEG?
      /Type /XObject
      /Subtype /Image
      manies14 0 get  %% fem l'efecte cromakey? (màscara pel blanc RGB)
      {
       /Mask [255 255 255 255 255 255]
      }if
      /Width _A
      /Height _B
      /BitsPerComponent bXp
      /ColorSpace /DeviceRGB
      /Filter /DCTDecode  %% podrem repicar mantenint el JPEG?
      /Length 0  %% valor provisional que serà reescrit
      >> put  %% afegim finalment l'objecte XObject al diccionari d'objectes de PDF
     }ifelse
    }ifelse
    iJPEGsXObject 1 add /iJPEGsXObject exch def
   }forall  %% per tots els JPEGs a restaurar
  }if  %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13

  QueLiFemFer 5 eq  %:05 dada variable
  {
%% ATENCIÓ! ARA AFEGIM ELS NOUS OBJECTES FONT DE FORMA FIXA (ara només la Bold)
%% per evitar problemes de xifrat, creem de nou els objectes /Font amb el mínim de dades
[  %% array d'objectes Font manats segons /taranna pel comportament de les bookmarks

 %% aquí el més important és literal /fontB2 que podem acompanyar amb qualsevol valor de /BaseFont

 %% 0 treballem amb romana
 %%<</Type/Font /Subtype/Type1 /Name/fontB0 /BaseFont/Helvetica /Encoding/WinAnsiEncoding>>
 %% 1 treballem amb itàlica
 %%<</Type/Font /Subtype/Type1 /Name/fontB1 /BaseFont/Helvetica-Oblique /Encoding/WinAnsiEncoding>>
 %% 2 treballem amb negreta
 <</Type/Font /Subtype/Type1 /Name/fontB2 /BaseFont/Helvetica-Bold /Encoding/WinAnsiEncoding>>
] /segonsF exch def  %% comportament segons l'entrada /F del diccionari de bookmarks

%% generem i afegim els nous objectes Font al dic del darrer tros de PDF
/fontResources 2 dict def  %% serà el diccionari de la clau /Font de Resources
MaxDimoni 1 sub 4 string cvs userdict exch get /darrerDic exch def

segonsF
{  %% forall
 dup /Name get
 %% en generem un per cada
 QuiEsAra 1 add /QuiEsAra exch def
 %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
 (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
 %% desem el nom i la ref ind de la font per Resources
 dup 3 -1 roll exch fontResources 3 1 roll put
 %% afegim l'objecte font al diccionari d'objectes de PDF
 exch darrerDic 3 1 roll put
}forall
%% ens cal afegir les /Fonts usades a fontResources per a tots els Resources de les pàgines
%% nou repicat dels /Fonts a /Resources de cada pàgina
 quinaPlana
 {  %% forall
  /actGina exch def /araPlana exch def  %% desem el literal del num d'obj /Page i l'ordinal de la plana a la que correspon
  %% pesquem la branca ...
  /iDimoni 0 def
  {  %% loop d'interrogacio dels dicts de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   %% el diccionari de l'objecte
   dup actGina known {actGina get exit}{pop}ifelse 
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% d'interrogacio dels dicts de COMdimoni
  %% 05.03.09 aquesta solucio de la cerca recursiva del dic Resources considerant el null i el diccionari buit cal implementar-la arreu on calgui!
  %% anem cercant cap enrera els Parent en cas de no trobar Resources dins la mateixa pagina
  {  %% loop
   dup /Resources known  %% hi ha Resources?
   {  %% Resources es a /Page o /Pages ?
    %% descartem la possibilitat de que la ref indirecte sigui un null o un dict buit
    %% pel que llavors tindria els Resources heretats i continuariem el loop enrera ...
    /Resources get dup type /nametype eq
    {
     /aCercar exch def  %% nom amb la ref ind del dic Resources
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dics de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
     dup length 0 eq
     {  %% pagina amb Resources heretats i continuem el loop enrera
      pop
     }
     {

%% /riResources aCercar def  %% la ref ind del diccionari Resources

      exit  %% sortim del loop amb el dic Resources a l'stack
     }ifelse
    }
    {
     dup null eq
     {  %% pagina amb Resources heretats i continuem el loop enrera
      pop
     }
     {  %% no pot ser altra cosa que un dic directe
      dup length 0 eq
      {  %% pagina amb Resources heretats i continuem el loop enrera
       pop
      }
      {

       exit  %% sortim del loop amb el dic Resources a l'stack
      }ifelse
     }ifelse
    }ifelse
   }
   {  %% Resources podria estar a /Pages!
    dup /Parent known
    {
     dup /Parent get
     /aCercar exch def
     %% pesquem la branca ...
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse 
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }
    {  %% aquesta pagina no te Resources!
     BaBeL 33 get print flush
actGina == (5)==
     %% informem dels fitxers del tmp
     BaBeL 50 get print flush
     clear stop  %%quit
%%UBpliegOMaker
    }ifelse
   }ifelse
  }loop
%% aquí tenim el diccionari Resources de la plana que explorem ara
dup /dicDrecursos exch def
%% si és 

  %% hi ha fonts ?
  dup /Font known
  {
   /Font get  %% es un diccionari directe o una ind ref ?
   dup type /nametype eq
   {
    /aCercar exch def  %% nom amb la ref ind del dic Font
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
   }if

%% aquí hi ha el diccionari dels recursos /Font de la plana
%% /recursosFont exch def
/aDins exch def
fontResources
{
 aDins 3 1 roll put
}forall
%% reinserim a Resources!
dicDrecursos /Font aDins put
%%(recursosFont)pstack quit

  }
  {  %% NO hi ha /Font

%% aquí hi ha el diccionari dels recursos /Font de la plana
%% /recursosFont exch def
/femRFont <<>> def
femRFont /aDins exch def
fontResources
{
 aDins 3 1 roll put
}forall
/Font femRFont put
  } ifelse


 } forall  %% fi del forall x pagines
  }if  %/05 dada variable

 QueLiFemFer 16 eq  %:16 cerca i substitució de text
 {  %% aquest codi és molt similar al de 05 dada variable
  %% ens cal incrustar les /Fonts de suport a l'edició que calguin als Resources de les pàgines que calgin
  quinaPlana
  {  %% forall
   /actGina exch def /araPlana exch def  %% desem el literal del num d'obj /Page i l'ordinal de la plana a la que correspon
   araPlana 6 string cvs cvx exec dup afegeixFont length lt
   {  %% sempre que sigui més petit podem tenir /Fonts a incrustar
    dup /araPlana exch def  %% desem l'índex
    afegeixFont exch get null eq
    {  %% segur que NO tenim /Fonts a incrustar
     false
    }
    {  %% SI que tenim /Fonts a incrustar
     true
    }ifelse
   }
   {  %% segur que NO tenim /Fonts a incrustar
    pop false
   }ifelse

   { %% if en aquesta pàgina hi ha /Font a incrustar a Resources
    %% generem i afegim els nous objectes Font al dic del darrer tros de PDF
    /fontResources 2 dict def  %% serà el diccionari de la clau /Font de Resources
    MaxDimoni 1 sub 4 string cvs userdict exch get /darrerDic exch def
    [  %% en aquest array hi desem els objectes /Font que necessitem incrustar en aquesta pàgina
     afegeixFont araPlana get
     {
      pop objectStandard14Fonts exch get
     }forall
    ]
    {  %% forall
     dup /Name get
     %% en generem un per cada
     QuiEsAra 1 add /QuiEsAra exch def
     %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
     (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
     %% desem el nom i la ref ind de la font per Resources
     dup 3 -1 roll exch fontResources 3 1 roll put
     %% afegim l'objecte font al diccionari d'objectes de PDF
     exch darrerDic 3 1 roll put
    }forall
    %% pesquem la branca ...
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup actGina known {actGina get exit}{pop}ifelse 
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% d'interrogacio dels dicts de COMdimoni
    %% 05.03.09 aquesta solucio de la cerca recursiva del dic Resources considerant el null i el diccionari buit cal implementar-la arreu on calgui!
    %% anem cercant cap enrera els Parent en cas de no trobar Resources dins la mateixa pagina
    {  %% loop
     dup /Resources known  %% hi ha Resources?
     {  %% Resources es a /Page o /Pages ?
      %% descartem la possibilitat de que la ref indirecte sigui un null o un dict buit
      %% pel que llavors tindria els Resources heretats i continuariem el loop enrera ...
      /Resources get dup type /nametype eq
      {
       /aCercar exch def  %% nom amb la ref ind del dic Resources
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dics de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
       dup length 0 eq
       {  %% pagina amb Resources heretats i continuem el loop enrera
        pop
       }
       {
        %% /riResources aCercar def  %% la ref ind del diccionari Resources
        exit  %% sortim del loop amb el dic Resources a l'stack
       }ifelse
      }
      {
       dup null eq
       {  %% pagina amb Resources heretats i continuem el loop enrera
        pop
       }
       {  %% no pot ser altra cosa que un dic directe
        dup length 0 eq
        {  %% pagina amb Resources heretats i continuem el loop enrera
         pop
        }
        {
         exit  %% sortim del loop amb el dic Resources a l'stack
        }ifelse
       }ifelse
      }ifelse
     }
     {  %% Resources podria estar a /Pages!
      dup /Parent known
      {
       dup /Parent get
       /aCercar exch def
       %% pesquem la branca ...
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse 
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
      }
      {  %% aquesta pagina no te Resources!
       BaBeL 33 get print flush
actGina == (5)==
       %% informem dels fitxers del tmp
       BaBeL 50 get print flush
       clear stop  %%quit
%%UBpliegOMaker
      }ifelse
     }ifelse
    }loop
    %% aquí tenim el diccionari Resources de la plana que explorem ara
    dup /dicDrecursos exch def
    %% si és 
    %% hi ha fonts ?
    dup /Font known
    {
     /Font get  %% es un diccionari directe o una ind ref ?
     dup type /nametype eq
     {
      /aCercar exch def  %% nom amb la ref ind del dic Font
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     %% aquí hi ha el diccionari dels recursos /Font de la plana
     %% /recursosFont exch def
     /aDins exch def
     fontResources
     {
      aDins 3 1 roll put
     }forall
     %% reinserim a Resources!
     dicDrecursos /Font aDins put
     %%(recursosFont)pstack quit
    }
    {  %% NO hi ha /Font
     %% aquí hi ha el diccionari dels recursos /Font de la plana
     %% /recursosFont exch def
     /femRFont <<>> def
     femRFont /aDins exch def
     fontResources
     {
      aDins 3 1 roll put
     }forall
     /Font femRFont put
    }ifelse
   }if
  }forall  %% fi del forall x pagines
 }if  %/16 cerca i substitució de text

  %% Simsi
  QueLiFemFer 12 eq  %:12 arbre jeràrquic
  {

%% això feia anar de bòlid el programa? ... llavors numerem un nou objecte
%% doncs alguna bruixa se'ns menjava sempre el primer objecte generat en aquesta secció
QuiEsAra 1 add /QuiEsAra exch def

%% constant per tot el 12
%% generem i afegim els nous objectes Font al dic del darrer tros de PDF
/fontResources 2 dict def  %% serà el diccionari de la clau /Font de Resources
MaxDimoni 1 sub 4 string cvs userdict exch get /darrerDic exch def
segonsF
{  %% forall
 dup /Name get
 %% en generem un per cada
 QuiEsAra 1 add /QuiEsAra exch def
 %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
 (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
 %% desem el nom i la ref ind de la font per Resources
 dup 3 -1 roll exch fontResources 3 1 roll put
 %% afegim l'objecte font al diccionari d'objectes de PDF
 exch darrerDic 3 1 roll put
}forall

   polyFEM
   0 get  %% generem l'índex amb bookmarks?
   polyFEM
   1 get  %% generem l'índex amb pàgines?
   or
   {  %% qualsevol de les dues menes d'índex
    arbreDbookmarks length 0 eq
    {  %% com que no n'hi ha, avisem!
     (\n\n ... Jerarquies NO detectades! ... en aquest PDF no hi podrem generar cap index\n\n) print flush quit
    }if

    polyFEM
    0 get  %% generem l'índex amb bookmarks?
    {
     (\n\nGenerant l'Index amb Bookmarks ...\n\n)print flush
     %% passem el paquet PDFDocEncoding a un diccionari (d_PDFDE) per fer més rapida la cerca
     %% del codi del caràcter a escriure a l'string del Title de la bookmark
     /d_PDFDE 2 dict def
     %% aqui podriem tibar de la crida interna d'encodings del GS (quan els eliminem de %#%20%)
     PDFDocEncoding
     0 1 255 {dup 2 index exch get exch d_PDFDE 3 1 roll put}for
     pop
     %% primerament generem l'objecte Outlines pel Catalog
     %% però abans comprovarem si ja existeix al diccionari viu del Catalog
     CtLgViu /Outlines known
     {  %% si és que si, com que ara no farem un purgador de bookmarks
      %% avisarem i sortirem sense acabar la feina!
     (\n\n ... aquest PDF ja te un arbre de Bookmarks i no hi podrem generar cap arbre nou\n\n) print flush quit
     }if

     QuiEsAra 1 add /QuiEsAra exch def  %% numerem l'objecte lliure per assignar a Outlines
     %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
     (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn dup
     CtLgViu exch /Outlines exch put  %% l'arrel dels bookmarks al diccionari viu del Catalog
     /siESzero exch def  %% farem la substitució de l'objecte Outlines als Parent que valguin zero

     CtLgViu /PageMode /UseOutlines put  %% forcem l'obertura de la solapa lateral de bookmarks

     %% generem el diccionari d'equivalències hexaRefInd amb les strings hexa de l'arbre de
     %% bookmarks i el literal equivalent al número d'objecte que tindran dins el PDF
     /hexaRefInd <<>> def
     arbreDbookmarks
     {  %% forall
      %% a l'arbre de bookmarks hi entren totes les categories
      pop 8 string cvs cvx exec 16 6 string cvrs  %% convertim la clau a string hexa per la detecció de l'objecte 
      QuiEsAra 1 add /QuiEsAra exch def
      %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
      (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
      %% desem l'hexa del bookmark i l'equivalent al número d'objecte que tindrà dins el PDF
      hexaRefInd 3 1 roll put 
     }forall

     %% avaluem el First i el Last i Count de l'objecte Outlines
     arbreDbookmarks length /totalBkmrks exch def  %% nombre total de bookmarks pel Count
     /maxJ 1000 def  %% sabrem el valor del màxim nivell del bookmark (l'enter més petit)
     arbreDbookmarks
     {  %% forall per saber l'enter del màxim nivell del bookmark
      %% /_JERARQUiA
      /_arajPDF get dup maxJ lt
      {
       /maxJ exch def pop
      }
      {
       pop pop
      }ifelse
     }forall
     /femFirst true def  %% gatell per saber si hem d'avaluar la primera de màxima categoria
     /femLast false def  %% gatell per saber si hem d'avaluar la darrera de màxima categoria
     saPrimeraB 1 saDarreraB  %% explorem de dalt a baix
     {  %% for per saber quina és la primera i la darrera bookmark de màxima categoria
      femFirst
      {
       8 string cvs dup arbreDbookmarks exch get  %% /_JERARQUiA
       /_arajPDF get maxJ eq
       {
        dup dup /esFirst exch def  %% aquest l'string identificador de la bookmark serà el First
        /esLast exch def  %% aquest l'string identificador de la bookmark podria ser el Last
        /femFirst false def  %% tanquem el gatell
        /femLast true def  %% obrim el gatell pel Last
       }
       {
        pop
       }ifelse
      }if
      femLast
      {
       8 string cvs dup arbreDbookmarks exch get  %% /_JERARQUiA
       /_arajPDF get maxJ eq
       {
        /esLast exch def  %% aquest l'string identificador de la bookmark serà el Last
       }
       {
        pop
       }ifelse
      }if
     }for

     %% afegim el nou objecte Outlines al diccionari del darrer tros de PDF
     MaxDimoni 1 sub 4 string cvs userdict exch get dup /DarreTros exch def
     siESzero
     <<
     /Count totalBkmrks  %% el nombre total # de bookmarks del document
     %% objecte indirecte # # R que apunta a la primera bookmark del màxim nivell
     /First hexaRefInd esFirst cvx exec 16 6 string cvrs get
     %% objecte indirecte # # R que apunta a la darrera bookmark del màxim nivell
     /Last hexaRefInd esLast cvx exec 16 6 string cvrs get
     /Type /Outlines  %% potser obligatòria?
     >> put

%% afegim els estils tipogràfics i colors definits al diccionari taranna
arbreDbookmarks
{  %% forall
 dup /araDB exch def
 /_JERARQUiA get taranna exch get
 dup /tabula undef  %% abans donem de baixa la variable que tabula el text
 {  %% forall per ficar totes les clau/valor d'estils de taranna al diccionari del bookmark
  araDB 3 1 roll put
 }forall
 pop
%(mmmmmmmm)pstack quit 
}forall


     %% generem tots els bookmarks com a objectes de PDF
     arbreDbookmarks
     {  %% forall per a cadascun dels bookmarks
      %% clonem amb profilaxi el diccionari per tractar-lo pel repicat d'objectes
      dup dup length dict copy /dicB exch def
      %% eliminem les claus privades
      dicB /_arajPDF undef
      dicB /_JERARQUiA undef
      dicB /_BLiNiA get /BxRepicar exch def  %% array de la línia de text per repicar a Title
      dicB /_BLiNiA undef
      dup
      {  %% forall al diccionari original (no del clònic!)
       dup type /stringtype eq
       {  %% substituim totes les strings hexa per la seva corresponent ref ind
        hexaRefInd exch get dicB 3 1 roll put
       }
       {
        pop pop
       }ifelse
      }forall
      %% si duu /Parent i val zero, li posarem siESzero que és la ref ind d'Outlines
      dup /Parent known
      {
       /Parent get 0 eq
       {  %% apuntem a l'objecte Outlines
        dicB /Parent siESzero put
       }if
      }
      {
       pop
      }ifelse      
      %% iniciem el repicat del text
      1024 string /sTitle exch def  %% buffer d'escriptura dins una string prou llarga
      sTitle /NullEncode filter /Frengs exch def  %% com a fitxer
      BxRepicar
      dup 1 get  %% extraiem l'array de noms de signes
      %% repiquem els noms dels signes a la seva representacio escrita
      %% segons la taula d_PDFDE (PDFDocEncoding)
      %%(:-#)pstack quit


      {  %% forall per tot l'array de noms de signes

%% hem de purgar els nulls!!!!!
dup null eq
{
 pop
}
{
       d_PDFDE
       1 index known
       {
        %% protegim l'string contra signes conflictius que cal blindar
        dup /parenright eq
        {
         pop Frengs (\)) writestring  %% escrivim el signe tancar parentesi protegit
        }
        {
         dup /parenleft eq
         {
          pop Frengs
          (\() writestring  %% escrivim el signe d'obrir parentesi protegit
         }
         {
          dup /backslash eq
          {
           pop Frengs
           (\\) writestring  %% escrivim el signe backslash protegit
          }
          {  %% no és cap dels conflictius i existeix
           d_PDFDE exch get
           Frengs exch write  %% escrivim el signe
          }ifelse
         }ifelse
        }ifelse
       }
       {  %% si no existeix
        %% fem una substitució adaptada per mitjà del diccionari SOFIglyphs
        %% hauríem de comparar les diferències entre els caràcters definits a SOFIglyphs
        %% i PDFDocEncoding, no fos que haguessim de xifrar les equivalències de forma diferent
        SOFIglyphs 1 index known
        {
         SOFIglyphs exch get
         Frengs exch writestring  %% escrivim el signe
        }
        {  %% si no existeix
         %% ara hi posem un espai en blanc i la pràctica continuada ja ens orientarà
         %% de com implementar el signe conflictiu de forma adequada
         == ( ... signe conflictiu ... l'exportem en blanc!)==
         Frengs 32 write
        }ifelse
       }ifelse

}ifelse  %% del purgat de nulls

      }forall  %% per tot l'array de noms de signes

      Frengs closefile  %% tanquem el fitxer que, com a string, fa de buffer
      sTitle (\000) search  %% purguem els caràcters zero (\000) sobrants del buffer
      {
       exch pop exch pop
      }if
      %% clau del text de la bookmark
      dicB /Title 3 -1 roll put
      %% extraurem l'Y del primer caràcter per l'índex 2 de /Dest on ajustarem la posició Y del link
      dup 0 get 0 get 5 get
      %% hi sumem el cos (1 cop i mig) per encaixar bé la finestra en vertical
      exch 3 get 0 get 1.5 mul add
      dicB dup /Dest get dup 2 5 -1 roll put /Dest exch put

%% aquí afinarem amb taranna el color i pes del text del bookmark
%%(:-jO) pstack quit

      8 string cvs cvx exec 16 6 string cvrs  %% convertim la clau dentificadora a string hexa
      %% obtenim la ref ind equivalent a la clau identificadora del bookmark
      hexaRefInd exch get
      %% desem la clau i el diccionari bookmark, com a nou objecte PDF
      DarreTros exch dicB put
     }forall  %% per a cadascun dels bookmarks
    }if  %% generem l'índex amb bookmarks

    polyFEM
    1 get  %% generem l'índex amb pàgines?
    {
     (\nGenerant l'Index amb Pagines ...\n)print flush

false{
%% constant per tot el 12
%% generem i afegim els nous objectes Font al dic del darrer tros de PDF
/fontResources 2 dict def  %% serà el diccionari de la clau /Font de Resources
MaxDimoni 1 sub 4 string cvs userdict exch get /darrerDic exch def
segonsF
{  %% forall
 dup /Name get
 %% en generem un per cada
 QuiEsAra 1 add /QuiEsAra exch def
 %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
 (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
 %% desem el nom i la ref ind de la font per Resources
 dup 3 -1 roll exch fontResources 3 1 roll put
 %% afegim l'objecte font al diccionari d'objectes de PDF
 exch darrerDic 3 1 roll put
}forall
%%(ppppppp)pstack quit
}if

%% hauríem d'ampliar l'array Kids on trobem l'objecte OiP amb tants nous objectes /Page com elements
%% tingui l'array d'OiP a paginesDindex, cadascun d'ells tindria ...
%% un diccionari... << /Type /Page ...on... /Parent ...apuntará al mateix que OiP
%% on ens cal crear un nou objecte (idem x tots) ... /Resources ...amb... << /ProcSet [/PDF /Text ]
%% ...i les fonts que toquin... /Font << /??? # # R >> ...i tancar Resources... >>
%% on ens cal crear un nou objecte d'stream de /Contents ...i tancar Page... >>
%% només cal pensar d'on pesquem el MediaBox i ens cal també retocar el Count

%% aquí bastim
%% hi desarem quines bookmarks hi haurà relacionades en cadascuna de les noves pàgines d'índex
%% de manera que podrem aprofitar la lectura de dades ja feta per generar el links de pàgina
/bookmarksXpaginaDindex <<>> def

%% espiaKids %%
%% aqui desarem les claus idem a paginesDindex amb l'array de les ref ind corresponents als streams
/objectesDindex <<>> def
%% hauríem de polir aquest algorisme per tal que només avaluessim l'array Kids i d'on penja
%% per exemple aquesta variable la necessitem d'abans i és absurd recalcular-la
quinaPlana dup length dict copy /suarAquinaPlana exch def
/quinaPlana <<>> def  %% diccionari on guardarem Num. Pagina / Clau de Pagina

/cntpa 0 def  %% valor inicial del compta pagines

%% pesquem el dict arrel de /Pages
/iDimoni 0 def
{  %% loop d'interrogacio dels dicts de COMdimoni
 currentdict iDimoni 4 string cvs cvn get
 %% el diccionari de l'objecte /Pages arrel
 dup l'arrel known {l'arrel get exit}{pop}ifelse
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
}loop  %% d'interrogacio dels dicts de COMdimoni

/Kids get  %% l'array de fills obligatoria
%% interroguem Kids, per ampliar-lo si cal i tornar-lo a desar a l'arrel iDimoni que toqui
(Kids 0) ==
%% inici del protocol d'afegir pàgines
%% anem a pescar la ref ind del /Parent compartit, per si inserim pàgines
dup 0 get /laBranca exch def
%% pesquem la branca ...
/iDimoni 0 def
{  %% loop d'interrogacio dels dicts de COMdimoni
 currentdict iDimoni 4 string cvs cvn get
 %% el diccionari de l'objecte
 dup laBranca known {laBranca get exit}{pop}ifelse 
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
}loop  %% d'interrogacio dels dicts de COMdimoni
/Parent get /elseuParent exch def  %% referència indirecta compartida per totes les pàgines
%% interroguem Kids i l'ampliem si cal per tornar-lo a desar a l'arrel iDimoni que toqui
%% generant tota la resta d'objectes que se'n deriven
/nousKids false def  %% gatell per saber si inserim pàgines
/nouCount 0 def  %% compta quantes pàgines noves crearem aquí
dup mark exch
{  %% forall
 dup paginesDindex exch known
 {  %% inserció de noves pàgines amb la generació de nous objectes /Page
  dup /idempDi exch def paginesDindex exch get dup /AsAdisc exch def length
  dup array /Prefind exch def /iNOP 0 def

%%ProblemaD
%% /copS 0 def

  {  %% repeat
   QuiEsAra 1 add /QuiEsAra exch def
   %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
   (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
   dup Prefind exch iNOP exch put
%% afegirem els nous objectes /Contents i /Page al dic del darrer tros de PDF
MaxDimoni 1 sub 4 string cvs userdict exch get dup
%% generem i desem l'objecte /Contents lligat al nou objecte /Page
QuiEsAra 1 add /QuiEsAra exch def
%% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
(_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
dup /elseusContents exch def  %% pel diccionari /Page
AsAdisc iNOP get  %% anem a pescar l'adreça a disc del stream de Contents

%%ProblemaD
%%copS 0 eq{(pipipipi)pstack quit}if
%%No s'ha desat el segon stream dins bookmarksXstream?

%% aquí bastim el canvi de bookmarksXstream per bookmarksXpaginaDindex
dup bookmarksXstream exch get  %% pesquem l'array amb les bookmarks relacionades amb l'stream
%% desem l'array de bookmarks relacionades amb la referència indirecte de la nova pàgina
bookmarksXpaginaDindex exch 6 index exch put

<< exch /XIU exch 1 array astore  %% clau per indicar al repicador que l'stream és a disc
/Length 0  %% el numeric indica al repicador que cal avaluar el Length de l'stream de nou
>> put
%% generem i desem l'objecte /Page
1 index
<<
  /Type /Page
  /Parent elseuParent
  /Resources
  <<
    /ProcSet [/PDF /Text ]
    /Font fontResources
  >>
  /Contents elseusContents
  suarAquinaPlana
  {  %% forall
   idempDi eq
   {
    /onMediaBox exch def
   }
   {
    pop
   }ifelse
  }forall
  XRay /PeDeEfa get onMediaBox get /MediaBox get
  /MediaBox exch

%%ProblemaD
%%pop [ 0 0 595 200]

>> put
   iNOP 1 add /iNOP exch def
   nouCount 1 add /nouCount exch def

%%ProblemaD
%%copS 1 add /copS exch def

  }repeat
  objectesDindex idempDi Prefind put
  idempDi
  /nousKids true def  %% gatell per saber si inserim pàgines
 }if
}forall
nousKids  %% comprovem si hem inserit pàgines
{  %% muntem el nou array Kids
 counttomark array astore
 %% si hem inserit pàgines hauríem de redesar Kids a *l'arrel* i aquest al dic de COMdimoni
 currentdict iDimoni 4 string cvs cvn get dup l'arrel get dup dup
 5 -1 roll /Kids exch put dup /Count get  %% ajustem el valor del nou nombre de pàgines
 nouCount add /Count exch put  %% desem el nou nombre de pàgines
 l'arrel exch put
 pop  %% eliminem la mark
}
{  %% NO, netegem fins a mark inclusiva i aquí no ha passat re
 cleartomark
}ifelse
%% fi del protocol d'afegir pàgines

aload pop
%% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
count dup 1 eq
{
 pop
}  %% tret de que nomes n'hi hagi 1
{
 /atura't exch def /ici 2 def
 {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
} ifelse
{  %% loop d'espia_PagesTree_2.ps
 count 0 eq {exit} if
 {  %% loop
  count 0 ne
  {
   dup type /marktype eq {pop}{exit} ifelse
  }
  {
   exit
  }ifelse
 } loop  %% elimina les marques d'inici d'array
 count 0 eq {exit} if
 %%dup COMdimoni exch get  % el diccionari de l'objecte
 dup /laBranca exch def
 %% pesquem la branca ...
 /iDimoni 0 def
 {  %% loop d'interrogacio dels dicts de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  %% el diccionari de l'objecte
  dup laBranca known {laBranca get exit}{pop}ifelse 
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq {exit} if
 } loop  %% d'interrogacio dels dicts de COMdimoni
 %% (:::) pstack quit  % aqui cal servir el loop de dics de COMdimoni amb una variable
 dup
 dup /Type known
 {  %% nou per controlar pagines (/Pages) que no porten la clau /Type (no Linearized)
  /Type get dup /Pages eq
 }
 {
  dup /Kids known {true}{false}ifelse
 } ifelse  %% nou per controlar pagines (/Pages) que no porten la clau /Type (en fitxers no optimitzats)
 {  %% ifelse
  %% son Pages
  pop exch pop
  /Kids get
%% interrogem Kids, per ampliar-lo si cal i tornar-lo a desar a l'arrel iDimoni que toqui
(Kids 1)==
%% inici del protocol d'afegir pàgines
%% anem a pescar la ref ind del /Parent compartit, per si inserim pàgines
dup 0 get /laBranca exch def
%% pesquem la branca ...
/iDimoni 0 def
{  %% loop d'interrogacio dels dicts de COMdimoni
 currentdict iDimoni 4 string cvs cvn get
 %% el diccionari de l'objecte
 dup laBranca known {laBranca get exit}{pop}ifelse 
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
}loop  %% d'interrogacio dels dicts de COMdimoni
/Parent get /elseuParent exch def  %% referència indirecta compartida per totes les pàgines
%% interroguem Kids i l'ampliem si cal per tornar-lo a desar a l'arrel iDimoni que toqui
%% generant tota la resta d'objectes que se'n deriven
/nousKids false def  %% gatell per saber si inserim pàgines
/nouCount 0 def  %% compta quantes pàgines noves crearem aquí
dup mark exch
{  %% forall
 dup paginesDindex exch known
 {  %% inserció de noves pàgines amb la generació de nous objectes /Page
  dup /idempDi exch def paginesDindex exch get dup /AsAdisc exch def length
  dup array /Prefind exch def /iNOP 0 def
  {  %% repeat
   QuiEsAra 1 add /QuiEsAra exch def
   %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
   (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
   dup Prefind exch iNOP exch put
%% afegirem els nous objectes /Contents i /Page al dic del darrer tros de PDF
MaxDimoni 1 sub 4 string cvs userdict exch get dup
%% generem i desem l'objecte /Contents lligat al nou objecte /Page
QuiEsAra 1 add /QuiEsAra exch def
%% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
(_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
dup /elseusContents exch def  %% pel diccionari /Page
AsAdisc iNOP get  %% anem a pescar l'adreça a disc del stream de Contents

%% aquí bastim el canvi de bookmarksXstream per bookmarksXpaginaDindex
dup bookmarksXstream exch get  %% pesquem l'array amb les bookmarks relacionades amb l'stream
%% desem l'array e bookmarks relacionades amb la referència indirecte de la nova pàgina
bookmarksXpaginaDindex exch 6 index exch put
%%(:-P)pstack quit quit

<< exch /XIU exch 1 array astore  %% clau per indicar al repicador que l'stream és a disc
/Length 0  %% el numeric indica al repicador que cal avaluar el Length de l'stream de nou
>> put
%% generem i desem l'objecte /Page
1 index
<<
  /Type /Page
  /Parent elseuParent
  /Resources
  <<
    /ProcSet [/PDF /Text ]
    /Font fontResources
  >>
  /Contents elseusContents
  suarAquinaPlana
  {  %% forall
   idempDi eq
   {
    /onMediaBox exch def
   }
   {
    pop
   }ifelse
  }forall
  XRay /PeDeEfa get onMediaBox get /MediaBox get
  /MediaBox exch

%%ProblemaD
%%pop [0 0 595 200]

>> put
%%(:-Futbol)pstack quit
   iNOP 1 add /iNOP exch def
   nouCount 1 add /nouCount exch def
  }repeat
  objectesDindex idempDi Prefind put
  idempDi
  /nousKids true def  %% gatell per saber si inserim pàgines
 }if
}forall
nousKids  %% comprovem si hem inserit pàgines
{  %% muntem el nou array Kids
 counttomark array astore
 %% si hem inserit pàgines hauríem de redesar Kids a *l'arrel* i aquest al dic de COMdimoni
 currentdict iDimoni 4 string cvs cvn get dup l'arrel get dup dup
 5 -1 roll /Kids exch put dup /Count get  %% ajustem el valor del nou nombre de pàgines
 nouCount add /Count exch put  %% desem el nou nombre de pàgines
 l'arrel exch put
 pop  %% eliminem la mark
}
{  %% NO, netegem fins a mark inclusiva i aquí no ha passat re
 cleartomark
}ifelse
%% fi del protocol d'afegir pàgines

  mark exch aload pop
  %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
  counttomark dup 1 eq
  {
   pop
  }  %% tret de que nomes n'hi hagi 1
  {
   /atura't exch def /ici 2 def
   {
    ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if
   } loop
  } ifelse
  {  %% loop #
   count 0 eq {exit} if
   {  %% loop
    count 0 ne
    {
     dup type /marktype eq {pop}{exit} ifelse
    }
    {
     exit
    }ifelse
   } loop  %% elimina les marques d'inici d'array
   count 0 eq {exit} if
   %%dup COMdimoni exch get
   dup /laBranca exch def
   %% pesquem la branca ...
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup laBranca known {laBranca get exit}{pop}ifelse 
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
   dup
   dup /Type known
   {  %% nou per controlar pagines (/Pages) que no porten la clau /Type (no Linearized)
    /Type get dup
    /Pages eq
   }
   {
    dup /Kids known {true}{false}ifelse
   } ifelse  %% nou per controlar pagines (/Pages) que no porten la clau /Type (en fitxers no optimitzats)
   {  %% son Pages
    pop exch pop
    /Kids get  %% posem l'array a la pila per la seguent volta de loop

%% interroguem Kids, per ampliar-lo si cal i tornar-lo a desar a l'arrel iDimoni que toqui
(Kids 2)==
%% inici del protocol d'afegir pàgines
%% anem a pescar la ref ind del /Parent compartit, per si inserim pàgines
dup 0 get /laBranca exch def
%% pesquem la branca ...
/iDimoni 0 def
{  %% loop d'interrogacio dels dicts de COMdimoni
 currentdict iDimoni 4 string cvs cvn get
 %% el diccionari de l'objecte
 dup laBranca known {laBranca get exit}{pop}ifelse 
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
}loop  %% d'interrogacio dels dicts de COMdimoni
/Parent get /elseuParent exch def  %% referència indirecta compartida per totes les pàgines
%% interroguem Kids i l'ampliem si cal per tornar-lo a desar a l'arrel iDimoni que toqui
%% generant tota la resta d'objectes que se'n deriven
/nousKids false def  %% gatell per saber si inserim pàgines
/nouCount 0 def  %% compta quantes pàgines noves crearem aquí
dup mark exch
{  %% forall
 dup paginesDindex exch known
 {  %% inserció de noves pàgines amb la generació de nous objectes /Page
  dup /idempDi exch def paginesDindex exch get dup /AsAdisc exch def length
  dup array /Prefind exch def /iNOP 0 def
  {  %% repeat
   QuiEsAra 1 add /QuiEsAra exch def
   %% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
   (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
   dup Prefind exch iNOP exch put
%% afegirem els nous objectes /Contents i /Page al dic del darrer tros de PDF
MaxDimoni 1 sub 4 string cvs userdict exch get dup
%% generem i desem l'objecte /Contents lligat al nou objecte /Page
QuiEsAra 1 add /QuiEsAra exch def
%% aquest literal serà transformat per l'algorisme de repicat a una ref ind normativa (# # R)
(_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
dup /elseusContents exch def  %% pel diccionari /Page
AsAdisc iNOP get  %% anem a pescar l'adreça a disc del stream de Contents

%% aquí bastim el canvi de bookmarksXstream per bookmarksXpaginaDindex
dup bookmarksXstream exch get  %% pesquem l'array amb les bookmarks relacionades amb l'stream
%% desem l'array e bookmarks relacionades amb la referència indirecte de la nova pàgina
bookmarksXpaginaDindex exch 6 index exch put
%%(:-P)pstack quit quit

<< exch /XIU exch 1 array astore  %% clau per indicar al repicador que l'stream és a disc
/Length 0  %% el numeric indica al repicador que cal avaluar el Length de l'stream de nou
>> put
%% generem i desem l'objecte /Page
1 index
<<
  /Type /Page
  /Parent elseuParent
  /Resources
  <<
    /ProcSet [/PDF /Text ]
    /Font fontResources
  >>
  /Contents elseusContents
  suarAquinaPlana
  {  %% forall
   idempDi eq
   {
    /onMediaBox exch def
   }
   {
    pop
   }ifelse
  }forall
  XRay /PeDeEfa get onMediaBox get /MediaBox get
  /MediaBox exch

%%ProblemaD
%%pop [0 0 595 200]

>> put
%%(:-Futbol)pstack quit
   iNOP 1 add /iNOP exch def
   nouCount 1 add /nouCount exch def
  }repeat
  objectesDindex idempDi Prefind put
  idempDi
  /nousKids true def  %% gatell per saber si inserim pàgines
 }if
}forall
nousKids  %% comprovem si hem inserit pàgines
{  %% muntem el nou array Kids
 counttomark array astore
 %% si hem inserit pàgines hauríem de redesar Kids a *l'arrel* i aquest al dic de COMdimoni
 currentdict iDimoni 4 string cvs cvn get dup l'arrel get dup dup
 5 -1 roll /Kids exch put dup /Count get  %% ajustem el valor del nou nombre de pàgines
 nouCount add /Count exch put  %% desem el nou nombre de pàgines
 l'arrel exch put
 pop  %% eliminem la mark
}
{  %% NO, netegem fins a mark inclusiva i aquí no ha passat re
 cleartomark
}ifelse
%% fi del protocol d'afegir pàgines

    mark exch aload pop
    %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
    counttomark dup 1 eq
    {
     pop
    }  %% tret de que nomes n'hi hagi 1
    {
     /atura't exch def /ici 2 def
     {
      ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if
     } loop
    } ifelse
   }
   { %% son Pagines
    pop pop  %% ens carreguem el diccionari de la pagina
    cntpa 1 add /cntpa exch def  %% cntpa 5 string cvs show
    quinaPlana exch cntpa 5 string cvs cvn exch put  %% afegim el parell Num. Pagina / Clau de Pagina
    count 0 eq {exit} if
    {  %% loop
     count 0 ne
     {
      dup type /marktype eq {pop}{exit} ifelse
     }
     {
      exit
     }ifelse
    } loop  %% elimina les marques d'inici d'array
    exit
   } ifelse
   count 0 eq {exit} if
   {  %% loop
    count 0 ne
    {
     dup type /marktype eq {pop}{exit} ifelse
    }
    {
     exit
    }ifelse
   } loop  %% elimina les marques d'inici d'array
  } loop  %% fi de loop #
  count 0 eq {exit} if
  {  %% loop
   count 0 ne
   {
    dup type /marktype eq {pop}{exit} ifelse
   }
   {
    exit
   }ifelse
  } loop  %% elimina les marques d'inici d'array
 }
 {  %% son Pagines
  pop pop  %% ens carreguem el diccionari de la pagina
  cntpa 1 add /cntpa exch def  %%cntpa 5 string cvs show
  quinaPlana exch cntpa 5 string cvs cvn exch put  %% afegim el parell Num. Pagina / Clau de Pagina
  count 0 eq {exit} if
  {  %% loop
   count 0 ne
   {
    dup type /marktype eq {pop}{exit} ifelse
   }
   {
    exit
   }ifelse
  } loop  %% elimina les marques d'inici d'array
 } ifelse
 count 0 eq {exit} if
 {  %% loop
  count 0 ne
  {
   dup type /marktype eq {pop}{exit} ifelse
  }
  {
   exit
  }ifelse
 } loop  %% elimina les marques d'inici d'array acomulades
} loop  %% fi d'espia_PagesTree_2.ps
%% espiaKids %%
%%paginesDindex {== ==}forall

%%ProblemaDD
%%bookmarksXpaginaDindex {== ==}forall (:-P)pstack quit

%% ens cal regenerar el diccionari quinaPlana on desarem número de pàgina / clau de pàgina
/quinaPlana <<>> def  %% diccionari on guardarem Num. Pagina / Clau de Pagina
/cntpa 0 def  %% valor inicial del compta pagines
%% pesquem el dict arrel de /Pages
/iDimoni 0 def
{  %% loop d'interrogacio dels dicts de COMdimoni
 currentdict iDimoni 4 string cvs cvn get
 %% el diccionari de l'objecte /Pages arrel
 dup l'arrel known {l'arrel get exit}{pop}ifelse
 iDimoni 1 add /iDimoni exch def
 iDimoni MaxDimoni eq {exit} if
} loop  %% d'interrogacio dels dicts de COMdimoni
/Kids get  %% l'array de fills obligatoria
aload pop
%% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
count dup 1 eq
{
 pop
}  %% tret de que nomes n'hi hagi 1
{
 /atura't exch def /ici 2 def
 {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
} ifelse
{  %% loop d'espia_PagesTree_2.ps
 count 0 eq {exit} if
 {  %% loop
  count 0 ne
  {
   dup type /marktype eq {pop}{exit} ifelse
  }
  {
   exit
  }ifelse
 } loop  %% elimina les marques d'inici d'array
 count 0 eq {exit} if
 %%dup COMdimoni exch get  % el diccionari de l'objecte
 dup /laBranca exch def
 %% pesquem la branca ...
 /iDimoni 0 def
 {  %% loop d'interrogacio dels dicts de COMdimoni
  currentdict iDimoni 4 string cvs cvn get
  %% el diccionari de l'objecte
  dup laBranca known {laBranca get exit}{pop}ifelse 
  iDimoni 1 add /iDimoni exch def
  iDimoni MaxDimoni eq {exit} if
 } loop  %% d'interrogacio dels dicts de COMdimoni
 %% (:::) pstack quit  % aqui cal servir el loop de dics de COMdimoni amb una variable
 dup
 dup /Type known
 {  %% nou per controlar pagines (/Pages) que no porten la clau /Type (no Linearized)
  /Type get dup /Pages eq
 }
 {
  dup /Kids known {true}{false}ifelse
 } ifelse  %% nou per controlar pagines (/Pages) que no porten la clau /Type (en fitxers no optimitzats)
 {  %% ifelse
  %% son Pages
  pop exch pop
  /Kids get
  mark exch aload pop
  %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
  counttomark dup 1 eq
  {
   pop
  }  %% tret de que nomes n'hi hagi 1
  {
   /atura't exch def /ici 2 def
   {
    ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if
   } loop
  } ifelse
  {  %% loop #
   count 0 eq {exit} if
   {  %% loop
    count 0 ne
    {
     dup type /marktype eq {pop}{exit} ifelse
    }
    {
     exit
    }ifelse
   } loop  %% elimina les marques d'inici d'array
   count 0 eq {exit} if
   %%dup COMdimoni exch get
   dup /laBranca exch def
   %% pesquem la branca ...
   /iDimoni 0 def
   {  %% loop d'interrogacio dels dicts de COMdimoni
    currentdict iDimoni 4 string cvs cvn get
    %% el diccionari de l'objecte
    dup laBranca known {laBranca get exit}{pop}ifelse 
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   } loop  %% d'interrogacio dels dicts de COMdimoni
   dup
   dup /Type known
   {  %% nou per controlar pagines (/Pages) que no porten la clau /Type (no Linearized)
    /Type get dup
    /Pages eq
   }
   {
    dup /Kids known {true}{false}ifelse
   } ifelse  %% nou per controlar pagines (/Pages) que no porten la clau /Type (en fitxers no optimitzats)
   {  %% son Pages
    pop exch pop
    /Kids get  %% posem l'array a la pila per la seguent volta de loop
    mark exch aload pop
    %% AQUEST LOOP CAPGIRA TOTS ELS ELEMENTS TROBATS A LA PILA
    counttomark dup 1 eq
    {
     pop
    }  %% tret de que nomes n'hi hagi 1
    {
     /atura't exch def /ici 2 def
     {
      ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if
     } loop
    } ifelse
   }
   { %% son Pagines
    pop pop  %% ens carreguem el diccionari de la pagina
    cntpa 1 add /cntpa exch def  %% cntpa 5 string cvs show
    quinaPlana exch cntpa 5 string cvs cvn exch put  %% afegim el parell Num. Pagina / Clau de Pagina
    count 0 eq {exit} if
    {  %% loop
     count 0 ne
     {
      dup type /marktype eq {pop}{exit} ifelse
     }
     {
      exit
     }ifelse
    } loop  %% elimina les marques d'inici d'array
    exit
   } ifelse
   count 0 eq {exit} if
   {  %% loop
    count 0 ne
    {
     dup type /marktype eq {pop}{exit} ifelse
    }
    {
     exit
    }ifelse
   } loop  %% elimina les marques d'inici d'array
  } loop  %% fi de loop #
  count 0 eq {exit} if
  {  %% loop
   count 0 ne
   {
    dup type /marktype eq {pop}{exit} ifelse
   }
   {
    exit
   }ifelse
  } loop  %% elimina les marques d'inici d'array
 }
 {  %% son Pagines
  pop pop  %% ens carreguem el diccionari de la pagina
  cntpa 1 add /cntpa exch def  %%cntpa 5 string cvs show
  quinaPlana exch cntpa 5 string cvs cvn exch put  %% afegim el parell Num. Pagina / Clau de Pagina
  count 0 eq {exit} if
  {  %% loop
   count 0 ne
   {
    dup type /marktype eq {pop}{exit} ifelse
   }
   {
    exit
   }ifelse
  } loop  %% elimina les marques d'inici d'array
 } ifelse
 count 0 eq {exit} if
 {  %% loop
  count 0 ne
  {
   dup type /marktype eq {pop}{exit} ifelse
  }
  {
   exit
  }ifelse
 } loop  %% elimina les marques d'inici d'array acomulades
} loop  %% fi d'espia_PagesTree_2.ps

quinaPlana length /maxPlana exch def  %% nombre de pagines del document o darrer numero de plana

%% hem de reescriure els streams d'index per substituir la ref ind pel seu numero de pàgina real
%% definim el fitxer de repicat
(DrefindAnum) dup length faPath add string dup /pAthXiU exch def
0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
pAthXiU /_DrefindAnum exch def
paginesDindex
{  %% forall per totes les insercions d'índex
 {  %% forall per tots els streams de pàgina de cada inserció
  _DrefindAnum (w) file /DrefindAnum exch def
  dup /streaMaRepicar exch def
  (r) file 65535 string readstring
  {
   (\n ... l'stream excedeix la capacitat prevista per aquest tipus d'objecte ... PLEGUEM!\n\n)
   pstack quit 
  }
  {
   {  %% loop pel search recursiu
    (___)  %% creiem que amb tres guions baixos seguits eliminem coincidències fatals
    search
    {  %% l'hem trobat
     %% muntem la ref ind i anem escrivint
     dup length dup /faTram exch def 1 sub /i40 exch def
     {  %% loop fins trobar l'obrir parèntesi 40
      dup i40 get 40 eq
      {
       dup 0 i40 getinterval
       %% escrivim el primer tram de l'stream fins on comença l'string amb la ref ind
       DrefindAnum exch writestring
       %% extirpem el primer tram de la ref ind
       i40 dup faTram exch sub getinterval
       %% reconstruim el dos primers trams de la ref ind
       18 string /refindS exch def
       dup length /araVa exch def refindS exch 0 exch putinterval
       refindS exch araVa exch putinterval araVa 3 add /araVa exch def
       (\)) search  %% cerquem el tancar parèntesi
       {
        %% reconstruim els dos darrers trams de la ref ind
        araVa exch refindS 3 1 roll putinterval
        refindS exch 17 exch putinterval
        refindS cvx exec  %% ara que ja tenim la ref ind en una string
        /quinNum exch def
        %% anem a buscar el seu equivalent de número de pàgina
        /nuDpag null def
        quinaPlana
        {  %% forall
         quinNum eq
         {
          /nuDpag exch def
         }
         {
          pop
         }ifelse
        }forall
        nuDpag null eq
        {
         (\n ... error estructural reinserint l'index ... PLEGUEM!\n\n) pstack quit
        }if
        %% repiquem el número de pàgina a l'stream
        DrefindAnum (\() writestring
        DrefindAnum nuDpag 6 string cvs writestring
        DrefindAnum (\)) writestring
        %% i sortim del loop per continuar el search recursiu per cercar més ref ind
        exit
       }
       {
        (\n ... error estructural a l'stream ... PLEGUEM!\n\n) pstack quit
       }ifelse
      }
      {
       i40 1 sub /i40 exch def
      }ifelse
     }loop
    }
    {  %% escrivim el darrer tram de l'stream, tanquem el fitxer i pleguem del loop
     DrefindAnum exch writestring DrefindAnum closefile exit
    }ifelse
   }loop
   %% eliminem l'stream antic
   streaMaRepicar deletefile
   %% renombrem l'stream repicat altre cop al nom antic
   _DrefindAnum streaMaRepicar renamefile
  }ifelse
 }forall  %% per tots els streams de pàgina de cada inserció
 pop  %% eliminem la clau
}forall  %% per totes les insercions d'índex
%%(fififififi)pstack quit

%% aquí bastim tota l'infraestructura de vincles d'índex per pàgina, paral·lel als vincles dels
%% bookmarks (aprofitem part del càlcul ja fet), si fem els bookmarks la clau /Dest del vincle
%% serà verticalment precisa i si no, hi quedarà un null a la posició vertical (no situarà l'Y)

%% afefim l'arbre de vincles plana a plana generant els objectes corresponents x cadascun

     bookmarksXpaginaDindex
     {  %% forall per totes les noves pàgines que tenen l'índex
      %% sabem quines bookmarks hi ha a cada pàgina d'índex, però aquí només triem les bookmarks
      %% actives fins la jerarquia utilitzada a l'índex de pàgina (L36322)
      {  %% forall per totes les bookmarks

%      %% l'array de cada pàgina amb totes les ref ind dels vincles per Annots el tractarem
%      %% prèviament com un diccionari per tal de no repetir mai referències indirectes
%      /aNNOTS <<>> def

       dup bboxBindexDpagina exch known
       {
        %% desem la bookmark i n'extraiem el BBox de la línia de text de l'índex a vincular
        bboxBindexDpagina exch dup /araBkmrk exch def get
        %% generem tota la serie d'objectes per a cada link
        QuiEsAra 1 add /QuiEsAra exch def
        (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn

%        %% el desem al diccionari temporal d'Annots?
%        dup aNNOTS exch known
%        {  %% objecte link repetit
%         pop
%         (&&&&&)pstack quit
%        }
%        {  %% el desem al diccionari temporal que muntarà l'array Annots
%         dup aNNOTS exch null put

dup /araOL exch def  %% l'objecte del link actual per Annots

%% abans un array
%%  aNNOTS dup length 1 add dup 1 sub /aFEGIR exch def array dup 3 -1 roll 0 exch putinterval
%%  /aNNOTS exch def dup aNNOTS exch aFEGIR exch put  %% desem la clau del link i deixem una còpia
         %% muntem el primer objecte de la serie
         <<
           /Rect 4 -1 roll
           %% creem el segon objecte de la serie
           /A QuiEsAra 1 add /QuiEsAra exch def
           (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
           %% deixem el literal per definir d'A a la penúltima posició de l'stack
           dup count 1 sub 1 roll
           /Type/Annot
           /Border [0 0 0]  %% u al tercer si volem q es vegi
           /H/I
           /BS<</S/S/W 0/Type/Border>>  %% u a W si volem que es vegi
           /Subtype/Link
           %%  /C [.5 0 0]  %% podem eliminar
         >>
         %% afegim l'objecte link al dic del darrer tros del PDF
         MaxDimoni 1 sub 4 string cvs userdict exch get 3 1 roll put
         %% construim l'objecte /A
         arbreDbookmarks araBkmrk get /Dest get
         <</D 3 -1 roll /S/GoTo>>
         %% afegim l'objecte /A al dic del darrer tros del PDF
         MaxDimoni 1 sub 4 string cvs userdict exch get 3 1 roll put
         %% agafem la ref ind de la pàgina per afegir de nou o ampliar l'objecte Annots al seu dic
         dup /aCercar exch def  %% desem el literal del num d'obj
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup aCercar known {aCercar get exit}{pop}ifelse
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         }loop  %% d'interrogacio dels dicts de COMdimoni
         %% ara tenim a l'stack el diccionari /Page on hi ha l'índex
         dup /Annots known
         {  %% si ja hi es l'afegim a la cua
          dup /Annots get
          dup type  %% nomes si es una array serem davant de l'objecte directe
          /nametype eq
          {  %% es una ref ind q apunta a l'array dels Annots
           /aCercar exch def  %% desem el literal del num d'obj
           %% pesquem el diccionari de la pagina x incrustar-hi l'entrada /Annots ...
           /iDimoni 0 def
           {  %% loop d'interrogacio dels dicts de COMdimoni
            currentdict iDimoni 4 string cvs cvn get
            %% el diccionari de l'objecte
            dup aCercar known {aCercar get exit}{pop}ifelse
            iDimoni 1 add /iDimoni exch def
            iDimoni MaxDimoni eq {exit} if
           }loop  %% d'interrogacio dels dicts de COMdimoni
          }if
          %% afegim les claus del dic temporal aNNOTS (links)
          dup length dup /aFEGIR exch def
% aNNOTS length dup /faDa exch def
1
          add array dup 3 -1 roll
          0 exch putinterval dup aFEGIR
% aNNOTS {pop}forall faDa array astore  %% desem les claus dins una array
[araOL]
          putinterval
%%          (mmmm)pstack quit
          /Annots exch put
         }
         {  %% o l'entrem de nou en nou
          /Annots
%% creem el contingut del diccionari temporal aNNOTS (links) com array per Annots
% aNNOTS {pop}forall aNNOTS length array astore
[araOL]
%%         (nnnnn)pstack quit
          put
         }ifelse
%        }ifelse
        %%{== ==}forall
       }
       {  %% fora de jerarquia
        pop
       }ifelse
      }forall  %% per totes les bookmarks
      pop  %% eliminem la ref ind /Page
     }forall  %% per totes les noves pàgines que tenen l'índex
    }if  %% generem l'índex amb pàgines
   }if  %% qualsevol de les dues menes d'índex

   polyFEM
   2 get  %% numerem les pàgines?
   {  %% si
    (\n\nNumerant les Pagines ...\n\n)print flush
    polyFEM
    3 get  %% on posem el numerador?
    {  %% true = a sota centrat
     /numJ true def  %% gatell pel repicat del PDF
    }
    {  %% false = a sota a la dreta
     /numJ false def  %% gatell pel repicat del PDF
    }ifelse
    /nmrpgns true def  %% gatell pel repicat del PDF
%%SimsiARA
%% si fem el numerador:
%% ens cal afegir les /Fonts usades a fontResources per a tots els Resources de les pàgines
%%%%%%%% nou repicat dels /Fonts a /Resources de cada pàgina
 quinaPlana
 {  %% forall
  /actGina exch def /araPlana exch def  %% desem el literal del num d'obj /Page i l'ordinal de la plana a la que correspon
  %% pesquem la branca ...
  /iDimoni 0 def
  {  %% loop d'interrogacio dels dicts de COMdimoni
   currentdict iDimoni 4 string cvs cvn get
   %% el diccionari de l'objecte
   dup actGina known {actGina get exit}{pop}ifelse 
   iDimoni 1 add /iDimoni exch def
   iDimoni MaxDimoni eq {exit} if
  } loop  %% d'interrogacio dels dicts de COMdimoni
  %% 05.03.09 aquesta solucio de la cerca recursiva del dic Resources considerant el null i el diccionari buit cal implementar-la arreu on calgui!
  %% anem cercant cap enrera els Parent en cas de no trobar Resources dins la mateixa pagina
  {  %% loop
   dup /Resources known  %% hi ha Resources?
   {  %% Resources es a /Page o /Pages ?
    %% descartem la possibilitat de que la ref indirecte sigui un null o un dict buit
    %% pel que llavors tindria els Resources heretats i continuariem el loop enrera ...
    /Resources get dup type /nametype eq
    {
     /aCercar exch def  %% nom amb la ref ind del dic Resources
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dics de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
     dup length 0 eq
     {  %% pagina amb Resources heretats i continuem el loop enrera
      pop
     }
     {

%% /riResources aCercar def  %% la ref ind del diccionari Resources

      exit  %% sortim del loop amb el dic Resources a l'stack
     }ifelse
    }
    {
     dup null eq
     {  %% pagina amb Resources heretats i continuem el loop enrera
      pop
     }
     {  %% no pot ser altra cosa que un dic directe
      dup length 0 eq
      {  %% pagina amb Resources heretats i continuem el loop enrera
       pop
      }
      {

       exit  %% sortim del loop amb el dic Resources a l'stack
      }ifelse
     }ifelse
    }ifelse
   }
   {  %% Resources podria estar a /Pages!
    dup /Parent known
    {
     dup /Parent get
     /aCercar exch def
     %% pesquem la branca ...
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup aCercar known {aCercar get exit}{pop}ifelse 
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     } loop  %% d'interrogacio dels dicts de COMdimoni
    }
    {  %% aquesta pagina no te Resources!
     BaBeL 33 get print flush
actGina == (6)==
     %% informem dels fitxers del tmp
     BaBeL 50 get print flush
     clear stop  %%quit
%%UBpliegOMaker
    }ifelse
   }ifelse
  }loop
%% aquí tenim el diccionari Resources de la plana que explorem ara
dup /dicDrecursos exch def
%% si és 

  %% hi ha fonts ?
  dup /Font known
  {
   /Font get  %% es un diccionari directe o una ind ref ?
   dup type /nametype eq
   {
    /aCercar exch def  %% nom amb la ref ind del dic Font
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup aCercar known {aCercar get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    } loop  %% d'interrogacio dels dicts de COMdimoni
   }if

%% aquí hi ha el diccionari dels recursos /Font de la plana
%% /recursosFont exch def
/aDins exch def
fontResources
{
 aDins 3 1 roll put
}forall
%% reinserim a Resources!
dicDrecursos /Font aDins put
%%(recursosFont)pstack quit

  }
  {  %% NO hi ha /Font

%% aquí hi ha el diccionari dels recursos /Font de la plana
%% /recursosFont exch def
/femRFont <<>> def
femRFont /aDins exch def
fontResources
{
 aDins 3 1 roll put
}forall
/Font femRFont put
  } ifelse


 } forall  %% fi del forall x pagines
%%%%%%%% fi del nou repicat

%% ens cal posar els gatells al repicat final
   }
   {  %% no
    /nmrpgns false def  %% gatell pel repicat del PDF
   }ifelse  %% numerem les pàgines

  }if  %/12 arbre jeràrquic

  QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
  {
   BaBeL 23 get print flush  %% missatge de reinterpretacio dels Contents
   %#%50% definim el fitxer on reescriurem els Contents repicats aplicant el tractament a través de les redefinicions d'OpContents_QueLiFemFer#
   (%#%50%)==
   l'objectenet2 (w) file
   /sEdAs2 exch def
   %#%51% procediments de replicat idèntic dels Contents (sense comprimir) dins un fitxer
   (%#%51%)==
   /BeSSo2  %% aquesta darrera funcio executa directament el fitxer de continguts l'objectenet (ja repicada 1 cop!)
   {
    %% {  % stopped
    OpContents_QueLiFemFer2 begin  %% activem el diccionari amb les redefinicions dels operadors PDF segons el tractament a fer
    l'objectenet (r) file cvx exec end  %% executem el fitxer dels Contents sencers i sortim del diccionari
    sEdAs2 dup flushfile closefile
    %% } stopped { %pop {== ==}forall (!!!!!!) ==(!) pstack quit}if
   }bind def
   %#%51bis% procediment de replicat idèntic de l'stream de Contents dels Form XObject (sense comprimir) dins un fitxer
   (%#%51bis%)==
   /BeSSo3  %% aquesta darrera funcio executa directament el fitxer de continguts l'objectenet (ja repicada 1 cop!)
   {
    %%{
    OpContents_QueLiFemFer2 begin  %% activem el diccionari amb les redefinicions dels operadors PDF segons el tractament a fer
    FormStream
    cvx exec end  %% executem el fitxer del Form stream i sortim del diccionari
    sEdAs2 dup flushfile closefile
    %%} stopped {() pstack quit}if
   }bind def
   %% inicialitzem les funcions dels valors actuals de ...
   /csARA [/Black] def  %% valor inicial de l'Espai de Color actual per fill
   /CSARA [/Black] def  %% valor inicial de l'Espai de Color actual per stroke
   /gsARA [null] def  %% Estat Grafic actual
   /tintARA [1] def  %% valor inicial de Tinta actual
   /Tfill 0 def  %% valor inical del gatell (suposem que no afecta) per saber si el valor de tinta es per fill (0) o stroke (1)
   /Tzero false def  %% valor inicial del gatell x saber si hem pintat amb tinta zero (blanc)
   /TiNTeMF true def  %% gatell de si Tintem x Fill
   /TiNTeMS true def  %% gatell de si Tintem x Stroke
   /TacaTintaF 1 def  %% valor x defecte de la Tinta per Fill
   /TacaTintaS 1 def  %% valor x defecte de la Tinta per Stroke
   /LaQtocaF true def  %% gatell x compensar el comportament Nexus/Backstage x Fill
   /LaQtocaS true def  %% gatell x compensar el comportament Nexus/Backstage x Stroke
   %% valors inicials dels gatells x control de l'overprint
   /NomesUn true def  %% valor inicial del gatell x saber si nomes treballem amb un espai de color d'1 sol component
   /OPactua false def
   /opactua false def
   /es4c false def  %% es CMYK ?
   %% ... abans dins el dic d'OpContents
   %% creiem que aqui no hi pinta res aixo
   %%csARA 0 get dup quinaTinta eq {  % com q es el primer, creiem que interrogant x fill n'hi ha prou
   %%                               pop %==
   %%                               /TiNTeM true def
   %%                              }
   %%                              {
   %%                               pop
   %%                               /TiNTeM false def
   %%                              }ifelse
   %#%52% reinterpretem els Contents unificats en un sol fitxer per fer-li el tractament
   (%#%52%)==
   %%null /nomDtp exch def  % a null indica a BeSSo2 que no esta reinterpretant cap stream de Patterns&Shadings
   BeSSo2  %% noteu q aqui repiquem l'stream unificat de l'unica pagina q pot existir!
  }if  %/01 SEPARACIÓ DE TINTES
  %% test
  %%sEdAs2 closefile

  QueLiFemFer 5 eq  %:05 dada variable
  QueLiFemFer 6 eq  %:06 COSIT D'IMATGES
  QueLiFemFer 10 eq  %:10 PREFLIGHT AMB CAPES
  QueLiFemFer 13 eq  %:13 eliminem continguts de pàgina
  QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
  QueLiFemFer 16 eq  %:16 cerca i substitució de text

  QueLiFemFer 12 eq  %:12 arbre jeràrquic
  {  %% sempre que numerem pàgines!
   nmrpgns
  }
  {
   false
  }ifelse

  or or or or or or
  {
   %#%52bis.5.0% gatell per controlar l'activat d'operadors amb funcions de dada variable
   (%#%52bis.5.0%)==
   /faDADAv false def
   %#%52bis.6.0% inicialitzem novament el valor de l'array dels diccionaris de /EstatGrafic
   (%#%52bis.6.0%)==
   /EstatGrafic  %% paquet on hi ha en tot moment els estats grafics actius
   [  %% mantindrem les claus originals dels operadors PDF q definixen els valors de l'estat grafic
    <<  %% a l'index zero sempre hi haura l'estat grafic per defecte (aquest no s'elimina mai)
      %% valors de l'estat grafic INdependents del dispositiu
      %% /cm [1 0 0 1 0 0]  % CTM activa ... indentity matrix per l'eix general de coordenades
      %% valors inicials de cm personalitzats un a un
      /cmPy 0  %% Y de l'origen de l'eix de coordenades a cm
      /cmPx 0  %% X de l'origen de l'eix de coordenades a cm
      /cmSy 1  %% escala Y a cm
      /cm_tanBsin 0  %% valor de la tangent o del sinus de l'angle a cm
      /cm_tanAsin 0  %% valor de la tangent o del sinus de l'angle a cm
      /cmSx 1  %% escala X a cm
      /girNOcontrolat false  %% gatell provisional per filtrar esbiaixats i miralls de l'eix cm no implementats encara
/A_cm 0  %% valor de l'angle calculat en funcio dels valors del sin/cos de la cm
/eixcmGirat false  %% valor inicial del gatell detector de girs a l'espai de coordenades

      %% clipping path actiu ...
      %% valors inicials del control de clips necessari pel trencaclosques ...
      /WARA false  %% clip
      /W*ARA false  %% eoclip
      %% color space actiu ... x implementar
      %% color actiu ... x implementar
      %% line width activa ... x implementar
      %% line cap activa ... x implementar
      %% line join actiu ... x implementar
      %% miter limit activa ... x implementar
      %% dash pattern actiu ... x implementar
      %% rendering intent actiu ... x implementar
      %% stroke adjustment actiu ... x implementar
      %% blend mode actiu ... x implementar
      %% soft mask activa ... x implementar
      %% alpha constant activa ... x implementar
      %% alpha source activa ... x implementar
      %% valors de l'estat grafic especifics pel text
      %% /Tm [1 0 0 1 0 0]  % ... Text matrix ... NO es un valor pur de l'estat grafic ... indentity matrix per les coordenades de text
      %% valors inicials de les variables de posicio absoluta del caracter definits per Tm
      /TxTm 0
      /TyTm 0
      %% valor inicial del multiplicador d'escala X del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
      /SxTm 1
      %% valor inicial del multiplicador d'escala Y del cos del text (podria mancar Tm) ... seria treballar amb una identity matrix [1 0 0 1 0 0]
      /SyTm 1

/A_Tm 0  %% valor de l'angle calculat en funcio dels valors del sin/cos de la Tm
/eixTmGirat false  %% valor inicial del gatell detector de girs a l'espai de coordenades

      %% Tc ecTc (definit tambe a ") ... character space
      %% valor inicial d'espaiat entre caracters (s'aplica a cada caracter) definit per Tc
      /ecTc 0
      %% Tw epTw (definit tambe a ") ... Word spacing
      %% valor inicial d'espaiat entre paraules (nomes s'aplica quan troba un /space) definit per Tw
      /epTw 0
      %% Tz ... Horizontal scaling
      %% valor inicial del % d'escala horitzontal definit per Tz
      /acTz 100
      %% TL TD ... Leading
      %% valor inicial del valor pur de l'interliniat (sense multiplicar per SyTm o cmSy)
      /TLoTD 0
      %% valor inicial de l'interliniat (s'aplica amb T* " i ') un cop multiplicat per SyTm i cmSy
      /INTERli 0
      %% Tf ... Text font+Text font size ... l'implementem pel gatell 16 MASATS
      /acTf
      [
       null  %% nom PDF de la font utilitzada  (si és null voldrà dir que encara no s'ha definit)
       null  %% valor del cos aquí, doncs el cos real ve condicionat per l'escala de Tm i cm
      ]
      %% Tr ... Text rendering mode ... x implementar
      %% Ts ... Text rise
      %% valor per defecte del desplacament vertical del text
      /TyTs 0
      %% /TK (definit com a clau del dic gs --graphics state parameter dictionary--) ... Text knockout ... x implementar
      %% valors inicials de les coordenades d'inici de cadena, nomes utilitzades pels operadors ' i "
      /iTxTm 0
      /iTyTm 0
      %% valors de l'estat grafic DEpendents del dispositiu
      %% overprint actiu ... x implementar
      %% overprint mode actiu ... x implementar
      %% black generation activa ... x implementar
      %% undercolor removal activa ... x implementar
      %% transfer function ... x implementar
      %% halftone activa ... x implementar
      %% flatness activa ... x implementar
      %% smoothness actiu ... x implementar
    >> %% els paramentres definits seran nomes els que l'aplicacio necessiti x treballar
   ]def
   %% index de l'estat grafic actiu
   0 /iEG exch def
   %% reexecutem els valors de l'estat grafic inicial x redefinir-ne les variables (no se si aqui els necessitem)
   EstatGrafic iEG get  %% recuperem del dic de l'estat grafic actiu
   {def}forall  %% redefinim les variables
   BaBeL 23 get print flush  %% missatge de reinterpretacio dels Contents
   /OdeBaixa << >> def  %% definim el diccionari de referencies indirectes d'objectes d'imatges que formen un mosaic i q s'han d'eliminar
   %%% es aixo?
   1 /iNousStreams exch def  %% index per assignar noms als nous streams repicats
   %% redefinició dels path i els índex pel repicat dels nou streams
   %%(%!!%)==
   %% Stream Original intacte (SOi)
   (1__________.SOi) dup length faPath add string dup /pAthXiU exch def
   0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
   pAthXiU /nousStreams exch def  %% utilitzat per l'applet per desar els nous streams redefinits al disc
   %%% es aixo?
   %#%52bis.6.1% definim el fitxer on reescriurem els Contents repicats aplicant el tractament a traves de les redefinicions d'OpContents_QueLiFemFer#
   (%#%52bis.6.1%)==
   l'objectenet (w) file
   /sEdAs2 exch def
   %#%52bis.6.2% procediments de replicat idèntic dels Contents (sense comprimir) dins un fitxer
   (%#%52bis.6.2%)==
   /BeSSo2  %% aquesta darrera funcio executa directament el fitxer de continguts l'objectenet (ja repicada 1 cop!)
   {
    %% {
    OpContents_QueLiFemFer2 begin  %% activem el diccionari amb les redefinicions dels operadors PDF segons el tractament a fer
    aLLeGiR cvx exec end  %% executem el fitxer de l'stream dels /Contents i sortim del diccionari
    sEdAs2 flushfile
    %% } stopped {pop {== ==}forall (!!!!!!) == quit}if
   }bind def
   %% array buida on desarem els parells de les ref ind dels resources i els propis objectes de tots els FormsXObjects
   /rsrcsFormsXObjects [] def 
   /VectorViu false def  %% gatell d'anellat en llesques de vectorials
   /DuuLlesques false def  %% gatell x tractar de forma adient els streams dels Forms interpretats abans o no 
   %% variables que necessitem pel gatell 13
   /alFoc false def  %% valor inicial del gatell que activa l'eliminació de continguts de pàgina
   %% ##% repiquem els Contents x segon cop
   %% a partir del diccionari dexifrador OpContents_QueLiFemFer2
   %%(%% #!*!#%)==
   quinaPlana
   {  %% forall que extrau els Contents i els repica
    /actGina exch def  %% desem el literal del num d'obj /Page
    %% /1 eq {/miraARA true def}{/miraARA false def}ifelse
    %%(pagina ... ) ==
    dup ==  %% llistem l'ordinal del num de pagina
    %%!%! literal del num de pagina
    /araPlana exch def
    QueLiFemFer 6 eq  %/10 PREFLIGHT AMB CAPES
    {
%% nou6xA3copiseny
%% a /capCapsa dins la pàgina d'iFenix hi ha el nom de totes les imatges que formen el trencadís
%% a /matriu hi ha la matriu de coordenades modificada per tot el trencadís cosit
%% cal veure WARA i W*ARA que són a la segona redefinició d'operadors
%iFenix /1 get /Im12077 get {== ==}forall
%%WARA W*ARA (:-D)pstack quit

     %#%52bis.6.3% generem el diccionari KaMPoRa amb totes les imatges d'una mateixa pàgina a eliminar
     (%#%52bis.6.3%)==
     %% cercant dins el dic de cada imatge frontisa (clau del mosaic) l'entrada /eliminem
     /KaMPoRa <<>>def
     iFenix araPlana known  %%length 0 ne
     {  %% if de tret que aquesta plana no tingui trencaclosques
      iFenix araPlana get
      {  %% forall x totes les imatges frontisa
       /eliminem get
       {  %% forall x totes les arrays de linies d'imatge q desapareixen
        {  %% forall x totes les imatges
         KaMPoRa exch null put  %% desem a KaMPoRa
        }forall
       }forall
       pop  %% eliminem el literal de la imatge frontisa
      }forall
     }if  %% tret que aquesta plana no tingui trencaclosques
     %% Quedelemi
     %% aqui eliminem del dic Resources de cada pagina els XObject que sobren del mosaic del trencaclosques
     KaMPoRa
     {
      pop  %% ens carreguem el null
      RSRCS araPlana get  %% pesquem el dic Resources que correspon a la plana q tractem
      /XObject get
      %% es una referencia indirecte?
      dup type /nametype eq 1 index length 16 eq
      {
       1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
      }
      {
       false
      }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
      and
      {  %% els dos han de ser certs (o sigui una ref ind segur), doncs llavors n'anirem a treure el literal que amaga
       /aCercar exch def
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
      }if
      exch undef  %% eliminem del dic /XObject la imatge sobrera del mosaic
     }forall
     %% ... i sobretot cal modificar la matriu de la imatge al seu dic xq quadri amb cm ?!?
    }if  %:10 PREFLIGHT AMB CAPES
    %% pesquem la branca ...
    /iDimoni 0 def
    {  %% loop d'interrogacio dels dicts de COMdimoni
     currentdict iDimoni 4 string cvs cvn get
     %% el diccionari de l'objecte
     dup actGina known {actGina get exit}{pop}ifelse 
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% d'interrogacio dels dicts de COMdimoni
    %% miraARA {actGina{== ==}forall(!!!!!!!)== quit }if
    dup /Contents known  %% hi ha continguts a la pagina ?
    {

QueLiFemFer 12 eq  %:12 arbre jeràrquic
{
 %%Simsi
 dup /MediaBox known {dup /MediaBox get
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def}if
}if
     /Contents get dup type /nametype eq
     {
      %%COMdimoni exch get
      /laBranca exch def
      %% pesquem la branca ...
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup laBranca known {laBranca get exit}{pop}ifelse 
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni
      dup
      dup type /arraytype eq
      {  %% es una array indirecte d'objectes indirectes
       %%( ... es una array indirecte d'objectes indirectes 0) ==
       %%    %%test
       %%    391 get == () == quit
       %%% x posar tots els Contents en 1 sol objecte
       dup dup length dup 0 eq
       {  %% no hi ha Contents!
        BaBeL 22 get print flush
        %% informem dels fitxers del tmp
        BaBeL 50 get print flush
        clear stop  %%quit
%%UBpliegOMaker
       }if                        
       1 sub /aFora exch def
       dup 0 get /ToTen1 exch def  %% triem a l'atzar el primer objecte de l'array x desar l'stream dels Contents unificats en 1 sol objecte
       1 aFora getinterval /xUnDef exch def  %% tota la resta d'objectes els donarem de baixa
       laBranca /quinOmodifiquem exch def  %% ref ind de l'objecte que apunta els Contents
       /QueLiFem {quinOmodifiquem [ToTen1] put} def  %% procediment x modificar l'objecte

QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
{
%%MattBianco AQUÍ LA IMATGE ANIRÀ A SOTA DE TOT
restauraJPEGs araPlana 4 string cvs cvx exec 1 sub dup /Psom exch def
get dup null eq  %% és el primer XObject que processem en aquesta pàgina?
{  %% no, o sigui que l'ignorem o li seguim la pista per donar-lo de baixa?
 %% per donar-lo de baixa, hauríem de treure'l del dic Resources i matar l'objecte
 %% XObject completament donant-lo d'alta a NomXdBaixa o a OdeBaixa?
 pop
}
{  %% si, per tant el fem servir per restaurar la capa d'imatge rasteritzada
 %% i marquem amb un null per fer saber que aquesta pàgina ja ha estat intervinguda
 restauraJPEGs Psom null put
 sEdAs2 (q ) writestring  %% anellem l'estat gràfic
 %% per restablir l'eix de coordenades ens cal interrogar el format de pàgina ...
 XRay /PeDeEfa get araPlana get /MediaBox get  %% ens determinarà l'escala d'imatge
 aload pop 3 -1 roll sub /altDpagina exch def exch sub /ampleDpagina exch def
 %% escrivim la matriu de l'espai de coordenades
 sEdAs2 dup dup dup ampleDpagina 128 string cvs writestring ( 0 0 ) writestring altDpagina
 128 string cvs writestring ( 0 0 cm\012) writestring  %% orígen de la imatge i tancament
 %% exraiem el nom del fitxer com a literal intern de l'XObject (per Do i per Resources)
 {
  bUsca search
  {pop pop}{exit}ifelse
 }loop dup /nomXObj exch def
 sEdAs2 dup (/) writestring exch writestring
 sEdAs2 ( Do Q\012) writestring  %% operador d'XObject i restaurem l'estat gràfic
}ifelse
}if  %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13

       %%% x posar tots els Contents en 1 sol objecte
       /DeNouContents exch def  %% desem l'array de Contents
       {  %% forall on extreiem el fitxer de continguts per cada un dels elements de l 'array
        /laBranca exch def
        %% pesquem la branca ...
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup laBranca known {laBranca get exit}{pop}ifelse 
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        }loop  %% d'interrogacio dels dicts de COMdimoni
        dup /Filter known
        {  %% fitxer stream amb algun tipus de filtre
         dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
         dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
         dup /DecodeParms known exch /DP known 2 copy or
         {
          {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
          {
           [ exch [ exch filtresstream ] ] /filtresstream exch def
          }
          {  %% es una array
           %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
           dup length filtresstream length ne
           {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
            (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
           }if
           /iDPF 0 def
           [ exch
            {  %% forall
             dup null eq
             {
              pop [filtresstream iDPF get]
              iDPF 1 add/iDPF exch def
             }
             {
              [exch filtresstream iDPF get]
              iDPF 1 add/iDPF exch def
             }ifelse
            }forall
           ]
           /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
          }ifelse
         }
         {
          pop pop  %% ens carreguem els logics
          pop  %% ens carreguem el dic
          %% avaluem filtresstream per redefinir-lo com cal per /filtRa
          filtresstream type /arraytype eq
          {
           [filtresstream] /filtresstream exch def
          }
          {
           [[filtresstream]] /filtresstream exch def
          }ifelse
         }ifelse
         dadesstream
         %% comprovem si l'stream es un path dins una array o una string de dades directe
         type /arraytype eq
         {
          dadesstream 0 get (r) file  %% convertim a fitxer des del path sense dexifrar
         }
         {  %% convertim a fitxer de la cadena sense dexifrar
          dadesstream 0 () /SubFileDecode filter
         }ifelse
         filtresstream
         (F12) ==
         filtRa  %% dexifrem el fitxer stream
         %%% preparem el fitxer de lectura que a l'estar filtrat el repiquem al disc
         repiCa (w) file /REPIcA exch def
         {  %% loop
          dup
          65535 string readstring
          {REPIcA exch writestring}		%% estrategia per no acabar mai amb un ET
          {REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit}ifelse
         }loop
         repiCa dup
         status  %%pop
         {
          pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
          (r) file /aLLeGiR exch def
         }
         {
          %%(zzzzzzzzzzzzzzzz ... x aqui petava!!! ... cal saber xq no troba aquest fitxer ¿?) ==
          pop
         }ifelse
        }
        {  %% fitxer stream sense filtres
         /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
         dadesstream  %% tibem el fitxer stream sense dexifrar
         %% comprovem si l'stream es un path dins una array o una string de dades directe
         type /arraytype eq
         {
          dadesstream 0 get
          dup
          status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
          (r) file /aLLeGiR exch def
         }
         {  %% convertim a fitxer de la cadena sense dexifrar
          dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
          0 () /SubFileDecode filter /aLLeGiR exch def
         }ifelse
        }ifelse
        %% repicat idem en ascii dels Contents
        %%(.1.)
        null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream de Patterns&Shadings
        (BESSONADA #1#)==
        BeSSo2
        %%     %%test
        %%     indexONpeta 1 add /indexONpeta exch def     
       }forall

QueLiFemFer 12 eq  %:12 arbre jeràrquic
{
 %%Simsi    
 XRay /PeDeEfa get dup
 araPlana known
 {
  araPlana get /MediaBox get
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def
 }
 {  %% segur que ja haurem desat MdBx abans
  AMedia
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def  %% per assegurar agafem el darrer valor del MediaBox desat a XRay
  pop
 }ifelse
 sEdAs2 dup dup dup dup dup dup dup dup
 ( BT 0 0 0 rg /fontB0 ) writestring
 COSi 64 string cvs writestring
 ( Tf ) writestring
 MdBx aload pop 3 -1 roll pop pop %% sub /altDpagina exch def
 exch sub /ampleDpagina exch def
 numJ
 {  %% a sota centrat (MANCA L'ALGORISME D'AMPLE DEL GLIF x CENTRAR B!)
  ampleDpagina 2 idiv 64 string cvs writestring
  32 write
 }
 {  %% a sota a la dreta
  ampleDpagina COSi 3 mul sub 64 string cvs writestring
  32 write
 }ifelse
 COSi 2 mul 64 string cvs writestring
 ( Td \() writestring
 araPlana 64 string cvs writestring 
 (\)' ET\012) writestring
}if
       %% bufem els fitxers
       aLLeGiR dup flushfile closefile
      }
      {  %% es un sol objecte indirecte
       %%( ... es un sol objecte indirecte 1) ==
       dup /DeNouContents exch def  %% desem el diccionari dels Contents
       /Filter known
       {  %% fitxer stream amb algun tipus de filtre
        dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
        dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
        dup /DecodeParms known exch /DP known 2 copy or
        {
         {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
         {
          [ exch [ exch filtresstream ] ] /filtresstream exch def
         }
         {  %% es una array
          %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
          dup length filtresstream length ne
          {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
           (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
          }if
          /iDPF 0 def
          [ exch
           {  %% forall
            dup null eq
            {
             pop [filtresstream iDPF get]
             iDPF 1 add/iDPF exch def
            }
            {
             [exch filtresstream iDPF get]
             iDPF 1 add/iDPF exch def
            }ifelse
           }forall
          ]
          /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
         }ifelse
        }
        {
         pop pop  %% ens carreguem els logics
         pop  %% ens carreguem el dic
         %% avaluem filtresstream per redefinir-lo com cal per /filtRa
         filtresstream type /arraytype eq
         {
          [filtresstream] /filtresstream exch def
         }
         {
          [[filtresstream]] /filtresstream exch def
         }ifelse
        }ifelse
        dadesstream
        %% comprovem si l'stream es un path dins una array o una string de dades directe
        type /arraytype eq
        {
         dadesstream 0 get (r) file  %% convertim a fitxer des del path sense dexifrar
        }
        {  %% convertim a fitxer de la cadena sense dexifrar
         dadesstream 0 () /SubFileDecode filter
        }ifelse
        filtresstream
        (F13) ==
        filtRa  %% dexifrem el fitxer stream
        %% a l'estar filtrat el repiquem al disc
        repiCa (w) file /REPIcA exch def
        {  %% loop
         dup
         65535 string readstring
         {
          REPIcA exch writestring
         }		%% estrategia per no acabar mai amb un ET
         {
          REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit
         }ifelse
        }loop
        repiCa dup status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
        (r) file /aLLeGiR exch def
       }
       {  %% fitxer stream sense filtres
        /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
        dadesstream  %% tibem el fitxer stream sense dexifrar
        %% comprovem si l'stream es un path dins una array o una string de dades directe
        type /arraytype eq
        {
         dadesstream 0 get
         dup
         status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
         (r) file /aLLeGiR exch def
        }
        {  %% convertim a fitxer de la cadena sense dexifrar
         dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
         0 () /SubFileDecode filter /aLLeGiR exch def
        }ifelse
       }ifelse
       %% repicat idem en ascii dels Contents
       %% (.2.)
       null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream de Patterns&Shadings
       (BESSONADA #2#)==

QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
{
%%MattBianco AQUÍ LA IMATGE ANIRÀ A SOTA DE TOT
restauraJPEGs araPlana 4 string cvs cvx exec 1 sub dup /Psom exch def
get dup null eq  %% és el primer XObject que processem en aquesta pàgina?
{  %% no, o sigui que l'ignorem o li seguim la pista per donar-lo de baixa?
 %% per donar-lo de baixa, hauríem de treure'l del dic Resources i matar l'objecte
 %% XObject completament donant-lo d'alta a NomXdBaixa o a OdeBaixa?
 pop
}
{  %% si, per tant el fem servir per restaurar la capa d'imatge rasteritzada
 %% i marquem amb un null per fer saber que aquesta pàgina ja ha estat intervinguda
 restauraJPEGs Psom null put
 sEdAs2 (q ) writestring  %% anellem l'estat gràfic
 %% per restablir l'eix de coordenades ens cal interrogar el format de pàgina ...
 XRay /PeDeEfa get araPlana get /MediaBox get  %% ens determinarà l'escala d'imatge
 aload pop 3 -1 roll sub /altDpagina exch def exch sub /ampleDpagina exch def
 %% escrivim la matriu de l'espai de coordenades
 sEdAs2 dup dup dup ampleDpagina 128 string cvs writestring ( 0 0 ) writestring altDpagina
 128 string cvs writestring ( 0 0 cm\012) writestring  %% orígen de la imatge i tancament
 %% exraiem el nom del fitxer com a literal intern de l'XObject (per Do i per Resources)
 {
  bUsca search
  {pop pop}{exit}ifelse
 }loop dup /nomXObj exch def
 sEdAs2 dup (/) writestring exch writestring
 sEdAs2 ( Do Q\012) writestring  %% operador d'XObject i restaurem l'estat gràfic
}ifelse
}if  %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13

       BeSSo2
%(LLLLLL)pstack quit

QueLiFemFer 12 eq  %:12 arbre jeràrquic
{
 %%Simsi    
 XRay /PeDeEfa get dup
 araPlana known
 {
  araPlana get /MediaBox get
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def
 }
 {  %% segur que ja haurem desat MdBx abans
  AMedia
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def  %% per assegurar agafem el darrer valor del MediaBox desat a XRay
  pop
 }ifelse
 sEdAs2 dup dup dup dup dup dup dup dup
 ( BT 0 0 0 rg /fontB0 ) writestring
 COSi 64 string cvs writestring
 ( Tf ) writestring
 MdBx aload pop 3 -1 roll pop pop %% sub /altDpagina exch def
 exch sub /ampleDpagina exch def
 numJ
 {  %% a sota centrat (MANCA L'ALGORISME D'AMPLE DEL GLIF x CENTRAR B!)
  ampleDpagina 2 idiv 64 string cvs writestring
  32 write
 }
 {  %% a sota a la dreta
  ampleDpagina COSi 3 mul sub 64 string cvs writestring
  32 write
 }ifelse
 COSi 2 mul 64 string cvs writestring
 ( Td \() writestring
 araPlana 64 string cvs writestring 
 (\)' ET\012) writestring
}if

       %% bufem els fitxers
       %%    REPIcA dup flushfile closefile
       aLLeGiR dup flushfile closefile
      }ifelse
     }
     {  %% es una array directe d'objectes indirectes
      %%( ... es una array directe d'objectes indirectes) ==  
      repiCa (w) file /REPIcA exch def
      %%% x posar tots els Contents en 1 sol objecte
      dup dup length dup 0 eq
      {  %% no hi ha Contents!
       BaBeL 22 get print flush
       %% informem dels fitxers del tmp
       BaBeL 50 get print flush
       clear stop  %%quit
%%UBpliegOMaker
      }if
      1 sub /aFora exch def
      dup 0 get /ToTen1 exch def  %% triem a l'atzar el primer objecte de l'array x desar l'stream dels Contents unificats en 1 sol objecte
      1 aFora getinterval /xUnDef exch def  %% tota la resta d'objectes els donarem de baixa
      actGina /quinOmodifiquem exch def  %% ref ind del dic on hi ha els Contents
      /QueLiFem {quinOmodifiquem get /Contents [ToTen1] put} def  %% procediment x modificar l'objecte
      %%% x posar tots els Contents en 1 sol objecte
      dup /DeNouContents exch def  %% desem l'array de Contents
      {  %% forall on extreiem el fitxer de continguts per cada un dels elements de l'array
       /laBranca exch def
       %% cada branca es un objecte amb part dels continguts ...
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup laBranca known {laBranca get exit}{pop}ifelse 
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
       dup /Filter known
       {  %% fitxer stream amb algun tipus de filtre
        dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
        dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
        dup /DecodeParms known exch /DP known 2 copy or
        {
         {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
         {
          [ exch [ exch filtresstream ] ] /filtresstream exch def
         }
         {  %% es una array
          %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
          dup length filtresstream length ne
          {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
           (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
          }if
          /iDPF 0 def
          [ exch
           {  %% forall
            dup null eq
            {
             pop [filtresstream iDPF get]
             iDPF 1 add/iDPF exch def
            }
            {
             [exch filtresstream iDPF get]
             iDPF 1 add/iDPF exch def
            }ifelse
           }forall
          ]
          /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
         }ifelse
        }
        {
         pop pop  %% ens carreguem els logics
         pop  %% ens carreguem el dic
         %% avaluem filtresstream per redefinir-lo com cal per /filtRa
         filtresstream type /arraytype eq
         {
          [filtresstream] /filtresstream exch def
         }
         {
          [[filtresstream]] /filtresstream exch def
         }ifelse
        }ifelse
        dadesstream
        %% comprovem si l'stream es un path dins una array o una string de dades directe
        type /arraytype eq
        {
         dadesstream 0 get (r) file  %% convertim a fitxer des del path sense dexifrar
        }
        {  %% convertim a fitxer de la cadena sense dexifrar
         dadesstream 0 () /SubFileDecode filter
        }ifelse
        filtresstream
        (F14) ==
        filtRa  %% dexifrem el fitxer stream
       }
       {  %% fitxer stream sense filtres
        /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
        dadesstream
        %% comprovem si l'stream es un path dins una array o una string de dades directe
        type /arraytype eq
        {
         dadesstream 0 get (r) file  %% convertim a fitxer des del path sense dexifrar
        }
        {  %% convertim a fitxer de la cadena sense dexifrar
         dadesstream 0 () /SubFileDecode filter
        }ifelse
       }ifelse
       {  %% loop
        dup
        %% afegim el contingut de l'array a REPIcA per si es trencat ...
        65535 string readstring
        {
         REPIcA exch writestring
        }		%% estrategia per no acabar mai amb un ET
        {
         REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit
        }ifelse
       }loop
      }forall
      %% tanquem el fitxer
      %%   REPIcA closefile
      repiCa  %% interpretem tot l'array enganxat per si era trencat ...
      dup
      status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
      (r) file /aLLeGiR exch def
      %% repicat idem en ascii dels Contents
      %% (.3.)
      null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream de Patterns&Shadings
      (BESSONADA #3#)==

QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
{
%%MattBianco AQUÍ LA IMATGE ANIRÀ A SOTA DE TOT
restauraJPEGs araPlana 4 string cvs cvx exec 1 sub dup /Psom exch def
get dup null eq  %% és el primer XObject que processem en aquesta pàgina?
{  %% no, o sigui que l'ignorem o li seguim la pista per donar-lo de baixa?
 %% per donar-lo de baixa, hauríem de treure'l del dic Resources i matar l'objecte
 %% XObject completament donant-lo d'alta a NomXdBaixa o a OdeBaixa?
 pop
}
{  %% si, per tant el fem servir per restaurar la capa d'imatge rasteritzada
 %% i marquem amb un null per fer saber que aquesta pàgina ja ha estat intervinguda
 restauraJPEGs Psom null put
 sEdAs2 (q ) writestring  %% anellem l'estat gràfic
 %% per restablir l'eix de coordenades ens cal interrogar el format de pàgina ...
 XRay /PeDeEfa get araPlana get /MediaBox get  %% ens determinarà l'escala d'imatge
 aload pop 3 -1 roll sub /altDpagina exch def exch sub /ampleDpagina exch def
 %% escrivim la matriu de l'espai de coordenades
 sEdAs2 dup dup dup ampleDpagina 128 string cvs writestring ( 0 0 ) writestring altDpagina
 128 string cvs writestring ( 0 0 cm\012) writestring  %% orígen de la imatge i tancament
 %% exraiem el nom del fitxer com a literal intern de l'XObject (per Do i per Resources)
 {
  bUsca search
  {pop pop}{exit}ifelse
 }loop dup /nomXObj exch def
 sEdAs2 dup (/) writestring exch writestring
 sEdAs2 ( Do Q\012) writestring  %% operador d'XObject i restaurem l'estat gràfic
}ifelse
}if  %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13

      BeSSo2

QueLiFemFer 12 eq  %:12 arbre jeràrquic
{
 %%Simsi    
 XRay /PeDeEfa get dup
 araPlana known
 {
  araPlana get /MediaBox get
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def
 }
 {  %% segur que ja haurem desat MdBx abans
  AMedia
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def  %% per assegurar agafem el darrer valor del MediaBox desat a XRay
  pop
 }ifelse
 sEdAs2 dup dup dup dup dup dup dup dup
 ( BT 0 0 0 rg /fontB0 ) writestring
 COSi 64 string cvs writestring
 ( Tf ) writestring
 MdBx aload pop 3 -1 roll pop pop %% sub /altDpagina exch def
 exch sub /ampleDpagina exch def
 numJ
 {  %% a sota centrat (MANCA L'ALGORISME D'AMPLE DEL GLIF x CENTRAR B!)
  ampleDpagina 2 idiv 64 string cvs writestring
  32 write
 }
 {  %% a sota a la dreta
  ampleDpagina COSi 3 mul sub 64 string cvs writestring
  32 write
 }ifelse
 COSi 2 mul 64 string cvs writestring
 ( Td \() writestring
 araPlana 64 string cvs writestring 
 (\)' ET\012) writestring
}if

     }ifelse
     %% bufem i tanquem el fitxer
     aLLeGiR dup flushfile closefile
    }
    {  %% no te continguts ...

%% pot ser una pàgina en blanc
QueLiFemFer 12 eq  %:12 arbre jeràrquic
{
 %%Simsi
 dup /MediaBox known
 {
  dup /MediaBox get
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def
 }
 {
  AMedia
%%ProblemaD
%%pop [0 0 595 200]
 /MdBx exch def  %% per assegurar agafem el darrer valor del MediaBox desat a XRay
 }ifelse
}if

     BaBeL 22 get print flush
%%     QueLiFemFer 1 eq  %% tret que fem la separacio de colors ...
%%     {
      %% ##% si fem la separacio de colors, sortim xq no te continguts
      %%(%% #*#%)==
      %% informem dels fitxers del tmp
%%    BaBeL 50 get print flush
%%      clear stop  %%quit
%%     }
%%     {  %% p.e. amb el multipagina no tallem la feina
      pop  %% eliminem el dic de la pagina
      /DeNouContents <</XIU ()>> def  %% amb aquest dic de Contents salpassem els PDF que no duen aquesta entrada
      null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream
      /aLLeGiR () 0 ()/SubFileDecode filter def  %% fitxer buit que necessitem tenir donat d'alta malgrat no hi hagi res
%%     }ifelse
    }ifelse
    sEdAs2 closefile
    %%% test de l'array de gamma de colors
    %%XRay /EspaisDeColor get /Desconeguts get {== ==} forall
    %%DeNouContents {== ==}forall
    %%% a3copiseny apriat dels Contents en 1 sol stream! ...
    %% #!%% aqui es on unificarem els Contents en 1 sol stream
    %%(%% #!#%)==
    %% reincrustem els streams reinterpretats, als seus corresponents objectes
    DeNouContents  %% diccionari o array de Contents de la plana
    type /dicttype eq
    {  %% es un diccionari directe (segur 1 sol stream)
     %% aqui mirem i redefinim el Length
     l'objectenet status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
     DeNouContents /Length FiFtxr put
     %% treiem el filtrat si en duu
     DeNouContents /Filter undef  %% encara que no en dugui, cap publema!
     %% esbrinem on hem de desar l'stream
     DeNouContents /XIU get /dadesstream exch def  %% la mena d'stream per despres
     dadesstream type /arraytype eq
     {  %% comprovem si l'stream es un path dins una array
      dadesstream 0 get /aRePiCaR exch def
      %%EP! genererem el nom dels Contents sencers ...
      iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
      nousStreams dup posNum iNousStreams 10 string cvs putinterval
      %% el repiquem
      (w) file /trAsllAt exch def 
      aRePiCaR (r) file
      {  %% loop
       dup 65535 string readstring
       {
        trAsllAt exch writestring
       }
       {
        trAsllAt exch writestring
        closefile exit
       }ifelse
      }loop
      trAsllAt closefile
      %% regenerem nousStreams al nom que duu l'stream original intacte
      (2__________.SOi)  %% aquest sempre duu l'Stream Original intacte (SOi)
      dup length faPath add string dup /pAthXiU exch def
      0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
      pAthXiU /nousStreams exch def  %% utilitzat per l'applet per desar els nous streams redefinits al disc
      nousStreams /l'objectenet99 exch def  %% redefinim el renombrat a la seva variable original!
      %% el repiquem
      aRePiCaR (w) file /trAsllAt exch def
      %% fitxer a traslladar
      l'objectenet
      (r) file
      {
       dup 65535 string readstring
       {
        trAsllAt exch writestring
       }
       {
        trAsllAt exch writestring
        closefile exit
       }ifelse
      }loop
      trAsllAt closefile
      %%( DiC DIRECTE AMB PATH DINS UNA ARRAY) ==
     }
     {  %% si es una cadena de dades directe ...
      %% llavors redefinim /XIU com una array renobrant l'objectenet a un *.nou
      iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
      l'objectenet nousStreams dup posNum iNousStreams 10 string cvs putinterval renamefile
      %% !!!!
      nousStreams /l'objectenet99 exch def  %% redefinim el renombrat a la seva variable original!
      DeNouContents /XIU [null] dup nousStreams dup length string copy 0 exch put put  %% incrustem el *.nou a l'array XIU i aquesta al dic
      %%( DIC DIRECTE AMB CADENA DE DADES) ==
     }ifelse
    }
    {  %% es una array (1 o + streams)
     %% aqui implementem l'algorisme per deixar 1 sol stream eliminant la resta
     /iDimoni 0 def
     {  %% loop, primer anem a buscar el dic ToTen1
      currentdict iDimoni 4 string cvs cvn get
      dup ToTen1 known {ToTen1 get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop  %% de descarrega
     %% desem el dic on posarem l'stream de Contents unificat
     /DeNouContents2 exch def
     %% incrustem l'stream de Contents sencer al mateix dic
     %% aqui mirem i redefinim el Length
     l'objectenet status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
     DeNouContents2 /Length FiFtxr put
     %% treiem el filtrat si en duu
     DeNouContents2 /Filter undef  %% encara que no en dugui, cap publema!
     %% esbrinem on hem de desar l'stream
     DeNouContents2 /XIU get /dadesstream exch def  %% la mena d'stream per despres
     dadesstream type /arraytype eq
     {  %% comprovem si l'stream es un path dins una array
      dadesstream 0 get
      %% el repiquem
      (w) file /trAsllAt exch def
      %% fitxer a traslladar
      l'objectenet (r) file
      {  %% loop
       dup 65535 string readstring
       {
        trAsllAt exch writestring
       }
       {
        trAsllAt exch writestring
        closefile exit
       }ifelse
      }loop
      trAsllAt closefile
      %%( DIC DIRECTE AMB PATH DINS UNA ARRAY) ==
     }
     {  %% si es una cadena de dades directe ...
      %% llavors redefinim /XIU com una array renobrant l'objectenet a un *.nou
      iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
      l'objectenet nousStreams dup posNum iNousStreams 10 string cvs putinterval renamefile
      %% !!!
      nousStreams /l'objectenet99 exch def  %% redefinim el renombrat a la seva variable original!
      DeNouContents2 /XIU [null] dup nousStreams dup length string copy 0 exch put put  %% incrustem el *.nou a l'array XIU i aquesta al dic
      %%( DIC DIRECTE AMB CADENA DE DADES) ==
     }ifelse
     %%% fi de l'incrustacio de l'stream de Contents
     %% donem de baixa tots els elements d'aquesta array ...
     /iDimoni 0 def
     {  %% loop
      currentdict iDimoni 4 string cvs cvn get
      /aSac exch def xUnDef {aSac exch undef}forall  %% podem fer-ho a sac sense mirar
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop  %% de descarrega
     %% rectifiquem l'objecte portador de la ref ind dels Contents
     /iDimoni 0 def
     {  %% loop
      currentdict iDimoni 4 string cvs cvn get
      dup quinOmodifiquem known {QueLiFem}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop  %% de descarrega
     %%( es una array de Contents trencats) ==
    }ifelse
    %%!% la inicialitzacio per multiples pagines hauria de contemplar un numerador xq els
    %%% fitxers dels Contents repicats fossin diferents a cada pagina pel seu tractament posterior?
    %% (la inicialitzacio d'aquest fitxer on reescriurem els Contents no es necessaria treballant amb PDF d'1 sola pagina)
    l'objectenet (w) file
    /sEdAs2 exch def
   }forall  %% que extrau els Contents i els repica
   sEdAs2 closefile
   flush
   %%% fi del repicat de Contents
   QueLiFemFer 6 eq  %/10 PREFLIGHT AMB CAPES
   {
    %#%52bis.6.4% algorisme culcosit
    (%#%52bis.6.4%)==
    %% filtres de xifrat d'imatge que NO suportem encara ...
    /fQNs
    <<
      /JPXDecode null  %% jpeg 2000
      /JBIG2Decode null  %% jpeg a 1 bit
    >> def
    iFenix
    {  %% forall plana x plana
     exch /PHipoDic exch def  %% pagina on som
     {  %% forall mosaic a mosaic on reconstruirem cada trancaclosques amb culcosit
%%% hauríem d'anellar això?
      null /SadiuX exch def  %% valor inicial del comparador d'amples de linies d'imatge (en pixels) d'un mateix mosaic
      null /SadiuEC exch def  %% valor inicial de la coherencia d'espai de color entre totes imatges q formen el mosaic
      /HipoDic <<>>def  %% ... que utilitzara l'algorisme culcusit.ps x sorgir cada mosaic
      dup /capCapsa get dup  %% pesquem l'array original amb la disposicio de les linies del mosaic
      {  %% forall per cadascuna de les linies d'imatge
       dup type /arraytype eq
       {  %% es un mosaic de + d'1 linia
        {  %% forall per a cadascuna de les imatges
         dup JectesX PHipoDic get exch get  %% capturem la ref ind de l'objecte XObject
         %% aqui anem a cercar el seu diccionari
         /laBranca exch def  %% la ref ind
         /iDimoni 0 def
         {  %% loop d'interrogacio dels dicts de COMdimoni
          currentdict iDimoni 4 string cvs cvn get
          %% el diccionari de l'objecte
          dup laBranca known {laBranca get exit}{pop}ifelse 
          iDimoni 1 add /iDimoni exch def
          iDimoni MaxDimoni eq {exit} if
         }loop  %% d'interrogacio dels dicts de COMdimoni
         HipoDic 3 1 roll put  %% desem cada imatge del mosaic d'una sola linia
        }forall  %% per a cadascuna de les imatges
       }
       {  %% es un mosaic 1 sola linia
        dup JectesX PHipoDic get exch get  %% capturem la ref ind de l'objecte XObject
        %% aqui anem a cercar el seu diccionari
        /laBranca exch def  %% la ref ind
        /iDimoni 0 def
        {  %% loop d'interrogacio dels dicts de COMdimoni
         currentdict iDimoni 4 string cvs cvn get
         %% el diccionari de l'objecte
         dup laBranca known {laBranca get exit}{pop}ifelse 
         iDimoni 1 add /iDimoni exch def
         iDimoni MaxDimoni eq {exit} if
        }loop  %% d'interrogacio dels dicts de COMdimoni
        HipoDic 3 1 roll put  %% desem cada imatge del mosaic d'una sola linia     
       }ifelse
      }forall  %% per cadascuna de les linies d'imatge
      %% algorisme culcosit (vegeu culcosit.ps) ... la cosidora del trencaclosques
      /FiPiX 0 def  %% comptador total de l'alt (Y) del mosaic (files de pixels)
      2 index  %% pesquem el nom de la imatge clau (frontisa) de la base de la pila
      HipoDic exch get /XIU get  %% del seu diccionari en tibem /XIU on ...
      dup type /arraytype eq
      {  %% ... hi pot haver-hi l'adreça del tou de dades a disc (array)
       0 get  %% llavors l'aprofitem
       /tOU exch def
       tOU length /faPath exch def (.frontisa) dup length faPath add string dup /tOUrAw exch def
       0 tOU putinterval tOUrAw exch faPath exch putinterval  %% incrustem la cadena al path
       tOUrAw dup 1 array astore /pathFRoNTiSa exch def  %% desem el pathFRoNTiSa per reinserir-lo al final de nou al diccionari de la imatge clau
       (w) file /MSC exch def  %% fitxer d'escriptura de les dades del mosaic sencer
       3 -1 roll /FRoNTiSa exch def  %% desem el literal del nom de la imatge frontisa (clau)
      }
      {  %% o pot ser una cadena amb el tou de dades directe (string)
       %% llavors, primer ens cal saber el nom literal de la ref ind de l'objecte XObject
       4 -1 roll dup /FRoNTiSa exch def  %% desem el literal del nom de la imatge frontisa (clau)
       JectesX PHipoDic get exch get 16 string cvs /tOU exch def
       tOU length /faPath exch def (.frontisa) dup length faPath add string dup /tOUrAw exch def
       0 tOU putinterval tOUrAw exch faPath exch putinterval  %% incrustem la cadena al path
       tOUrAw
       tEmp length /faPath exch def
       dup length faPath add string dup /pAthXiU exch def
       0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
       pAthXiU dup 1 array astore /pathFRoNTiSa exch def  %% desem el pathFRoNTiSa per reinserir-lo al final de nou al diccionari de la imatge clau
       %%dup ==
       (w) file /MSC exch def  %% fitxer d'escriptura de les dades del mosaic sencer
       pop  %% ens carreguem la cadena del tou de dades
      }ifelse
      dup 0 get type /nametype eq
      {  %% no fos que fos una trista linia sola d'imatges
       1 array astore  %% necessitem que sigui sempre una array d'arrays
      }if
      {  %% forall x cada linia (paquet) d'imatges que formen el mosaic
       null /SadiuY exch def  %% valor inicial del comparador d'alts d'imatge (en pixels) d'una mateixa linia
       0 /iDlinia exch def  %% index pel lector d'imatges d'una linia
       dup mark exch
       {  %% forall imatge a imatge x pescar /XIU per tal de crear les adreces que utilitzarem en el repicat del raw
        %% (sempre desxifrat i descomprimit) que necessitem per l'algorisme cosidor
        HipoDic exch dup /BoCi exch def  %% desem el nom de la imatge del mosaic q ara tractem
        get dup
        %% aqui comprovarem la coherencia de l'altura, en pixels, de les imatges que formen una mateixa linia
        %% doncs pots haver-hi imatges que malgrat tenir el mateix alt, en punts, el tinguin diferent en pixels
        %% llavors (si es voles solucionar) s'hauria d'implementar un retallador?
        SadiuY null eq
        {
         /Height get /SadiuY exch def
%% /ignoreMosaic false def
        }
        {
         /Height get SadiuY ne
         {
          (>>> CaLi2CoPi#6 ... els pixels d'altura de les imatges que formen aquesta linia NO s'adiuen ... ) == stop
%% /ignoreMosaic true def cleartomark exit
         } if
%%{
%% /ignoreMosaic false def
%%}ifelse
        }ifelse
        /XIU get dup type /arraytype eq
        {  %% ... hi pot haver-hi l'adreça del tou de dades a disc (array)
         0 get /tOU exch def  %% llavors l'aprofitem
         tOU length /faPath exch def (.raw) dup length faPath add string dup /tOUrAw exch def
         0 tOU putinterval tOUrAw exch faPath exch putinterval  %% incrustem la cadena al path
         tOUrAw  %% adreça que utilitzarem pel repicat del raw a la cosidora
        }
        {  %% o pot ser una cadena amb el tou de dades directe (string)
         %% llavors, primer ens cal saber el nom literal de la ref ind de l'objecte XObject
         JectesX PHipoDic get BoCi get 16 string cvs /tOU exch def
         tOU length /faPath exch def (.raw) dup length faPath add string dup /tOUrAw exch def
         0 tOU putinterval tOUrAw exch faPath exch putinterval  %% incrustem la cadena al path
         tOUrAw
         tEmp length /faPath exch def
         dup length faPath add string dup /pAthXiU exch def
         0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
         pAthXiU  %% adreça al tmp que utilitzarem pel repicat del raw a la cosidora
         exch pop  %% ens carreguem la cadena del tou de dades
        }ifelse
       }forall  %% imatge a imatge x pescar /XIU

%%ignoreMosaic
%%{
%% (>>> ignorem el mosaic format per ... )== {==}forall
%% pop
%%}
%%{

       counttomark array astore
       /1LiNia exch def  %% paquet d'adreces (arrays) o strings del tou de dades x linia
       exch {HipoDic exch get}forall
       counttomark array astore /1lInIa exch def  %% paquet de diccionaris de les imatges x linia
       pop  %% ens carreguem la mark
       /CoPiX 0 def  %% comptador total de l'ample (X) del mosaic (columna de pixels)
       1LiNia
       {  %% forall d'1 linia
        /BRoSSa exch def  %% utilitzat per l'applet per llencar informacio
        1lInIa iDlinia get /XIU get  %% pesquem XIU del dic de la imatge q toca
        /strEAm exch def  %% capturem l'array o string del fitxer stream
        strEAm /dadesstream exch def  %% definim l'adreca de l'stream per despres (cal?)
        1lInIa iDlinia get  %% pesquem el dic de la imatge q toca
        dup /Filter known  %% duu filtres ??
        {
         dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
         filtresstream
         %% comprovem que no sigui cap dels NO suportats fins ara ...
         dup type /arraytype eq
         {  %% filtre/s dins una array
          {  %% forall
           fQNs exch known
           {
            %% no tenim encara el dexifrador d'aquest filtre
            filtresstream == (>>> CaLi2CoPi#6 ... filtre d'imatge NO suportat ... PLEGUEM!) == stop %%quit
           }if
          }forall
         }
         {  %% filtre directe
          fQNs exch known
          {
           %% no tenim encara el dexifrador d'aquest filtre
           filtresstream == (>>> CaLi2CoPi#6 ... filtre d'imatge NO suportat ... PLEGUEM!) == stop  %%quit
          }if
         }ifelse  %% no tenim encara el dexifrador d'aquest filtre?
         dup dup /DecodeParms known exch /DP known 2 copy or
         {
          {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
          {
           [ exch [ exch filtresstream ] ] /filtresstream exch def
          }
          {  %% es una array
           %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
           dup length filtresstream length ne
           {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
            (>>> CaLi2CoPi#6 ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
           }if
           /iDPF 0 def
           [ exch
            {  %% forall
             dup null eq
             {
              pop [filtresstream iDPF get]
              iDPF 1 add/iDPF exch def
             }
             {
              [exch filtresstream iDPF get]
              iDPF 1 add/iDPF exch def
             }ifelse
            }forall
           ]
           /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
          }ifelse
         }
         {
          pop pop  %% ens carreguem els logics
          pop  %% ens carreguem el dic
          %% avaluem filtresstream per redefinir-lo com cal per /filtRa
          filtresstream type /arraytype eq
          {
           [filtresstream] /filtresstream exch def
          }
          {
           [[filtresstream]] /filtresstream exch def
          }ifelse
         }ifelse
         %%      /filtresstream exch def  % definim el filtre directe o l'array dels filtres per despres
         %%      % filtrem si duu DecodeParms o abreujat DP, doncs ara no ho soportem ...
         %%      dup dup /DecodeParms known exch /DP known or
         %%      {(>>> CaLi2CoPi#6 ... DecodeParms NO suportat ... PLEGUEM!) == quit}if
         /Width get CoPiX add /CoPiX exch def  %% pixels totals d'ample (columnes)
         dadesstream
         %% comprovem si l'stream es un path dins una array o una string de dades directe
         type /arraytype eq
         {
          dadesstream 0 get (r) file  %% convertim a fitxer des del path
          filtresstream
          (F15) ==
          filtRa  %% dexifrem el fitxer stream
          %%% a l'estar filtrat el repiquem al disc
          BRoSSa (w) file /REPIcA exch def
          {  %% loop
           dup
           65535 string readstring
           {
            REPIcA exch writestring
           }
           {
            REPIcA exch writestring REPIcA closefile closefile exit
           }ifelse
          }loop
         }
         {  %% traspassem les cadenes com a fitxers doncs poden inflar-se moltissim
          dadesstream
          0 () /SubFileDecode filter  %% convertim a fitxer des del path
          %% repiquem la cadena a fixter i dexifrem a partid d'aqui x evitar ioerrors
          filtresstream
          (F16) ==
          filtRa  %% dexifrem el fitxer stream
          %%% a l'estar filtrat el repiquem al disc
          BRoSSa
          (w) file /REPIcA exch def
          {  %% loop
           dup
           65535 string readstring
           {
            REPIcA exch writestring
           }
           {
            REPIcA exch writestring REPIcA closefile closefile exit
           }ifelse
          }loop
         }ifelse
        }
        {  %% si no duu filtres ...
         /Width get CoPiX add /CoPiX exch def  %% pixels totals d'ample (columnes)
         dadesstream type /stringtype eq
         {  %% i es una cadena de dades
          %% la traspassem com a fitxer
          dadesstream 0 () /SubFileDecode filter  %% convertim a fitxer des del path
          %% el repiquem al disc
          BRoSSa (w) file /REPIcA exch def
          {  %% loop
           dup
           65535 string readstring
           {
            REPIcA exch writestring
           }
           {
            REPIcA exch writestring REPIcA closefile closefile exit
           }ifelse
          }loop
         }
         {  %% i encara que sigui a fitxer el traspassem a BRoSSa per unificar criteris
          dadesstream 0 get (r) file  %% convertim a fitxer des del path
          %% el repiquem novament a disc
          BRoSSa (w) file /REPIcA exch def
          {  %% loop
           dup
           65535 string readstring
           {
            REPIcA exch writestring
           }
           {
            REPIcA exch writestring REPIcA closefile closefile exit
           }ifelse
          }loop
         }ifelse
        }ifelse
        1LiNia iDlinia BRoSSa (r) file put  %% redesem l'objecte file al mateix paquet d'on llegim el path del raw
        iDlinia 1 add /iDlinia exch def
       }forall  %% d'1 linia

%% ignorem aquest mosaic?
%%}ifelse

%%ignoreMosaic
%%{
%%(:-i ... aturem el segon tou!)==
%%exit
%%}
%%{
       %% aqui comprovarem la coherencia de l'ample, en pixels, de les linies que formen el mosaic
       %% doncs pots haver-hi linies d'imatge que malgrat tenir el mateix ample, en punts, el tinguin diferent en pixels
       %% llavors (si es voles solucionar) s'hauria d'implementar un retallador?
       SadiuX null eq
       {
        CoPiX /SadiuX exch def
%% /ignoreMosaic false def
       }
       {
        CoPiX SadiuX ne
        {
         (>>> CaLi2CoPi#6 ... els pixels d'ample de les linies d'imatge que formen el trencaclosques NO s'adiuen ... ) == stop
%% /ignoreMosaic true def cleartomark exit
         }if
%%{
%% /ignoreMosaic false def
%%}ifelse

       }ifelse
       1LiNia length 1 sub /Lfins exch def  %% index per agafar cada vegada 1 linia de cada imatge
       {  %% loop cosidor
        0 1 Lfins
%%(:-B)pstack quit
        {  %% for d'1 linia de cada imatge
         dup 1LiNia exch get /aLLegir exch def  %% pesquem el fitxer obert a llegir
         1lInIa exch get  %% aquest diccionari a l'hora de la veritat hauria de ser de cadascuna de les imatges
         %% hem de saber quants caracters descriuen 1 linia d'imatge, doncs aquest sera el buffer de lectura/escriptura q farem servir
         dup /Width get exch  %% pixels d'ample
         %%%v***
         %% hem de saber el nombre de canals que te la imatge
         dup /ColorSpace get
         dup type /nametype eq 1 index length 16 eq  %% primer ens assegurem q no sigui una ref ind
         {
          1 index 16 string cvs 10 get 95 eq{true}{false}ifelse
         }
         {
          false
         }ifelse  %% i ens en acabem d'assegurar mirant si el caracter central es un _
         and
         {  %% els dos han de ser certs (o sigui una ref ind segur), doncs llavors n'anirem a treure el literal que amaga
          /aCercar exch def
          /iDimoni 0 def
          {  %% loop d'interrogacio dels dicts de COMdimoni
           currentdict iDimoni 4 string cvs cvn get
           %% el diccionari de l'objecte
           dup aCercar known {aCercar get exit}{pop}ifelse
           iDimoni 1 add /iDimoni exch def
           iDimoni MaxDimoni eq {exit} if
          }loop  %% d'interrogacio dels dicts de COMdimoni
         }if
         dup type /arraytype eq
         {  %% si es un array podria ser algun dels CIEbased (CalGray, CalRGB, Lab i ICCBased), o un Indexed, o un Separation o un DeviceN
          dup 0 get
          <<
            /CalGray 1
            /CalRGB 3
            /Lab 3
            /ICCBased null  %% cal saber quants components el formen, pescant /N del diccionari de l'stream de l'ICC (index 1 de l'array de l'espai de color)
            /Indexed 1  %% sempre es 1 byte d'index?
            %% /Pattern ( Pattern Color Space Not Supported)  % a les imatges no existeix
            /DeviceN null  %% cal saber quants components el formen mirant el nombre d'elements de l'array de components (index 1 de l'array de l'espai de color)
            /Separation 1
          >>
          %% ens assegurem filtrar possibles novetats no contemplades
          2 copy exch known not {exch == (>>> CaLi2CoPi#6 ... espai de color desconegut ... PLEGUEM!) == stop}if
          exch
          %% comprovem que es mante el mateix espai de color a totes les imatges q formen el mosaic
          dup SadiuEC null eq
          {
           /SadiuEC exch def
          }
          {
           SadiuEC ne {== SadiuEC == (>>> CaLi2CoPi#6 ... l'espai de color entre les imatges que formen el trencaclosques NO s'adiu ... PLEGUEM!) == stop}if
          }ifelse
          get dup null eq
          {  %% es una ICC o DeviceN
           pop dup 0 get /ICCBased eq
           {  %% es ICC i anem a buscar la ref ind del seu diccionari de l'stream de dades
            1 get /aCercar exch def
            /iDimoni 0 def
            {  %% loop d'interrogacio dels dicts de COMdimoni
             currentdict iDimoni 4 string cvs cvn get
             %% el diccionari de l'objecte
             dup aCercar known {aCercar get exit}{pop}ifelse
             iDimoni 1 add /iDimoni exch def
             iDimoni MaxDimoni eq {exit} if
            }loop  %% d'interrogacio dels dicts de COMdimoni
            /N get exch  %% pesquem el nombre de components de color (canals) i els deixem al seu lloc
           }
           {  %% es DeviceN
            1 get length exch  %% nombre de components de color (canals) de l'array i els deixem al seu lloc
           }ifelse
          }
          {
           exch pop exch  %% matem l'array i posem els canals al seu lloc
          }ifelse
         }
         {
          <<
            /DeviceGray 1
            /DeviceRGB 3
            /DeviceCMYK 4
          >>
          %% ens assegurem filtrar possibles novetats no contemplades
          2 copy exch known not {exch == (>>> CaLi2CoPi#6 ... espai de color desconegut ... PLEGUEM!) == stop}if
          exch
          %% comprovem que es mante el mateix espai de color a totes les imatges q formen el mosaic
          dup SadiuEC null eq
          {
           /SadiuEC exch def
          }
          {
           SadiuEC ne {== SadiuEC == (>>> CaLi2CoPi#6 ... l'espai de color entre les imatges que formen el trencaclosques NO s'adiu ... PLEGUEM!) == stop}if
          }ifelse
          get exch  %% pesquem el nombre de canals i les deixem al seu lloc
         }ifelse
         /BitsPerComponent get  %% bits x canal
         mul mul 8 idiv  %% bytes x linia
         string aLLegir exch readstring
         exch
         %%pop  % test
         MSC exch writestring
        }for  %% 1 linia de cada imatge
        Lfins {and} repeat  %% nomes haurem acabat si hem exhaurit tots els fitxers
        {
         FiPiX 1 add /FiPiX exch def  %% comptador de fileres d'imatge (Y)
        }
        {  %% llavors els tanquem tots
         1LiNia {closefile}forall  %% els de lectura
         %%MSC flushfile
         exit
        }ifelse
       }loop  %% cosidor de linies d'imatge

%%}ifelse  %% aturem el segon tou?

      }forall  %% x cada linia (paquet) d'imatges que formen el mosaic

      MSC closefile  %% el d'escriptura del mosaic

%%ignoreMosaic
%%{
%%(:-iiii) == %%pstack quit
%%}
%%{

      %% ara cal inserir les noves dades al dicionari de la imatge clau (frontisa) que cus el trencaclosques
      %% ... el raw del trencacloques ...
      HipoDic FRoNTiSa get dup dup dup
      /XIU pathFRoNTiSa put
      %% ... l'ample i alt de pixels d'imatge ...
      /Width CoPiX put
      /Height FiPiX put
      %% ... aqui es on donem de baixa l'entrada /Filter doncs segur q el tou de dades es un raw pur
      /Filter undef
      %% desem la ref ind de l'XObject clau (frontisa) al dic de control FRoNTiSeS
      FRoNTiSeS JectesX PHipoDic get FRoNTiSa get null put
      %% un cop acabat el trencaclosques d'1 mosaic seleccionem els XObject a eliminar com a objectes del fitxer tibant del
      %% diccionari iFenix q ens queda a la pila l'array /eliminem x tal d'esborrar els objectes fisicament (estrategia OdeBaixa?)
      /eliminem get
      %% posem un filtre on ens assegurem de no esborrar una imatge que el seu objecte (ref ind) sigui utilitzat amb un altre nom
      %% per construir una imatge isolada o un altre mosaic (al dic FRoNTiSeS desem les ref ind de totes les imatges clau i les imatges isolades)
      {  %% forall de l'array d'arrays
       {  %% forall de cada array
        FRoNTiSeS exch JectesX PHipoDic get exch get dup 3 1 roll known  %% hi ha la seva ref ind?
        {  %% no fem res
         pop  %%(objecte d'imatge a CONSERVAR) ==
        }
        {  %% activem l'estrategia OdeBaixa
         OdeBaixa exch null put  %%(objecte d'imatge a ELIMINAR) ==
        }ifelse
       }forall  %% de cada array
      }forall  %% de l'array d'arrays

%%}ifelse
%% hauríem d'anellar això?

     }forall  %% mosaic a mosaic on reconstruirem cada trencaclosques amb culcosit
    }forall  %% plana x plana
   }if  %:10 PREFLIGHT AMB CAPES
   %:13 eliminem continguts de pàgina
   %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
   QueLiFemFer 10 eq  %/06 COSIT D'IMATGES
   QueLiFemFer 13 eq
   QueLiFemFer 14 eq
   or or
   {
    %#%52bis.6.5% aquí repicarem els streams dels Forms recursius
    %# atenció que a 52.bis tindríem l'oportunitat de repicar x tercer cop els streams dels Forms (ara només si fem 1)
    %# repiquem l'stream de cada Form per primer o segon cop (semblant a %23)
    (%#%52bis.6.5%)==
    /VectorViu false def  %% gatell d'anellat en llesques de vectorials
    /DuuLlesques false def  %% gatell x tractar de forma adient els streams dels Forms interpretats abans o no
    FormsRecursius
    %%1 get{== ==}forall(HHV)pstack quit
    {  %% forall x tots els dics directes
     dup /dicX10 exch def  %% el necessitem x l'opcio 10 de verificacio de PDF
     dup /Filter known
     {  %% fitxer stream amb algun tipus de filtre
      dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
      dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
      dup /DecodeParms known exch /DP known 2 copy or
      {
       {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
       {
        [ exch [ exch filtresstream ] ] /filtresstream exch def
       }
       {  %% es una array
        %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
        dup length filtresstream length ne
        {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
         (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
        }if
        /iDPF 0 def
        [ exch
         {  %% forall
          dup null eq
          {
           pop [filtresstream iDPF get]
           iDPF 1 add/iDPF exch def
          }
          {
           [exch filtresstream iDPF get]
           iDPF 1 add/iDPF exch def
          }ifelse
         }forall
        ]
        /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
       }ifelse
      }
      {
       pop pop  %% ens carreguem els logics
       pop  %% ens carreguem el dic
       %% avaluem filtresstream per redefinir-lo com cal per /filtRa
       filtresstream type /arraytype eq
       {
        [filtresstream] /filtresstream exch def
       }
       {
        [[filtresstream]] /filtresstream exch def
       }ifelse
      }ifelse
      dadesstream
      %% comprovem si l'stream es un path dins una array o una string de dades directe
      type /arraytype eq
      {
       dadesstream 0 get (r) file  %% convertim a fitxer des del path sense decodificar
      }
      {  %% convertim a fitxer de la cadena sense decodificar
       dadesstream 0 () /SubFileDecode filter
      }ifelse
      filtresstream
      (F4?) ==
      filtRa  %% decodifiquem el fitxer stream
      %% preparem el fitxer de lectura que a l'estar filtrat el repiquem al disc
      repiCa (w) file /REPIcA exch def
      {  %% loop
       dup
       65535 string readstring
       {REPIcA exch writestring}  %% estrategia per no acabar mai amb un ET
       {REPIcA exch writestring REPIcA dup 32 write flushfile closefile exit}ifelse
      }loop
      repiCa dup
      status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
      (r) file /aLLeGiR exch def
     }
     {  %% fitxer stream sense filtres
      /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
      dadesstream  %% tibem el fitxer stream sense decodificar
      %% comprovem si l'stream es un path dins una array o una string de dades directe
      type /arraytype eq
      {
       dadesstream 0 get
       dup
       status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
       (r) file /aLLeGiR exch def
      }
      {  %% convertim a fitxer de la cadena sense decodificar
       dadesstream dup length /FiFtxr exch def  %% bytes totals del fitxer
       0 () /SubFileDecode filter /aLLeGiR exch def
      }ifelse
     }ifelse
     %% repicat idem en ascii de l'stream de Contents particular del Form
     null /nomDtp exch def  %% a null indica a BeSSo que no esta reinterpretant cap stream de Patterns&Shadings
     %% redefinim el fitxer on reescriurem l'stream de Contents del Form x 1er cop
     l'objectenet5 (w) file  %%  repicats a traves de les redefinicions d'OpContents_QueLiFemFer1
     /sEdAs2 exch def
     BeSSo2
     %% bufem els fitxers
     aLLeGiR dup flushfile closefile
     sEdAs2 dup flushfile closefile
     %%(%??)==
     %%%EP!
     dicX10 dup /Filter undef  %% treiem a sac aquesta possible entrada doncs l'stream ara sera pla
     dup /XIU get dup type /stringtype eq
     {  %% es una cadena
      pop
      l'objectenet5
      (r) file dup 65535 string readstring
      pop
      exch dup flushfile closefile  %% tanquem el fitxer de lectura!
      /XIU exch put
     }
     {  %% es un fitxer a disc
      0 get (w) file /trAsllAt exch def  %% pesquem el path on reescriure l'stream del form
      pop  %% ens carreguem el dic
      l'objectenet5 (r) file  %% llegim l'stream repicat
      {  %% loop
       dup 65535 string readstring
       {
        trAsllAt exch writestring
       }
       {
        trAsllAt exch writestring
        closefile exit
       }ifelse
      }loop
      trAsllAt closefile
     }ifelse
    }forall  %% x tots els dics directes
    %%  (HHV) pstack quit
   }if  %:06 COSIT D'IMATGES
   %% fi de repicat d'streams de Forms recursius
   %% donem de baixa totes les ref ind que hem desat a OdeBaixa (imatges no claus dels mosaics)
   /iDimoni 0 def
   {  %% loop de decarrega de definicions pels dic creats
    OdeBaixa
    {
     pop
     currentdict iDimoni 4 string cvs cvn get
     exch undef
    }forall
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   }loop  %% de descarrega
   QueLiFemFer 5 eq  %:05 dada variable
   {
    %% índex sumador per llegir, dins els operadors sensibles a la dada variable, l'array DADAmestre
    %% que conté una array de dades per fitxer a reescriure
    iDADAv 1 add /iDADAv exch def
   }if
  }if  %/16 cerca i substitució de text
       %/12 arbre jeràrquic
       %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
       %/13 eliminem continguts de pàgina
       %/10 PREFLIGHT AMB CAPES
       %/06 COSIT D'IMATGES
       %/05 dada variable

  %%% fi de culcosit
  %%userdict /0 get dup /2______________0 get /XIU get ==
  %% /9______________0 get /XIU get ==
  %%(HoHaveuVist) == quit
  %%(U)pstack quit
  %% x test
  %%gsARA ==
  %%tintARA ==
  %%CSARA ==
  %%csARA ==

  QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
  {
   %#%52bis% reescriurem l'stream del Form XObject repicat aplicant el tractament a través de les redefinicions d'OpContents_QueLiFemFer#
   (%#%52bis%)==
   %%l'objectenet4 (w) file
   %% /sEdAs2 exch def
   %% 270206
   %% repiquem els streams ...
   HiHaForms  %% ... mentre hi hagi Forms
   {
    FormsQhiHa
    {  %% forall
     dup /FormQhiHaAra exch def  %% desem el nom x bastir el nom unic q apuntara al fitxer stream a disc
     XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get exch get
     2 get dup type /nametype eq
     {
      /laBranca exch def
      %% pesquem la branca ...
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup laBranca known {laBranca get exit}{pop}ifelse 
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     dup dup /DictFormQhiHa exch def  %% desem el dic del Form x repicar-hi XIU
     /Filter known
     {  %% fitxer stream amb algun tipus de filtre
      dup /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
      dup dup /Filter get /filtresstream exch def  %% definim (l'array d)els filtres per despres
      dup /DecodeParms known exch /DP known 2 copy or
      {
       {pop/DP get}{pop/DecodeParms get}ifelse dup type /dicttype eq
       {
        [ exch [ exch filtresstream ] ] /filtresstream exch def
       }
       {  %% es una array
        %% ... llavors filterstream tambe ho ha de ser i de la mateixa llargada
        dup length filtresstream length ne
        {  %% el nombre de filtres i els seus parametres addicionals haurien de coincidir
         (>>> CaLi2CoPi# ... el nombre de parametres de Filter i DecodeParms NO s'adiuen ... PLEGUEM!) == stop  %%quit
        }if
        /iDPF 0 def
        [ exch
         {  %% forall
          dup null eq
          {
           pop [filtresstream iDPF get]
           iDPF 1 add/iDPF exch def
          }
          {
           [exch filtresstream iDPF get]
           iDPF 1 add/iDPF exch def
          }ifelse
         }forall
        ]
        /filtresstream exch def  %% redefinim l'array d'arrays amb DecodeParms
       }ifelse
      }
      {
       pop pop  %% ens carreguem els logics
       pop  %% ens carreguem el dic
       %% avaluem filtresstream per redefinir-lo com cal per /filtRa
       filtresstream type /arraytype eq
       {
        [filtresstream] /filtresstream exch def
       }
       {
        [[filtresstream]] /filtresstream exch def
       }ifelse
      }ifelse
      dadesstream
      %% comprovem si l'stream es un path dins una array o una string de dades directe
      type /arraytype eq
      {
       save
       dadesstream
       0 get (r) file  %% convertim a fitxer des del path sense dexifrar
       filtresstream
       (F17) ==
       filtRa  %% dexifrem el fitxer stream
       %%% preparem el fitxer d'escriptura que a l'estar filtrat el repiquem al disc
       repiCa (w) file /REPIcA exch def
       {  %% loop
        dup
        65535 string readstring
        {
         REPIcA exch writestring
        }
        {
         REPIcA exch writestring
         REPIcA dup flushfile closefile
         closefile exit
        }ifelse
       }loop
       restore
      }
      {  %% convertim a fitxer de la cadena sense dexifrar
       save
       %%% preparem el fitxer d'escriptura que a l'estar filtrat el repiquem al disc
       repiCa (w) file /REPIcA exch def
       dadesstream
       0 () /SubFileDecode filter
       filtresstream
       (F18) ==
       filtRa  %% dexifrem el fitxer stream
       {  %% loop per forca doncs la cadena es pot expandir molt + enlla dels 65535
        dup
        65535 string readstring
        {
         REPIcA exch writestring
        }
        {
         REPIcA exch writestring
         REPIcA dup flushfile closefile
         closefile exit
        }ifelse
       }loop
       restore
      }ifelse
      repiCa (r) file /FormStream exch def
     }
     {  %% fitxer stream sense filtres
      /XIU get /dadesstream exch def  %% definim l'adreca de l'stream per despres
      dadesstream  %% tibem el fitxer stream sense dexifrar
      %% comprovem si l'stream es un path dins una array o una string de dades directe
      type /arraytype eq
      {
       dadesstream 0 get
       (r) file /FormStream exch def
      }
      {  %% convertim a fitxer de la cadena sense xifrar
       dadesstream
       0 () /SubFileDecode filter /FormStream exch def
      }ifelse
     }ifelse
     FormQhiHaAra 128 string cvs dup length faPath add string dup /pAthXiU exch def
     0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
     pAthXiU dup /l'objectenet4 exch def
     (w) file /sEdAs2 exch def
     %%% suposem q cal?
     %% inicialitzem les funcions dels valors actuals de ...
     /csARA [/Black] def  %% valor inicial de l'Espai de Color actual per fill
     /CSARA [/Black] def  %% valor inicial de l'Espai de Color actual per stroke
     /gsARA [null] def  %% Estat Grafic actual
     /tintARA [1] def  %% valor inicial de Tinta actual
     /Tfill 0 def  %% valor inical del gatell (suposem que no afecta) per saber si el valor de tinta es per fill (0) o stroke (1)
     /Tzero false def  %% valor inicial del gatell x saber si hem pintat amb tinta zero (blanc)
     /TiNTeMF true def  %% gatell de si Tintem x Fill
     /TiNTeMS true def  %% gatell de si Tintem x Stroke
     /TacaTintaF 1 def  %% valor x defecte de la Tinta per Fill
     /TacaTintaS 1 def  %% valor x defecte de la Tinta per Stroke
     /LaQtocaF true def  %% gatell x compensar el comportament Nexus/Backstage x Fill
     /LaQtocaS true def  %% gatell x compensar el comportament Nexus/Backstage x Stroke
     %% valors inicials dels gatells x control de l'overprint
     /NomesUn true def  %% valor inicial del gatell x saber si nomes treballem amb un espai de color d'1 sol component
     /OPactua false def
     /opactua false def
     /es4c false def  %% es CMYK ?
     BeSSo3  %% repiquem l'stream dels continguts del Form x segona vegada
     DictFormQhiHa dup /Filter undef  %%% o aixo es el q feia petar amb ioerror
     /XIU 1 array dup 0 l'objectenet4 put put  %% repiquem l'entrada q apunta a l'stream a disc
    }forall
   }if  %% ...  mentre hi hagi Forms
   %#%53% aquí és on unificarem els Contents en un sol stream
   (%#%53%)==
   %% reincrustem els streams reinterpretats, als seus corresponents objectes
   DeNouContents  %% diccionari o array de Contents de la plana
   type /dicttype eq
   {  %% es un diccionari directe (segur 1 sol stream)
    %% aqui mirem i redefinim el Length
    l'objectenet2 status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
    DeNouContents /Length FiFtxr put
    %% treiem el filtrat si en duu
    DeNouContents /Filter undef  %% encara que no en dugui, cap publema!
    %% esbrinem on hem de desar l'stream
    DeNouContents /XIU get /dadesstream exch def  %% la mena d'stream per despres
    dadesstream type /arraytype eq
    {  %% comprovem si l'stream es un path dins una array
     dadesstream 0 get /aRePiCaR exch def
     %%EP! genererem el nom dels Contents sencers ...
     iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
     nousStreams dup posNum iNousStreams 10 string cvs putinterval
     %% el repiquem
     (w) file /trAsllAt exch def 
     aRePiCaR (r) file
     {  %% loop
      dup 65535 string readstring
      {
       trAsllAt exch writestring
      }
      {
       trAsllAt exch writestring
       closefile exit
      }ifelse
     }loop
     trAsllAt closefile
     %% regenerem nousStreams al nom que duu l'stream original intacte
     (2__________.nou)  %% aquest sempre duu l'stream original intacte
     dup length faPath add string dup /pAthXiU exch def
     0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
     pAthXiU /nousStreams exch def  %% utilitzat per l'applet per desar els nous streams redefinits al disc
     nousStreams /l'objectenet exch def  %% redefinim el renombrat a la seva variable original!
     %% el repiquem
     aRePiCaR (w) file /trAsllAt exch def
     %% fitxer a traslladar
     l'objectenet2
     (r) file
     {
      dup 65535 string readstring
      {
       trAsllAt exch writestring
      }
      {
       trAsllAt exch writestring
       closefile exit
      }ifelse
     }loop
     trAsllAt closefile
     %%( DiC DIRECTE AMB PATH DINS UNA ARRAY) ==
    }
    {  %% si es una cadena de dades directe ...
     %% llavors redefinim /XIU com una array renobrant l'objectenet a un *.nou
     iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
     l'objectenet2 nousStreams dup posNum iNousStreams 10 string cvs putinterval renamefile
     %% !!!!
     nousStreams /l'objectenet exch def  %% redefinim el renombrat a la seva variable original!
     DeNouContents /XIU [null] dup nousStreams dup length string copy 0 exch put put  %% incrustem el *.nou a l'array XIU i aquesta al dic
     %%( DIC DIRECTE AMB CADENA DE DADES) ==
    }ifelse
   }
   {  %% es una array (1 o + streams)
    %% aqui implementem l'algorisme per deixar 1 sol stream eliminant la resta
    /iDimoni 0 def
    {  %% loop, primer anem a buscar el dic ToTen1
     currentdict iDimoni 4 string cvs cvn get
     dup ToTen1 known {ToTen1 get exit}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% de descarrega
    %% desem el dic on posarem l'stream de Contents unificat
    /DeNouContents2 exch def
    %% incrustem l'stream de Contents sencer al mateix dic
    %% aqui mirem i redefinim el Length
    l'objectenet2 status pop pop pop /FiFtxr exch def pop  %% bytes totals del fitxer
    DeNouContents2 /Length FiFtxr put
    %% treiem el filtrat si en duu
    DeNouContents2 /Filter undef  %% encara que no en dugui, cap publema!
    %% esbrinem on hem de desar l'stream
    DeNouContents2 /XIU get /dadesstream exch def  %% la mena d'stream per despres
    dadesstream type /arraytype eq
    {  %% comprovem si l'stream es un path dins una array
     dadesstream 0 get
     %% el repiquem
     (w) file /trAsllAt exch def
     %% fitxer a traslladar
     l'objectenet2 (r) file
     {  %% loop
      dup 65535 string readstring
      {
       trAsllAt exch writestring
      }
      {
       trAsllAt exch writestring
       closefile exit
      }ifelse
     }loop
     trAsllAt closefile
     %%( DIC DIRECTE AMB PATH DINS UNA ARRAY) ==
    }
    {  %% si es una cadena de dades directe ...
     %% llavors redefinim /XIU com una array renobrant l'objectenet a un *.nou
     iNousStreams 1 add /iNousStreams exch def  %% comptador de nous fitxers d'stream
     l'objectenet2 nousStreams dup posNum iNousStreams 10 string cvs putinterval renamefile
     %% !!!
     nousStreams /l'objectenet exch def  %% redefinim el renombrat a la seva variable original!
     DeNouContents2 /XIU [null] dup nousStreams dup length string copy 0 exch put put  %% incrustem el *.nou a l'array XIU i aquesta al dic
     %%( DIC DIRECTE AMB CADENA DE DADES) ==
    }ifelse
    %%% fi de l'incrustacio de l'stream de Contents
    %% donem de baixa tots els elements d'aquesta array ...
    /iDimoni 0 def
    {  %% loop
     currentdict iDimoni 4 string cvs cvn get
     /aSac exch def xUnDef {aSac exch undef}forall  %% podem fer-ho a sac sense mirar
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% de descarrega
    %% rectifiquem l'objecte portador de la ref ind dels Contents
    /iDimoni 0 def
    {  %% loop
     currentdict iDimoni 4 string cvs cvn get
     dup quinOmodifiquem known {QueLiFem}{pop}ifelse
     iDimoni 1 add /iDimoni exch def
     iDimoni MaxDimoni eq {exit} if
    }loop  %% de descarrega
    %%( es una array de Contents trencats) ==
   }ifelse
   %% fi del repicat de Contents
  }if  %/01 SEPARACIÓ DE TINTES

  %% espiem com canvien els objectes a 14imatgesxtrossos_2pagines_streamsXtrossos_apel.pdf
  %%currentdict /0 get /2______________0 get {== ==}forall (****************)==
  %%currentdict /0 get /24_____________0 get {== ==}forall (****************)==
  %%currentdict /0 get /23_____________0 get {== ==}forall (****************)==
  %%currentdict /0 get /25_____________0 get {== ==}forall (****************)==
  %%quit
  %% fi de l'espiat

  QueLiFemFer 14 eq  %:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
  QueLiFemFer 13 eq  %:13 eliminem continguts de pàgina
  QueLiFemFer 10 eq  %:10 PREFLIGHT AMB CAPES
  QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
  or or or
  { %#%53bis% incrustem l'estructura de llesques (layers) per la verificació
   (%#%53bis%)==
   %%  %%% hauriem d'aprofitar els objectes morts (f) que han quedat entremig de la taula xref
   %%  %%% el deixarem x + endavant doncs te una certa complexitat i cal q contempli tots els casos (GN<>0)
   %%  %%% ATENCIO aquest algorisme s'hauria d'executar nomes un cop a les opcions de CaLi2CoPi on es crein nous objectes
   %%  % generem l'array tAndA on desarem els nums d'objecte reutilitzables
   %%  /tAndA [] def  % paquet buit d'entrada
   %%  /d1aQuiEsAra 1 def  % primer num d'objecte possible
   %%  {  % loop d'objectes correlatiu
   %%   /iDimoni 0 def
   %%   currentdict iDimoni 4 string cvs get
   %%   (_______________0)
   %%   16 string copy  % treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
   %%   dup 0 d1aQuiEsAra 10 string cvs putinterval
   %%   dup
   %%(***************)pstack quit
   %%   2 index exch known
   %%  }loop  % d'objectes correlatiu
   %% sempre que tAndA s'hagi exhaurit (paquet buit) començariem a donar nous nombres per la cua (QuiEsAra)
   %%  %%% el deixarem x + endavant doncs te una certa complexitat i cal q contempli tots els casos (GN<>0)
   %% a partir del darrer objecte actiu, numerem el nou objecte array on apuntaran /Order i /OCGs (de moment nomes n'hi ha un x PDF)
   QuiEsAra 1 add /QuiEsAra exch def
   %% el dic del Catalog viu ...
   CtLgViu
   /OCProperties
   <<
     /D
     <<
       %% objecte ind a l'array (1)
       /Order (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn  %% cal q sigui un literal xq l'algorisme de repicat el transformi a una ref ind normativa (# # R)

       QueLiFemFer 8 eq  %/10 ETIQUETA TEXT 
       {  %% aqui configurem que la Layer sigui NO imprimible i NO exportable
        /ON (_______________0) dup 0 QuiEsAra 1 add 10 string cvs putinterval cvn  %% cal q sigui un ral xq l'algorisme de repicat el transformi a una ref ind normativa (# # R)
        /AS
        [
         <<
           /Event /Print
           /Category [/Print]
           /OCGs
           [
            (_______________0) dup 0 QuiEsAra 1 add 10 string cvs putinterval cvn  %% cal q sigui un  ral xq l'algorisme de repicat el transformi a una ref ind normativa (# # R)
           ]
         >>
         <<
           /Event /Export
           /Category [/Export]
           /OCGs
           [
            (_______________0) dup 0 QuiEsAra 1 add 10 string cvs putinterval cvn  %% cal q sigui un  ral xq l'algorisme de repicat el transformi a una ref ind normativa (# # R)
           ]
         >>
        ]
       }if  %:10 ETIQUETA TEXT 

     >>
     %% objecte ind d'array (1) idem on apunta Order
     /OCGs (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn  %% cal q sigui un literal xq l'algorisme de repicat el transformi a una ref ind normativa (# # R)
   >> put  %% incrustem una estructura inicial de llesques al Catalog
   %% (1) generem el nou obj d'array on hi ha les ref ind de (2) ... tantes com tipus de materials digitals discriminem
   MaxDimoni 1 sub 4 string cvs userdict exch get  %% afegim el nou objecte al dic del darrer tros de PDF ... no cal q convertim a literal
   (_______________0) dup 0 QuiEsAra 10 string cvs putinterval  %% ... no cal q convertim a literal
   /OrderOCGs [] def  %% paquet buit de ref ind que apuntaran a (2) compartit per /Order i /OCGs
   /prprts <<>> def  %% dic buit de /Properties pels Resources de cada pagina
   %% malgrat nomes hi hagi FormXObjects i llavors no tenir activada la capa d'XObjects erroniament ...
   QueLiFemFer 10 eq  %/08 ETIQUETA TEXT
   QueLiFemFer 13 eq
   QueLiFemFer 14 eq
   or or
   {
    llesques 0 get 0 HiHaXObjects put  %% ... repiquem sense mirar el valor del gatell on ens diu en ferm si hi ha XObjects
   }if  %:08 ETIQUETA TEXT

   llesques  %% paquet de materials digitals detectables
   {  %% forall que genera un objecte nou x cada material digital actiu
    dup dup 0 get
    {  %% material digital detectat
     %% primer, farcim el paquet d'objectes ind que apunten a (2) ... tants com tipus de materials digitals detectem
     %% ampliem l'array OrderOCGs 1 + x sota ...
     OrderOCGs dup length dup /afegimA exch def 1 add array dup 3 -1 roll 0 exch putinterval dup
     QuiEsAra 1 add /QuiEsAra exch def  %% numerem el nou objecte
     (_______________0) dup 0 QuiEsAra 10 string cvs putinterval  %% ... no cal q convertim a literal encara
     cvn dup /suaraOCG exch def  %% el necessitarem x farcir l'array OCGs de l'objecte (3)
     afegimA exch put /OrderOCGs exch def  %% desem al paquet
     %% segon, farcim el dic prprts (Properties)
     1 get cvx exec  %% pesquem el nom intern que passem d'string a literal executant, doncs si no se'ns convertiria (un cop dins el dic) en un 'immediately evaluate name' !
     QuiEsAra 1 add /QuiEsAra exch def  %% numerem el nou objecte
     prprts exch (_______________0) dup 0 QuiEsAra 10 string cvs putinterval dup cvn exch /suaraOCMD exch def put
     %% tercer, generem el nou objecte (2) pel dic OCG
     %% aquest es un nou objecte que es dins l'array on apunta /Order i /OCGs ... tants com tipus de materials digitals detectem
     2 get  %% triem el nom extern de la llesca segons l'idioma 2=catala 3=english
     <<
       /Type /OCG
       /Name 5 -1 roll
       QueLiFemFer 8 eq  %/10 ETIQUETA TEXT
       {
        /Usage << /Export <</ExportState /OFF>> /Print <</PrintState /OFF>> >>
       }if  %:10 ETIQUETA TEXT
     >>
     suaraOCG exch 3 index  %% situem a lloc i fem una copia del dic del darrer tros de PDF
     3 1 roll put  %% desem el nou objecte (2)
     %% quart, generem el nou objecte (3) pel dic OCMD
     %% aquest nou objecte que penja de Properties dels Resources de cada pagina
     1 index  %% fem una copia del dic del darrer tros de PDF
     suaraOCMD
     << /Type /OCMD /OCGs [
     suaraOCG  %% objecte ind que apunta a (2)
     ] >> put  %% desem el nou objecte (3)
    }
    {  %% material digital no detectat al PDF
     pop pop
    }ifelse
   }forall
   OrderOCGs put  %% cinque, afegim el nou objecte d'array (1) al dic del darrer tros de PDF
   %% sise, incrustem l'entrada Properties als Resources de cada pagina amb les ref ind que apunten a (3)
   %% aqui es on cercariem els Resources particulars de cada Form x incrustar-hi Propierties
   %%  XRay /ObjectesX get
   %%  /1 get /Utilitzats get {== ==}forall
   RSRCS   %% Resources paginats trets de %26%
   {
    /Properties
    prprts  %% diccionari on les claus son els noms interns de les llesques q posem als Contents ... tantes com tipus de materials digitals detectats ... i els valors son objectes ind que apunten a (3)
    put  %% desem als Resources de cada pagina
    pop
   }forall
   %% farcim /Properties als dics dels Resources de cada FormXObject detectat
   %% si som dins un dic ara no podem fer currentdict!
   totalRSRCS  %% ara incrustem a sac /Properties dins aquest array on hi ha els dics directes de tots els Resources del document (xq n'hi ha de repetits?)
   %%  rsrcsFormsXObjects
   {  %% forall
    %%   0 get  % ara pesquem la primera ref ind o dic que es el dels Resources
    %%   dup type /nametype eq
    %%   {  % tret q sigui un dic directe! 
    %%    /aCercar exch def
    %%    /iDimoni 0 def
    %%    {  % loop d'interrogacio dels dicts de COMdimoni
    %%     userdict iDimoni 4 string cvs cvn get
    %%     % el diccionari de l'objecte
    %%     dup aCercar known {aCercar get exit}{pop}ifelse
    %%     iDimoni 1 add /iDimoni exch def
    %%     iDimoni MaxDimoni eq {exit} if
    %%    } loop  % d'interrogacio dels dicts de COMdimoni
    %%   }if   
    %% ara idem q als Resources de pagina x simplificar!
    /Properties prprts  %% diccionari on les claus son els noms interns de les llesques q posem als Contents ... tantes com tipus de materials digitals detectats ... i els valors son objectes ind que apunten a (3)
    put  %% desem als Resources de cada pagina
   }forall
  }if  %/08 ETIQUETA TEXT
       %/10 PREFLIGHT AMB CAPES
       %/13 eliminem continguts de pàgina
       %/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13

  QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
  {
   %#%53bis2% generem l'estat gràfic pels objectes transparents i tot el seu mapa de vincles
   (%#%53bis2%)==
   %% a partir del darrer objecte actiu, numerem el nou objecte de l'ExtGState pels recursos de totes les planes
   QuiEsAra 1 add /QuiEsAra exch def
   RSRCS  %% on hi ha els dics directes de tots els Resources de cada pagina del document ...
   {  %% forall
    exch pop
    dup /ExtGState known
    {  %% incrustem la nova entrada de l'estat grafic si ja hi ha ExtGS
     dup /ExtGState get dup type /nametype eq  %% es una ref ind?
     {
      /aCercar exch def  %% desem el literal del num d'obj
      %% pesquem el diccionari de la pagina x incrustar-hi l'entrada /Annots ...
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     dup (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
     /MRCT_t1 exch put /ExtGState exch put
    }
    {  %% creem el dic de l'estat grafic i incrustem l'entrada q defineix el comportament de les transparencies
     /ExtGState 1 dict dup /MRCT_t1 (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn put put
    }ifelse
   }forall
   %% afegim el nou objecte al dic del darrer tros del PDF ... no cal q convertim a literal
   MaxDimoni 1 sub 4 string cvs userdict exch get
   (_______________0) dup 0 QuiEsAra 10 string cvs putinterval  %% ... no cal q convertim a literal 
   <<
     /Type /ExtGState
     /ca .3 /CA .3  %% aqui es on controlem el to del color que transparenta (1 = 100%)
     /BM /Multiply  %% mixtura de mescla substractiva
   >> put
   /iplAnA 1 def  %% index de pàgina
   /faBotoCec false def  %% gatell per saber si hem de generar missatges Post-It amb botó cec
   rengsDtext (r) file cvx exec  %% deixem l'array des vincles localitzats del document a la pila
   %% aqui comprovem que el nombre de pagines detectades al rengsDtext s'avingui amb maxPlana
   dup length maxPlana ne {(>>> el nombre de planes de l'analisi no s'adiu a les que ara detectem ... PLEGUEM!)== stop}if
   {  %% forall
    /FiELDS [] def  %% array temporal (el regenerem per pàgina!) amb totes les ref ind dels vincles per Fields+Annots
    dup length 0 eq
    {  %% si l'array es buit es q no hi ha vincles localitzats
     pop
    }
    {  %% afefim l'arbre de vincles plana a plana generant els objectes corresponents x cadascun
     /aNNOTS [] def  %% array temporal de cada plana amb totes les ref ind dels vincles per Annots
     dup /motsXplana exch def length 1 sub 1 exch 2 exch
     {  %% for ... on ventem a sac els array de cada vincle
      %% :-Z desem l'índex que apunta a la cadena traduïda
      torsimany{dup 1 sub /iTorsimany exch def}if
      motsXplana exch get
      %% aquí és on avaluem l'índex 8 per saber si hem de fabricar un vincle o un botó cec
      dup 8 get null eq
      {  % fabriquem el botó cec
       /faBotoCec true def  %% hem de generar missatges Post-It amb botó cec
       %% generem tota la sèrie d'objectes relacionats amb el botó cec que durà el missatge
       QuiEsAra 1 add /QuiEsAra exch def
       (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
       %% el desem a l'array temporal de Fields+Annots
       FiELDS dup length 1 add dup 1 sub /aFEGIR exch def array dup 3 -1 roll 0 exch putinterval
       /FiELDS exch def dup FiELDS exch aFEGIR exch put
       %% muntem l'objecte del botó cec
       <</Rect 4 -1 roll 0 8 getinterval
       %% aqui executem graficament els 8 punts del rectangle x esbrinar-ne el BoundingBox
       gsave
       newpath
       dup 0 2 getinterval aload pop moveto
       dup 2 2 getinterval aload pop lineto
       dup 4 2 getinterval aload pop lineto
       dup 6 2 getinterval aload pop lineto
       closepath
       pathbbox
       grestore
       4 array astore exch pop  %% fem l'array del BBox i eliminem la còpia
       /P %% aqui es on afegim la ref ind al diccionari de pàgina
       quinaPlana iplAnA 6 string cvs get
       /FT /Btn  %% tipus botó
       /T QuiEsAra 10 string cvs  %% nom intern únic
       /Ff 65536  %% flag obligatori per al tipus botó
       /Subtype /Widget  %% obligatori
       /Type /Annot  %% obligatori
       /TU
       %% :-Z
       torsimany
       {  %% text del tooltip amb la cadena traduïda
        motsXplana iTorsimany get
       }
       {
        noTrobat   %% text del Tooltip per JBC (Sticky Note o Post-It)
       }ifelse
       >>
       %% afegim l'objecte del botó cec al dic del darrer tros del PDF
       MaxDimoni 1 sub 4 string cvs userdict exch get 3 1 roll put
      }
      {  % fabriquem el vincle
       %% generem tota la serie d'objectes vinculats x vincle
       QuiEsAra 1 add /QuiEsAra exch def
       (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
       %% el desem a l'array temporal d'Annots
       aNNOTS dup length 1 add dup 1 sub /aFEGIR exch def array dup 3 -1 roll 0 exch putinterval
       /aNNOTS exch def dup aNNOTS exch aFEGIR exch put
       %% muntem el primer objecte de la serie
       <</Rect 3 index 0 8 getinterval
       %% aqui executem graficament els 8 punts del rectangle x esbrinar-ne el BoundingBox
       gsave
       newpath
       dup 0 2 getinterval aload pop moveto
       dup 2 2 getinterval aload pop lineto
       dup 4 2 getinterval aload pop lineto
       dup 6 2 getinterval aload pop lineto
       closepath
       pathbbox
       grestore
       4 array astore
       %% evitem l'exces de decimals i l'aparicio de radials
       %%{10000 mul truncate 64 string cvs cvi 10000 div}forall 4 array astore
       exch  %% fem l'array del Bbox per Rect
       %% evitem l'exces de decimals i l'aparicio de radials
       %%{10000 mul truncate 64 string cvs cvi 10000 div}forall 8 array astore
       %% cal veure si l'array dels QuadPoints l'acceptara amb l'ordre amb que treballem ara
       /QuadPoints exch
       %%(:-3)pstack quit
       %% creem el segon objecte de la serie
       /A QuiEsAra 1 add /QuiEsAra exch def
       (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
       dup count 1 roll  %% i el posem a la base de la pila
       /Type/Annot /Border [0 0 0] /H/I /BS<</S/S/W 0/Type/Border>> /NewWindow true /Subtype/Link>>
       %% afegim el primer objecte al dic del darrer tros del PDF
       MaxDimoni 1 sub 4 string cvs userdict exch get 3 1 roll put
       %% vincle URL o a disc ?
       dup 8 get (http://)search
       {
        pop pop pop/vincleURL true def
       }
       {
        pop/vincleURL false def
       }ifelse
       %% anem x muntar el segon objecte
       exch <<
       vincleURL  %% vincle URL o a disc ?
       {
        3 -1 roll 8 get  %% pesquem la URL del vincle
        /URI exch /S/URI>>
       }
       {
        /F
        %% creem el tercer objecte i ultim
        QuiEsAra 1 add /QuiEsAra exch def (_______________0) dup 0 QuiEsAra 10 string cvs putinterval cvn
        dup count 1 roll  %% i el posem a la base de la pila
        /S/Launch/NewWindow true>>
        %% afegim el segon objecte al dic del darrer tros del PDF
        MaxDimoni 1 sub 4 string cvs userdict exch get 3 1 roll put
        8 get  %% pesquem el path a disc del vincle 
        <</F 3 -1 roll /Type/Filespec>>
       }ifelse
       %% afegim el tercer objecte, i ultim, al dic del darrer tros del PDF
       MaxDimoni 1 sub 4 string cvs userdict exch get 3 1 roll put
      }ifelse
     }for
     %% aqui es on afegim l'entrada Annots (comú tant si té links com missatges de botó cec)
     quinaPlana iplAnA 6 string cvs get
     /actGina exch def  %% desem el literal del num d'obj /Page
     %% pesquem el diccionari de la pagina x incrustar-hi l'entrada /Annots ...
     /iDimoni 0 def
     {  %% loop d'interrogacio dels dicts de COMdimoni
      currentdict iDimoni 4 string cvs cvn get
      %% el diccionari de l'objecte
      dup actGina known {actGina get exit}{pop}ifelse
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop  %% d'interrogacio dels dicts de COMdimoni
     dup /Annots known
     {  %% si ja hi es l'afegim a la cua
      dup /Annots get
      dup type  %% nomes si es una array serem davant de l'objecte directe
      /nametype eq
      {  %% es una ref ind q apunta a l'array dels Annots
       /aCercar exch def  %% desem el literal del num d'obj
       %% pesquem el diccionari de la pagina x incrustar-hi l'entrada /Annots ...
       /iDimoni 0 def
       {  %% loop d'interrogacio dels dicts de COMdimoni
        currentdict iDimoni 4 string cvs cvn get
        %% el diccionari de l'objecte
        dup aCercar known {aCercar get exit}{pop}ifelse
        iDimoni 1 add /iDimoni exch def
        iDimoni MaxDimoni eq {exit} if
       }loop  %% d'interrogacio dels dicts de COMdimoni
      }if
      %% afegim el contingut dels array temporals aNNOTS (links) i FiELDS (missatges de botó cec)
      dup length dup /aFEGIR exch def aNNOTS length add array dup 3 -1 roll
      0 exch putinterval dup aFEGIR aNNOTS putinterval
      dup length dup /aFEGIR exch def FiELDS length add array dup 3 -1 roll
      0 exch putinterval dup aFEGIR FiELDS putinterval
      /Annots exch put
     }
     {  %% l'entrem de nou en nou
      /Annots
      %% sumem els dos arrays temporals possibles
      aNNOTS dup length dup /aFEGIR exch def FiELDS length add array dup 3 -1 roll
      0 exch putinterval dup aFEGIR FiELDS putinterval put
     }ifelse
    }ifelse
    iplAnA 1 add /iplAnA exch def  %% actualitzem l'index d plana
   }forall
   %% si hem creat missatges de botó cec, ara ens cal afegir l'entrada AcroForm (si no hi és) al
   %% Catalog, i si hi és doncs retocar el dic directe o regenerar l'objecte indirecte corresponent
   faBotoCec
   {
    CtLgViu /AcroForm known
    {  %% existeix i completem l'entrada Fields
     CtLgViu /AcroForm get
     dup type /nametype eq
     {  %% es una ref ind q apunta al diccionari
      /aCercar exch def  %% desem el literal del num d'obj
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup aCercar known {aCercar get exit}{pop}ifelse
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni
     }if
     dup /Fields get  %% extraiem aquesta entrada sense interrogar, doncs és obligatòria
     %% i la completem amb els nopus objectes de botó cec amb missatge
     dup length dup /aFEGIR exch def FiELDS length add array dup 3 -1 roll
     0 exch putinterval dup aFEGIR FiELDS putinterval /Fields exch put
    }
    {  %% hem de crear l'entrada i no cal que sigui nou objecte indirecte!
     CtLgViu /AcroForm <</Fields FiELDS>>put
    }ifelse
   }if
  }if  %/08 ETIQUETA TEXT
  %%% aqui hi havia el depurador de l'estructura de Layers
  %%% final del depurador de Layers no utilizades
  QueLiFemFer 8 eq  %:08 ETIQUETA TEXT
  torsimany not and  %% tret que NO tinguem actiu el torsimany ...
  {
   %#%53bis3% ... com en el cas del projecte JBC, és la DLL qui controla el nom i el path del fitxer de sortida
   (%#%53bis3%)==
   aFeGeiX (w) file /Objected'Ara exch def
  }  %/08 ETIQUETA TEXT
  {
%:00 REESCRIPTURA IDEM
%:01 SEPARACIÓ DE TINTES
%:02 MARQUES DE TALL
%:03 CORRECTOR TIPOGRÀFIC
%:05 dada variable
%:06 COSIT D'IMATGES
%:07 REINSEREIX IMATGES JPEG
%:08 ETIQUETA TEXT
%:10 PREFLIGHT AMB CAPES
%:12 arbre jeràrquic
%:13 eliminem continguts de pàgina
%:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%:15 ELIMINA LLESQUES
%:17 ENCAVALCA CONTINGUTS

   %#%54% fitxer on reconstruirem el PDF
   (%#%54%)==
   QueLiFemFer 2 eq
   QueLiFemFer 6 eq
   QueLiFemFer 13 eq
   QueLiFemFer 14 eq
   or or or
   {  %% ho fem per A3copiseny (cosit) i Sarrió (creus)
    false
   }
   {
    true
   }ifelse  %% que fem?
   {  %% ordre classic del nom del PDF: primer les nostres llatinades i depres el nom original
    dena length
    aFeGeiX
    length dup /VaS exch def add dup /VaS2 exch def
    4 add string dup 0 aFeGeiX putinterval dup VaS dena putinterval dup
    VaS2 (.pdf) putinterval  %% ara ho posem en minuscules doncs a Win en majuscules no sortia la icona d'Acrobat
   }
   {  %% demanat pel Xavier de Sarrió: capgirem l'ordre: primer el nom original del PDF i despres les nostres llatinades
    aFeGeiX
    {
     bUsca search
     {pop pop}{exit}ifelse
    }loop
    dup length dup /Va2 exch def aFeGeiX length exch sub /Va1 exch def
    aFeGeiX length Va2 sub dena length add /Va2 exch def
    aFeGeiX length dena length add dup /Va3 exch def 4 add string dup
    0 aFeGeiX putinterval  %% incrustem el primer tram del path
    dup Va1 dena putinterval  %% incrustem el nom del pdf a partir de la darrera / del dir
    dup 3 -1 roll Va2 exch putinterval  %% incrustem la cadena unica
    dup Va3 (.pdf) putinterval  %% incrustem l'extensio en minuscules doncs a Win en majuscules no sortia la icona d'Acrobat

   }ifelse
   QueLiFemFer 6 eq
%%   QueLiFemFer 13 eq
%%   QueLiFemFer 14 eq
%%   or or
   {  %% cal posar un detector per saber si processem un directori o un sol fitxer
    dup dup length string copy
    xQuinaArea
    1 eq
    {  %% si val u, es que fem un directori sencer
     pop fApplet
     dup
     %% primer extraiem el nom del fitxer...
     {
      bUsca search
      {pop pop}{exit}ifelse
     }loop    
     1 index length exch length 1 add sub 0 exch getinterval
     dup /primerPath exch def
     {
      bUsca search
      {pop pop}{exit}ifelse
     }loop    
     %% ... per controlar el nom del directori i tractar-lo com a nom del log que generem
     dup length dup 8 add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll (_dir.log) putinterval

%%     dup length primerPath length add 1 add string dup 0 primerPath putinterval
%%     %% ... i tractar-lo com a nom del log que generem
%%     dup primerPath length (/) putinterval dup primerPath length 1 add 4 -1 roll putinterval
%%     dup length dup 8 add string dup dup 5 -1 roll 0 exch putinterval 3 -1 roll (_dir.log) putinterval

    }
    {  %% si val zero, es que fem un sol fitxer
%%(:-])pstack quit  %% aturem l'execució doncs hem de veure com fiquem aquesta extensió
     dup dup length 3 sub (log)putinterval
     %% extraiem el nom del fitxer .log
     {
      bUsca search
      {pop pop}{exit}ifelse
     }loop 
    }ifelse
    %% i el reobrim dins el context del localhost doncs ha estat creat pel PHP i també hi ha de tornar a escriure
    (a) file /ARAlog exch def
    %% aquí és on hi hauríem de ventar tota la informació del diccionari de guia de cosits

    TRNCCLSQS
    {
     iFenix  %% només té les pàgines de document que tenen imatges cosides
     {  %% forall per les pàgines que tenen imatges cosides
      length 3 string cvs  %% nombre d'imatges cosides
      exch 4 string cvs  %% número de pàgina
      ARAlog (pag: ) writestring ARAlog exch writestring  %% escrivim el núm. de pàgina
      ARAlog ( ... cosides ... ) writestring ARAlog exch writestring  %% escrivim el nombre d'imatges
      ARAlog ( ... imatges\012) writestring
      %% /capCapsa get  %% el length de capCapsa -1 ens diria quants trocets hem enganxat
     }forall
    }if
%(:-])pstack quit
   }if

   dup
   {
    bUsca search
    {pop pop}{exit}ifelse
   }loop /nomTotBe exch def

%%MASATSfebrer0
   bateiG null ne
   {
    pop bateiG  %% eliminem el path+nom del fitxer a reescriure segons la nomenclatura clàssica i hi posem el nou path+nom
   }if

   %% caldria posar un missatge d'avis en cas que no ens deixes escriure?
   (w) file /Objected'Ara exch def
  }ifelse
  %%noZero length == (***) pstack quit
  %%userdict /0 get {== ==}forall (***) == quit
  iPrev 1 add /iPrev exch def  %% posem el sumador fora de l'anellat save/restore
  /Salva'm save def  %% anellat important x poder eliminar els fitxers al final
  %%%
  %#%55% aquí s'inicia la reescriptura del PDF
  (%#%55%)==
  BaBeL 14 get print flush
  %% escrivim el cap del PDF normatiu, segons la versio de vPDF (que pot haver-se reactualitzat segons /Version)
  Objected'Ara dup dup (%PDF-) writestring vPDF writestring EOL writestring
  %% NOU! ara posem nosaltres el tipic comentari a la segona linia per temes de deteccio
  %% de fitxer binari (un minim de 4 caracters que estiguin x sobre del 128)
  Objected'Ara dup
  %% (%\342\343\317\323)  % tal i com ho fa Acrobat6/7
  (%~È¬`á.ü.á«ø`á.ü¸.·´¯`·.¸.·´¨«~)  %% ascii art personalitzat, si es Mac es veu la cuca de l'esquerra i si es PC es veu la cuca de la dreta.
  writestring EOL writestring
  %%% EP! CAL REPASSAR AQUESTS CONCEPTES (alguns ja no són vigents)
  %% escrivim els objectes ventant el diccionari COMdimoni
  %% (ho fem tal com venen doncs NO estem obligats a escriure'ls per ordre numèric !!)
  %% i la taula xref de byte offsets a l'array Axref.
  %% A l'escriure els objectes simultàniament prenem els seu byte offset com a
  %% primer valor d'una array i el generationNumber com a segon valor de l'array
  %% que anirà posada a l'índex de /Axref en funció del num d'objecte corresponent.
  %% Els objectes lliures (no existents a COMdimoni) aniran marcats a Axref amb un null
  %% Utilitzarem /Axref per muntar la xref final, tenint en compte que haurem de crear un
  %% algorisme detector dels objectes lliures i la seva numeració correcte a la taula fent:
  %% a. Que al byte offset de l'objecte 0 hi ha d'anar el número del proper objecte lliure,
  %% si no n'hi ha, ha de dur el 0
  %% b. Que el genNum de l'objecte 0 sempre es 65535
  %% c. Detectarem els objectes lliures localitzant els null a l'array Axref
  %% d. Els objectes lliures han de dur com a byte offset el número d'objecte del lliure proper,
  %% tret del darrer que sempre es 0
  %% e. Donat que el recomposat del PDF que estem fent equival aproximadament a un SaveAs
  %% deixarem tots els objectes lliures amb un genNum igual a 1
  %% cerquem simultàniament dins els diccionaris l'entrada /XIU que voldra dir que duu
  %% un stream que caldrà escriure també (més endavant comprovarem el valor /Length)
%%Preparem l'algorisme per què pugui treballar amb subseccions (gran estalvi d'octets en arxius amb molts objectes discontinus)
true setglobal
%% dins el loop d'objectes ens cal saber on s'escriuen les variables clau com /elPrimer (objectes vius n)
globaldict
dup /araBada 0 put  %% desa el núm d'objecte viu que s'escriu i resta amb el següent per saber quants n'hi ha de morts seguits
dup /maxBada 2 put  %% mínim d'objectes morts per crear una subsecció
dup /nSubscc 0 put  %% hauria de comptar el nombre d'objectes totals de cada subsecció
dup /CMPTf 0 put  %% compta les f seguides (objectes morts) 
dup /PRIMERf true put  %% gatell de control de la primera subsecció
dup /faSbscc [] put  %% array on desarem cadascun dels parells a escriure l'xref amb subseccions i extraure'n línies a /TOTxref
/DARRERSf [] put  %% array on desarem el probables darrers objectes f (doncs cal deixar el byteoffset a zero)
false setglobal

  %%% EEEEPPPP AQUI havia 43, 44 i 45
  %%% (HAURIEM DE REEXECUTAR ELS CONTENTS PER 3er COP ???)
  save  %% salvem l'escriptura final de l'xref, si no ho fem així, llegir i escriure els fixters
  %% SUBxref i TOTxref donen problemes d'esborrat al final!
  %#%56% just abans podríem donar d'alta als nous objectes
  (%#%56%)==
  %% refem l'escriptura d'objectes (ara per estricte ordre) i la taula xref
  %%% fitxer on desarem les subseccions amb n
  SUBxref (w) file /subXREF exch def
  %%% fitxer on desarem tota l'xref
  TOTxref (w) file /totXREF exch def
  %%% ATENCIO! ara no podem fer subseccions a l'Acro6 (obligats a posar f!)
  %%% primera linia inicial dels parells ...
  totXREF dup dup (0 ) writestring  %% index inicial xref (ara sempre sera 0)
  QuiEsAra 1 add 10 string cvs writestring  %% total entrades xref (darrer objecte+1)
  EOL writestring
  %% cadena facidora d'objectes buits (f) que nomes modificarem i escriurem a totXREF quan trobem el seguent f o quan arribem al final del fitxer
  (0000000000 00001 f)
  18 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
  /ReS exch def
  ReS 11 (65535) putinterval  %% modifiquem el primer f obligatori de la primera linia de l'xref
  %% per assegurar una neteja correcta, donarem de baixa (amb undef) tots els objectes
  %% fins el GN-1 existens al dic noZero
  noZero length 0 ne
  {
   %% ( ... atencio objectes amb GN<>0 ... ) ==
   %%% CAL FER-HO + podriem donar un missatge x la pantalleta
   noZero
   {  %% forall, muntem sobre l'estructura de 16_ cada element del dic i el donem de baixa
    /GN exch def 10 string cvs
    (________________)
    16 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
    dup 3 -1 roll 0 exch putinterval /16ON exch def
    GN cvi 1 sub -1 0
    {  %% for
     /GNara exch def
     /iDimoni 0 def
     {
      currentdict iDimoni 4 string cvs get
      16ON GNara 5 string cvs dup length 16 exch sub exch putinterval
      16ON undef
      iDimoni 1 add /iDimoni exch def
      iDimoni MaxDimoni eq {exit} if
     }loop
    }for
   }forall
  }if

 {  %% loop d'objectes correlatiu
   /iDimoni 0 def
   {  %% loop per ventar els dicts trencats i escriure'n l'objecte i els BO i GN
    currentdict iDimoni 4 string cvs get
    %%test
    %%dup length ==
    %%{pop ==}forall quit
    (_______________0)
    16 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
    dup 0 elPrimer 10 string cvs putinterval
    dup
    2 index exch known
    {
     true
     ( 00000 n\015\012)
%%     ( 00000 n\012)
     10 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
     /GNx exch def
     ( 0 obj)
     6 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
     /GNo exch def
    }
    {  %% aqui evaluem si l'objecte realment no hi es o te un GN<>0
     %% cercant el ON dins noZero ... CAL FER_HO ...
     dup (_) search pop exch pop exch pop /ONara exch def
     noZero ONara known
     {  %% te un GN<>0
      noZero ONara
      get
      /GN exch def
      ( 00000 n\015\012)
%%      ( 00000 n\012)
      10 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
      dup GN dup length 6 exch sub exch putinterval
      /GNx exch def
      GN dup length 5 add string dup 3 -1 roll
      1 exch putinterval dup dup length
      4 sub ( obj) putinterval
      dup 0 32 put  %% x evitar nulls
      /GNo exch def
      16 string cvs dup GN dup length 16 exch sub exch putinterval  %% incrustem de nou el GN que toca x recuperar-ne el contingut
      dup 2 index exch known {true}{false}ifelse  %% potser que al tros de diccionari no hi sigui
     }
     {  %% l'objecte no hi es
      false
     }ifelse
    }ifelse
    {  %% si troba l'objecte
     get
     %% avaluem el byte offset i escrivim a SUBxref
     (0000000000)
     10 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
     dup
     Objected'Ara fileposition
     10 string cvs dup length 10 exch sub exch putinterval
     subXREF exch writestring
     subXREF dup  %%( 00000 n\015)
     GNx writestring flushfile  %% Ara el GN de l'Xref ja sera el que toqui
     %% escrivim el cap de l'objecte
     Objected'Ara elPrimer 10 string cvs writestring  %% escrivim el num d'objecte
     Objected'Ara dup  %%( 0 obj)

%%Aquest és el núm de l'objecte viu que ara s'escriu
true setglobal
elPrimer
araBada sub
maxBada gt  %% hi ha una distància de més de maxBada entre dos objectes vius?
{
 PRIMERf  %% exclusiu per al primer parell de la primera subsecció
 {
  mark 0 nSubscc dup /capNum exch def  %% desem el cap del núm d'objecte per a la següent subsecció
  CMPTf sub 1 add ]  %% parell amb el núm del primer objecte i nombre d'elements de la subsecció

%dup 0 get 17 eq{
%(aqui es on plora la criatura3?)pstack quit
%}if

  globaldict /faSbscc get dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
  dup 3 -1 roll araVa exch put globaldict exch /faSbscc exch put  %% desem a l'array
  /PRIMERf false def
 }
 {
  %% és el primer valor que anuncía la subsecció acompanyada del nombre d'objectes com a segon valor (l'haurem de deduïr)
  %%(1) ==
  mark
  capNum 1 add  %% ens don el núm del primer objecte viu després d'un tram de maxBada o més f
  %%(nof) ==
  %% són el nombre de línies que combinen n i f sense trencar
  nSubscc dup /capNum exch def  %% desem el cap del núm d'objecte per a la següent subsecció
  %%(fs) ==
  CMPTf  %% són els objectes morts seguits de maxBada cap amunt?
  sub ]  %% ens don el nombre d'elements de la subsecció

%dup 0 get 17 eq{
%(aqui es on plora la criatura2?)pstack quit
%}if

  globaldict /faSbscc get dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
  dup 3 -1 roll araVa exch put globaldict exch /faSbscc exch put  %% desem a l'array
 }ifelse
 /nSubscc 1 def  %% hauria de comptar el nombre d'objectes de cada subsecció
}
{
 nSubscc 1 add /nSubscc exch def
}ifelse
elPrimer /araBada exch def
/CMPTf 0 def  %% posem a zero el comptador d'objectes morts f seguits
false setglobal

     GNo writestring  %% Ara el GN de l'objecte ja sera el que toqui
     EOL writestring
     dup type /dicttype eq
     {  %% es un diccionari
      dup /XIU known  %% te stream?   
      {
       dup /XIU get /strEAm exch def  %% capturem l'array o string del fitxer stream
       %%% aqui reajustem l'entrada /Length
       dup /Length get dup type /nametype eq
       {
        pop
       }  %% de moment descartem els Lengths de ref ind (doncs ja l'haurien de dur B)
       {
        /araL exch def
        strEAm type /arraytype eq
        {
         strEAm 0 get  %% capturem el path de l'array
         status pop pop pop /FaF exch def pop  %% bytes reals x Length
        }
        {  %% es una cadena
         strEAm length /FaF exch def  %% bytes reals x Length
        }ifelse
        araL FaF eq
        {
         %%(BON Length !) ==
        }
        {
         %%(MAL Length !) ==
         dup /Length FaF put  %% incrustem al dic el length corregit
        }ifelse
       }ifelse
       dup /XIU undef  %% la donem de baixa abans d'escriure
       Objected'Ara (<<) writestring  %% obrim aqui el diccionari
       /salva'l save def espiadic_fura2 salva'l restore
       %% diu la PDF Reference: "The keyword stream that follows the stream dictionary should be followed by an end-of-line marker consisting of either a carriage return and a line feed or just a line feed, and not by a carriage return alone."

       Objected'Ara (>>\012stream\015\012) writestring  %% posem aqui el tancament del diccionari
%%       Objected'Ara (>>\012stream\012) writestring  %% posem aqui el tancament del diccionari

       %% comprovem si l'stream es un path dins una array o una string de dades directe
       strEAm type /arraytype eq
       {
        strEAm 0 get (r) file  %% capturem el path de l'array
        {  %% loop
         dup 65535 string readstring
         {
          Objected'Ara exch writestring
         }
         {
          Objected'Ara exch writestring closefile exit
         }ifelse
        }loop  %% escrivim totes les dades del strEAm XIU a Objected'Ara
       }
       {  %% escrivim directament la cadena de dades de l'stream
        Objected'Ara strEAm writestring
       } ifelse
       %% diu la PDF Reference: "It is recommended that there be an end-of-line marker after the data and before endstream; this marker is not included in the stream length."
       Objected'Ara (\012endstream\012endobj\012) writestring
      }
      {
       Objected'Ara (<<) writestring  %% obrim aqui el diccionari
       /salva'l save def espiadic_fura2 salva'l restore
       Objected'Ara (>>\012endobj\012) writestring  %% posem aqui el tancament del diccionari
      }ifelse
     }
     {
      %% == (*** aquest objecte no es un diccionari ***) == quit
      dup type /arraytype eq
      {  %% es una array
       /salva'l save def espiapaq_fura3 salva'l restore
       Objected'Ara (endobj\012) writestring
      }
      {
       dup type /stringtype eq
       {  %% es una cadena
        Objected'Ara (\() writestring
        Objected'Ara exch writestring
        Objected'Ara (\)) writestring
        Objected'Ara (\012endobj\012) writestring
       }
       {
        dup type /nametype eq
        {  %% es un literal
         Objected'Ara dup (/) writestring exch 128 string cvs writestring
         Objected'Ara (\012endobj\012) writestring
        }
        {  %% detectem un objecte null
         dup type /nulltype eq
         {
          pop Objected'Ara (null) writestring
          Objected'Ara (\012endobj\012) writestring
         }
         {
          dup type /realtype eq
          {  %% es un real
           10000 mul truncate 10000 div
           256 string cvs Objected'Ara exch writestring
           Objected'Ara (\012endobj\012) writestring
          }
          {  %% dins l'entorn del PDF nomes queda ser un enter o un booleni no ?
           256 string cvs Objected'Ara exch writestring
           Objected'Ara (\012endobj\012) writestring
          }ifelse
         }ifelse
        }ifelse
       }ifelse
      }ifelse
     }ifelse
     /TancaSub false def
     Objected'Ara flushfile
     exit  %% un cop escrit l'objecte sortim
    }
    {  %% no ha trobat l'objecte
     pop pop
     /TancaSub true def
    }ifelse
    iDimoni 1 add /iDimoni exch def
    iDimoni MaxDimoni eq {exit} if
   }loop  %% fi del loop per ventar els dicts trencats
   %% detectem objectes no trobats (f)
   TancaSub
   {
    %% profilaxi de fitxers ... soluciona els problemes d'ioError detectats a 143a1_tagged.pdf
    subXREF dup flushfile closefile
    %% incrustem l'index del seguent objecte buit (f)
    ReS elPrimer 10 string cvs dup length 10 exch sub exch putinterval

%%Aquí s'escriu l'objecte mort
true setglobal
nSubscc 1 add /nSubscc exch def
CMPTf 1 add /CMPTf exch def  %% compta les f seguides (objectes morts) amb un valor superior o igual a maxBada

%%Haurem de fer això a +Preparem 
%%Ens cal capturar el darrer objecte mort de la darrera subsecció que en dugui (llavors tot 0)
%%Si el primer f de dalt de tot apunta a una f següent NO atrapada en una subsecció i no hi ha cap f més entre les subseccions  (llavors tot 0)

CMPTf maxBada 1 sub eq
{  %% només desem els maxBada -1 
 globaldict /DARRERSf get length dup /araVa exch def 1 add array dup 0
 globaldict /DARRERSf get putinterval dup araVa elPrimer put globaldict exch /DARRERSf exch put
}if  %% els desem tots perquè després ens cal saber si correspon a una subsecció i si és la darrera
false setglobal

    %% i l'escrivim a totXREF
    totXREF ReS writestring
    totXREF EOL writestring
    SUBxref (r) file
    {  %% loop
     dup 18 string readline
     {
      totXREF exch writestring
      totXREF EOL writestring
     }
     {
      totXREF exch writestring
      totXREF flushfile
      closefile exit
     }ifelse
    }loop
    %% i resetem el fitxer on desarem les subseccions
    SUBxref (w) file /subXREF exch def
    (0000000000 00001 f)
    18 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
    /ReS exch def  %% redefinim de nou ReS
   }if
   %% comptador ciclic d'objectes del primer al darrer
   elPrimer 1 add dup QuiEsAra gt
   {

%%Aquí s'escriu EL DARRER objecte mort
true setglobal
%%(1) ==
mark
elPrimer  %% el núm del darrer objecte viu després d'un tram de maxBada o més f
nSubscc sub 1 add  %% ens el núm del primer objecte viu del darrer tram de la subsecció
%% són el nombre de línies que combinen n i f sense trencar
nSubscc
%%(fs) ==
CMPTf  %% són els objectes morts seguits de maxBada cap amunt?
sub ]  %% ens don el nombre d'elements que té la darrera subsecció

%dup 0 get 17 eq{
%(aqui es on plora la criatura1?)pstack quit
%}if

globaldict /faSbscc get dup length dup /araVa exch def 1 add array dup 3 -1 roll 0 exch putinterval
dup 3 -1 roll araVa exch put globaldict exch /faSbscc exch put  %% desem a l'array
%% el núm d'objecte f teòric darrer també el desem
globaldict /DARRERSf get length dup /araVa exch def 1 add array dup 0
globaldict /DARRERSf get putinterval dup araVa elPrimer put globaldict exch /DARRERSf exch put
false setglobal

    pop
    %% escrivim el darrer objecte f
    (0000000000 00001 f)
    18 string copy  %% treballem sempre amb una copia x assegurar-nos de l'aillament de les dades
    /ReS exch def  %% redefinim de nou ReS
    totXREF ReS writestring
    totXREF EOL writestring
    %% profilaxi de fitxers ... soluciona els problemes d'ioError detectats a 143a1_tagged.pdf
    subXREF dup flushfile closefile
    %% volquem la darrera subseccio amb objectes n
    SUBxref (r) file
    {
     dup 18 string readline
     {
      totXREF exch writestring
      totXREF EOL writestring
     }
     {
      totXREF exch writestring
      totXREF closefile
      closefile exit
     }ifelse
    }loop
    exit
   }
   {
    /elPrimer exch def
   }ifelse
  }loop  %% d'objectes
  restore  %% restaurem l'estat per l'escriptura de l'xref
  %% control de temps
  %%usertime Td'ara sub == (escrivim els objectes\n) print flush
  %% control de temps
  %%usertime /Td'ara exch def
  %% escrivim la taula xref
  Objected'Ara fileposition /BOsXr exch def  %% desem el byte offset d'startxref
  Objected'Ara dup (xref) writestring EOL writestring  %% cap de l'xref
%%+Preparem l'algorisme per què pugui treballar amb subseccions
%%MASATSencvlct
false
  {  %% apliquem el resultat de l'anàlisi de subseccions fet (06.04.19) a /Users/femfum/Masats/projecteSumaCapes/breuHistoric.txt
   %% aqui repiquem totXREF a la cua d'Objected'Ara
   TOTxref (r) file
   /aXREF [] def  %% hi desem (a GS hi ha +d16 milions de marge) cadascuna de les línies de l'xref escrites a TOTxref
   /aXREFss [] def  %% hi desem les línies de l'xref amb les subseccions a punt d'escriure
   {  %% loop
    dup 128 string readline
    {
     aXREF length dup /araVa exch def 1 add array dup 0 aXREF putinterval dup 3 -1 roll araVa exch put /aXREF exch def
    }
    {  %% sortim
     pop closefile exit
    }ifelse
   }loop
   %% escapcem de l'array sense el primer element: el parell numèric de capçalera
   aXREF dup length 1 sub 1 exch getinterval
   globaldict /faSbscc get  %% ens ha de pautar l'extracció de les línies d'xref a TOTxref
   dup length 1 eq  %% només si té més d'1 subsecció fa sentit treballar-hi
   %% degut al fet que NO hi hagin subseccions, o sigui 1 xref sencera, els dos numerics de l'array /faSbscc són idèntics
   {  %% no té subseccions possibles
    pop pop  %% ens carreguem les arrays
   }
   {  %% refem l'estructura de l'xref dins Txref______.obj a punt d'escriure

%%EP! el comptador de línies de subseccions (segon valor de l'array) NO és correcte!
%exch length
%(arasomaqui)pstack quit

    {  %% forall per desar les línies de les subseccions a /aXREFss
     1 index exch aload pop getinterval
     aXREFss length dup /araVa exch def 1 add array dup 0 aXREFss putinterval dup 3 -1 roll araVa exch put /aXREFss exch def
    }forall
    pop
    %% ara ens cal saber quina és la darrera f que podem trobar dins una subsecció
    0 0  %% comptadors de l'índex de la subsecció i de la línia on hi ha la darrera efa
    aXREFss
    {  %% forall de subseccions
     {  %% forall per dins de cada subsecció
      17 get 102 eq  %% acaba amb una f?
      {
       2 copy 2 array astore /iEfa exch def
      }if
      1 add  %% fem córrer l'índex de les f dins l'array de la subsecció
     }forall
     pop 1 add 0  %% fem córrer l'índex de les subseccions i posem a zero el de les f 
    }forall
    pop pop  %% esborrem els comptadors
    aXREFss iEfa 0 get get dup  %% l'índex de la subsecció on hi ha la darrera efa
    iEfa 1 get dup 0 eq
    {
     (0000000000 65535 f) put  %% la darrera efa és la del cap de l'xref
    }
    {
     (0000000000 00001 f) put  %% índex de la línia on hi ha la darrera efa
    }ifelse
    %% refem l'array de la subsecció on hi ha la darrera efa
    aXREFss iEfa 0 get 3 -1 roll put
    %% escrivim aparelladament els 2 núms. de control de cada subsecció /faSbscc amb les línies corresponents /aXREFss
    TOTxref (w) file /totXREF exch def  %% repiquem aquí la taula xref a Txref______.obj
    0 1 aXREFss length 1 sub
    {  %% aparellament i escriptura d'arrays
     dup globaldict /faSbscc get exch get
     dup 0 get 256 string cvs totXREF exch writestring  %% primera xifra del núm. d'objecte
     totXREF 32 write  %% espai en blanc separador
     1 get 256 string cvs totXREF exch writestring  %% segona xifra del nombre de línies de la.subsecció
     totXREF EOL writestring  %% retorn de carro
     aXREFss exch get
     {
      totXREF exch writestring  %% cadascuna de les línies de la.subsecció
      totXREF EOL writestring  %% retorn de carro
     }forall
    }for
    totXREF closefile
   }ifelse  %% només si té més d'1 subsecció fa sentit treballar-hi
  }if
%%+Preparem l'algorisme per què pugui treballar amb subseccions

  %% aqui repiquem totXREF a la cua d'Objected'Ara
  TOTxref (r) file  %% rellegim Txref______.obj

  %% aquí en mengem tota la xref encolumnada amb els retorns de carro
  {  %% loop
   dup 65535 string readstring
   {
    Objected'Ara exch writestring
   }
   {
    Objected'Ara exch writestring closefile exit
   }ifelse
  }loop  %% escrivim totes les dades del strEAm XIU a Objected'Ara

  Objected'Ara dup (trailer) writestring EOL writestring  %% el cap del trailer
  %%% hem traslladat aquest analisi + amunt al comprovar la versio del PDF
  %% escrivim el dict del trailer
  %% primer cal que pesquem el trailer de la darrera xref (la mes nova)
  %% tret de si esta liniaritzat que sera la primera de totes (amb valor xref+nova=0)
  %%0 /xref+nova exch def  % valor inicial de l'xref mes nova
  %%LNRZD not  % no ho executem si esta liniaritzat (sempre agafara la xref+nova=0)
  %%{
  %% TAUxREF
  %% {  % l'xref mes nova sera la que tingui el literal mes gran numericament
  %%  exch dup 10 string cvs cvi dup xref+nova gt
  %%  {/xref+nova exch def pop pop}{pop pop pop}ifelse
  %% }forall
  %%} if
  TAUxREF xref+nova 10 string cvs cvn get
  %% fins la versio 1.3 haurem de tractar els elements com segueix ...
  %% ID: matenir-lo intacte (fins que no tinguem una transcripcio de l'MDA5 a PS) ... ep! ara ho podem fer amb el GS!
  %% Info: mantenir-lo (no caldra segurament fer comprovacions)
  %% Encrypt: mantenir-lo i/o decidir si seguim processant el fitxer degut al seu blindatge o per raons de (c)
  %% Root: mantenir-lo (no caldra segurament fer comprovacions)
  %% Prev: eliminar-lo (nomes tenim una xref ara!)
  %% Size: actualitzar-lo amb el valor QuiEsAra+1
  dup /Prev undef  %% l'undef no cal comprovar-lo doncs mai dona error
  dup /Size QuiEsAra 1 add put
  %% tenim cura que l'ID, si existeix, es reescrigui novament en hexa
  %%% pero tambe la podem eliminar (true) ...
  %%% L'ELIMINEM! doncs hem trobat nous PDF que duen les cadenes no en binari < ... >
  %%% (o sigui hexa que al caure a l'interpret queda en binari) si no en hexa ( ... )
  %%% (doncs a l'estar entre parentesi en comptes de <> es queda igualment en hexa!)
%%EP cal afinar aquest detectorID pels PDF amb Reference XObjects, doncs és via ID que s'identifiquen els Proxy
%{== ==}forall(+++)pstack quit
  true {dup /ID undef}if
  dup /ID known 
  {
   dup /ID get type /nametype eq  %% x si la ID es un obj ind com passa amb PDF fets amb l'OSX
   {
    false
   }
   {
    true
   }ifelse
  }
  {
   false
  }ifelse
  {  %% atencio! hem vist que algunS PDF (73_H538.pdf de Nexus) duen les cadenes en Hexa
   %% en comptes de binari i llavors aquest algorisme no funciona B en Ghostscript
   %% entre d'altres xq llavors el binari ja no l'hauriem d xifrar a Hexa (com detectar-ho?)
   dup /ID get dup 0 get dup length 2 mul string dup /NullEncode filter
   /ASCIIHexEncode filter dup 4 -1 roll writestring flushfile /id1 exch def
   1 get dup length 2 mul string dup /NullEncode filter /ASCIIHexEncode filter dup 4 -1 roll
   writestring flushfile /id2 exch def dup /ID undef
   Objected'Ara (<<) writestring  %% obrim aqui el diccionari
   /salva'l save def espiadic_fura2 salva'l restore
   Objected'Ara dup dup dup dup (/ID [<) writestring id1 writestring (><) writestring
   id2 writestring (>] >>) writestring  %% posem aqui el tancament del diccionari
  }
  {
   Objected'Ara (<<) writestring  %% obrim aqui el diccionari
   /salva'l save def espiadic_fura2 salva'l restore
   Objected'Ara (>>) writestring  %% posem aqui el tancament del diccionari
  }ifelse
  %% escrivim el final del PDF
  Objected'Ara dup dup dup dup dup dup dup EOL writestring (startxref) writestring
  EOL writestring BOsXr 10 string cvs writestring EOL writestring
  (%%EOF) writestring EOL writestring closefile
  Salva'm restore  %% anellat important x poder eliminar els fitxers aqui sota!
  %% fi de la reescriptura del PDF

%/17 ENCAVALCA CONTINGUTS
%/15 ELIMINA LLESQUES
%/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%/13 eliminem continguts de pàgina
%/12 arbre jeràrquic
%/10 PREFLIGHT AMB CAPES
%/08 ETIQUETA TEXT
%/07 REINSEREIX IMATGES JPEG
%/06 COSIT D'IMATGES
%/05 dada variable
%/03 CORRECTOR TIPOGRÀFIC
%/02 MARQUES DE TALL
%/01 SEPARACIÓ DE TINTES
%/00 REESCRIPTURA IDEM

  QueLiFemFer 1 eq  %:01 SEPARACIÓ DE TINTES
  QueLiFemFer 5 eq  %:05 dada variable
  or
  {
   %%%CALi2COPi%%%
   %#%57% restaurem els diccionaris trencats de ComDimoni a partir del clònic
   (%#%57%)==
   clON
   {  %% executem el radial per convertir-lo en enter tal com havia estat
    exch 6 string cvs cvx exec 3 string cvs cvn
    exch currentdict 3 1 roll
    dup length dict copy put  %% restaurem el dic original (userdict)
   }forall
   %%userdict /0 get /31_____________0 get {== ==}forall ( ... ) == quit
   %% restaurem el dic noZero
   clON2 dup length dict copy /noZero exch def
   %% restaurem el dic TAUxREF
   clON3 dup length dict copy /TAUxREF exch def
   %% regenerem el dic amb arrays dels GStates Utilitzats
   XRay /EstatsGrafics get /Utilitzats get
   dup length dict copy dup /Fenix exch def
   {  %% forall, clona un dic amb estructura tipu aixi ... << /A [ [1 2] [3 4] ] >>
    exch /laClau exch def
    dup null eq
    {
     /AoN exch def
    }
    {
     dup length array copy dup /AoN exch def
     /iA 0 def
     {  %% forall
      dup length array copy
      AoN iA 3 -1 roll put
      iA 1 add /iA exch def
     }forall
    }ifelse
    Fenix laClau AoN put
   }forall
   %% regenerem els dics dels Forms ...
   HiHaForms
   {  %% ... si n'hi ha
    clONformsX 
    {  %% forall
     XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
     /Utilitzats get 2 index known
     {  %% el Form no es un objecte indirecte (pot passar?)
      dup length dict copy exch
      XRay /ObjectesX get araPlana get  %% pesquem el dic de la plana on som
      /Utilitzats get exch get
      exch 2 exch put  %% clonem l'original i el desem directe a l'array del Form
     }
     {
      exch /laBranca exch def
      %% pesquem la branca ...
      /iDimoni 0 def
      {  %% loop d'interrogacio dels dicts de COMdimoni
       currentdict iDimoni 4 string cvs cvn get
       %% el diccionari de l'objecte
       dup laBranca known
       %% clonem l'original i el redesem a l'objecte indirecte que toca dins el seu dic trencat
       {
        exch dup length dict copy laBranca exch put exit
       }
       {
        pop
       }ifelse 
       iDimoni 1 add /iDimoni exch def
       iDimoni MaxDimoni eq {exit} if
      }loop  %% d'interrogacio dels dicts de COMdimoni   
     }ifelse
    }forall
   }if
   %%¿?
   %%currentdict /0 get /191____________0 get /XIU get ==
   %% regenerem els dics del dic FotoCromPS !
   %% /FotoCromPS 2 dict def
   %%CLONfcps dup length dict copy {
   %%                               dup length dict copy /clonL1 exch def
   %%                               clonL1 {dup length dict copy clonL1 3 1 roll put}forall
   %%                               clonL1 FotoCromPS 3 1 roll put
   %%                             }forall
   %%FotoCromPS /Cyan get /P1 get /aMTXCR exch def
   %%currentdict /0 get /7______________0 get {== ==}forall (////) ==
   %%FotoCromPS {{{== ==} forall ==} forall ==}forall %($) == quit
       %/05 dada variable
  }if  %/01 SEPARACIÓ DE TINTES
 }forall  %% de la generacio de PDF x Tinta
 %%%CALi2COPi%%%
}if  %% fi d'aquí decidirem si fem el repicat del PDF sempre que NO fem l'opció 9 o 4

%:00 REESCRIPTURA IDEM
%:01 SEPARACIÓ DE TINTES
%:02 MARQUES DE TALL
%:03 CORRECTOR TIPOGRÀFIC
%:05 dada variable
%:06 COSIT D'IMATGES
%:07 REINSEREIX IMATGES JPEG
%:08 ETIQUETA TEXT
%:10 PREFLIGHT AMB CAPES
%:12 arbre jeràrquic
%:13 eliminem continguts de pàgina
%:14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%:15 ELIMINA LLESQUES
%:17 ENCAVALCA CONTINGUTS

%#%58% hem canviat l'estratègia i esborrarem els temporals al principi
%# ara només informarem que hi queden temporals (demanarem a la DLL que acabi de netejar si cal)
(%#%58%)==
BaBeL 50 get print flush

%%testVM
%%(VM fi >>>) == vmstatus == == ==
%CalaixDeTipus /1 get {== ==}forall

%%REpublica
%% fApplet ...es el nom del PDF que s'ha carregat al servidor /Hpdf
%% bateiG ...es el nom del PDF repicat per CaLi2CoPi tambe dins /Hpdf

%% control de temps
%%usertime Td'ara sub == (escrivim la taula XREF final\n) print flush

%#%59% fitxer TXT de control final del resultat pel web+PHP
(%#%59%)==
(totbe.txt)  %% si NO HI HA aquest arxiu, la interfície donarà un error d'execució de CaLi2CoPi
dup length tEmp length dup /faPath exch def add string dup /pAthXiU exch def
0 tEmp putinterval pAthXiU exch faPath exch putinterval  %% incrustem la cadena al path
pAthXiU (w) file

QueLiFemFer 12 eq
{  %% escrivim el nom que li hem donat al PDF repicat a totbe.txt per tal que l'exe del 6q
   %% pugui respectar el nom original d'entrada, malgrat sigui un nyap x compatibilitat
 dup nomTotBe writestring closefile
}
{
 dup 32 write closefile
}ifelse

QueLiFemFer 6 eq
{
 ARAlog  %% dup (**** BÉ!\012\012)writestring
 closefile
%% %% (:-])pstack quit
}if

%% EstatGrafic 0 get {== ==}forall pstack  % hi ha brossa a la pila?
%%quit  % sortim de l'execucio de GS (cal treure aquest quit x treballar amb el filenameforall)

%%% x treballar en massa per A3copiseny
%%}stopped
%%{
%% (\n ... aquest fitxer no s'ha tractat ... \n\n)print flush clear cleardictstack
%%}
%%{
%% Tdir 1 add /Tdir exch def
%%}ifelse
%%}512 string filenameforall
%%(\n\n ... HEM EXECUTAT AMB EXIT ... ) print flush Tdir 6 string cvs print flush
%%( ... fitxers PDF\n\n\n) print flush
%%% fi del treball en massa x A3copiseny

%/17 ENCAVALCA CONTINGUTS
%/15 ELIMINA LLESQUES
%/14 restaura les capes d'imatge rasteritzades per CaLi2CoPi 13
%/13 eliminem continguts de pàgina
%/12 arbre jeràrquic
%/10 PREFLIGHT AMB CAPES
%/08 ETIQUETA TEXT
%/07 REINSEREIX IMATGES JPEG
%/06 COSIT D'IMATGES
%/05 dada variable
%/03 CORRECTOR TIPOGRÀFIC
%/02 MARQUES DE TALL
%/01 SEPARACIÓ DE TINTES
%/00 REESCRIPTURA IDEM

